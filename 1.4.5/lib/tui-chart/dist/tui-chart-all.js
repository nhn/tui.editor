/*!
 * tui-chart-all
 * @fileoverview tui-chart
 * @author NHN. FE Development Lab <dl_javascript@nhn.com>
 * @version 3.7.0
 * @license MIT
 * @link https://github.com/nhn/tui.chart
 * bundle created at "Tue Apr 23 2019 10:58:00 GMT+0900 (대한민국 표준시)"
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["chart"] = factory();
	else
		root["tui"] = root["tui"] || {}, root["tui"]["chart"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(2);
	module.exports = __webpack_require__(328);


/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(3);
	
	__webpack_require__(324);
	
	__webpack_require__(325);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	__webpack_require__(52);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(57);
	__webpack_require__(60);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(68);
	__webpack_require__(70);
	__webpack_require__(72);
	__webpack_require__(74);
	__webpack_require__(76);
	__webpack_require__(79);
	__webpack_require__(80);
	__webpack_require__(81);
	__webpack_require__(85);
	__webpack_require__(87);
	__webpack_require__(89);
	__webpack_require__(92);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(95);
	__webpack_require__(97);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(103);
	__webpack_require__(105);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(109);
	__webpack_require__(110);
	__webpack_require__(111);
	__webpack_require__(113);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(140);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(158);
	__webpack_require__(159);
	__webpack_require__(161);
	__webpack_require__(162);
	__webpack_require__(168);
	__webpack_require__(169);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(173);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(181);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(186);
	__webpack_require__(189);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(193);
	__webpack_require__(195);
	__webpack_require__(197);
	__webpack_require__(199);
	__webpack_require__(200);
	__webpack_require__(201);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(205);
	__webpack_require__(206);
	__webpack_require__(217);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(224);
	__webpack_require__(225);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(243);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(250);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(258);
	__webpack_require__(259);
	__webpack_require__(260);
	__webpack_require__(262);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(267);
	__webpack_require__(268);
	__webpack_require__(269);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(277);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(288);
	__webpack_require__(289);
	__webpack_require__(290);
	__webpack_require__(291);
	__webpack_require__(292);
	__webpack_require__(293);
	__webpack_require__(294);
	__webpack_require__(295);
	__webpack_require__(296);
	__webpack_require__(297);
	__webpack_require__(299);
	__webpack_require__(300);
	__webpack_require__(301);
	__webpack_require__(302);
	__webpack_require__(303);
	__webpack_require__(304);
	__webpack_require__(305);
	__webpack_require__(306);
	__webpack_require__(307);
	__webpack_require__(308);
	__webpack_require__(309);
	__webpack_require__(311);
	__webpack_require__(312);
	__webpack_require__(313);
	__webpack_require__(314);
	__webpack_require__(315);
	__webpack_require__(316);
	__webpack_require__(317);
	__webpack_require__(318);
	__webpack_require__(319);
	__webpack_require__(320);
	__webpack_require__(321);
	__webpack_require__(322);
	__webpack_require__(323);
	module.exports = __webpack_require__(10);


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global = __webpack_require__(5);
	var has = __webpack_require__(6);
	var DESCRIPTORS = __webpack_require__(7);
	var $export = __webpack_require__(9);
	var redefine = __webpack_require__(19);
	var META = __webpack_require__(23).KEY;
	var $fails = __webpack_require__(8);
	var shared = __webpack_require__(24);
	var setToStringTag = __webpack_require__(26);
	var uid = __webpack_require__(20);
	var wks = __webpack_require__(27);
	var wksExt = __webpack_require__(28);
	var wksDefine = __webpack_require__(29);
	var enumKeys = __webpack_require__(30);
	var isArray = __webpack_require__(45);
	var anObject = __webpack_require__(13);
	var isObject = __webpack_require__(14);
	var toIObject = __webpack_require__(33);
	var toPrimitive = __webpack_require__(17);
	var createDesc = __webpack_require__(18);
	var _create = __webpack_require__(46);
	var gOPNExt = __webpack_require__(49);
	var $GOPD = __webpack_require__(51);
	var $DP = __webpack_require__(12);
	var $keys = __webpack_require__(31);
	var gOPD = $GOPD.f;
	var dP = $DP.f;
	var gOPN = gOPNExt.f;
	var $Symbol = global.Symbol;
	var $JSON = global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE = 'prototype';
	var HIDDEN = wks('_hidden');
	var TO_PRIMITIVE = wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = shared('symbol-registry');
	var AllSymbols = shared('symbols');
	var OPSymbols = shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function () {
	  return _create(dP({}, 'a', {
	    get: function () { return dP(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _create(D, { enumerable: createDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = toPrimitive(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f = $defineProperty;
	  __webpack_require__(50).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(44).f = $propertyIsEnumerable;
	  __webpack_require__(43).f = $getOwnPropertySymbols;
	
	  if (DESCRIPTORS && !__webpack_require__(25)) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function (name) {
	    return wrap(wks(name));
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
	
	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);
	
	for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(8)(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 8 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5);
	var core = __webpack_require__(10);
	var hide = __webpack_require__(11);
	var redefine = __webpack_require__(19);
	var ctx = __webpack_require__(21);
	var PROTOTYPE = 'prototype';
	
	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
	  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
	  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
	  var key, own, out, exp;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if (target) redefine(target, key, out, type & $export.U);
	    // export
	    if (exports[key] != out) hide(exports, key, exp);
	    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	module.exports = $export;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

	var core = module.exports = { version: '2.5.7' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(12);
	var createDesc = __webpack_require__(18);
	module.exports = __webpack_require__(7) ? function (object, key, value) {
	  return dP.f(object, key, createDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(13);
	var IE8_DOM_DEFINE = __webpack_require__(15);
	var toPrimitive = __webpack_require__(17);
	var dP = Object.defineProperty;
	
	exports.f = __webpack_require__(7) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	module.exports = function (it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(7) && !__webpack_require__(8)(function () {
	  return Object.defineProperty(__webpack_require__(16)('div'), 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	var document = __webpack_require__(5).document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
	  return is ? document.createElement(it) : {};
	};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(14);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function (it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	module.exports = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5);
	var hide = __webpack_require__(11);
	var has = __webpack_require__(6);
	var SRC = __webpack_require__(20)('src');
	var TO_STRING = 'toString';
	var $toString = Function[TO_STRING];
	var TPL = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(10).inspectSource = function (it) {
	  return $toString.call(it);
	};
	
	(module.exports = function (O, key, val, safe) {
	  var isFunction = typeof val == 'function';
	  if (isFunction) has(val, 'name') || hide(val, 'name', key);
	  if (O[key] === val) return;
	  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if (O === global) {
	    O[key] = val;
	  } else if (!safe) {
	    delete O[key];
	    hide(O, key, val);
	  } else if (O[key]) {
	    O[key] = val;
	  } else {
	    hide(O, key, val);
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString() {
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});


/***/ }),
/* 20 */
/***/ (function(module, exports) {

	var id = 0;
	var px = Math.random();
	module.exports = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(22);
	module.exports = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var META = __webpack_require__(20)('meta');
	var isObject = __webpack_require__(14);
	var has = __webpack_require__(6);
	var setDesc = __webpack_require__(12).f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !__webpack_require__(8)(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var core = __webpack_require__(10);
	var global = __webpack_require__(5);
	var SHARED = '__core-js_shared__';
	var store = global[SHARED] || (global[SHARED] = {});
	
	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: core.version,
	  mode: __webpack_require__(25) ? 'pure' : 'global',
	  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
	});


/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = false;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(12).f;
	var has = __webpack_require__(6);
	var TAG = __webpack_require__(27)('toStringTag');
	
	module.exports = function (it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var store = __webpack_require__(24)('wks');
	var uid = __webpack_require__(20);
	var Symbol = __webpack_require__(5).Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(27);


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5);
	var core = __webpack_require__(10);
	var LIBRARY = __webpack_require__(25);
	var wksExt = __webpack_require__(28);
	var defineProperty = __webpack_require__(12).f;
	module.exports = function (name) {
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(31);
	var gOPS = __webpack_require__(43);
	var pIE = __webpack_require__(44);
	module.exports = function (it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = pIE.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys = __webpack_require__(32);
	var enumBugKeys = __webpack_require__(42);
	
	module.exports = Object.keys || function keys(O) {
	  return $keys(O, enumBugKeys);
	};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var has = __webpack_require__(6);
	var toIObject = __webpack_require__(33);
	var arrayIndexOf = __webpack_require__(37)(false);
	var IE_PROTO = __webpack_require__(41)('IE_PROTO');
	
	module.exports = function (object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(34);
	var defined = __webpack_require__(36);
	module.exports = function (it) {
	  return IObject(defined(it));
	};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(35);
	// eslint-disable-next-line no-prototype-builtins
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};


/***/ }),
/* 35 */
/***/ (function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function (it) {
	  return toString.call(it).slice(8, -1);
	};


/***/ }),
/* 36 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(33);
	var toLength = __webpack_require__(38);
	var toAbsoluteIndex = __webpack_require__(40);
	module.exports = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(39);
	var min = Math.min;
	module.exports = function (it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	module.exports = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(39);
	var max = Math.max;
	var min = Math.min;
	module.exports = function (index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(24)('keys');
	var uid = __webpack_require__(20);
	module.exports = function (key) {
	  return shared[key] || (shared[key] = uid(key));
	};


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');


/***/ }),
/* 43 */
/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 44 */
/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(35);
	module.exports = Array.isArray || function isArray(arg) {
	  return cof(arg) == 'Array';
	};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject = __webpack_require__(13);
	var dPs = __webpack_require__(47);
	var enumBugKeys = __webpack_require__(42);
	var IE_PROTO = __webpack_require__(41)('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(16)('iframe');
	  var i = enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(48).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(12);
	var anObject = __webpack_require__(13);
	var getKeys = __webpack_require__(31);
	
	module.exports = __webpack_require__(7) ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	var document = __webpack_require__(5).document;
	module.exports = document && document.documentElement;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(33);
	var gOPN = __webpack_require__(50).f;
	var toString = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it) {
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys = __webpack_require__(32);
	var hiddenKeys = __webpack_require__(42).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	var pIE = __webpack_require__(44);
	var createDesc = __webpack_require__(18);
	var toIObject = __webpack_require__(33);
	var toPrimitive = __webpack_require__(17);
	var has = __webpack_require__(6);
	var IE8_DOM_DEFINE = __webpack_require__(15);
	var gOPD = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(7) ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
	};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', { create: __webpack_require__(46) });


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperty: __webpack_require__(12).f });


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(7), 'Object', { defineProperties: __webpack_require__(47) });


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject = __webpack_require__(33);
	var $getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	__webpack_require__(56)('getOwnPropertyDescriptor', function () {
	  return function getOwnPropertyDescriptor(it, key) {
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(9);
	var core = __webpack_require__(10);
	var fails = __webpack_require__(8);
	module.exports = function (KEY, exec) {
	  var fn = (core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
	};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject = __webpack_require__(58);
	var $getPrototypeOf = __webpack_require__(59);
	
	__webpack_require__(56)('getPrototypeOf', function () {
	  return function getPrototypeOf(it) {
	    return $getPrototypeOf(toObject(it));
	  };
	});


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(36);
	module.exports = function (it) {
	  return Object(defined(it));
	};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has = __webpack_require__(6);
	var toObject = __webpack_require__(58);
	var IE_PROTO = __webpack_require__(41)('IE_PROTO');
	var ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(58);
	var $keys = __webpack_require__(31);
	
	__webpack_require__(56)('keys', function () {
	  return function keys(it) {
	    return $keys(toObject(it));
	  };
	});


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(56)('getOwnPropertyNames', function () {
	  return __webpack_require__(49).f;
	});


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(14);
	var meta = __webpack_require__(23).onFreeze;
	
	__webpack_require__(56)('freeze', function ($freeze) {
	  return function freeze(it) {
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(14);
	var meta = __webpack_require__(23).onFreeze;
	
	__webpack_require__(56)('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(14);
	var meta = __webpack_require__(23).onFreeze;
	
	__webpack_require__(56)('preventExtensions', function ($preventExtensions) {
	  return function preventExtensions(it) {
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(14);
	
	__webpack_require__(56)('isFrozen', function ($isFrozen) {
	  return function isFrozen(it) {
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(14);
	
	__webpack_require__(56)('isSealed', function ($isSealed) {
	  return function isSealed(it) {
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(14);
	
	__webpack_require__(56)('isExtensible', function ($isExtensible) {
	  return function isExtensible(it) {
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(9);
	
	$export($export.S + $export.F, 'Object', { assign: __webpack_require__(69) });


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys = __webpack_require__(31);
	var gOPS = __webpack_require__(43);
	var pIE = __webpack_require__(44);
	var toObject = __webpack_require__(58);
	var IObject = __webpack_require__(34);
	var $assign = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(8)(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = pIE.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	  } return T;
	} : $assign;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(9);
	$export($export.S, 'Object', { is: __webpack_require__(71) });


/***/ }),
/* 71 */
/***/ (function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(9);
	$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(73).set });


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(14);
	var anObject = __webpack_require__(13);
	var check = function (O, proto) {
	  anObject(O);
	  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function (test, buggy, set) {
	      try {
	        set = __webpack_require__(21)(Function.call, __webpack_require__(51).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch (e) { buggy = true; }
	      return function setPrototypeOf(O, proto) {
	        check(O, proto);
	        if (buggy) O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(75);
	var test = {};
	test[__webpack_require__(27)('toStringTag')] = 'z';
	if (test + '' != '[object z]') {
	  __webpack_require__(19)(Object.prototype, 'toString', function toString() {
	    return '[object ' + classof(this) + ']';
	  }, true);
	}


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(35);
	var TAG = __webpack_require__(27)('toStringTag');
	// ES3 wrong here
	var ARG = cof(function () { return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) { /* empty */ }
	};
	
	module.exports = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(9);
	
	$export($export.P, 'Function', { bind: __webpack_require__(77) });


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction = __webpack_require__(22);
	var isObject = __webpack_require__(14);
	var invoke = __webpack_require__(78);
	var arraySlice = [].slice;
	var factories = {};
	
	var construct = function (F, len, args) {
	  if (!(len in factories)) {
	    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction(this);
	  var partArgs = arraySlice.call(arguments, 1);
	  var bound = function (/* args... */) {
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
	  return bound;
	};


/***/ }),
/* 78 */
/***/ (function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(12).f;
	var FProto = Function.prototype;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME = 'name';
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(7) && dP(FProto, NAME, {
	  configurable: true,
	  get: function () {
	    try {
	      return ('' + this).match(nameRE)[1];
	    } catch (e) {
	      return '';
	    }
	  }
	});


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var isObject = __webpack_require__(14);
	var getPrototypeOf = __webpack_require__(59);
	var HAS_INSTANCE = __webpack_require__(27)('hasInstance');
	var FunctionProto = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(12).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
	  if (typeof this != 'function' || !isObject(O)) return false;
	  if (!isObject(this.prototype)) return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
	  return false;
	} });


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	var $parseInt = __webpack_require__(82);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(5).parseInt;
	var $trim = __webpack_require__(83).trim;
	var ws = __webpack_require__(84);
	var hex = /^[-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	var defined = __webpack_require__(36);
	var fails = __webpack_require__(8);
	var spaces = __webpack_require__(84);
	var space = '[' + spaces + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');
	
	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = fails(function () {
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;


/***/ }),
/* 84 */
/***/ (function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	var $parseFloat = __webpack_require__(86);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(5).parseFloat;
	var $trim = __webpack_require__(83).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(84) + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(5);
	var has = __webpack_require__(6);
	var cof = __webpack_require__(35);
	var inheritIfRequired = __webpack_require__(88);
	var toPrimitive = __webpack_require__(17);
	var fails = __webpack_require__(8);
	var gOPN = __webpack_require__(50).f;
	var gOPD = __webpack_require__(51).f;
	var dP = __webpack_require__(12).f;
	var $trim = __webpack_require__(83).trim;
	var NUMBER = 'Number';
	var $Number = global[NUMBER];
	var Base = $Number;
	var proto = $Number.prototype;
	// Opera ~12 has broken Object#toString
	var BROKEN_COF = cof(__webpack_require__(46)(proto)) == NUMBER;
	var TRIM = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function (argument) {
	  var it = toPrimitive(argument, false);
	  if (typeof it == 'string' && it.length > 2) {
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0);
	    var third, radix, maxCode;
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default: return +it;
	      }
	      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
	  $Number = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for (var keys = __webpack_require__(7) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++) {
	    if (has(Base, key = keys[j]) && !has($Number, key)) {
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(19)(global, NUMBER, $Number);
	}


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	var setPrototypeOf = __webpack_require__(73).set;
	module.exports = function (that, target, C) {
	  var S = target.constructor;
	  var P;
	  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
	    setPrototypeOf(that, P);
	  } return that;
	};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var toInteger = __webpack_require__(39);
	var aNumberValue = __webpack_require__(90);
	var repeat = __webpack_require__(91);
	var $toFixed = 1.0.toFixed;
	var floor = Math.floor;
	var data = [0, 0, 0, 0, 0, 0];
	var ERROR = 'Number.toFixed: incorrect invocation!';
	var ZERO = '0';
	
	var multiply = function (n, c) {
	  var i = -1;
	  var c2 = c;
	  while (++i < 6) {
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function (n) {
	  var i = 6;
	  var c = 0;
	  while (--i >= 0) {
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function () {
	  var i = 6;
	  var s = '';
	  while (--i >= 0) {
	    if (s !== '' || i === 0 || data[i] !== 0) {
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function (x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function (x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(8)(function () {
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits) {
	    var x = aNumberValue(this, ERROR);
	    var f = toInteger(fractionDigits);
	    var s = '';
	    var m = ZERO;
	    var e, z, j, k;
	    if (f < 0 || f > 20) throw RangeError(ERROR);
	    // eslint-disable-next-line no-self-compare
	    if (x != x) return 'NaN';
	    if (x <= -1e21 || x >= 1e21) return String(x);
	    if (x < 0) {
	      s = '-';
	      x = -x;
	    }
	    if (x > 1e-21) {
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = f;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if (f > 0) {
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(35);
	module.exports = function (it, msg) {
	  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
	  return +it;
	};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(39);
	var defined = __webpack_require__(36);
	
	module.exports = function repeat(count) {
	  var str = String(defined(this));
	  var res = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
	  return res;
	};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $fails = __webpack_require__(8);
	var aNumberValue = __webpack_require__(90);
	var $toPrecision = 1.0.toPrecision;
	
	$export($export.P + $export.F * ($fails(function () {
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function () {
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision) {
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
	  }
	});


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export = __webpack_require__(9);
	var _isFinite = __webpack_require__(5).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', { isInteger: __webpack_require__(96) });


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(14);
	var floor = Math.floor;
	module.exports = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export = __webpack_require__(9);
	var isInteger = __webpack_require__(96);
	var abs = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	var $parseFloat = __webpack_require__(86);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	var $parseInt = __webpack_require__(82);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(9);
	var log1p = __webpack_require__(104);
	var sqrt = Math.sqrt;
	var $acosh = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});


/***/ }),
/* 104 */
/***/ (function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(9);
	var $asinh = Math.asinh;
	
	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(9);
	var $atanh = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(9);
	var sign = __webpack_require__(108);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x) {
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});


/***/ }),
/* 108 */
/***/ (function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(9);
	var exp = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x) {
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(9);
	var $expm1 = __webpack_require__(112);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 112 */
/***/ (function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', { fround: __webpack_require__(114) });


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var sign = __webpack_require__(108);
	var pow = Math.pow;
	var EPSILON = pow(2, -52);
	var EPSILON32 = pow(2, -23);
	var MAX32 = pow(2, 127) * (2 - EPSILON32);
	var MIN32 = pow(2, -126);
	
	var roundTiesToEven = function (n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	module.exports = Math.fround || function fround(x) {
	  var $abs = Math.abs(x);
	  var $sign = sign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	var $export = __webpack_require__(9);
	var abs = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(9);
	var $imul = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(8)(function () {
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y) {
	    var UINT16 = 0xffff;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  log10: function log10(x) {
	    return Math.log(x) * Math.LOG10E;
	  }
	});


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', { log1p: __webpack_require__(104) });


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  log2: function log2(x) {
	    return Math.log(x) / Math.LN2;
	  }
	});


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', { sign: __webpack_require__(108) });


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(9);
	var expm1 = __webpack_require__(112);
	var exp = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(8)(function () {
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x) {
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(9);
	var expm1 = __webpack_require__(112);
	var exp = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x) {
	    var a = expm1(x = +x);
	    var b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it) {
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	var toAbsoluteIndex = __webpack_require__(40);
	var fromCharCode = String.fromCharCode;
	var $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
	    var res = [];
	    var aLen = arguments.length;
	    var i = 0;
	    var code;
	    while (aLen > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	var toIObject = __webpack_require__(33);
	var toLength = __webpack_require__(38);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite) {
	    var tpl = toIObject(callSite.raw);
	    var len = toLength(tpl.length);
	    var aLen = arguments.length;
	    var res = [];
	    var i = 0;
	    while (len > i) {
	      res.push(String(tpl[i++]));
	      if (i < aLen) res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(83)('trim', function ($trim) {
	  return function trim() {
	    return $trim(this, 3);
	  };
	});


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $at = __webpack_require__(128)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(129)(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(39);
	var defined = __webpack_require__(36);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(25);
	var $export = __webpack_require__(9);
	var redefine = __webpack_require__(19);
	var hide = __webpack_require__(11);
	var Iterators = __webpack_require__(130);
	var $iterCreate = __webpack_require__(131);
	var setToStringTag = __webpack_require__(26);
	var getPrototypeOf = __webpack_require__(59);
	var ITERATOR = __webpack_require__(27)('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';
	
	var returnThis = function () { return this; };
	
	module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};


/***/ }),
/* 130 */
/***/ (function(module, exports) {

	module.exports = {};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var create = __webpack_require__(46);
	var descriptor = __webpack_require__(18);
	var setToStringTag = __webpack_require__(26);
	var IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(11)(IteratorPrototype, __webpack_require__(27)('iterator'), function () { return this; });
	
	module.exports = function (Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $at = __webpack_require__(128)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos) {
	    return $at(this, pos);
	  }
	});


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export = __webpack_require__(9);
	var toLength = __webpack_require__(38);
	var context = __webpack_require__(134);
	var ENDS_WITH = 'endsWith';
	var $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(136)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = context(this, searchString, ENDS_WITH);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
	    var search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(135);
	var defined = __webpack_require__(36);
	
	module.exports = function (that, searchString, NAME) {
	  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(14);
	var cof = __webpack_require__(35);
	var MATCH = __webpack_require__(27)('match');
	module.exports = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(27)('match');
	module.exports = function (KEY) {
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch (e) {
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch (f) { /* empty */ }
	  } return true;
	};


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export = __webpack_require__(9);
	var context = __webpack_require__(134);
	var INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(136)(INCLUDES), 'String', {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(91)
	});


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export = __webpack_require__(9);
	var toLength = __webpack_require__(38);
	var context = __webpack_require__(134);
	var STARTS_WITH = 'startsWith';
	var $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(136)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = context(this, searchString, STARTS_WITH);
	    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(141)('anchor', function (createHTML) {
	  return function anchor(name) {
	    return createHTML(this, 'a', 'name', name);
	  };
	});


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	var fails = __webpack_require__(8);
	var defined = __webpack_require__(36);
	var quot = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function (string, tag, attribute, value) {
	  var S = String(defined(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function (NAME, exec) {
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function () {
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(141)('big', function (createHTML) {
	  return function big() {
	    return createHTML(this, 'big', '', '');
	  };
	});


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(141)('blink', function (createHTML) {
	  return function blink() {
	    return createHTML(this, 'blink', '', '');
	  };
	});


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(141)('bold', function (createHTML) {
	  return function bold() {
	    return createHTML(this, 'b', '', '');
	  };
	});


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(141)('fixed', function (createHTML) {
	  return function fixed() {
	    return createHTML(this, 'tt', '', '');
	  };
	});


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(141)('fontcolor', function (createHTML) {
	  return function fontcolor(color) {
	    return createHTML(this, 'font', 'color', color);
	  };
	});


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(141)('fontsize', function (createHTML) {
	  return function fontsize(size) {
	    return createHTML(this, 'font', 'size', size);
	  };
	});


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(141)('italics', function (createHTML) {
	  return function italics() {
	    return createHTML(this, 'i', '', '');
	  };
	});


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(141)('link', function (createHTML) {
	  return function link(url) {
	    return createHTML(this, 'a', 'href', url);
	  };
	});


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(141)('small', function (createHTML) {
	  return function small() {
	    return createHTML(this, 'small', '', '');
	  };
	});


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(141)('strike', function (createHTML) {
	  return function strike() {
	    return createHTML(this, 'strike', '', '');
	  };
	});


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(141)('sub', function (createHTML) {
	  return function sub() {
	    return createHTML(this, 'sub', '', '');
	  };
	});


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(141)('sup', function (createHTML) {
	  return function sup() {
	    return createHTML(this, 'sup', '', '');
	  };
	});


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var toObject = __webpack_require__(58);
	var toPrimitive = __webpack_require__(17);
	
	$export($export.P + $export.F * __webpack_require__(8)(function () {
	  return new Date(NaN).toJSON() !== null
	    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
	}), 'Date', {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = toObject(this);
	    var pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(9);
	var toISOString = __webpack_require__(157);
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
	  toISOString: toISOString
	});


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var fails = __webpack_require__(8);
	var getTime = Date.prototype.getTime;
	var $toISOString = Date.prototype.toISOString;
	
	var lz = function (num) {
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	module.exports = (fails(function () {
	  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  $toISOString.call(new Date(NaN));
	})) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var d = this;
	  var y = d.getUTCFullYear();
	  var m = d.getUTCMilliseconds();
	  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
	  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	} : $toISOString;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	var DateProto = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var $toString = DateProto[TO_STRING];
	var getTime = DateProto.getTime;
	if (new Date(NaN) + '' != INVALID_DATE) {
	  __webpack_require__(19)(DateProto, TO_STRING, function toString() {
	    var value = getTime.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(27)('toPrimitive');
	var proto = Date.prototype;
	
	if (!(TO_PRIMITIVE in proto)) __webpack_require__(11)(proto, TO_PRIMITIVE, __webpack_require__(160));


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var anObject = __webpack_require__(13);
	var toPrimitive = __webpack_require__(17);
	var NUMBER = 'number';
	
	module.exports = function (hint) {
	  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Array', { isArray: __webpack_require__(45) });


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var ctx = __webpack_require__(21);
	var $export = __webpack_require__(9);
	var toObject = __webpack_require__(58);
	var call = __webpack_require__(163);
	var isArrayIter = __webpack_require__(164);
	var toLength = __webpack_require__(38);
	var createProperty = __webpack_require__(165);
	var getIterFn = __webpack_require__(166);
	
	$export($export.S + $export.F * !__webpack_require__(167)(function (iter) { Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	    var O = toObject(arrayLike);
	    var C = typeof this == 'function' ? this : Array;
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var index = 0;
	    var iterFn = getIterFn(O);
	    var length, result, step, iterator;
	    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
	      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for (result = new C(length); length > index; index++) {
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(13);
	module.exports = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) anObject(ret.call(iterator));
	    throw e;
	  }
	};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators = __webpack_require__(130);
	var ITERATOR = __webpack_require__(27)('iterator');
	var ArrayProto = Array.prototype;
	
	module.exports = function (it) {
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(12);
	var createDesc = __webpack_require__(18);
	
	module.exports = function (object, index, value) {
	  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	var classof = __webpack_require__(75);
	var ITERATOR = __webpack_require__(27)('iterator');
	var Iterators = __webpack_require__(130);
	module.exports = __webpack_require__(10).getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	var ITERATOR = __webpack_require__(27)('iterator');
	var SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(riter, function () { throw 2; });
	} catch (e) { /* empty */ }
	
	module.exports = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR] = function () { return iter; };
	    exec(arr);
	  } catch (e) { /* empty */ }
	  return safe;
	};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var createProperty = __webpack_require__(165);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(8)(function () {
	  function F() { /* empty */ }
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */) {
	    var index = 0;
	    var aLen = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(aLen);
	    while (aLen > index) createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export = __webpack_require__(9);
	var toIObject = __webpack_require__(33);
	var arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(34) != Object || !__webpack_require__(170)(arrayJoin)), 'Array', {
	  join: function join(separator) {
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var fails = __webpack_require__(8);
	
	module.exports = function (method, arg) {
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call
	    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
	  });
	};


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var html = __webpack_require__(48);
	var cof = __webpack_require__(35);
	var toAbsoluteIndex = __webpack_require__(40);
	var toLength = __webpack_require__(38);
	var arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(8)(function () {
	  if (html) arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end) {
	    var len = toLength(this.length);
	    var klass = cof(this);
	    end = end === undefined ? len : end;
	    if (klass == 'Array') return arraySlice.call(this, begin, end);
	    var start = toAbsoluteIndex(begin, len);
	    var upTo = toAbsoluteIndex(end, len);
	    var size = toLength(upTo - start);
	    var cloned = new Array(size);
	    var i = 0;
	    for (; i < size; i++) cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var aFunction = __webpack_require__(22);
	var toObject = __webpack_require__(58);
	var fails = __webpack_require__(8);
	var $sort = [].sort;
	var test = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function () {
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function () {
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(170)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $forEach = __webpack_require__(174)(0);
	var STRICT = __webpack_require__(170)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */) {
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx = __webpack_require__(21);
	var IObject = __webpack_require__(34);
	var toObject = __webpack_require__(58);
	var toLength = __webpack_require__(38);
	var asc = __webpack_require__(175);
	module.exports = function (TYPE, $create) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  var create = $create || asc;
	  return function ($this, callbackfn, that) {
	    var O = toObject($this);
	    var self = IObject(O);
	    var f = ctx(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var val, res;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      val = self[index];
	      res = f(val, index, O);
	      if (TYPE) {
	        if (IS_MAP) result[index] = res;   // map
	        else if (res) switch (TYPE) {
	          case 3: return true;             // some
	          case 5: return val;              // find
	          case 6: return index;            // findIndex
	          case 2: result.push(val);        // filter
	        } else if (IS_EVERY) return false; // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(176);
	
	module.exports = function (original, length) {
	  return new (speciesConstructor(original))(length);
	};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	var isArray = __webpack_require__(45);
	var SPECIES = __webpack_require__(27)('species');
	
	module.exports = function (original) {
	  var C;
	  if (isArray(original)) {
	    C = original.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $map = __webpack_require__(174)(1);
	
	$export($export.P + $export.F * !__webpack_require__(170)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $filter = __webpack_require__(174)(2);
	
	$export($export.P + $export.F * !__webpack_require__(170)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $some = __webpack_require__(174)(3);
	
	$export($export.P + $export.F * !__webpack_require__(170)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $every = __webpack_require__(174)(4);
	
	$export($export.P + $export.F * !__webpack_require__(170)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments[1]);
	  }
	});


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $reduce = __webpack_require__(182);
	
	$export($export.P + $export.F * !__webpack_require__(170)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(22);
	var toObject = __webpack_require__(58);
	var IObject = __webpack_require__(34);
	var toLength = __webpack_require__(38);
	
	module.exports = function (that, callbackfn, aLen, memo, isRight) {
	  aFunction(callbackfn);
	  var O = toObject(that);
	  var self = IObject(O);
	  var length = toLength(O.length);
	  var index = isRight ? length - 1 : 0;
	  var i = isRight ? -1 : 1;
	  if (aLen < 2) for (;;) {
	    if (index in self) {
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if (isRight ? index < 0 : length <= index) {
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $reduce = __webpack_require__(182);
	
	$export($export.P + $export.F * !__webpack_require__(170)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $indexOf = __webpack_require__(37)(false);
	var $native = [].indexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(170)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var toIObject = __webpack_require__(33);
	var toInteger = __webpack_require__(39);
	var toLength = __webpack_require__(38);
	var $native = [].lastIndexOf;
	var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(170)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	    // convert -0 to +0
	    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
	    var O = toIObject(this);
	    var length = toLength(O.length);
	    var index = length - 1;
	    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
	    if (index < 0) index = length + index;
	    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
	    return -1;
	  }
	});


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(9);
	
	$export($export.P, 'Array', { copyWithin: __webpack_require__(187) });
	
	__webpack_require__(188)('copyWithin');


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58);
	var toAbsoluteIndex = __webpack_require__(40);
	var toLength = __webpack_require__(38);
	
	module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = toObject(this);
	  var len = toLength(O.length);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];
	    else delete O[to];
	    to += inc;
	    from += inc;
	  } return O;
	};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(27)('unscopables');
	var ArrayProto = Array.prototype;
	if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(11)(ArrayProto, UNSCOPABLES, {});
	module.exports = function (key) {
	  ArrayProto[UNSCOPABLES][key] = true;
	};


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(9);
	
	$export($export.P, 'Array', { fill: __webpack_require__(190) });
	
	__webpack_require__(188)('fill');


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58);
	var toAbsoluteIndex = __webpack_require__(40);
	var toLength = __webpack_require__(38);
	module.exports = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var aLen = arguments.length;
	  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
	  var end = aLen > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(9);
	var $find = __webpack_require__(174)(5);
	var KEY = 'find';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(188)(KEY);


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(9);
	var $find = __webpack_require__(174)(6);
	var KEY = 'findIndex';
	var forced = true;
	// Shouldn't skip holes
	if (KEY in []) Array(1)[KEY](function () { forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(188)(KEY);


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(194)('Array');


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(5);
	var dP = __webpack_require__(12);
	var DESCRIPTORS = __webpack_require__(7);
	var SPECIES = __webpack_require__(27)('species');
	
	module.exports = function (KEY) {
	  var C = global[KEY];
	  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(188);
	var step = __webpack_require__(196);
	var Iterators = __webpack_require__(130);
	var toIObject = __webpack_require__(33);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(129)(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');


/***/ }),
/* 196 */
/***/ (function(module, exports) {

	module.exports = function (done, value) {
	  return { value: value, done: !!done };
	};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5);
	var inheritIfRequired = __webpack_require__(88);
	var dP = __webpack_require__(12).f;
	var gOPN = __webpack_require__(50).f;
	var isRegExp = __webpack_require__(135);
	var $flags = __webpack_require__(198);
	var $RegExp = global.RegExp;
	var Base = $RegExp;
	var proto = $RegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;
	// "new" creates a new object, old webkit buggy here
	var CORRECT_NEW = new $RegExp(re1) !== re1;
	
	if (__webpack_require__(7) && (!CORRECT_NEW || __webpack_require__(8)(function () {
	  re2[__webpack_require__(27)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))) {
	  $RegExp = function RegExp(p, f) {
	    var tiRE = this instanceof $RegExp;
	    var piRE = isRegExp(p);
	    var fiU = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function (key) {
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function () { return Base[key]; },
	      set: function (it) { Base[key] = it; }
	    });
	  };
	  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(19)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(194)('RegExp');


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(13);
	module.exports = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(200);
	var anObject = __webpack_require__(13);
	var $flags = __webpack_require__(198);
	var DESCRIPTORS = __webpack_require__(7);
	var TO_STRING = 'toString';
	var $toString = /./[TO_STRING];
	
	var define = function (fn) {
	  __webpack_require__(19)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if (__webpack_require__(8)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
	  define(function toString() {
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if ($toString.name != TO_STRING) {
	  define(function toString() {
	    return $toString.call(this);
	  });
	}


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if (__webpack_require__(7) && /./g.flags != 'g') __webpack_require__(12).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(198)
	});


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(202)('match', 1, function (defined, MATCH, $match) {
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp) {
	    'use strict';
	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var hide = __webpack_require__(11);
	var redefine = __webpack_require__(19);
	var fails = __webpack_require__(8);
	var defined = __webpack_require__(36);
	var wks = __webpack_require__(27);
	
	module.exports = function (KEY, length, exec) {
	  var SYMBOL = wks(KEY);
	  var fns = exec(defined, SYMBOL, ''[KEY]);
	  var strfn = fns[0];
	  var rxfn = fns[1];
	  if (fails(function () {
	    var O = {};
	    O[SYMBOL] = function () { return 7; };
	    return ''[KEY](O) != 7;
	  })) {
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function (string, arg) { return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function (string) { return rxfn.call(string, this); }
	    );
	  }
	};


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(202)('replace', 2, function (defined, REPLACE, $replace) {
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue) {
	    'use strict';
	    var O = defined(this);
	    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(202)('search', 1, function (defined, SEARCH, $search) {
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp) {
	    'use strict';
	    var O = defined(this);
	    var fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(202)('split', 2, function (defined, SPLIT, $split) {
	  'use strict';
	  var isRegExp = __webpack_require__(135);
	  var _split = $split;
	  var $push = [].push;
	  var $SPLIT = 'split';
	  var LENGTH = 'length';
	  var LAST_INDEX = 'lastIndex';
	  if (
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ) {
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function (separator, limit) {
	      var string = String(this);
	      if (separator === undefined && limit === 0) return [];
	      // If `separator` is not a regex, use native split
	      if (!isRegExp(separator)) return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while (match = separatorCopy.exec(string)) {
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          // eslint-disable-next-line no-loop-func
	          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
	            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
	          });
	          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if (output[LENGTH] >= splitLimit) break;
	        }
	        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string[LENGTH]) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
	    $split = function (separator, limit) {
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit) {
	    var O = defined(this);
	    var fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(25);
	var global = __webpack_require__(5);
	var ctx = __webpack_require__(21);
	var classof = __webpack_require__(75);
	var $export = __webpack_require__(9);
	var isObject = __webpack_require__(14);
	var aFunction = __webpack_require__(22);
	var anInstance = __webpack_require__(207);
	var forOf = __webpack_require__(208);
	var speciesConstructor = __webpack_require__(209);
	var task = __webpack_require__(210).set;
	var microtask = __webpack_require__(211)();
	var newPromiseCapabilityModule = __webpack_require__(212);
	var perform = __webpack_require__(213);
	var userAgent = __webpack_require__(214);
	var promiseResolve = __webpack_require__(215);
	var PROMISE = 'Promise';
	var TypeError = global.TypeError;
	var process = global.process;
	var versions = process && process.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = global[PROMISE];
	var isNode = classof(process) == 'process';
	var empty = function () { /* empty */ };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
	
	var USE_NATIVE = !!function () {
	  try {
	    // correct subclassing with @@species support
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[__webpack_require__(27)('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	      // we can't detect it synchronously, so just check versions
	      && v8.indexOf('6.6') !== 0
	      && userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) { /* empty */ }
	}();
	
	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // may throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = perform(function () {
	        if (isNode) {
	          process.emit('unhandledRejection', value, promise);
	        } else if (handler = global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(global, function () {
	    var handler;
	    if (isNode) {
	      process.emit('rejectionHandled', promise);
	    } else if (handler = global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if (promise === value) throw TypeError("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false }; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e); // wrap
	  }
	};
	
	// constructor polyfill
	if (!USE_NATIVE) {
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor) {
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(216)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject = ctx($reject, promise, 1);
	  };
	  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
	__webpack_require__(26)($Promise, PROMISE);
	__webpack_require__(194)(PROMISE);
	Wrapper = __webpack_require__(10)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x) {
	    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(167)(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});


/***/ }),
/* 207 */
/***/ (function(module, exports) {

	module.exports = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(21);
	var call = __webpack_require__(163);
	var isArrayIter = __webpack_require__(164);
	var anObject = __webpack_require__(13);
	var toLength = __webpack_require__(38);
	var getIterFn = __webpack_require__(166);
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
	  var f = ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = call(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject = __webpack_require__(13);
	var aFunction = __webpack_require__(22);
	var SPECIES = __webpack_require__(27)('species');
	module.exports = function (O, D) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx = __webpack_require__(21);
	var invoke = __webpack_require__(78);
	var html = __webpack_require__(48);
	var cel = __webpack_require__(16);
	var global = __webpack_require__(5);
	var process = global.process;
	var setTask = global.setImmediate;
	var clearTask = global.clearImmediate;
	var MessageChannel = global.MessageChannel;
	var Dispatch = global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (__webpack_require__(35)(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
	    defer = function (id) {
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in cel('script')) {
	    defer = function (id) {
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set: setTask,
	  clear: clearTask
	};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5);
	var macrotask = __webpack_require__(210).set;
	var Observer = global.MutationObserver || global.WebKitMutationObserver;
	var process = global.process;
	var Promise = global.Promise;
	var isNode = __webpack_require__(35)(process) == 'process';
	
	module.exports = function () {
	  var head, last, notify;
	
	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };
	
	  // Node.js
	  if (isNode) {
	    notify = function () {
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
	  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise && Promise.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    var promise = Promise.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 25.4.1.5 NewPromiseCapability(C)
	var aFunction = __webpack_require__(22);
	
	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	}
	
	module.exports.f = function (C) {
	  return new PromiseCapability(C);
	};


/***/ }),
/* 213 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5);
	var navigator = global.navigator;
	
	module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(13);
	var isObject = __webpack_require__(14);
	var newPromiseCapability = __webpack_require__(212);
	
	module.exports = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(19);
	module.exports = function (target, src, safe) {
	  for (var key in src) redefine(target, key, src[key], safe);
	  return target;
	};


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(218);
	var validate = __webpack_require__(219);
	var MAP = 'Map';
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(220)(MAP, function (get) {
	  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key) {
	    var entry = strong.getEntry(validate(this, MAP), key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value) {
	    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
	  }
	}, strong, true);


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var dP = __webpack_require__(12).f;
	var create = __webpack_require__(46);
	var redefineAll = __webpack_require__(216);
	var ctx = __webpack_require__(21);
	var anInstance = __webpack_require__(207);
	var forOf = __webpack_require__(208);
	var $iterDefine = __webpack_require__(129);
	var step = __webpack_require__(196);
	var setSpecies = __webpack_require__(194);
	var DESCRIPTORS = __webpack_require__(7);
	var fastKey = __webpack_require__(23).fastKey;
	var validate = __webpack_require__(219);
	var SIZE = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function (that, key) {
	  // fast case
	  var index = fastKey(key);
	  var entry;
	  if (index !== 'F') return that._i[index];
	  // frozen object case
	  for (entry = that._f; entry; entry = entry.n) {
	    if (entry.k == key) return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._t = NAME;         // collection type
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
	          entry.r = true;
	          if (entry.p) entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = validate(this, NAME);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.n;
	          var prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if (prev) prev.n = next;
	          if (next) next.p = prev;
	          if (that._f == entry) that._f = next;
	          if (that._l == entry) that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        validate(this, NAME);
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.n : this._f) {
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while (entry && entry.r) entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(validate(this, NAME), key);
	      }
	    });
	    if (DESCRIPTORS) dP(C.prototype, 'size', {
	      get: function () {
	        return validate(this, NAME)[SIZE];
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var entry = getEntry(that, key);
	    var prev, index;
	    // change existing entry
	    if (entry) {
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if (!that._f) that._f = entry;
	      if (prev) prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if (index !== 'F') that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function (C, NAME, IS_MAP) {
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function (iterated, kind) {
	      this._t = validate(iterated, NAME); // target
	      this._k = kind;                     // kind
	      this._l = undefined;                // previous
	    }, function () {
	      var that = this;
	      var kind = that._k;
	      var entry = that._l;
	      // revert to the last existing entry
	      while (entry && entry.r) entry = entry.p;
	      // get next entry
	      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if (kind == 'keys') return step(0, entry.k);
	      if (kind == 'values') return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(14);
	module.exports = function (it, TYPE) {
	  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
	  return it;
	};


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(5);
	var $export = __webpack_require__(9);
	var redefine = __webpack_require__(19);
	var redefineAll = __webpack_require__(216);
	var meta = __webpack_require__(23);
	var forOf = __webpack_require__(208);
	var anInstance = __webpack_require__(207);
	var isObject = __webpack_require__(14);
	var fails = __webpack_require__(8);
	var $iterDetect = __webpack_require__(167);
	var setToStringTag = __webpack_require__(26);
	var inheritIfRequired = __webpack_require__(88);
	
	module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
	  var Base = global[NAME];
	  var C = Base;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var proto = C && C.prototype;
	  var O = {};
	  var fixMethod = function (KEY) {
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function (a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a) {
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a) {
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
	    new C().entries().next();
	  }))) {
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance = new C();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new C();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      C = wrapper(function (target, iterable) {
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base(), target, C);
	        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if (IS_WEAK && proto.clear) delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(218);
	var validate = __webpack_require__(219);
	var SET = 'Set';
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(220)(SET, function (get) {
	  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value) {
	    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
	  }
	}, strong);


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var each = __webpack_require__(174)(0);
	var redefine = __webpack_require__(19);
	var meta = __webpack_require__(23);
	var assign = __webpack_require__(69);
	var weak = __webpack_require__(223);
	var isObject = __webpack_require__(14);
	var fails = __webpack_require__(8);
	var validate = __webpack_require__(219);
	var WEAK_MAP = 'WeakMap';
	var getWeak = meta.getWeak;
	var isExtensible = Object.isExtensible;
	var uncaughtFrozenStore = weak.ufstore;
	var tmp = {};
	var InternalMap;
	
	var wrapper = function (get) {
	  return function WeakMap() {
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key) {
	    if (isObject(key)) {
	      var data = getWeak(key);
	      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value) {
	    return weak.def(validate(this, WEAK_MAP), key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(220)(WEAK_MAP, wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
	  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function (key) {
	    var proto = $WeakMap.prototype;
	    var method = proto[key];
	    redefine(proto, key, function (a, b) {
	      // store frozen objects on internal weakmap shim
	      if (isObject(a) && !isExtensible(a)) {
	        if (!this._f) this._f = new InternalMap();
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll = __webpack_require__(216);
	var getWeak = __webpack_require__(23).getWeak;
	var anObject = __webpack_require__(13);
	var isObject = __webpack_require__(14);
	var anInstance = __webpack_require__(207);
	var forOf = __webpack_require__(208);
	var createArrayMethod = __webpack_require__(174);
	var $has = __webpack_require__(6);
	var validate = __webpack_require__(219);
	var arrayFind = createArrayMethod(5);
	var arrayFindIndex = createArrayMethod(6);
	var id = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function (that) {
	  return that._l || (that._l = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function () {
	  this.a = [];
	};
	var findUncaughtFrozen = function (store, key) {
	  return arrayFind(store.a, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function (key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function (key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function (key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function (key) {
	    var index = arrayFindIndex(this.a, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, NAME, '_i');
	      that._t = NAME;      // collection type
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function (key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key) {
	        if (!isObject(key)) return false;
	        var data = getWeak(key);
	        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function (that, key, value) {
	    var data = getWeak(anObject(key), true);
	    if (data === true) uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(223);
	var validate = __webpack_require__(219);
	var WEAK_SET = 'WeakSet';
	
	// 23.4 WeakSet Objects
	__webpack_require__(220)(WEAK_SET, function (get) {
	  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value) {
	    return weak.def(validate(this, WEAK_SET), value, true);
	  }
	}, weak, false, true);


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var $typed = __webpack_require__(226);
	var buffer = __webpack_require__(227);
	var anObject = __webpack_require__(13);
	var toAbsoluteIndex = __webpack_require__(40);
	var toLength = __webpack_require__(38);
	var isObject = __webpack_require__(14);
	var ArrayBuffer = __webpack_require__(5).ArrayBuffer;
	var speciesConstructor = __webpack_require__(209);
	var $ArrayBuffer = buffer.ArrayBuffer;
	var $DataView = buffer.DataView;
	var $isView = $typed.ABV && ArrayBuffer.isView;
	var $slice = $ArrayBuffer.prototype.slice;
	var VIEW = $typed.VIEW;
	var ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it) {
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(8)(function () {
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end) {
	    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
	    var len = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, len);
	    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
	    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
	    var viewS = new $DataView(this);
	    var viewT = new $DataView(result);
	    var index = 0;
	    while (first < fin) {
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(194)(ARRAY_BUFFER);


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(5);
	var hide = __webpack_require__(11);
	var uid = __webpack_require__(20);
	var TYPED = uid('typed_array');
	var VIEW = uid('view');
	var ABV = !!(global.ArrayBuffer && global.DataView);
	var CONSTR = ABV;
	var i = 0;
	var l = 9;
	var Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while (i < l) {
	  if (Typed = global[TypedArrayConstructors[i++]]) {
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV: ABV,
	  CONSTR: CONSTR,
	  TYPED: TYPED,
	  VIEW: VIEW
	};


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global = __webpack_require__(5);
	var DESCRIPTORS = __webpack_require__(7);
	var LIBRARY = __webpack_require__(25);
	var $typed = __webpack_require__(226);
	var hide = __webpack_require__(11);
	var redefineAll = __webpack_require__(216);
	var fails = __webpack_require__(8);
	var anInstance = __webpack_require__(207);
	var toInteger = __webpack_require__(39);
	var toLength = __webpack_require__(38);
	var toIndex = __webpack_require__(228);
	var gOPN = __webpack_require__(50).f;
	var dP = __webpack_require__(12).f;
	var arrayFill = __webpack_require__(190);
	var setToStringTag = __webpack_require__(26);
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE = 'prototype';
	var WRONG_LENGTH = 'Wrong length!';
	var WRONG_INDEX = 'Wrong index!';
	var $ArrayBuffer = global[ARRAY_BUFFER];
	var $DataView = global[DATA_VIEW];
	var Math = global.Math;
	var RangeError = global.RangeError;
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity = global.Infinity;
	var BaseBuffer = $ArrayBuffer;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;
	var BUFFER = 'buffer';
	var BYTE_LENGTH = 'byteLength';
	var BYTE_OFFSET = 'byteOffset';
	var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
	var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
	var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	function packIEEE754(value, mLen, nBytes) {
	  var buffer = new Array(nBytes);
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var i = 0;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	  var e, m, c;
	  value = abs(value);
	  // eslint-disable-next-line no-self-compare
	  if (value != value || value === Infinity) {
	    // eslint-disable-next-line no-self-compare
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if (value * (c = pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	}
	function unpackIEEE754(buffer, mLen, nBytes) {
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = eLen - 7;
	  var i = nBytes - 1;
	  var s = buffer[i--];
	  var e = s & 127;
	  var m;
	  s >>= 7;
	  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	}
	
	function unpackI32(bytes) {
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	}
	function packI8(it) {
	  return [it & 0xff];
	}
	function packI16(it) {
	  return [it & 0xff, it >> 8 & 0xff];
	}
	function packI32(it) {
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	}
	function packF64(it) {
	  return packIEEE754(it, 52, 8);
	}
	function packF32(it) {
	  return packIEEE754(it, 23, 4);
	}
	
	function addGetter(C, key, internal) {
	  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
	}
	
	function get(view, bytes, index, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	}
	function set(view, bytes, index, conversion, value, isLittleEndian) {
	  var numIndex = +index;
	  var intIndex = toIndex(numIndex);
	  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b;
	  var start = intIndex + view[$OFFSET];
	  var pack = conversion(+value);
	  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	}
	
	if (!$typed.ABV) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = toIndex(length);
	    this._b = arrayFill.call(new Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH];
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if (DESCRIPTORS) {
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset) {
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if (!fails(function () {
	    $ArrayBuffer(1);
	  }) || !fails(function () {
	    new $ArrayBuffer(-1); // eslint-disable-line no-new
	  }) || fails(function () {
	    new $ArrayBuffer(); // eslint-disable-line no-new
	    new $ArrayBuffer(1.5); // eslint-disable-line no-new
	    new $ArrayBuffer(NaN); // eslint-disable-line no-new
	    return $ArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, $ArrayBuffer);
	      return new BaseBuffer(toIndex(length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
	      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
	    }
	    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2));
	  var $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/ecma262/#sec-toindex
	var toInteger = __webpack_require__(39);
	var toLength = __webpack_require__(38);
	module.exports = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length!');
	  return length;
	};


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	$export($export.G + $export.W + $export.F * !__webpack_require__(226).ABV, {
	  DataView: __webpack_require__(227).DataView
	});


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(231)('Int8', 1, function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	if (__webpack_require__(7)) {
	  var LIBRARY = __webpack_require__(25);
	  var global = __webpack_require__(5);
	  var fails = __webpack_require__(8);
	  var $export = __webpack_require__(9);
	  var $typed = __webpack_require__(226);
	  var $buffer = __webpack_require__(227);
	  var ctx = __webpack_require__(21);
	  var anInstance = __webpack_require__(207);
	  var propertyDesc = __webpack_require__(18);
	  var hide = __webpack_require__(11);
	  var redefineAll = __webpack_require__(216);
	  var toInteger = __webpack_require__(39);
	  var toLength = __webpack_require__(38);
	  var toIndex = __webpack_require__(228);
	  var toAbsoluteIndex = __webpack_require__(40);
	  var toPrimitive = __webpack_require__(17);
	  var has = __webpack_require__(6);
	  var classof = __webpack_require__(75);
	  var isObject = __webpack_require__(14);
	  var toObject = __webpack_require__(58);
	  var isArrayIter = __webpack_require__(164);
	  var create = __webpack_require__(46);
	  var getPrototypeOf = __webpack_require__(59);
	  var gOPN = __webpack_require__(50).f;
	  var getIterFn = __webpack_require__(166);
	  var uid = __webpack_require__(20);
	  var wks = __webpack_require__(27);
	  var createArrayMethod = __webpack_require__(174);
	  var createArrayIncludes = __webpack_require__(37);
	  var speciesConstructor = __webpack_require__(209);
	  var ArrayIterators = __webpack_require__(195);
	  var Iterators = __webpack_require__(130);
	  var $iterDetect = __webpack_require__(167);
	  var setSpecies = __webpack_require__(194);
	  var arrayFill = __webpack_require__(190);
	  var arrayCopyWithin = __webpack_require__(187);
	  var $DP = __webpack_require__(12);
	  var $GOPD = __webpack_require__(51);
	  var dP = $DP.f;
	  var gOPD = $GOPD.f;
	  var RangeError = global.RangeError;
	  var TypeError = global.TypeError;
	  var Uint8Array = global.Uint8Array;
	  var ARRAY_BUFFER = 'ArrayBuffer';
	  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
	  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	  var PROTOTYPE = 'prototype';
	  var ArrayProto = Array[PROTOTYPE];
	  var $ArrayBuffer = $buffer.ArrayBuffer;
	  var $DataView = $buffer.DataView;
	  var arrayForEach = createArrayMethod(0);
	  var arrayFilter = createArrayMethod(2);
	  var arraySome = createArrayMethod(3);
	  var arrayEvery = createArrayMethod(4);
	  var arrayFind = createArrayMethod(5);
	  var arrayFindIndex = createArrayMethod(6);
	  var arrayIncludes = createArrayIncludes(true);
	  var arrayIndexOf = createArrayIncludes(false);
	  var arrayValues = ArrayIterators.values;
	  var arrayKeys = ArrayIterators.keys;
	  var arrayEntries = ArrayIterators.entries;
	  var arrayLastIndexOf = ArrayProto.lastIndexOf;
	  var arrayReduce = ArrayProto.reduce;
	  var arrayReduceRight = ArrayProto.reduceRight;
	  var arrayJoin = ArrayProto.join;
	  var arraySort = ArrayProto.sort;
	  var arraySlice = ArrayProto.slice;
	  var arrayToString = ArrayProto.toString;
	  var arrayToLocaleString = ArrayProto.toLocaleString;
	  var ITERATOR = wks('iterator');
	  var TAG = wks('toStringTag');
	  var TYPED_CONSTRUCTOR = uid('typed_constructor');
	  var DEF_CONSTRUCTOR = uid('def_constructor');
	  var ALL_CONSTRUCTORS = $typed.CONSTR;
	  var TYPED_ARRAY = $typed.TYPED;
	  var VIEW = $typed.VIEW;
	  var WRONG_LENGTH = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function (O, length) {
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function () {
	    // eslint-disable-next-line no-undef
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
	    new Uint8Array(1).set({});
	  });
	
	  var toOffset = function (it, BYTES) {
	    var offset = toInteger(it);
	    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function (it) {
	    if (isObject(it) && TYPED_ARRAY in it) return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function (C, length) {
	    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function (O, list) {
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function (C, list) {
	    var index = 0;
	    var length = list.length;
	    var result = allocate(C, length);
	    while (length > index) result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function (it, key, internal) {
	    dP(it, key, { get: function () { return this._d[internal]; } });
	  };
	
	  var $from = function from(source /* , mapfn, thisArg */) {
	    var O = toObject(source);
	    var aLen = arguments.length;
	    var mapfn = aLen > 1 ? arguments[1] : undefined;
	    var mapping = mapfn !== undefined;
	    var iterFn = getIterFn(O);
	    var i, length, values, result, step, iterator;
	    if (iterFn != undefined && !isArrayIter(iterFn)) {
	      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
	        values.push(step.value);
	      } O = values;
	    }
	    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
	    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/* ...items */) {
	    var index = 0;
	    var length = arguments.length;
	    var result = allocate(this, length);
	    while (length > index) result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString() {
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /* , end */) {
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /* , thisArg */) {
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /* , thisArg */) {
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /* , thisArg */) {
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /* , thisArg */) {
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /* , thisArg */) {
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /* , fromIndex */) {
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /* , fromIndex */) {
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator) { // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /* , thisArg */) {
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse() {
	      var that = this;
	      var length = validate(that).length;
	      var middle = Math.floor(length / 2);
	      var index = 0;
	      var value;
	      while (index < middle) {
	        value = that[index];
	        that[index++] = that[--length];
	        that[length] = value;
	      } return that;
	    },
	    some: function some(callbackfn /* , thisArg */) {
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn) {
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end) {
	      var O = validate(this);
	      var length = O.length;
	      var $begin = toAbsoluteIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end) {
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /* , offset */) {
	    validate(this);
	    var offset = toOffset(arguments[1], 1);
	    var length = this.length;
	    var src = toObject(arrayLike);
	    var len = toLength(src.length);
	    var index = 0;
	    if (len + offset > length) throw RangeError(WRONG_LENGTH);
	    while (index < len) this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries() {
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys() {
	      return arrayKeys.call(validate(this));
	    },
	    values: function values() {
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function (target, key) {
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key) {
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc) {
	    if (isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ) {
	      target[key] = desc.value;
	      return target;
	    } return dP(target, key, desc);
	  };
	
	  if (!ALL_CONSTRUCTORS) {
	    $GOPD.f = $getDesc;
	    $DP.f = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty: $setDesc
	  });
	
	  if (fails(function () { arrayToString.call({}); })) {
	    arrayToString = arrayToLocaleString = function toString() {
	      return arrayJoin.call(this);
	    };
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice: $slice,
	    set: $set,
	    constructor: function () { /* noop */ },
	    toString: arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function () { return this[TYPED_ARRAY]; }
	  });
	
	  // eslint-disable-next-line max-statements
	  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
	    CLAMPED = !!CLAMPED;
	    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + KEY;
	    var SETTER = 'set' + KEY;
	    var TypedArray = global[NAME];
	    var Base = TypedArray || {};
	    var TAC = TypedArray && getPrototypeOf(TypedArray);
	    var FORCED = !TypedArray || !$typed.ABV;
	    var O = {};
	    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function (that, index) {
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function (that, index, value) {
	      var data = that._d;
	      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function (that, index) {
	      dP(that, index, {
	        get: function () {
	          return getter(this, index);
	        },
	        set: function (value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if (FORCED) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME, '_d');
	        var index = 0;
	        var offset = 0;
	        var buffer, byteLength, length, klass;
	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new $ArrayBuffer(byteLength);
	        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (TYPED_ARRAY in data) {
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if (!fails(function () {
	      TypedArray(1);
	    }) || !fails(function () {
	      new TypedArray(-1); // eslint-disable-line no-new
	    }) || !$iterDetect(function (iter) {
	      new TypedArray(); // eslint-disable-line no-new
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(1.5); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)) {
	      TypedArray = wrapper(function (that, data, $offset, $length) {
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if (!isObject(data)) return new Base(toIndex(data));
	        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
	        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator = TypedArrayPrototype[ITERATOR];
	    var CORRECT_ITER_NAME = !!$nativeIterator
	      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
	    var $iterator = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
	      dP(TypedArrayPrototype, TAG, {
	        get: function () { return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES
	    });
	
	    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
	      from: $from,
	      of: $of
	    });
	
	    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
	
	    $export($export.P + $export.F * fails(function () {
	      new TypedArray(1).slice();
	    }), NAME, { slice: $slice });
	
	    $export($export.P + $export.F * (fails(function () {
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
	    }) || !fails(function () {
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, { toLocaleString: $toLocaleString });
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function () { /* empty */ };


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(231)('Uint8', 1, function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(231)('Uint8', 1, function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(231)('Int16', 2, function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(231)('Uint16', 2, function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(231)('Int32', 4, function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(231)('Uint32', 4, function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(231)('Float32', 4, function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(231)('Float64', 8, function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export = __webpack_require__(9);
	var aFunction = __webpack_require__(22);
	var anObject = __webpack_require__(13);
	var rApply = (__webpack_require__(5).Reflect || {}).apply;
	var fApply = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(8)(function () {
	  rApply(function () { /* empty */ });
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList) {
	    var T = aFunction(target);
	    var L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export = __webpack_require__(9);
	var create = __webpack_require__(46);
	var aFunction = __webpack_require__(22);
	var anObject = __webpack_require__(13);
	var isObject = __webpack_require__(14);
	var fails = __webpack_require__(8);
	var bind = __webpack_require__(77);
	var rConstruct = (__webpack_require__(5).Reflect || {}).construct;
	
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() { /* empty */ }
	  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  rConstruct(function () { /* empty */ });
	});
	
	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = create(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP = __webpack_require__(12);
	var $export = __webpack_require__(9);
	var anObject = __webpack_require__(13);
	var toPrimitive = __webpack_require__(17);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(8)(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export = __webpack_require__(9);
	var gOPD = __webpack_require__(51).f;
	var anObject = __webpack_require__(13);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export = __webpack_require__(9);
	var anObject = __webpack_require__(13);
	var Enumerate = function (iterated) {
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = [];      // keys
	  var key;
	  for (key in iterated) keys.push(key);
	};
	__webpack_require__(131)(Enumerate, 'Object', function () {
	  var that = this;
	  var keys = that._k;
	  var key;
	  do {
	    if (that._i >= keys.length) return { value: undefined, done: true };
	  } while (!((key = keys[that._i++]) in that._t));
	  return { value: key, done: false };
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target) {
	    return new Enumerate(target);
	  }
	});


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD = __webpack_require__(51);
	var getPrototypeOf = __webpack_require__(59);
	var has = __webpack_require__(6);
	var $export = __webpack_require__(9);
	var isObject = __webpack_require__(14);
	var anObject = __webpack_require__(13);
	
	function get(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var desc, proto;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD = __webpack_require__(51);
	var $export = __webpack_require__(9);
	var anObject = __webpack_require__(13);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export = __webpack_require__(9);
	var getProto = __webpack_require__(59);
	var anObject = __webpack_require__(13);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return getProto(anObject(target));
	  }
	});


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export = __webpack_require__(9);
	var anObject = __webpack_require__(13);
	var $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Reflect', { ownKeys: __webpack_require__(251) });


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN = __webpack_require__(50);
	var gOPS = __webpack_require__(43);
	var anObject = __webpack_require__(13);
	var Reflect = __webpack_require__(5).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
	  var keys = gOPN.f(anObject(it));
	  var getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export = __webpack_require__(9);
	var anObject = __webpack_require__(13);
	var $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      if ($preventExtensions) $preventExtensions(target);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP = __webpack_require__(12);
	var gOPD = __webpack_require__(51);
	var getPrototypeOf = __webpack_require__(59);
	var has = __webpack_require__(6);
	var $export = __webpack_require__(9);
	var createDesc = __webpack_require__(18);
	var anObject = __webpack_require__(13);
	var isObject = __webpack_require__(14);
	
	function set(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDesc = gOPD.f(anObject(target), propertyKey);
	  var existingDescriptor, proto;
	  if (!ownDesc) {
	    if (isObject(proto = getPrototypeOf(target))) {
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if (has(ownDesc, 'value')) {
	    if (ownDesc.writable === false || !isObject(receiver)) return false;
	    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
	      existingDescriptor.value = V;
	      dP.f(receiver, propertyKey, existingDescriptor);
	    } else dP.f(receiver, propertyKey, createDesc(0, V));
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export = __webpack_require__(9);
	var setProto = __webpack_require__(73);
	
	if (setProto) $export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }
	});


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export = __webpack_require__(9);
	var $includes = __webpack_require__(37)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(188)('includes');


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
	var $export = __webpack_require__(9);
	var flattenIntoArray = __webpack_require__(257);
	var toObject = __webpack_require__(58);
	var toLength = __webpack_require__(38);
	var aFunction = __webpack_require__(22);
	var arraySpeciesCreate = __webpack_require__(175);
	
	$export($export.P, 'Array', {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var sourceLen, A;
	    aFunction(callbackfn);
	    sourceLen = toLength(O.length);
	    A = arraySpeciesCreate(O, 0);
	    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
	    return A;
	  }
	});
	
	__webpack_require__(188)('flatMap');


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
	var isArray = __webpack_require__(45);
	var isObject = __webpack_require__(14);
	var toLength = __webpack_require__(38);
	var ctx = __webpack_require__(21);
	var IS_CONCAT_SPREADABLE = __webpack_require__(27)('isConcatSpreadable');
	
	function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
	  var element, spreadable;
	
	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
	
	      spreadable = false;
	      if (isObject(element)) {
	        spreadable = element[IS_CONCAT_SPREADABLE];
	        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
	      }
	
	      if (spreadable && depth > 0) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
	        target[targetIndex] = element;
	      }
	
	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	}
	
	module.exports = flattenIntoArray;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
	var $export = __webpack_require__(9);
	var flattenIntoArray = __webpack_require__(257);
	var toObject = __webpack_require__(58);
	var toLength = __webpack_require__(38);
	var toInteger = __webpack_require__(39);
	var arraySpeciesCreate = __webpack_require__(175);
	
	$export($export.P, 'Array', {
	  flatten: function flatten(/* depthArg = 1 */) {
	    var depthArg = arguments[0];
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A = arraySpeciesCreate(O, 0);
	    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
	    return A;
	  }
	});
	
	__webpack_require__(188)('flatten');


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(9);
	var $at = __webpack_require__(128)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos) {
	    return $at(this, pos);
	  }
	});


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(9);
	var $pad = __webpack_require__(261);
	var userAgent = __webpack_require__(214);
	
	// https://github.com/zloirock/core-js/issues/280
	$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(38);
	var repeat = __webpack_require__(91);
	var defined = __webpack_require__(36);
	
	module.exports = function (that, maxLength, fillString, left) {
	  var S = String(defined(that));
	  var stringLength = S.length;
	  var fillStr = fillString === undefined ? ' ' : String(fillString);
	  var intMaxLength = toLength(maxLength);
	  if (intMaxLength <= stringLength || fillStr == '') return S;
	  var fillLen = intMaxLength - stringLength;
	  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(9);
	var $pad = __webpack_require__(261);
	var userAgent = __webpack_require__(214);
	
	// https://github.com/zloirock/core-js/issues/280
	$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimLeft', function ($trim) {
	  return function trimLeft() {
	    return $trim(this, 1);
	  };
	}, 'trimStart');


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimRight', function ($trim) {
	  return function trimRight() {
	    return $trim(this, 2);
	  };
	}, 'trimEnd');


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export = __webpack_require__(9);
	var defined = __webpack_require__(36);
	var toLength = __webpack_require__(38);
	var isRegExp = __webpack_require__(135);
	var getFlags = __webpack_require__(198);
	var RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function (regexp, string) {
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(131)($RegExpStringIterator, 'RegExp String', function next() {
	  var match = this._r.exec(this._s);
	  return { value: match, done: match === null };
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp) {
	    defined(this);
	    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
	    var S = String(this);
	    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
	    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(29)('asyncIterator');


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(29)('observable');


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export = __webpack_require__(9);
	var ownKeys = __webpack_require__(251);
	var toIObject = __webpack_require__(33);
	var gOPD = __webpack_require__(51);
	var createProperty = __webpack_require__(165);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIObject(object);
	    var getDesc = gOPD.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var i = 0;
	    var key, desc;
	    while (keys.length > i) {
	      desc = getDesc(O, key = keys[i++]);
	      if (desc !== undefined) createProperty(result, key, desc);
	    }
	    return result;
	  }
	});


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(9);
	var $values = __webpack_require__(270)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

	var getKeys = __webpack_require__(31);
	var toIObject = __webpack_require__(33);
	var isEnum = __webpack_require__(44).f;
	module.exports = function (isEntries) {
	  return function (it) {
	    var O = toIObject(it);
	    var keys = getKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) if (isEnum.call(O, key = keys[i++])) {
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(9);
	var $entries = __webpack_require__(270)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it) {
	    return $entries(it);
	  }
	});


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var toObject = __webpack_require__(58);
	var aFunction = __webpack_require__(22);
	var $defineProperty = __webpack_require__(12);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(7) && $export($export.P + __webpack_require__(273), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter) {
	    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
	  }
	});


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(25) || !__webpack_require__(8)(function () {
	  var K = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call
	  __defineSetter__.call(null, K, function () { /* empty */ });
	  delete __webpack_require__(5)[K];
	});


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var toObject = __webpack_require__(58);
	var aFunction = __webpack_require__(22);
	var $defineProperty = __webpack_require__(12);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(7) && $export($export.P + __webpack_require__(273), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter) {
	    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
	  }
	});


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var toObject = __webpack_require__(58);
	var toPrimitive = __webpack_require__(17);
	var getPrototypeOf = __webpack_require__(59);
	var getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(7) && $export($export.P + __webpack_require__(273), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P) {
	    var O = toObject(this);
	    var K = toPrimitive(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
	    } while (O = getPrototypeOf(O));
	  }
	});


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(9);
	var toObject = __webpack_require__(58);
	var toPrimitive = __webpack_require__(17);
	var getPrototypeOf = __webpack_require__(59);
	var getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(7) && $export($export.P + __webpack_require__(273), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P) {
	    var O = toObject(this);
	    var K = toPrimitive(P, true);
	    var D;
	    do {
	      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
	    } while (O = getPrototypeOf(O));
	  }
	});


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(9);
	
	$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(278)('Map') });


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(75);
	var from = __webpack_require__(279);
	module.exports = function (NAME) {
	  return function toJSON() {
	    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(208);
	
	module.exports = function (iter, ITERATOR) {
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export = __webpack_require__(9);
	
	$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(278)('Set') });


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	__webpack_require__(282)('Map');


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = __webpack_require__(9);
	
	module.exports = function (COLLECTION) {
	  $export($export.S, COLLECTION, { of: function of() {
	    var length = arguments.length;
	    var A = new Array(length);
	    while (length--) A[length] = arguments[length];
	    return new this(A);
	  } });
	};


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
	__webpack_require__(282)('Set');


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
	__webpack_require__(282)('WeakMap');


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
	__webpack_require__(282)('WeakSet');


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	__webpack_require__(287)('Map');


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/proposal-setmap-offrom/
	var $export = __webpack_require__(9);
	var aFunction = __webpack_require__(22);
	var ctx = __webpack_require__(21);
	var forOf = __webpack_require__(208);
	
	module.exports = function (COLLECTION) {
	  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
	    var mapFn = arguments[1];
	    var mapping, A, n, cb;
	    aFunction(this);
	    mapping = mapFn !== undefined;
	    if (mapping) aFunction(mapFn);
	    if (source == undefined) return new this();
	    A = [];
	    if (mapping) {
	      n = 0;
	      cb = ctx(mapFn, arguments[2], 2);
	      forOf(source, false, function (nextItem) {
	        A.push(cb(nextItem, n++));
	      });
	    } else {
	      forOf(source, false, A.push, A);
	    }
	    return new this(A);
	  } });
	};


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
	__webpack_require__(287)('Set');


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
	__webpack_require__(287)('WeakMap');


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
	__webpack_require__(287)('WeakSet');


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-global
	var $export = __webpack_require__(9);
	
	$export($export.G, { global: __webpack_require__(5) });


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-global
	var $export = __webpack_require__(9);
	
	$export($export.S, 'System', { global: __webpack_require__(5) });


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(9);
	var cof = __webpack_require__(35);
	
	$export($export.S, 'Error', {
	  isError: function isError(it) {
	    return cof(it) === 'Error';
	  }
	});


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  clamp: function clamp(x, lower, upper) {
	    return Math.min(upper, Math.max(lower, x));
	  }
	});


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(9);
	var RAD_PER_DEG = 180 / Math.PI;
	
	$export($export.S, 'Math', {
	  degrees: function degrees(radians) {
	    return radians * RAD_PER_DEG;
	  }
	});


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(9);
	var scale = __webpack_require__(298);
	var fround = __webpack_require__(114);
	
	$export($export.S, 'Math', {
	  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
	    return fround(scale(x, inLow, inHigh, outLow, outHigh));
	  }
	});


/***/ }),
/* 298 */
/***/ (function(module, exports) {

	// https://rwaldron.github.io/proposal-math-extensions/
	module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
	  if (
	    arguments.length === 0
	      // eslint-disable-next-line no-self-compare
	      || x != x
	      // eslint-disable-next-line no-self-compare
	      || inLow != inLow
	      // eslint-disable-next-line no-self-compare
	      || inHigh != inHigh
	      // eslint-disable-next-line no-self-compare
	      || outLow != outLow
	      // eslint-disable-next-line no-self-compare
	      || outHigh != outHigh
	  ) return NaN;
	  if (x === Infinity || x === -Infinity) return x;
	  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
	};


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1) {
	    var $x0 = x0 >>> 0;
	    var $x1 = x1 >>> 0;
	    var $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >> 16;
	    var v1 = $v >> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(9);
	var DEG_PER_RAD = Math.PI / 180;
	
	$export($export.S, 'Math', {
	  radians: function radians(degrees) {
	    return degrees * DEG_PER_RAD;
	  }
	});


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

	// https://rwaldron.github.io/proposal-math-extensions/
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', { scale: __webpack_require__(298) });


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v) {
	    var UINT16 = 0xffff;
	    var $u = +u;
	    var $v = +v;
	    var u0 = $u & UINT16;
	    var v0 = $v & UINT16;
	    var u1 = $u >>> 16;
	    var v1 = $v >>> 16;
	    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

	// http://jfbastien.github.io/papers/Math.signbit.html
	var $export = __webpack_require__(9);
	
	$export($export.S, 'Math', { signbit: function signbit(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
	} });


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-promise-finally
	'use strict';
	var $export = __webpack_require__(9);
	var core = __webpack_require__(10);
	var global = __webpack_require__(5);
	var speciesConstructor = __webpack_require__(209);
	var promiseResolve = __webpack_require__(215);
	
	$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
	  var C = speciesConstructor(this, core.Promise || global.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-promise-try
	var $export = __webpack_require__(9);
	var newPromiseCapability = __webpack_require__(212);
	var perform = __webpack_require__(213);
	
	$export($export.S, 'Promise', { 'try': function (callbackfn) {
	  var promiseCapability = newPromiseCapability.f(this);
	  var result = perform(callbackfn);
	  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	  return promiseCapability.promise;
	} });


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(310);
	var anObject = __webpack_require__(13);
	var toMetaKey = metadata.key;
	var ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	} });


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

	var Map = __webpack_require__(217);
	var $export = __webpack_require__(9);
	var shared = __webpack_require__(24)('metadata');
	var store = shared.store || (shared.store = new (__webpack_require__(222))());
	
	var getOrCreateMetadataMap = function (target, targetKey, create) {
	  var targetMetadata = store.get(target);
	  if (!targetMetadata) {
	    if (!create) return undefined;
	    store.set(target, targetMetadata = new Map());
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if (!keyMetadata) {
	    if (!create) return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map());
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function (target, targetKey) {
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
	  var keys = [];
	  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
	  return keys;
	};
	var toMetaKey = function (it) {
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function (O) {
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(310);
	var anObject = __webpack_require__(13);
	var toMetaKey = metadata.key;
	var getOrCreateMetadataMap = metadata.map;
	var store = metadata.store;
	
	metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
	  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
	  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
	  if (metadataMap.size) return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	} });


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(310);
	var anObject = __webpack_require__(13);
	var getPrototypeOf = __webpack_require__(59);
	var ordinaryHasOwnMetadata = metadata.has;
	var ordinaryGetOwnMetadata = metadata.get;
	var toMetaKey = metadata.key;
	
	var ordinaryGetMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

	var Set = __webpack_require__(221);
	var from = __webpack_require__(279);
	var metadata = __webpack_require__(310);
	var anObject = __webpack_require__(13);
	var getPrototypeOf = __webpack_require__(59);
	var ordinaryOwnMetadataKeys = metadata.keys;
	var toMetaKey = metadata.key;
	
	var ordinaryMetadataKeys = function (O, P) {
	  var oKeys = ordinaryOwnMetadataKeys(O, P);
	  var parent = getPrototypeOf(O);
	  if (parent === null) return oKeys;
	  var pKeys = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	} });


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(310);
	var anObject = __webpack_require__(13);
	var ordinaryGetOwnMetadata = metadata.get;
	var toMetaKey = metadata.key;
	
	metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(310);
	var anObject = __webpack_require__(13);
	var ordinaryOwnMetadataKeys = metadata.keys;
	var toMetaKey = metadata.key;
	
	metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	} });


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(310);
	var anObject = __webpack_require__(13);
	var getPrototypeOf = __webpack_require__(59);
	var ordinaryHasOwnMetadata = metadata.has;
	var toMetaKey = metadata.key;
	
	var ordinaryHasMetadata = function (MetadataKey, O, P) {
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if (hasOwn) return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

	var metadata = __webpack_require__(310);
	var anObject = __webpack_require__(13);
	var ordinaryHasOwnMetadata = metadata.has;
	var toMetaKey = metadata.key;
	
	metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	} });


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

	var $metadata = __webpack_require__(310);
	var anObject = __webpack_require__(13);
	var aFunction = __webpack_require__(22);
	var toMetaKey = $metadata.key;
	var ordinaryDefineOwnMetadata = $metadata.set;
	
	$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
	  return function decorator(target, targetKey) {
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	} });


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export = __webpack_require__(9);
	var microtask = __webpack_require__(211)();
	var process = __webpack_require__(5).process;
	var isNode = __webpack_require__(35)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn) {
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export = __webpack_require__(9);
	var global = __webpack_require__(5);
	var core = __webpack_require__(10);
	var microtask = __webpack_require__(211)();
	var OBSERVABLE = __webpack_require__(27)('observable');
	var aFunction = __webpack_require__(22);
	var anObject = __webpack_require__(13);
	var anInstance = __webpack_require__(207);
	var redefineAll = __webpack_require__(216);
	var hide = __webpack_require__(11);
	var forOf = __webpack_require__(208);
	var RETURN = forOf.RETURN;
	
	var getMethod = function (fn) {
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function (subscription) {
	  var cleanup = subscription._c;
	  if (cleanup) {
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function (subscription) {
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function (subscription) {
	  if (!subscriptionClosed(subscription)) {
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function (observer, subscriber) {
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup = subscriber(observer);
	    var subscription = cleanup;
	    if (cleanup != null) {
	      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch (e) {
	    observer.error(e);
	    return;
	  } if (subscriptionClosed(this)) cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe() { closeSubscription(this); }
	});
	
	var SubscriptionObserver = function (subscription) {
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if (m) return m.call(observer, value);
	      } catch (e) {
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value) {
	    var subscription = this._s;
	    if (subscriptionClosed(subscription)) throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if (!m) throw value;
	      value = m.call(observer, value);
	    } catch (e) {
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value) {
	    var subscription = this._s;
	    if (!subscriptionClosed(subscription)) {
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch (e) {
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber) {
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer) {
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn) {
	    var that = this;
	    return new (core.Promise || global.Promise)(function (resolve, reject) {
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next: function (value) {
	          try {
	            return fn(value);
	          } catch (e) {
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x) {
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if (method) {
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function (observer) {
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          try {
	            if (forOf(x, false, function (it) {
	              observer.next(it);
	              if (done) return RETURN;
	            }) === RETURN) return;
	          } catch (e) {
	            if (done) throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  },
	  of: function of() {
	    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
	      var done = false;
	      microtask(function () {
	        if (!done) {
	          for (var j = 0; j < items.length; ++j) {
	            observer.next(items[j]);
	            if (done) return;
	          } observer.complete();
	        }
	      });
	      return function () { done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function () { return this; });
	
	$export($export.G, { Observable: $Observable });
	
	__webpack_require__(194)('Observable');


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global = __webpack_require__(5);
	var $export = __webpack_require__(9);
	var userAgent = __webpack_require__(214);
	var slice = [].slice;
	var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
	var wrap = function (set) {
	  return function (fn, time /* , ...args */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice.call(arguments, 2) : false;
	    return set(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
	    } : fn, time);
	  };
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout: wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(9);
	var $task = __webpack_require__(210);
	$export($export.G + $export.B, {
	  setImmediate: $task.set,
	  clearImmediate: $task.clear
	});


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

	var $iterators = __webpack_require__(195);
	var getKeys = __webpack_require__(31);
	var redefine = __webpack_require__(19);
	var global = __webpack_require__(5);
	var hide = __webpack_require__(11);
	var Iterators = __webpack_require__(130);
	var wks = __webpack_require__(27);
	var ITERATOR = wks('iterator');
	var TO_STRING_TAG = wks('toStringTag');
	var ArrayValues = Iterators.Array;
	
	var DOMIterables = {
	  CSSRuleList: true, // TODO: Not spec compliant, should be false.
	  CSSStyleDeclaration: false,
	  CSSValueList: false,
	  ClientRectList: false,
	  DOMRectList: false,
	  DOMStringList: false,
	  DOMTokenList: true,
	  DataTransferItemList: false,
	  FileList: false,
	  HTMLAllCollection: false,
	  HTMLCollection: false,
	  HTMLFormElement: false,
	  HTMLSelectElement: false,
	  MediaList: true, // TODO: Not spec compliant, should be false.
	  MimeTypeArray: false,
	  NamedNodeMap: false,
	  NodeList: true,
	  PaintRequestList: false,
	  Plugin: false,
	  PluginArray: false,
	  SVGLengthList: false,
	  SVGNumberList: false,
	  SVGPathSegList: false,
	  SVGPointList: false,
	  SVGStringList: false,
	  SVGTransformList: false,
	  SourceBufferList: false,
	  StyleSheetList: true, // TODO: Not spec compliant, should be false.
	  TextTrackCueList: false,
	  TextTrackList: false,
	  TouchList: false
	};
	
	for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
	  var NAME = collections[i];
	  var explicit = DOMIterables[NAME];
	  var Collection = global[NAME];
	  var proto = Collection && Collection.prototype;
	  var key;
	  if (proto) {
	    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
	    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
	  }
	}


/***/ }),
/* 324 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };
	
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	
	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof global.process === "object" && global.process.domain) {
	      invoke = global.process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  runtime.AsyncIterator = AsyncIterator;
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      context.method = method;
	      context.arg = arg;
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	
	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;
	
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }
	
	          context.dispatchException(context.arg);
	
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          if (record.arg === ContinueSentinel) {
	            continue;
	          }
	
	          return {
	            value: record.arg,
	            done: context.done
	          };
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;
	
	      if (context.method === "throw") {
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);
	
	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }
	
	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }
	
	      return ContinueSentinel;
	    }
	
	    var record = tryCatch(method, delegate.iterator, context.arg);
	
	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    var info = record.arg;
	
	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	
	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;
	
	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;
	
	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }
	
	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }
	
	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.method = "next";
	      this.arg = undefined;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	
	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }
	
	        return !! caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }
	
	      return this.complete(record);
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	
	      return ContinueSentinel;
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(326);
	module.exports = __webpack_require__(10).RegExp.escape;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(9);
	var $re = __webpack_require__(327)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });


/***/ }),
/* 327 */
/***/ (function(module, exports) {

	module.exports = function (regExp, replace) {
	  var replacer = replace === Object(replace) ? function (part) {
	    return replace[part];
	  } : replace;
	  return function (it) {
	    return String(it).replace(regExp, replacer);
	  };
	};


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _pluginRaphael = __webpack_require__(329);
	
	var _chart = __webpack_require__(357);
	
	var _chart2 = _interopRequireDefault(_chart);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _colorutil = __webpack_require__(465);
	
	var _colorutil2 = _interopRequireDefault(_colorutil);
	
	__webpack_require__(474);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	_chart2['default'].registerPlugin('Raphael', _pluginRaphael.pluginRaphael, _pluginRaphael.callback);
	
	_chart2['default'].renderUtil = _renderUtil2['default'];
	_chart2['default'].arrayUtil = _arrayUtil2['default'];
	_chart2['default'].colorutil = _colorutil2['default'];
	
	/**
	 * NHN. Toast UI Chart.
	 * @namespace tui.chart
	 */
	module.exports = _chart2['default'];

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.callback = exports.pluginRaphael = undefined;
	
	var _raphael = __webpack_require__(330);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	var _raphaelBarChart = __webpack_require__(331);
	
	var _raphaelBarChart2 = _interopRequireDefault(_raphaelBarChart);
	
	var _raphaelBoxplotChart = __webpack_require__(338);
	
	var _raphaelBoxplotChart2 = _interopRequireDefault(_raphaelBoxplotChart);
	
	var _raphaelBulletChart = __webpack_require__(339);
	
	var _raphaelBulletChart2 = _interopRequireDefault(_raphaelBulletChart);
	
	var _raphaelLineChart = __webpack_require__(340);
	
	var _raphaelLineChart2 = _interopRequireDefault(_raphaelLineChart);
	
	var _raphaelAreaChart = __webpack_require__(343);
	
	var _raphaelAreaChart2 = _interopRequireDefault(_raphaelAreaChart);
	
	var _raphaelPieChart = __webpack_require__(345);
	
	var _raphaelPieChart2 = _interopRequireDefault(_raphaelPieChart);
	
	var _raphaelRadialLineSeries = __webpack_require__(346);
	
	var _raphaelRadialLineSeries2 = _interopRequireDefault(_raphaelRadialLineSeries);
	
	var _raphaelCoordinateTypeChart = __webpack_require__(347);
	
	var _raphaelCoordinateTypeChart2 = _interopRequireDefault(_raphaelCoordinateTypeChart);
	
	var _raphaelBoxTypeChart = __webpack_require__(348);
	
	var _raphaelBoxTypeChart2 = _interopRequireDefault(_raphaelBoxTypeChart);
	
	var _raphaelMapChart = __webpack_require__(349);
	
	var _raphaelMapChart2 = _interopRequireDefault(_raphaelMapChart);
	
	var _raphaelLegendComponent = __webpack_require__(350);
	
	var _raphaelLegendComponent2 = _interopRequireDefault(_raphaelLegendComponent);
	
	var _raphaelMapLegend = __webpack_require__(352);
	
	var _raphaelMapLegend2 = _interopRequireDefault(_raphaelMapLegend);
	
	var _raphaelCircleLegend = __webpack_require__(353);
	
	var _raphaelCircleLegend2 = _interopRequireDefault(_raphaelCircleLegend);
	
	var _raphaelTitleComponent = __webpack_require__(354);
	
	var _raphaelTitleComponent2 = _interopRequireDefault(_raphaelTitleComponent);
	
	var _raphaelAxisComponent = __webpack_require__(355);
	
	var _raphaelAxisComponent2 = _interopRequireDefault(_raphaelAxisComponent);
	
	var _raphaelRadialPlot = __webpack_require__(356);
	
	var _raphaelRadialPlot2 = _interopRequireDefault(_raphaelRadialPlot);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var pluginRaphael = exports.pluginRaphael = {
	    bar: _raphaelBarChart2['default'],
	    boxplot: _raphaelBoxplotChart2['default'],
	    bullet: _raphaelBulletChart2['default'],
	    column: _raphaelBarChart2['default'],
	    line: _raphaelLineChart2['default'],
	    area: _raphaelAreaChart2['default'],
	    pie: _raphaelPieChart2['default'],
	    bubble: _raphaelCoordinateTypeChart2['default'],
	    scatter: _raphaelCoordinateTypeChart2['default'],
	    heatmap: _raphaelBoxTypeChart2['default'],
	    treemap: _raphaelBoxTypeChart2['default'],
	    map: _raphaelMapChart2['default'],
	    radial: _raphaelRadialLineSeries2['default'],
	    legend: _raphaelLegendComponent2['default'],
	    mapLegend: _raphaelMapLegend2['default'],
	    circleLegend: _raphaelCircleLegend2['default'],
	    radialPlot: _raphaelRadialPlot2['default'],
	    title: _raphaelTitleComponent2['default'],
	    axis: _raphaelAxisComponent2['default']
	}; /**
	    * @fileoverview Raphael render plugin.
	    * @author NHN.
	    *         FE Development Lab <dl_javascript@nhn.com>
	    */
	
	var callback = exports.callback = function callback(container, dimension) {
	    var paper = (0, _raphael2['default'])(container, dimension.width, dimension.height);
	    var rect = paper.rect(0, 0, dimension.width, dimension.height);
	
	    if (paper.raphael.svg) {
	        appendGlowFilterToDefs(paper);
	        appendShadowFilterToDefs(paper);
	    }
	
	    paper.pushDownBackgroundToBottom = function () {
	        rect.toBack();
	    };
	
	    paper.changeChartBackgroundColor = function (color) {
	        rect.attr({
	            fill: color
	        });
	    };
	
	    paper.changeChartBackgroundOpacity = function (opacity) {
	        rect.attr({
	            'fill-opacity': opacity
	        });
	    };
	
	    paper.resizeBackground = function (width, height) {
	        rect.attr({
	            width: width,
	            height: height
	        });
	    };
	
	    rect.attr({
	        fill: '#fff',
	        'stroke-width': 0
	    });
	
	    return paper;
	};
	
	/**
	 * Append glow filter for series label
	 * @param {object} paper Raphael paper object
	 * @ignore
	 */
	function appendGlowFilterToDefs(paper) {
	    var filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
	    var feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
	    var feFlood = document.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
	    var feComposite = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
	    var feMorphology = document.createElementNS('http://www.w3.org/2000/svg', 'feMorphology');
	    var feMerge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
	    var feMergeNodeColoredBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
	    var feMergeNodeSourceGraphic = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
	
	    filter.id = 'glow';
	
	    feFlood.setAttribute('result', 'flood');
	    feFlood.setAttribute('flood-color', '#ffffff');
	    feFlood.setAttribute('flood-opacity', '0.5');
	
	    feComposite.setAttribute('in', 'flood');
	    feComposite.setAttribute('result', 'mask');
	    feComposite.setAttribute('in2', 'SourceGraphic');
	    feComposite.setAttribute('operator', 'in');
	
	    feMorphology.setAttribute('in', 'mask');
	    feMorphology.setAttribute('result', 'dilated');
	    feMorphology.setAttribute('operator', 'dilate');
	    feMorphology.setAttribute('radius', '2');
	
	    feGaussianBlur.setAttribute('in', 'dilated');
	    feGaussianBlur.setAttribute('result', 'blurred');
	    feGaussianBlur.setAttribute('stdDeviation', '1');
	
	    feMergeNodeColoredBlur.setAttribute('in', 'blurred');
	    feMergeNodeSourceGraphic.setAttribute('in', 'SourceGraphic');
	
	    filter.appendChild(feFlood);
	    filter.appendChild(feComposite);
	    filter.appendChild(feMorphology);
	    filter.appendChild(feGaussianBlur);
	
	    filter.appendChild(feMerge);
	
	    feMerge.appendChild(feMergeNodeColoredBlur);
	    feMerge.appendChild(feMergeNodeSourceGraphic);
	
	    paper.defs.appendChild(filter);
	}
	
	/**
	 * Append shadow filter for series label
	 * @param {object} paper Raphael paper object
	 * @ignore
	 */
	function appendShadowFilterToDefs(paper) {
	    var filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
	    var feOffset = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
	    var feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
	    var feBlend = document.createElementNS('http://www.w3.org/2000/svg', 'feBlend');
	
	    filter.setAttributeNS(null, 'id', 'shadow');
	    filter.setAttributeNS(null, 'x', '-15%');
	    filter.setAttributeNS(null, 'y', '-15%');
	    filter.setAttributeNS(null, 'width', '180%');
	    filter.setAttributeNS(null, 'height', '180%');
	    feOffset.setAttributeNS(null, 'result', 'offOut');
	    feOffset.setAttributeNS(null, 'in', 'SourceAlpha');
	    feOffset.setAttributeNS(null, 'dx', '2');
	    feOffset.setAttributeNS(null, 'dy', '2');
	    feGaussianBlur.setAttributeNS(null, 'result', 'blurOut');
	    feGaussianBlur.setAttributeNS(null, 'in', 'offOut');
	    feGaussianBlur.setAttributeNS(null, 'stdDeviation', '2');
	    feBlend.setAttributeNS(null, 'in', 'SourceGraphic');
	    feBlend.setAttributeNS(null, 'in2', 'blurOut');
	    feBlend.setAttributeNS(null, 'mode', 'normal');
	    filter.appendChild(feOffset);
	    filter.appendChild(feGaussianBlur);
	    filter.appendChild(feBlend);
	    paper.defs.appendChild(filter);
	}

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

	!function t(e,r){ true?module.exports=r():"function"==typeof define&&define.amd?define("Raphael",[],r):"object"==typeof exports?exports.Raphael=r():e.Raphael=r()}(this,function(){return function(t){function e(i){if(r[i])return r[i].exports;var n=r[i]={exports:{},id:i,loaded:!1};return t[i].call(n.exports,n,n.exports,e),n.loaded=!0,n.exports}var r={};return e.m=t,e.c=r,e.p="",e(0)}([function(t,e,r){var i,n;i=[r(1),r(3),r(4)],n=function(t){return t}.apply(e,i),!(void 0!==n&&(t.exports=n))},function(t,e,r){var i,n;i=[r(2)],n=function(t){function e(r){if(e.is(r,"function"))return w?r():t.on("raphael.DOMload",r);if(e.is(r,Q))return e._engine.create[z](e,r.splice(0,3+e.is(r[0],$))).add(r);var i=Array.prototype.slice.call(arguments,0);if(e.is(i[i.length-1],"function")){var n=i.pop();return w?n.call(e._engine.create[z](e,i)):t.on("raphael.DOMload",function(){n.call(e._engine.create[z](e,i))})}return e._engine.create[z](e,arguments)}function r(t){if("function"==typeof t||Object(t)!==t)return t;var e=new t.constructor;for(var i in t)t[T](i)&&(e[i]=r(t[i]));return e}function i(t,e){for(var r=0,i=t.length;r<i;r++)if(t[r]===e)return t.push(t.splice(r,1)[0])}function n(t,e,r){function n(){var a=Array.prototype.slice.call(arguments,0),s=a.join("␀"),o=n.cache=n.cache||{},l=n.count=n.count||[];return o[T](s)?(i(l,s),r?r(o[s]):o[s]):(l.length>=1e3&&delete o[l.shift()],l.push(s),o[s]=t[z](e,a),r?r(o[s]):o[s])}return n}function a(){return this.hex}function s(t,e){for(var r=[],i=0,n=t.length;n-2*!e>i;i+=2){var a=[{x:+t[i-2],y:+t[i-1]},{x:+t[i],y:+t[i+1]},{x:+t[i+2],y:+t[i+3]},{x:+t[i+4],y:+t[i+5]}];e?i?n-4==i?a[3]={x:+t[0],y:+t[1]}:n-2==i&&(a[2]={x:+t[0],y:+t[1]},a[3]={x:+t[2],y:+t[3]}):a[0]={x:+t[n-2],y:+t[n-1]}:n-4==i?a[3]=a[2]:i||(a[0]={x:+t[i],y:+t[i+1]}),r.push(["C",(-a[0].x+6*a[1].x+a[2].x)/6,(-a[0].y+6*a[1].y+a[2].y)/6,(a[1].x+6*a[2].x-a[3].x)/6,(a[1].y+6*a[2].y-a[3].y)/6,a[2].x,a[2].y])}return r}function o(t,e,r,i,n){var a=-3*e+9*r-9*i+3*n,s=t*a+6*e-12*r+6*i;return t*s-3*e+3*r}function l(t,e,r,i,n,a,s,l,h){null==h&&(h=1),h=h>1?1:h<0?0:h;for(var u=h/2,c=12,f=[-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],p=[.2491,.2491,.2335,.2335,.2032,.2032,.1601,.1601,.1069,.1069,.0472,.0472],d=0,g=0;g<c;g++){var x=u*f[g]+u,v=o(x,t,r,n,s),y=o(x,e,i,a,l),m=v*v+y*y;d+=p[g]*Y.sqrt(m)}return u*d}function h(t,e,r,i,n,a,s,o,h){if(!(h<0||l(t,e,r,i,n,a,s,o)<h)){var u=1,c=u/2,f=u-c,p,d=.01;for(p=l(t,e,r,i,n,a,s,o,f);H(p-h)>d;)c/=2,f+=(p<h?1:-1)*c,p=l(t,e,r,i,n,a,s,o,f);return f}}function u(t,e,r,i,n,a,s,o){if(!(W(t,r)<G(n,s)||G(t,r)>W(n,s)||W(e,i)<G(a,o)||G(e,i)>W(a,o))){var l=(t*i-e*r)*(n-s)-(t-r)*(n*o-a*s),h=(t*i-e*r)*(a-o)-(e-i)*(n*o-a*s),u=(t-r)*(a-o)-(e-i)*(n-s);if(u){var c=l/u,f=h/u,p=+c.toFixed(2),d=+f.toFixed(2);if(!(p<+G(t,r).toFixed(2)||p>+W(t,r).toFixed(2)||p<+G(n,s).toFixed(2)||p>+W(n,s).toFixed(2)||d<+G(e,i).toFixed(2)||d>+W(e,i).toFixed(2)||d<+G(a,o).toFixed(2)||d>+W(a,o).toFixed(2)))return{x:c,y:f}}}}function c(t,e){return p(t,e)}function f(t,e){return p(t,e,1)}function p(t,r,i){var n=e.bezierBBox(t),a=e.bezierBBox(r);if(!e.isBBoxIntersect(n,a))return i?0:[];for(var s=l.apply(0,t),o=l.apply(0,r),h=W(~~(s/5),1),c=W(~~(o/5),1),f=[],p=[],d={},g=i?0:[],x=0;x<h+1;x++){var v=e.findDotsAtSegment.apply(e,t.concat(x/h));f.push({x:v.x,y:v.y,t:x/h})}for(x=0;x<c+1;x++)v=e.findDotsAtSegment.apply(e,r.concat(x/c)),p.push({x:v.x,y:v.y,t:x/c});for(x=0;x<h;x++)for(var y=0;y<c;y++){var m=f[x],b=f[x+1],_=p[y],w=p[y+1],k=H(b.x-m.x)<.001?"y":"x",B=H(w.x-_.x)<.001?"y":"x",C=u(m.x,m.y,b.x,b.y,_.x,_.y,w.x,w.y);if(C){if(d[C.x.toFixed(4)]==C.y.toFixed(4))continue;d[C.x.toFixed(4)]=C.y.toFixed(4);var S=m.t+H((C[k]-m[k])/(b[k]-m[k]))*(b.t-m.t),T=_.t+H((C[B]-_[B])/(w[B]-_[B]))*(w.t-_.t);S>=0&&S<=1.001&&T>=0&&T<=1.001&&(i?g++:g.push({x:C.x,y:C.y,t1:G(S,1),t2:G(T,1)}))}}return g}function d(t,r,i){t=e._path2curve(t),r=e._path2curve(r);for(var n,a,s,o,l,h,u,c,f,d,g=i?0:[],x=0,v=t.length;x<v;x++){var y=t[x];if("M"==y[0])n=l=y[1],a=h=y[2];else{"C"==y[0]?(f=[n,a].concat(y.slice(1)),n=f[6],a=f[7]):(f=[n,a,n,a,l,h,l,h],n=l,a=h);for(var m=0,b=r.length;m<b;m++){var _=r[m];if("M"==_[0])s=u=_[1],o=c=_[2];else{"C"==_[0]?(d=[s,o].concat(_.slice(1)),s=d[6],o=d[7]):(d=[s,o,s,o,u,c,u,c],s=u,o=c);var w=p(f,d,i);if(i)g+=w;else{for(var k=0,B=w.length;k<B;k++)w[k].segment1=x,w[k].segment2=m,w[k].bez1=f,w[k].bez2=d;g=g.concat(w)}}}}}return g}function g(t,e,r,i,n,a){null!=t?(this.a=+t,this.b=+e,this.c=+r,this.d=+i,this.e=+n,this.f=+a):(this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0)}function x(){return this.x+I+this.y}function v(){return this.x+I+this.y+I+this.width+" × "+this.height}function y(t,e,r,i,n,a){function s(t){return((c*t+u)*t+h)*t}function o(t,e){var r=l(t,e);return((d*r+p)*r+f)*r}function l(t,e){var r,i,n,a,o,l;for(n=t,l=0;l<8;l++){if(a=s(n)-t,H(a)<e)return n;if(o=(3*c*n+2*u)*n+h,H(o)<1e-6)break;n-=a/o}if(r=0,i=1,n=t,n<r)return r;if(n>i)return i;for(;r<i;){if(a=s(n),H(a-t)<e)return n;t>a?r=n:i=n,n=(i-r)/2+r}return n}var h=3*e,u=3*(i-e)-h,c=1-h-u,f=3*r,p=3*(n-r)-f,d=1-f-p;return o(t,1/(200*a))}function m(t,e){var r=[],i={};if(this.ms=e,this.times=1,t){for(var n in t)t[T](n)&&(i[ht(n)]=t[n],r.push(ht(n)));r.sort(Bt)}this.anim=i,this.top=r[r.length-1],this.percents=r}function b(r,i,n,a,s,o){n=ht(n);var l,h,u,c=[],f,p,d,x=r.ms,v={},m={},b={};if(a)for(w=0,B=Ee.length;w<B;w++){var _=Ee[w];if(_.el.id==i.id&&_.anim==r){_.percent!=n?(Ee.splice(w,1),u=1):h=_,i.attr(_.totalOrigin);break}}else a=+m;for(var w=0,B=r.percents.length;w<B;w++){if(r.percents[w]==n||r.percents[w]>a*r.top){n=r.percents[w],p=r.percents[w-1]||0,x=x/r.top*(n-p),f=r.percents[w+1],l=r.anim[n];break}a&&i.attr(r.anim[r.percents[w]])}if(l){if(h)h.initstatus=a,h.start=new Date-h.ms*a;else{for(var C in l)if(l[T](C)&&(pt[T](C)||i.paper.customAttributes[T](C)))switch(v[C]=i.attr(C),null==v[C]&&(v[C]=ft[C]),m[C]=l[C],pt[C]){case $:b[C]=(m[C]-v[C])/x;break;case"colour":v[C]=e.getRGB(v[C]);var S=e.getRGB(m[C]);b[C]={r:(S.r-v[C].r)/x,g:(S.g-v[C].g)/x,b:(S.b-v[C].b)/x};break;case"path":var A=Qt(v[C],m[C]),E=A[1];for(v[C]=A[0],b[C]=[],w=0,B=v[C].length;w<B;w++){b[C][w]=[0];for(var N=1,M=v[C][w].length;N<M;N++)b[C][w][N]=(E[w][N]-v[C][w][N])/x}break;case"transform":var L=i._,z=le(L[C],m[C]);if(z)for(v[C]=z.from,m[C]=z.to,b[C]=[],b[C].real=!0,w=0,B=v[C].length;w<B;w++)for(b[C][w]=[v[C][w][0]],N=1,M=v[C][w].length;N<M;N++)b[C][w][N]=(m[C][w][N]-v[C][w][N])/x;else{var F=i.matrix||new g,R={_:{transform:L.transform},getBBox:function(){return i.getBBox(1)}};v[C]=[F.a,F.b,F.c,F.d,F.e,F.f],se(R,m[C]),m[C]=R._.transform,b[C]=[(R.matrix.a-F.a)/x,(R.matrix.b-F.b)/x,(R.matrix.c-F.c)/x,(R.matrix.d-F.d)/x,(R.matrix.e-F.e)/x,(R.matrix.f-F.f)/x]}break;case"csv":var I=j(l[C])[q](k),D=j(v[C])[q](k);if("clip-rect"==C)for(v[C]=D,b[C]=[],w=D.length;w--;)b[C][w]=(I[w]-v[C][w])/x;m[C]=I;break;default:for(I=[][P](l[C]),D=[][P](v[C]),b[C]=[],w=i.paper.customAttributes[C].length;w--;)b[C][w]=((I[w]||0)-(D[w]||0))/x}var V=l.easing,O=e.easing_formulas[V];if(!O)if(O=j(V).match(st),O&&5==O.length){var Y=O;O=function(t){return y(t,+Y[1],+Y[2],+Y[3],+Y[4],x)}}else O=St;if(d=l.start||r.start||+new Date,_={anim:r,percent:n,timestamp:d,start:d+(r.del||0),status:0,initstatus:a||0,stop:!1,ms:x,easing:O,from:v,diff:b,to:m,el:i,callback:l.callback,prev:p,next:f,repeat:o||r.times,origin:i.attr(),totalOrigin:s},Ee.push(_),a&&!h&&!u&&(_.stop=!0,_.start=new Date-x*a,1==Ee.length))return Me();u&&(_.start=new Date-_.ms*a),1==Ee.length&&Ne(Me)}t("raphael.anim.start."+i.id,i,r)}}function _(t){for(var e=0;e<Ee.length;e++)Ee[e].el.paper==t&&Ee.splice(e--,1)}e.version="@@VERSION",e.eve=t;var w,k=/[, ]+/,B={circle:1,rect:1,path:1,ellipse:1,text:1,image:1},C=/\{(\d+)\}/g,S="prototype",T="hasOwnProperty",A={doc:document,win:window},E={was:Object.prototype[T].call(A.win,"Raphael"),is:A.win.Raphael},N=function(){this.ca=this.customAttributes={}},M,L="appendChild",z="apply",P="concat",F="ontouchstart"in A.win||A.win.DocumentTouch&&A.doc instanceof DocumentTouch,R="",I=" ",j=String,q="split",D="click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[q](I),V={mousedown:"touchstart",mousemove:"touchmove",mouseup:"touchend"},O=j.prototype.toLowerCase,Y=Math,W=Y.max,G=Y.min,H=Y.abs,X=Y.pow,U=Y.PI,$="number",Z="string",Q="array",J="toString",K="fill",tt=Object.prototype.toString,et={},rt="push",it=e._ISURL=/^url\(['"]?(.+?)['"]?\)$/i,nt=/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,at={NaN:1,Infinity:1,"-Infinity":1},st=/^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,ot=Y.round,lt="setAttribute",ht=parseFloat,ut=parseInt,ct=j.prototype.toUpperCase,ft=e._availableAttrs={"arrow-end":"none","arrow-start":"none",blur:0,"clip-rect":"0 0 1e9 1e9",cursor:"default",cx:0,cy:0,fill:"#fff","fill-opacity":1,font:'10px "Arial"',"font-family":'"Arial"',"font-size":"10","font-style":"normal","font-weight":400,gradient:0,height:0,href:"http://raphaeljs.com/","letter-spacing":0,opacity:1,path:"M0,0",r:0,rx:0,ry:0,src:"",stroke:"#000","stroke-dasharray":"","stroke-linecap":"butt","stroke-linejoin":"butt","stroke-miterlimit":0,"stroke-opacity":1,"stroke-width":1,target:"_blank","text-anchor":"middle",title:"Raphael",transform:"",width:0,x:0,y:0},pt=e._availableAnimAttrs={blur:$,"clip-rect":"csv",cx:$,cy:$,fill:"colour","fill-opacity":$,"font-size":$,height:$,opacity:$,path:"path",r:$,rx:$,ry:$,stroke:"colour","stroke-opacity":$,"stroke-width":$,transform:"transform",width:$,x:$,y:$},dt=/[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,gt=/[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,xt={hs:1,rg:1},vt=/,?([achlmqrstvxz]),?/gi,yt=/([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi,mt=/([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi,bt=/(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/gi,_t=e._radial_gradient=/^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,wt={},kt=function(t,e){return t.key-e.key},Bt=function(t,e){return ht(t)-ht(e)},Ct=function(){},St=function(t){return t},Tt=e._rectPath=function(t,e,r,i,n){return n?[["M",t+n,e],["l",r-2*n,0],["a",n,n,0,0,1,n,n],["l",0,i-2*n],["a",n,n,0,0,1,-n,n],["l",2*n-r,0],["a",n,n,0,0,1,-n,-n],["l",0,2*n-i],["a",n,n,0,0,1,n,-n],["z"]]:[["M",t,e],["l",r,0],["l",0,i],["l",-r,0],["z"]]},At=function(t,e,r,i){return null==i&&(i=r),[["M",t,e],["m",0,-i],["a",r,i,0,1,1,0,2*i],["a",r,i,0,1,1,0,-2*i],["z"]]},Et=e._getPath={path:function(t){return t.attr("path")},circle:function(t){var e=t.attrs;return At(e.cx,e.cy,e.r)},ellipse:function(t){var e=t.attrs;return At(e.cx,e.cy,e.rx,e.ry)},rect:function(t){var e=t.attrs;return Tt(e.x,e.y,e.width,e.height,e.r)},image:function(t){var e=t.attrs;return Tt(e.x,e.y,e.width,e.height)},text:function(t){var e=t._getBBox();return Tt(e.x,e.y,e.width,e.height)},set:function(t){var e=t._getBBox();return Tt(e.x,e.y,e.width,e.height)}},Nt=e.mapPath=function(t,e){if(!e)return t;var r,i,n,a,s,o,l;for(t=Qt(t),n=0,s=t.length;n<s;n++)for(l=t[n],a=1,o=l.length;a<o;a+=2)r=e.x(l[a],l[a+1]),i=e.y(l[a],l[a+1]),l[a]=r,l[a+1]=i;return t};if(e._g=A,e.type=A.win.SVGAngle||A.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")?"SVG":"VML","VML"==e.type){var Mt=A.doc.createElement("div"),Lt;if(Mt.innerHTML='<v:shape adj="1"/>',Lt=Mt.firstChild,Lt.style.behavior="url(#default#VML)",!Lt||"object"!=typeof Lt.adj)return e.type=R;Mt=null}e.svg=!(e.vml="VML"==e.type),e._Paper=N,e.fn=M=N.prototype=e.prototype,e._id=0,e._oid=0,e.is=function(t,e){return e=O.call(e),"finite"==e?!at[T](+t):"array"==e?t instanceof Array:"null"==e&&null===t||e==typeof t&&null!==t||"object"==e&&t===Object(t)||"array"==e&&Array.isArray&&Array.isArray(t)||tt.call(t).slice(8,-1).toLowerCase()==e},e.angle=function(t,r,i,n,a,s){if(null==a){var o=t-i,l=r-n;return o||l?(180+180*Y.atan2(-l,-o)/U+360)%360:0}return e.angle(t,r,a,s)-e.angle(i,n,a,s)},e.rad=function(t){return t%360*U/180},e.deg=function(t){return Math.round(180*t/U%360*1e3)/1e3},e.snapTo=function(t,r,i){if(i=e.is(i,"finite")?i:10,e.is(t,Q)){for(var n=t.length;n--;)if(H(t[n]-r)<=i)return t[n]}else{t=+t;var a=r%t;if(a<i)return r-a;if(a>t-i)return r-a+t}return r};var zt=e.createUUID=function(t,e){return function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(t,e).toUpperCase()}}(/[xy]/g,function(t){var e=16*Y.random()|0,r="x"==t?e:3&e|8;return r.toString(16)});e.setWindow=function(r){t("raphael.setWindow",e,A.win,r),A.win=r,A.doc=A.win.document,e._engine.initWin&&e._engine.initWin(A.win)};var Pt=function(t){if(e.vml){var r=/^\s+|\s+$/g,i;try{var a=new ActiveXObject("htmlfile");a.write("<body>"),a.close(),i=a.body}catch(s){i=createPopup().document.body}var o=i.createTextRange();Pt=n(function(t){try{i.style.color=j(t).replace(r,R);var e=o.queryCommandValue("ForeColor");return e=(255&e)<<16|65280&e|(16711680&e)>>>16,"#"+("000000"+e.toString(16)).slice(-6)}catch(n){return"none"}})}else{var l=A.doc.createElement("i");l.title="Raphaël Colour Picker",l.style.display="none",A.doc.body.appendChild(l),Pt=n(function(t){return l.style.color=t,A.doc.defaultView.getComputedStyle(l,R).getPropertyValue("color")})}return Pt(t)},Ft=function(){return"hsb("+[this.h,this.s,this.b]+")"},Rt=function(){return"hsl("+[this.h,this.s,this.l]+")"},It=function(){return this.hex},jt=function(t,r,i){if(null==r&&e.is(t,"object")&&"r"in t&&"g"in t&&"b"in t&&(i=t.b,r=t.g,t=t.r),null==r&&e.is(t,Z)){var n=e.getRGB(t);t=n.r,r=n.g,i=n.b}return(t>1||r>1||i>1)&&(t/=255,r/=255,i/=255),[t,r,i]},qt=function(t,r,i,n){t*=255,r*=255,i*=255;var a={r:t,g:r,b:i,hex:e.rgb(t,r,i),toString:It};return e.is(n,"finite")&&(a.opacity=n),a};e.color=function(t){var r;return e.is(t,"object")&&"h"in t&&"s"in t&&"b"in t?(r=e.hsb2rgb(t),t.r=r.r,t.g=r.g,t.b=r.b,t.hex=r.hex):e.is(t,"object")&&"h"in t&&"s"in t&&"l"in t?(r=e.hsl2rgb(t),t.r=r.r,t.g=r.g,t.b=r.b,t.hex=r.hex):(e.is(t,"string")&&(t=e.getRGB(t)),e.is(t,"object")&&"r"in t&&"g"in t&&"b"in t?(r=e.rgb2hsl(t),t.h=r.h,t.s=r.s,t.l=r.l,r=e.rgb2hsb(t),t.v=r.b):(t={hex:"none"},t.r=t.g=t.b=t.h=t.s=t.v=t.l=-1)),t.toString=It,t},e.hsb2rgb=function(t,e,r,i){this.is(t,"object")&&"h"in t&&"s"in t&&"b"in t&&(r=t.b,e=t.s,i=t.o,t=t.h),t*=360;var n,a,s,o,l;return t=t%360/60,l=r*e,o=l*(1-H(t%2-1)),n=a=s=r-l,t=~~t,n+=[l,o,0,0,o,l][t],a+=[o,l,l,o,0,0][t],s+=[0,0,o,l,l,o][t],qt(n,a,s,i)},e.hsl2rgb=function(t,e,r,i){this.is(t,"object")&&"h"in t&&"s"in t&&"l"in t&&(r=t.l,e=t.s,t=t.h),(t>1||e>1||r>1)&&(t/=360,e/=100,r/=100),t*=360;var n,a,s,o,l;return t=t%360/60,l=2*e*(r<.5?r:1-r),o=l*(1-H(t%2-1)),n=a=s=r-l/2,t=~~t,n+=[l,o,0,0,o,l][t],a+=[o,l,l,o,0,0][t],s+=[0,0,o,l,l,o][t],qt(n,a,s,i)},e.rgb2hsb=function(t,e,r){r=jt(t,e,r),t=r[0],e=r[1],r=r[2];var i,n,a,s;return a=W(t,e,r),s=a-G(t,e,r),i=0==s?null:a==t?(e-r)/s:a==e?(r-t)/s+2:(t-e)/s+4,i=(i+360)%6*60/360,n=0==s?0:s/a,{h:i,s:n,b:a,toString:Ft}},e.rgb2hsl=function(t,e,r){r=jt(t,e,r),t=r[0],e=r[1],r=r[2];var i,n,a,s,o,l;return s=W(t,e,r),o=G(t,e,r),l=s-o,i=0==l?null:s==t?(e-r)/l:s==e?(r-t)/l+2:(t-e)/l+4,i=(i+360)%6*60/360,a=(s+o)/2,n=0==l?0:a<.5?l/(2*a):l/(2-2*a),{h:i,s:n,l:a,toString:Rt}},e._path2string=function(){return this.join(",").replace(vt,"$1")};var Dt=e._preload=function(t,e){var r=A.doc.createElement("img");r.style.cssText="position:absolute;left:-9999em;top:-9999em",r.onload=function(){e.call(this),this.onload=null,A.doc.body.removeChild(this)},r.onerror=function(){A.doc.body.removeChild(this)},A.doc.body.appendChild(r),r.src=t};e.getRGB=n(function(t){if(!t||(t=j(t)).indexOf("-")+1)return{r:-1,g:-1,b:-1,hex:"none",error:1,toString:a};if("none"==t)return{r:-1,g:-1,b:-1,hex:"none",toString:a};!(xt[T](t.toLowerCase().substring(0,2))||"#"==t.charAt())&&(t=Pt(t));var r,i,n,s,o,l,h,u=t.match(nt);return u?(u[2]&&(s=ut(u[2].substring(5),16),n=ut(u[2].substring(3,5),16),i=ut(u[2].substring(1,3),16)),u[3]&&(s=ut((l=u[3].charAt(3))+l,16),n=ut((l=u[3].charAt(2))+l,16),i=ut((l=u[3].charAt(1))+l,16)),u[4]&&(h=u[4][q](gt),i=ht(h[0]),"%"==h[0].slice(-1)&&(i*=2.55),n=ht(h[1]),"%"==h[1].slice(-1)&&(n*=2.55),s=ht(h[2]),"%"==h[2].slice(-1)&&(s*=2.55),"rgba"==u[1].toLowerCase().slice(0,4)&&(o=ht(h[3])),h[3]&&"%"==h[3].slice(-1)&&(o/=100)),u[5]?(h=u[5][q](gt),i=ht(h[0]),"%"==h[0].slice(-1)&&(i*=2.55),n=ht(h[1]),"%"==h[1].slice(-1)&&(n*=2.55),s=ht(h[2]),"%"==h[2].slice(-1)&&(s*=2.55),("deg"==h[0].slice(-3)||"°"==h[0].slice(-1))&&(i/=360),"hsba"==u[1].toLowerCase().slice(0,4)&&(o=ht(h[3])),h[3]&&"%"==h[3].slice(-1)&&(o/=100),e.hsb2rgb(i,n,s,o)):u[6]?(h=u[6][q](gt),i=ht(h[0]),"%"==h[0].slice(-1)&&(i*=2.55),n=ht(h[1]),"%"==h[1].slice(-1)&&(n*=2.55),s=ht(h[2]),"%"==h[2].slice(-1)&&(s*=2.55),("deg"==h[0].slice(-3)||"°"==h[0].slice(-1))&&(i/=360),"hsla"==u[1].toLowerCase().slice(0,4)&&(o=ht(h[3])),h[3]&&"%"==h[3].slice(-1)&&(o/=100),e.hsl2rgb(i,n,s,o)):(u={r:i,g:n,b:s,toString:a},u.hex="#"+(16777216|s|n<<8|i<<16).toString(16).slice(1),e.is(o,"finite")&&(u.opacity=o),u)):{r:-1,g:-1,b:-1,hex:"none",error:1,toString:a}},e),e.hsb=n(function(t,r,i){return e.hsb2rgb(t,r,i).hex}),e.hsl=n(function(t,r,i){return e.hsl2rgb(t,r,i).hex}),e.rgb=n(function(t,e,r){function i(t){return t+.5|0}return"#"+(16777216|i(r)|i(e)<<8|i(t)<<16).toString(16).slice(1)}),e.getColor=function(t){var e=this.getColor.start=this.getColor.start||{h:0,s:1,b:t||.75},r=this.hsb2rgb(e.h,e.s,e.b);return e.h+=.075,e.h>1&&(e.h=0,e.s-=.2,e.s<=0&&(this.getColor.start={h:0,s:1,b:e.b})),r.hex},e.getColor.reset=function(){delete this.start},e.parsePathString=function(t){if(!t)return null;var r=Vt(t);if(r.arr)return Yt(r.arr);var i={a:7,c:6,h:1,l:2,m:2,r:4,q:4,s:4,t:2,v:1,z:0},n=[];return e.is(t,Q)&&e.is(t[0],Q)&&(n=Yt(t)),n.length||j(t).replace(yt,function(t,e,r){var a=[],s=e.toLowerCase();if(r.replace(bt,function(t,e){e&&a.push(+e)}),"m"==s&&a.length>2&&(n.push([e][P](a.splice(0,2))),s="l",e="m"==e?"l":"L"),"r"==s)n.push([e][P](a));else for(;a.length>=i[s]&&(n.push([e][P](a.splice(0,i[s]))),i[s]););}),n.toString=e._path2string,r.arr=Yt(n),n},e.parseTransformString=n(function(t){if(!t)return null;var r={r:3,s:4,t:2,m:6},i=[];return e.is(t,Q)&&e.is(t[0],Q)&&(i=Yt(t)),i.length||j(t).replace(mt,function(t,e,r){var n=[],a=O.call(e);r.replace(bt,function(t,e){e&&n.push(+e)}),i.push([e][P](n))}),i.toString=e._path2string,i});var Vt=function(t){var e=Vt.ps=Vt.ps||{};return e[t]?e[t].sleep=100:e[t]={sleep:100},setTimeout(function(){for(var r in e)e[T](r)&&r!=t&&(e[r].sleep--,!e[r].sleep&&delete e[r])}),e[t]};e.findDotsAtSegment=function(t,e,r,i,n,a,s,o,l){var h=1-l,u=X(h,3),c=X(h,2),f=l*l,p=f*l,d=u*t+3*c*l*r+3*h*l*l*n+p*s,g=u*e+3*c*l*i+3*h*l*l*a+p*o,x=t+2*l*(r-t)+f*(n-2*r+t),v=e+2*l*(i-e)+f*(a-2*i+e),y=r+2*l*(n-r)+f*(s-2*n+r),m=i+2*l*(a-i)+f*(o-2*a+i),b=h*t+l*r,_=h*e+l*i,w=h*n+l*s,k=h*a+l*o,B=90-180*Y.atan2(x-y,v-m)/U;return(x>y||v<m)&&(B+=180),{x:d,y:g,m:{x:x,y:v},n:{x:y,y:m},start:{x:b,y:_},end:{x:w,y:k},alpha:B}},e.bezierBBox=function(t,r,i,n,a,s,o,l){e.is(t,"array")||(t=[t,r,i,n,a,s,o,l]);var h=Zt.apply(null,t);return{x:h.min.x,y:h.min.y,x2:h.max.x,y2:h.max.y,width:h.max.x-h.min.x,height:h.max.y-h.min.y}},e.isPointInsideBBox=function(t,e,r){return e>=t.x&&e<=t.x2&&r>=t.y&&r<=t.y2},e.isBBoxIntersect=function(t,r){var i=e.isPointInsideBBox;return i(r,t.x,t.y)||i(r,t.x2,t.y)||i(r,t.x,t.y2)||i(r,t.x2,t.y2)||i(t,r.x,r.y)||i(t,r.x2,r.y)||i(t,r.x,r.y2)||i(t,r.x2,r.y2)||(t.x<r.x2&&t.x>r.x||r.x<t.x2&&r.x>t.x)&&(t.y<r.y2&&t.y>r.y||r.y<t.y2&&r.y>t.y)},e.pathIntersection=function(t,e){return d(t,e)},e.pathIntersectionNumber=function(t,e){return d(t,e,1)},e.isPointInsidePath=function(t,r,i){var n=e.pathBBox(t);return e.isPointInsideBBox(n,r,i)&&d(t,[["M",r,i],["H",n.x2+10]],1)%2==1},e._removedFactory=function(e){return function(){t("raphael.log",null,"Raphaël: you are calling to method “"+e+"” of removed object",e)}};var Ot=e.pathBBox=function(t){var e=Vt(t);if(e.bbox)return r(e.bbox);if(!t)return{x:0,y:0,width:0,height:0,x2:0,y2:0};t=Qt(t);for(var i=0,n=0,a=[],s=[],o,l=0,h=t.length;l<h;l++)if(o=t[l],"M"==o[0])i=o[1],n=o[2],a.push(i),s.push(n);else{var u=Zt(i,n,o[1],o[2],o[3],o[4],o[5],o[6]);a=a[P](u.min.x,u.max.x),s=s[P](u.min.y,u.max.y),i=o[5],n=o[6]}var c=G[z](0,a),f=G[z](0,s),p=W[z](0,a),d=W[z](0,s),g=p-c,x=d-f,v={x:c,y:f,x2:p,y2:d,width:g,height:x,cx:c+g/2,cy:f+x/2};return e.bbox=r(v),v},Yt=function(t){var i=r(t);return i.toString=e._path2string,i},Wt=e._pathToRelative=function(t){var r=Vt(t);if(r.rel)return Yt(r.rel);e.is(t,Q)&&e.is(t&&t[0],Q)||(t=e.parsePathString(t));var i=[],n=0,a=0,s=0,o=0,l=0;"M"==t[0][0]&&(n=t[0][1],a=t[0][2],s=n,o=a,l++,i.push(["M",n,a]));for(var h=l,u=t.length;h<u;h++){var c=i[h]=[],f=t[h];if(f[0]!=O.call(f[0]))switch(c[0]=O.call(f[0]),c[0]){case"a":c[1]=f[1],c[2]=f[2],c[3]=f[3],c[4]=f[4],c[5]=f[5],c[6]=+(f[6]-n).toFixed(3),c[7]=+(f[7]-a).toFixed(3);break;case"v":c[1]=+(f[1]-a).toFixed(3);break;case"m":s=f[1],o=f[2];default:for(var p=1,d=f.length;p<d;p++)c[p]=+(f[p]-(p%2?n:a)).toFixed(3)}else{c=i[h]=[],"m"==f[0]&&(s=f[1]+n,o=f[2]+a);for(var g=0,x=f.length;g<x;g++)i[h][g]=f[g]}var v=i[h].length;switch(i[h][0]){case"z":n=s,a=o;break;case"h":n+=+i[h][v-1];break;case"v":a+=+i[h][v-1];break;default:n+=+i[h][v-2],a+=+i[h][v-1]}}return i.toString=e._path2string,r.rel=Yt(i),i},Gt=e._pathToAbsolute=function(t){var r=Vt(t);if(r.abs)return Yt(r.abs);if(e.is(t,Q)&&e.is(t&&t[0],Q)||(t=e.parsePathString(t)),!t||!t.length)return[["M",0,0]];var i=[],n=0,a=0,o=0,l=0,h=0;"M"==t[0][0]&&(n=+t[0][1],a=+t[0][2],o=n,l=a,h++,i[0]=["M",n,a]);for(var u=3==t.length&&"M"==t[0][0]&&"R"==t[1][0].toUpperCase()&&"Z"==t[2][0].toUpperCase(),c,f,p=h,d=t.length;p<d;p++){if(i.push(c=[]),f=t[p],f[0]!=ct.call(f[0]))switch(c[0]=ct.call(f[0]),c[0]){case"A":c[1]=f[1],c[2]=f[2],c[3]=f[3],c[4]=f[4],c[5]=f[5],c[6]=+(f[6]+n),c[7]=+(f[7]+a);break;case"V":c[1]=+f[1]+a;break;case"H":c[1]=+f[1]+n;break;case"R":for(var g=[n,a][P](f.slice(1)),x=2,v=g.length;x<v;x++)g[x]=+g[x]+n,g[++x]=+g[x]+a;i.pop(),i=i[P](s(g,u));break;case"M":o=+f[1]+n,l=+f[2]+a;default:for(x=1,v=f.length;x<v;x++)c[x]=+f[x]+(x%2?n:a)}else if("R"==f[0])g=[n,a][P](f.slice(1)),i.pop(),i=i[P](s(g,u)),c=["R"][P](f.slice(-2));else for(var y=0,m=f.length;y<m;y++)c[y]=f[y];switch(c[0]){case"Z":n=o,a=l;break;case"H":n=c[1];break;case"V":a=c[1];break;case"M":o=c[c.length-2],l=c[c.length-1];default:n=c[c.length-2],a=c[c.length-1]}}return i.toString=e._path2string,r.abs=Yt(i),i},Ht=function(t,e,r,i){return[t,e,r,i,r,i]},Xt=function(t,e,r,i,n,a){var s=1/3,o=2/3;return[s*t+o*r,s*e+o*i,s*n+o*r,s*a+o*i,n,a]},Ut=function(t,e,r,i,a,s,o,l,h,u){var c=120*U/180,f=U/180*(+a||0),p=[],d,g=n(function(t,e,r){var i=t*Y.cos(r)-e*Y.sin(r),n=t*Y.sin(r)+e*Y.cos(r);return{x:i,y:n}});if(u)S=u[0],T=u[1],B=u[2],C=u[3];else{d=g(t,e,-f),t=d.x,e=d.y,d=g(l,h,-f),l=d.x,h=d.y;var x=Y.cos(U/180*a),v=Y.sin(U/180*a),y=(t-l)/2,m=(e-h)/2,b=y*y/(r*r)+m*m/(i*i);b>1&&(b=Y.sqrt(b),r=b*r,i=b*i);var _=r*r,w=i*i,k=(s==o?-1:1)*Y.sqrt(H((_*w-_*m*m-w*y*y)/(_*m*m+w*y*y))),B=k*r*m/i+(t+l)/2,C=k*-i*y/r+(e+h)/2,S=Y.asin(((e-C)/i).toFixed(9)),T=Y.asin(((h-C)/i).toFixed(9));S=t<B?U-S:S,T=l<B?U-T:T,S<0&&(S=2*U+S),T<0&&(T=2*U+T),o&&S>T&&(S-=2*U),!o&&T>S&&(T-=2*U)}var A=T-S;if(H(A)>c){var E=T,N=l,M=h;T=S+c*(o&&T>S?1:-1),l=B+r*Y.cos(T),h=C+i*Y.sin(T),p=Ut(l,h,r,i,a,0,o,N,M,[T,E,B,C])}A=T-S;var L=Y.cos(S),z=Y.sin(S),F=Y.cos(T),R=Y.sin(T),I=Y.tan(A/4),j=4/3*r*I,D=4/3*i*I,V=[t,e],O=[t+j*z,e-D*L],W=[l+j*R,h-D*F],G=[l,h];if(O[0]=2*V[0]-O[0],O[1]=2*V[1]-O[1],u)return[O,W,G][P](p);p=[O,W,G][P](p).join()[q](",");for(var X=[],$=0,Z=p.length;$<Z;$++)X[$]=$%2?g(p[$-1],p[$],f).y:g(p[$],p[$+1],f).x;return X},$t=function(t,e,r,i,n,a,s,o,l){var h=1-l;return{x:X(h,3)*t+3*X(h,2)*l*r+3*h*l*l*n+X(l,3)*s,y:X(h,3)*e+3*X(h,2)*l*i+3*h*l*l*a+X(l,3)*o}},Zt=n(function(t,e,r,i,n,a,s,o){var l=n-2*r+t-(s-2*n+r),h=2*(r-t)-2*(n-r),u=t-r,c=(-h+Y.sqrt(h*h-4*l*u))/2/l,f=(-h-Y.sqrt(h*h-4*l*u))/2/l,p=[e,o],d=[t,s],g;return H(c)>"1e12"&&(c=.5),H(f)>"1e12"&&(f=.5),c>0&&c<1&&(g=$t(t,e,r,i,n,a,s,o,c),d.push(g.x),p.push(g.y)),f>0&&f<1&&(g=$t(t,e,r,i,n,a,s,o,f),d.push(g.x),p.push(g.y)),l=a-2*i+e-(o-2*a+i),h=2*(i-e)-2*(a-i),u=e-i,c=(-h+Y.sqrt(h*h-4*l*u))/2/l,f=(-h-Y.sqrt(h*h-4*l*u))/2/l,H(c)>"1e12"&&(c=.5),H(f)>"1e12"&&(f=.5),c>0&&c<1&&(g=$t(t,e,r,i,n,a,s,o,c),d.push(g.x),p.push(g.y)),f>0&&f<1&&(g=$t(t,e,r,i,n,a,s,o,f),d.push(g.x),p.push(g.y)),{min:{x:G[z](0,d),y:G[z](0,p)},max:{x:W[z](0,d),y:W[z](0,p)}}}),Qt=e._path2curve=n(function(t,e){var r=!e&&Vt(t);if(!e&&r.curve)return Yt(r.curve);for(var i=Gt(t),n=e&&Gt(e),a={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},s={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},o=(function(t,e,r){var i,n,a={T:1,Q:1};if(!t)return["C",e.x,e.y,e.x,e.y,e.x,e.y];switch(!(t[0]in a)&&(e.qx=e.qy=null),t[0]){case"M":e.X=t[1],e.Y=t[2];break;case"A":t=["C"][P](Ut[z](0,[e.x,e.y][P](t.slice(1))));break;case"S":"C"==r||"S"==r?(i=2*e.x-e.bx,n=2*e.y-e.by):(i=e.x,n=e.y),t=["C",i,n][P](t.slice(1));break;case"T":"Q"==r||"T"==r?(e.qx=2*e.x-e.qx,e.qy=2*e.y-e.qy):(e.qx=e.x,e.qy=e.y),t=["C"][P](Xt(e.x,e.y,e.qx,e.qy,t[1],t[2]));break;case"Q":e.qx=t[1],e.qy=t[2],t=["C"][P](Xt(e.x,e.y,t[1],t[2],t[3],t[4]));break;case"L":t=["C"][P](Ht(e.x,e.y,t[1],t[2]));break;case"H":t=["C"][P](Ht(e.x,e.y,t[1],e.y));break;case"V":t=["C"][P](Ht(e.x,e.y,e.x,t[1]));break;case"Z":t=["C"][P](Ht(e.x,e.y,e.X,e.Y))}return t}),l=function(t,e){if(t[e].length>7){t[e].shift();for(var r=t[e];r.length;)u[e]="A",n&&(c[e]="A"),t.splice(e++,0,["C"][P](r.splice(0,6)));t.splice(e,1),g=W(i.length,n&&n.length||0)}},h=function(t,e,r,a,s){t&&e&&"M"==t[s][0]&&"M"!=e[s][0]&&(e.splice(s,0,["M",a.x,a.y]),r.bx=0,r.by=0,r.x=t[s][1],r.y=t[s][2],g=W(i.length,n&&n.length||0))},u=[],c=[],f="",p="",d=0,g=W(i.length,n&&n.length||0);d<g;d++){i[d]&&(f=i[d][0]),"C"!=f&&(u[d]=f,d&&(p=u[d-1])),i[d]=o(i[d],a,p),"A"!=u[d]&&"C"==f&&(u[d]="C"),l(i,d),n&&(n[d]&&(f=n[d][0]),"C"!=f&&(c[d]=f,d&&(p=c[d-1])),n[d]=o(n[d],s,p),"A"!=c[d]&&"C"==f&&(c[d]="C"),l(n,d)),h(i,n,a,s,d),h(n,i,s,a,d);var x=i[d],v=n&&n[d],y=x.length,m=n&&v.length;a.x=x[y-2],a.y=x[y-1],a.bx=ht(x[y-4])||a.x,a.by=ht(x[y-3])||a.y,s.bx=n&&(ht(v[m-4])||s.x),s.by=n&&(ht(v[m-3])||s.y),s.x=n&&v[m-2],s.y=n&&v[m-1]}return n||(r.curve=Yt(i)),n?[i,n]:i},null,Yt),Jt=e._parseDots=n(function(t){for(var r=[],i=0,n=t.length;i<n;i++){var a={},s=t[i].match(/^([^:]*):?([\d\.]*)/);if(a.color=e.getRGB(s[1]),a.color.error)return null;a.opacity=a.color.opacity,a.color=a.color.hex,s[2]&&(a.offset=s[2]+"%"),r.push(a)}for(i=1,n=r.length-1;i<n;i++)if(!r[i].offset){for(var o=ht(r[i-1].offset||0),l=0,h=i+1;h<n;h++)if(r[h].offset){l=r[h].offset;break}l||(l=100,h=n),l=ht(l);for(var u=(l-o)/(h-i+1);i<h;i++)o+=u,r[i].offset=o+"%"}return r}),Kt=e._tear=function(t,e){t==e.top&&(e.top=t.prev),t==e.bottom&&(e.bottom=t.next),t.next&&(t.next.prev=t.prev),t.prev&&(t.prev.next=t.next)},te=e._tofront=function(t,e){e.top!==t&&(Kt(t,e),t.next=null,t.prev=e.top,e.top.next=t,e.top=t)},ee=e._toback=function(t,e){e.bottom!==t&&(Kt(t,e),t.next=e.bottom,t.prev=null,e.bottom.prev=t,e.bottom=t)},re=e._insertafter=function(t,e,r){Kt(t,r),e==r.top&&(r.top=t),e.next&&(e.next.prev=t),t.next=e.next,t.prev=e,e.next=t},ie=e._insertbefore=function(t,e,r){Kt(t,r),e==r.bottom&&(r.bottom=t),e.prev&&(e.prev.next=t),t.prev=e.prev,e.prev=t,t.next=e},ne=e.toMatrix=function(t,e){var r=Ot(t),i={_:{transform:R},getBBox:function(){return r}};return se(i,e),i.matrix},ae=e.transformPath=function(t,e){return Nt(t,ne(t,e))},se=e._extractTransform=function(t,r){if(null==r)return t._.transform;r=j(r).replace(/\.{3}|\u2026/g,t._.transform||R);var i=e.parseTransformString(r),n=0,a=0,s=0,o=1,l=1,h=t._,u=new g;if(h.transform=i||[],i)for(var c=0,f=i.length;c<f;c++){var p=i[c],d=p.length,x=j(p[0]).toLowerCase(),v=p[0]!=x,y=v?u.invert():0,m,b,_,w,k;"t"==x&&3==d?v?(m=y.x(0,0),b=y.y(0,0),_=y.x(p[1],p[2]),w=y.y(p[1],p[2]),u.translate(_-m,w-b)):u.translate(p[1],p[2]):"r"==x?2==d?(k=k||t.getBBox(1),u.rotate(p[1],k.x+k.width/2,k.y+k.height/2),n+=p[1]):4==d&&(v?(_=y.x(p[2],p[3]),w=y.y(p[2],p[3]),u.rotate(p[1],_,w)):u.rotate(p[1],p[2],p[3]),n+=p[1]):"s"==x?2==d||3==d?(k=k||t.getBBox(1),u.scale(p[1],p[d-1],k.x+k.width/2,k.y+k.height/2),o*=p[1],l*=p[d-1]):5==d&&(v?(_=y.x(p[3],p[4]),w=y.y(p[3],p[4]),u.scale(p[1],p[2],_,w)):u.scale(p[1],p[2],p[3],p[4]),o*=p[1],l*=p[2]):"m"==x&&7==d&&u.add(p[1],p[2],p[3],p[4],p[5],p[6]),h.dirtyT=1,t.matrix=u}t.matrix=u,h.sx=o,h.sy=l,h.deg=n,h.dx=a=u.e,h.dy=s=u.f,1==o&&1==l&&!n&&h.bbox?(h.bbox.x+=+a,h.bbox.y+=+s):h.dirtyT=1},oe=function(t){var e=t[0];switch(e.toLowerCase()){case"t":return[e,0,0];case"m":return[e,1,0,0,1,0,0];case"r":return 4==t.length?[e,0,t[2],t[3]]:[e,0];case"s":return 5==t.length?[e,1,1,t[3],t[4]]:3==t.length?[e,1,1]:[e,1]}},le=e._equaliseTransform=function(t,r){r=j(r).replace(/\.{3}|\u2026/g,t),t=e.parseTransformString(t)||[],r=e.parseTransformString(r)||[];for(var i=W(t.length,r.length),n=[],a=[],s=0,o,l,h,u;s<i;s++){if(h=t[s]||oe(r[s]),u=r[s]||oe(h),h[0]!=u[0]||"r"==h[0].toLowerCase()&&(h[2]!=u[2]||h[3]!=u[3])||"s"==h[0].toLowerCase()&&(h[3]!=u[3]||h[4]!=u[4]))return;for(n[s]=[],a[s]=[],o=0,l=W(h.length,u.length);o<l;o++)o in h&&(n[s][o]=h[o]),o in u&&(a[s][o]=u[o])}return{from:n,to:a}};e._getContainer=function(t,r,i,n){var a;if(a=null!=n||e.is(t,"object")?t:A.doc.getElementById(t),null!=a)return a.tagName?null==r?{container:a,width:a.style.pixelWidth||a.offsetWidth,height:a.style.pixelHeight||a.offsetHeight}:{container:a,width:r,height:i}:{container:1,x:t,y:r,width:i,height:n}},e.pathToRelative=Wt,e._engine={},e.path2curve=Qt,e.matrix=function(t,e,r,i,n,a){return new g(t,e,r,i,n,a)},function(t){function r(t){return t[0]*t[0]+t[1]*t[1]}function i(t){var e=Y.sqrt(r(t));t[0]&&(t[0]/=e),t[1]&&(t[1]/=e)}t.add=function(t,e,r,i,n,a){var s=[[],[],[]],o=[[this.a,this.c,this.e],[this.b,this.d,this.f],[0,0,1]],l=[[t,r,n],[e,i,a],[0,0,1]],h,u,c,f;for(t&&t instanceof g&&(l=[[t.a,t.c,t.e],[t.b,t.d,t.f],[0,0,1]]),h=0;h<3;h++)for(u=0;u<3;u++){for(f=0,c=0;c<3;c++)f+=o[h][c]*l[c][u];s[h][u]=f}this.a=s[0][0],this.b=s[1][0],this.c=s[0][1],this.d=s[1][1],this.e=s[0][2],this.f=s[1][2]},t.invert=function(){var t=this,e=t.a*t.d-t.b*t.c;return new g(t.d/e,-t.b/e,-t.c/e,t.a/e,(t.c*t.f-t.d*t.e)/e,(t.b*t.e-t.a*t.f)/e)},t.clone=function(){return new g(this.a,this.b,this.c,this.d,this.e,this.f)},t.translate=function(t,e){
	this.add(1,0,0,1,t,e)},t.scale=function(t,e,r,i){null==e&&(e=t),(r||i)&&this.add(1,0,0,1,r,i),this.add(t,0,0,e,0,0),(r||i)&&this.add(1,0,0,1,-r,-i)},t.rotate=function(t,r,i){t=e.rad(t),r=r||0,i=i||0;var n=+Y.cos(t).toFixed(9),a=+Y.sin(t).toFixed(9);this.add(n,a,-a,n,r,i),this.add(1,0,0,1,-r,-i)},t.x=function(t,e){return t*this.a+e*this.c+this.e},t.y=function(t,e){return t*this.b+e*this.d+this.f},t.get=function(t){return+this[j.fromCharCode(97+t)].toFixed(4)},t.toString=function(){return e.svg?"matrix("+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)].join()+")":[this.get(0),this.get(2),this.get(1),this.get(3),0,0].join()},t.toFilter=function(){return"progid:DXImageTransform.Microsoft.Matrix(M11="+this.get(0)+", M12="+this.get(2)+", M21="+this.get(1)+", M22="+this.get(3)+", Dx="+this.get(4)+", Dy="+this.get(5)+", sizingmethod='auto expand')"},t.offset=function(){return[this.e.toFixed(4),this.f.toFixed(4)]},t.split=function(){var t={};t.dx=this.e,t.dy=this.f;var n=[[this.a,this.c],[this.b,this.d]];t.scalex=Y.sqrt(r(n[0])),i(n[0]),t.shear=n[0][0]*n[1][0]+n[0][1]*n[1][1],n[1]=[n[1][0]-n[0][0]*t.shear,n[1][1]-n[0][1]*t.shear],t.scaley=Y.sqrt(r(n[1])),i(n[1]),t.shear/=t.scaley;var a=-n[0][1],s=n[1][1];return s<0?(t.rotate=e.deg(Y.acos(s)),a<0&&(t.rotate=360-t.rotate)):t.rotate=e.deg(Y.asin(a)),t.isSimple=!(+t.shear.toFixed(9)||t.scalex.toFixed(9)!=t.scaley.toFixed(9)&&t.rotate),t.isSuperSimple=!+t.shear.toFixed(9)&&t.scalex.toFixed(9)==t.scaley.toFixed(9)&&!t.rotate,t.noRotation=!+t.shear.toFixed(9)&&!t.rotate,t},t.toTransformString=function(t){var e=t||this[q]();return e.isSimple?(e.scalex=+e.scalex.toFixed(4),e.scaley=+e.scaley.toFixed(4),e.rotate=+e.rotate.toFixed(4),(e.dx||e.dy?"t"+[e.dx,e.dy]:R)+(1!=e.scalex||1!=e.scaley?"s"+[e.scalex,e.scaley,0,0]:R)+(e.rotate?"r"+[e.rotate,0,0]:R)):"m"+[this.get(0),this.get(1),this.get(2),this.get(3),this.get(4),this.get(5)]}}(g.prototype);for(var he=function(){this.returnValue=!1},ue=function(){return this.originalEvent.preventDefault()},ce=function(){this.cancelBubble=!0},fe=function(){return this.originalEvent.stopPropagation()},pe=function(t){var e=A.doc.documentElement.scrollTop||A.doc.body.scrollTop,r=A.doc.documentElement.scrollLeft||A.doc.body.scrollLeft;return{x:t.clientX+r,y:t.clientY+e}},de=function(){return A.doc.addEventListener?function(t,e,r,i){var n=function(t){var e=pe(t);return r.call(i,t,e.x,e.y)};if(t.addEventListener(e,n,!1),F&&V[e]){var a=function(e){for(var n=pe(e),a=e,s=0,o=e.targetTouches&&e.targetTouches.length;s<o;s++)if(e.targetTouches[s].target==t){e=e.targetTouches[s],e.originalEvent=a,e.preventDefault=ue,e.stopPropagation=fe;break}return r.call(i,e,n.x,n.y)};t.addEventListener(V[e],a,!1)}return function(){return t.removeEventListener(e,n,!1),F&&V[e]&&t.removeEventListener(V[e],a,!1),!0}}:A.doc.attachEvent?function(t,e,r,i){var n=function(t){t=t||A.win.event;var e=A.doc.documentElement.scrollTop||A.doc.body.scrollTop,n=A.doc.documentElement.scrollLeft||A.doc.body.scrollLeft,a=t.clientX+n,s=t.clientY+e;return t.preventDefault=t.preventDefault||he,t.stopPropagation=t.stopPropagation||ce,r.call(i,t,a,s)};t.attachEvent("on"+e,n);var a=function(){return t.detachEvent("on"+e,n),!0};return a}:void 0}(),ge=[],xe=function(e){for(var r=e.clientX,i=e.clientY,n=A.doc.documentElement.scrollTop||A.doc.body.scrollTop,a=A.doc.documentElement.scrollLeft||A.doc.body.scrollLeft,s,o=ge.length;o--;){if(s=ge[o],F&&e.touches){for(var l=e.touches.length,h;l--;)if(h=e.touches[l],h.identifier==s.el._drag.id){r=h.clientX,i=h.clientY,(e.originalEvent?e.originalEvent:e).preventDefault();break}}else e.preventDefault();var u=s.el.node,c,f=u.nextSibling,p=u.parentNode,d=u.style.display;A.win.opera&&p.removeChild(u),u.style.display="none",c=s.el.paper.getElementByPoint(r,i),u.style.display=d,A.win.opera&&(f?p.insertBefore(u,f):p.appendChild(u)),c&&t("raphael.drag.over."+s.el.id,s.el,c),r+=a,i+=n,t("raphael.drag.move."+s.el.id,s.move_scope||s.el,r-s.el._drag.x,i-s.el._drag.y,r,i,e)}},ve=function(r){e.unmousemove(xe).unmouseup(ve);for(var i=ge.length,n;i--;)n=ge[i],n.el._drag={},t("raphael.drag.end."+n.el.id,n.end_scope||n.start_scope||n.move_scope||n.el,r);ge=[]},ye=e.el={},me=D.length;me--;)!function(t){e[t]=ye[t]=function(r,i){return e.is(r,"function")&&(this.events=this.events||[],this.events.push({name:t,f:r,unbind:de(this.shape||this.node||A.doc,t,r,i||this)})),this},e["un"+t]=ye["un"+t]=function(r){for(var i=this.events||[],n=i.length;n--;)i[n].name!=t||!e.is(r,"undefined")&&i[n].f!=r||(i[n].unbind(),i.splice(n,1),!i.length&&delete this.events);return this}}(D[me]);ye.data=function(r,i){var n=wt[this.id]=wt[this.id]||{};if(0==arguments.length)return n;if(1==arguments.length){if(e.is(r,"object")){for(var a in r)r[T](a)&&this.data(a,r[a]);return this}return t("raphael.data.get."+this.id,this,n[r],r),n[r]}return n[r]=i,t("raphael.data.set."+this.id,this,i,r),this},ye.removeData=function(t){return null==t?wt[this.id]={}:wt[this.id]&&delete wt[this.id][t],this},ye.getData=function(){return r(wt[this.id]||{})},ye.hover=function(t,e,r,i){return this.mouseover(t,r).mouseout(e,i||r)},ye.unhover=function(t,e){return this.unmouseover(t).unmouseout(e)};var be=[];ye.drag=function(r,i,n,a,s,o){function l(l){(l.originalEvent||l).preventDefault();var h=l.clientX,u=l.clientY,c=A.doc.documentElement.scrollTop||A.doc.body.scrollTop,f=A.doc.documentElement.scrollLeft||A.doc.body.scrollLeft;if(this._drag.id=l.identifier,F&&l.touches)for(var p=l.touches.length,d;p--;)if(d=l.touches[p],this._drag.id=d.identifier,d.identifier==this._drag.id){h=d.clientX,u=d.clientY;break}this._drag.x=h+f,this._drag.y=u+c,!ge.length&&e.mousemove(xe).mouseup(ve),ge.push({el:this,move_scope:a,start_scope:s,end_scope:o}),i&&t.on("raphael.drag.start."+this.id,i),r&&t.on("raphael.drag.move."+this.id,r),n&&t.on("raphael.drag.end."+this.id,n),t("raphael.drag.start."+this.id,s||a||this,l.clientX+f,l.clientY+c,l)}return this._drag={},be.push({el:this,start:l}),this.mousedown(l),this},ye.onDragOver=function(e){e?t.on("raphael.drag.over."+this.id,e):t.unbind("raphael.drag.over."+this.id)},ye.undrag=function(){for(var r=be.length;r--;)be[r].el==this&&(this.unmousedown(be[r].start),be.splice(r,1),t.unbind("raphael.drag.*."+this.id));!be.length&&e.unmousemove(xe).unmouseup(ve),ge=[]},M.circle=function(t,r,i){var n=e._engine.circle(this,t||0,r||0,i||0);return this.__set__&&this.__set__.push(n),n},M.rect=function(t,r,i,n,a){var s=e._engine.rect(this,t||0,r||0,i||0,n||0,a||0);return this.__set__&&this.__set__.push(s),s},M.ellipse=function(t,r,i,n){var a=e._engine.ellipse(this,t||0,r||0,i||0,n||0);return this.__set__&&this.__set__.push(a),a},M.path=function(t){t&&!e.is(t,Z)&&!e.is(t[0],Q)&&(t+=R);var r=e._engine.path(e.format[z](e,arguments),this);return this.__set__&&this.__set__.push(r),r},M.image=function(t,r,i,n,a){var s=e._engine.image(this,t||"about:blank",r||0,i||0,n||0,a||0);return this.__set__&&this.__set__.push(s),s},M.text=function(t,r,i){var n=e._engine.text(this,t||0,r||0,j(i));return this.__set__&&this.__set__.push(n),n},M.set=function(t){!e.is(t,"array")&&(t=Array.prototype.splice.call(arguments,0,arguments.length));var r=new ze(t);return this.__set__&&this.__set__.push(r),r.paper=this,r.type="set",r},M.setStart=function(t){this.__set__=t||this.set()},M.setFinish=function(t){var e=this.__set__;return delete this.__set__,e},M.getSize=function(){var t=this.canvas.parentNode;return{width:t.offsetWidth,height:t.offsetHeight}},M.setSize=function(t,r){return e._engine.setSize.call(this,t,r)},M.setViewBox=function(t,r,i,n,a){return e._engine.setViewBox.call(this,t,r,i,n,a)},M.top=M.bottom=null,M.raphael=e;var _e=function(t){var e=t.getBoundingClientRect(),r=t.ownerDocument,i=r.body,n=r.documentElement,a=n.clientTop||i.clientTop||0,s=n.clientLeft||i.clientLeft||0,o=e.top+(A.win.pageYOffset||n.scrollTop||i.scrollTop)-a,l=e.left+(A.win.pageXOffset||n.scrollLeft||i.scrollLeft)-s;return{y:o,x:l}};M.getElementByPoint=function(t,e){var r=this,i=r.canvas,n=A.doc.elementFromPoint(t,e);if(A.win.opera&&"svg"==n.tagName){var a=_e(i),s=i.createSVGRect();s.x=t-a.x,s.y=e-a.y,s.width=s.height=1;var o=i.getIntersectionList(s,null);o.length&&(n=o[o.length-1])}if(!n)return null;for(;n.parentNode&&n!=i.parentNode&&!n.raphael;)n=n.parentNode;return n==r.canvas.parentNode&&(n=i),n=n&&n.raphael?r.getById(n.raphaelid):null},M.getElementsByBBox=function(t){var r=this.set();return this.forEach(function(i){e.isBBoxIntersect(i.getBBox(),t)&&r.push(i)}),r},M.getById=function(t){for(var e=this.bottom;e;){if(e.id==t)return e;e=e.next}return null},M.forEach=function(t,e){for(var r=this.bottom;r;){if(t.call(e,r)===!1)return this;r=r.next}return this},M.getElementsByPoint=function(t,e){var r=this.set();return this.forEach(function(i){i.isPointInside(t,e)&&r.push(i)}),r},ye.isPointInside=function(t,r){var i=this.realPath=Et[this.type](this);return this.attr("transform")&&this.attr("transform").length&&(i=e.transformPath(i,this.attr("transform"))),e.isPointInsidePath(i,t,r)},ye.getBBox=function(t){if(this.removed)return{};var e=this._;return t?(!e.dirty&&e.bboxwt||(this.realPath=Et[this.type](this),e.bboxwt=Ot(this.realPath),e.bboxwt.toString=v,e.dirty=0),e.bboxwt):((e.dirty||e.dirtyT||!e.bbox)&&(!e.dirty&&this.realPath||(e.bboxwt=0,this.realPath=Et[this.type](this)),e.bbox=Ot(Nt(this.realPath,this.matrix)),e.bbox.toString=v,e.dirty=e.dirtyT=0),e.bbox)},ye.clone=function(){if(this.removed)return null;var t=this.paper[this.type]().attr(this.attr());return this.__set__&&this.__set__.push(t),t},ye.glow=function(t){if("text"==this.type)return null;t=t||{};var e={width:(t.width||10)+(+this.attr("stroke-width")||1),fill:t.fill||!1,opacity:null==t.opacity?.5:t.opacity,offsetx:t.offsetx||0,offsety:t.offsety||0,color:t.color||"#000"},r=e.width/2,i=this.paper,n=i.set(),a=this.realPath||Et[this.type](this);a=this.matrix?Nt(a,this.matrix):a;for(var s=1;s<r+1;s++)n.push(i.path(a).attr({stroke:e.color,fill:e.fill?e.color:"none","stroke-linejoin":"round","stroke-linecap":"round","stroke-width":+(e.width/r*s).toFixed(3),opacity:+(e.opacity/r).toFixed(3)}));return n.insertBefore(this).translate(e.offsetx,e.offsety)};var we={},ke=function(t,r,i,n,a,s,o,u,c){return null==c?l(t,r,i,n,a,s,o,u):e.findDotsAtSegment(t,r,i,n,a,s,o,u,h(t,r,i,n,a,s,o,u,c))},Be=function(t,r){return function(i,n,a){i=Qt(i);for(var s,o,l,h,u="",c={},f,p=0,d=0,g=i.length;d<g;d++){if(l=i[d],"M"==l[0])s=+l[1],o=+l[2];else{if(h=ke(s,o,l[1],l[2],l[3],l[4],l[5],l[6]),p+h>n){if(r&&!c.start){if(f=ke(s,o,l[1],l[2],l[3],l[4],l[5],l[6],n-p),u+=["C"+f.start.x,f.start.y,f.m.x,f.m.y,f.x,f.y],a)return u;c.start=u,u=["M"+f.x,f.y+"C"+f.n.x,f.n.y,f.end.x,f.end.y,l[5],l[6]].join(),p+=h,s=+l[5],o=+l[6];continue}if(!t&&!r)return f=ke(s,o,l[1],l[2],l[3],l[4],l[5],l[6],n-p),{x:f.x,y:f.y,alpha:f.alpha}}p+=h,s=+l[5],o=+l[6]}u+=l.shift()+l}return c.end=u,f=t?p:r?c:e.findDotsAtSegment(s,o,l[0],l[1],l[2],l[3],l[4],l[5],1),f.alpha&&(f={x:f.x,y:f.y,alpha:f.alpha}),f}},Ce=Be(1),Se=Be(),Te=Be(0,1);e.getTotalLength=Ce,e.getPointAtLength=Se,e.getSubpath=function(t,e,r){if(this.getTotalLength(t)-r<1e-6)return Te(t,e).end;var i=Te(t,r,1);return e?Te(i,e).end:i},ye.getTotalLength=function(){var t=this.getPath();if(t)return this.node.getTotalLength?this.node.getTotalLength():Ce(t)},ye.getPointAtLength=function(t){var e=this.getPath();if(e)return Se(e,t)},ye.getPath=function(){var t,r=e._getPath[this.type];if("text"!=this.type&&"set"!=this.type)return r&&(t=r(this)),t},ye.getSubpath=function(t,r){var i=this.getPath();if(i)return e.getSubpath(i,t,r)};var Ae=e.easing_formulas={linear:function(t){return t},"<":function(t){return X(t,1.7)},">":function(t){return X(t,.48)},"<>":function(t){var e=.48-t/1.04,r=Y.sqrt(.1734+e*e),i=r-e,n=X(H(i),1/3)*(i<0?-1:1),a=-r-e,s=X(H(a),1/3)*(a<0?-1:1),o=n+s+.5;return 3*(1-o)*o*o+o*o*o},backIn:function(t){var e=1.70158;return t*t*((e+1)*t-e)},backOut:function(t){t-=1;var e=1.70158;return t*t*((e+1)*t+e)+1},elastic:function(t){return t==!!t?t:X(2,-10*t)*Y.sin((t-.075)*(2*U)/.3)+1},bounce:function(t){var e=7.5625,r=2.75,i;return t<1/r?i=e*t*t:t<2/r?(t-=1.5/r,i=e*t*t+.75):t<2.5/r?(t-=2.25/r,i=e*t*t+.9375):(t-=2.625/r,i=e*t*t+.984375),i}};Ae.easeIn=Ae["ease-in"]=Ae["<"],Ae.easeOut=Ae["ease-out"]=Ae[">"],Ae.easeInOut=Ae["ease-in-out"]=Ae["<>"],Ae["back-in"]=Ae.backIn,Ae["back-out"]=Ae.backOut;var Ee=[],Ne=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){setTimeout(t,16)},Me=function(){for(var r=+new Date,i=0;i<Ee.length;i++){var n=Ee[i];if(!n.el.removed&&!n.paused){var a=r-n.start,s=n.ms,o=n.easing,l=n.from,h=n.diff,u=n.to,c=n.t,f=n.el,p={},d,g={},x;if(n.initstatus?(a=(n.initstatus*n.anim.top-n.prev)/(n.percent-n.prev)*s,n.status=n.initstatus,delete n.initstatus,n.stop&&Ee.splice(i--,1)):n.status=(n.prev+(n.percent-n.prev)*(a/s))/n.anim.top,!(a<0))if(a<s){var v=o(a/s);for(var y in l)if(l[T](y)){switch(pt[y]){case $:d=+l[y]+v*s*h[y];break;case"colour":d="rgb("+[Le(ot(l[y].r+v*s*h[y].r)),Le(ot(l[y].g+v*s*h[y].g)),Le(ot(l[y].b+v*s*h[y].b))].join(",")+")";break;case"path":d=[];for(var m=0,_=l[y].length;m<_;m++){d[m]=[l[y][m][0]];for(var w=1,k=l[y][m].length;w<k;w++)d[m][w]=+l[y][m][w]+v*s*h[y][m][w];d[m]=d[m].join(I)}d=d.join(I);break;case"transform":if(h[y].real)for(d=[],m=0,_=l[y].length;m<_;m++)for(d[m]=[l[y][m][0]],w=1,k=l[y][m].length;w<k;w++)d[m][w]=l[y][m][w]+v*s*h[y][m][w];else{var B=function(t){return+l[y][t]+v*s*h[y][t]};d=[["m",B(0),B(1),B(2),B(3),B(4),B(5)]]}break;case"csv":if("clip-rect"==y)for(d=[],m=4;m--;)d[m]=+l[y][m]+v*s*h[y][m];break;default:var C=[][P](l[y]);for(d=[],m=f.paper.customAttributes[y].length;m--;)d[m]=+C[m]+v*s*h[y][m]}p[y]=d}f.attr(p),function(e,r,i){setTimeout(function(){t("raphael.anim.frame."+e,r,i)})}(f.id,f,n.anim)}else{if(function(r,i,n){setTimeout(function(){t("raphael.anim.frame."+i.id,i,n),t("raphael.anim.finish."+i.id,i,n),e.is(r,"function")&&r.call(i)})}(n.callback,f,n.anim),f.attr(u),Ee.splice(i--,1),n.repeat>1&&!n.next){for(x in u)u[T](x)&&(g[x]=n.totalOrigin[x]);n.el.attr(g),b(n.anim,n.el,n.anim.percents[0],null,n.totalOrigin,n.repeat-1)}n.next&&!n.stop&&b(n.anim,n.el,n.next,null,n.totalOrigin,n.repeat)}}}Ee.length&&Ne(Me)},Le=function(t){return t>255?255:t<0?0:t};ye.animateWith=function(t,r,i,n,a,s){var o=this;if(o.removed)return s&&s.call(o),o;var l=i instanceof m?i:e.animation(i,n,a,s),h,u;b(l,o,l.percents[0],null,o.attr());for(var c=0,f=Ee.length;c<f;c++)if(Ee[c].anim==r&&Ee[c].el==t){Ee[f-1].start=Ee[c].start;break}return o},ye.onAnimation=function(e){return e?t.on("raphael.anim.frame."+this.id,e):t.unbind("raphael.anim.frame."+this.id),this},m.prototype.delay=function(t){var e=new m(this.anim,this.ms);return e.times=this.times,e.del=+t||0,e},m.prototype.repeat=function(t){var e=new m(this.anim,this.ms);return e.del=this.del,e.times=Y.floor(W(t,0))||1,e},e.animation=function(t,r,i,n){if(t instanceof m)return t;!e.is(i,"function")&&i||(n=n||i||null,i=null),t=Object(t),r=+r||0;var a={},s,o;for(o in t)t[T](o)&&ht(o)!=o&&ht(o)+"%"!=o&&(s=!0,a[o]=t[o]);if(s)return i&&(a.easing=i),n&&(a.callback=n),new m({100:a},r);if(n){var l=0;for(var h in t){var u=ut(h);t[T](h)&&u>l&&(l=u)}l+="%",!t[l].callback&&(t[l].callback=n)}return new m(t,r)},ye.animate=function(t,r,i,n){var a=this;if(a.removed)return n&&n.call(a),a;var s=t instanceof m?t:e.animation(t,r,i,n);return b(s,a,s.percents[0],null,a.attr()),a},ye.setTime=function(t,e){return t&&null!=e&&this.status(t,G(e,t.ms)/t.ms),this},ye.status=function(t,e){var r=[],i=0,n,a;if(null!=e)return b(t,this,-1,G(e,1)),this;for(n=Ee.length;i<n;i++)if(a=Ee[i],a.el.id==this.id&&(!t||a.anim==t)){if(t)return a.status;r.push({anim:a.anim,status:a.status})}return t?0:r},ye.pause=function(e){for(var r=0;r<Ee.length;r++)Ee[r].el.id!=this.id||e&&Ee[r].anim!=e||t("raphael.anim.pause."+this.id,this,Ee[r].anim)!==!1&&(Ee[r].paused=!0);return this},ye.resume=function(e){for(var r=0;r<Ee.length;r++)if(Ee[r].el.id==this.id&&(!e||Ee[r].anim==e)){var i=Ee[r];t("raphael.anim.resume."+this.id,this,i.anim)!==!1&&(delete i.paused,this.status(i.anim,i.status))}return this},ye.stop=function(e){for(var r=0;r<Ee.length;r++)Ee[r].el.id!=this.id||e&&Ee[r].anim!=e||t("raphael.anim.stop."+this.id,this,Ee[r].anim)!==!1&&Ee.splice(r--,1);return this},t.on("raphael.remove",_),t.on("raphael.clear",_),ye.toString=function(){return"Raphaël’s object"};var ze=function(t){if(this.items=[],this.length=0,this.type="set",t)for(var e=0,r=t.length;e<r;e++)!t[e]||t[e].constructor!=ye.constructor&&t[e].constructor!=ze||(this[this.items.length]=this.items[this.items.length]=t[e],this.length++)},Pe=ze.prototype;Pe.push=function(){for(var t,e,r=0,i=arguments.length;r<i;r++)t=arguments[r],!t||t.constructor!=ye.constructor&&t.constructor!=ze||(e=this.items.length,this[e]=this.items[e]=t,this.length++);return this},Pe.pop=function(){return this.length&&delete this[this.length--],this.items.pop()},Pe.forEach=function(t,e){for(var r=0,i=this.items.length;r<i;r++)if(t.call(e,this.items[r],r)===!1)return this;return this};for(var Fe in ye)ye[T](Fe)&&(Pe[Fe]=function(t){return function(){var e=arguments;return this.forEach(function(r){r[t][z](r,e)})}}(Fe));return Pe.attr=function(t,r){if(t&&e.is(t,Q)&&e.is(t[0],"object"))for(var i=0,n=t.length;i<n;i++)this.items[i].attr(t[i]);else for(var a=0,s=this.items.length;a<s;a++)this.items[a].attr(t,r);return this},Pe.clear=function(){for(;this.length;)this.pop()},Pe.splice=function(t,e,r){t=t<0?W(this.length+t,0):t,e=W(0,G(this.length-t,e));var i=[],n=[],a=[],s;for(s=2;s<arguments.length;s++)a.push(arguments[s]);for(s=0;s<e;s++)n.push(this[t+s]);for(;s<this.length-t;s++)i.push(this[t+s]);var o=a.length;for(s=0;s<o+i.length;s++)this.items[t+s]=this[t+s]=s<o?a[s]:i[s-o];for(s=this.items.length=this.length-=e-o;this[s];)delete this[s++];return new ze(n)},Pe.exclude=function(t){for(var e=0,r=this.length;e<r;e++)if(this[e]==t)return this.splice(e,1),!0},Pe.animate=function(t,r,i,n){(e.is(i,"function")||!i)&&(n=i||null);var a=this.items.length,s=a,o,l=this,h;if(!a)return this;n&&(h=function(){!--a&&n.call(l)}),i=e.is(i,Z)?i:h;var u=e.animation(t,r,i,h);for(o=this.items[--s].animate(u);s--;)this.items[s]&&!this.items[s].removed&&this.items[s].animateWith(o,u,u),this.items[s]&&!this.items[s].removed||a--;return this},Pe.insertAfter=function(t){for(var e=this.items.length;e--;)this.items[e].insertAfter(t);return this},Pe.getBBox=function(){for(var t=[],e=[],r=[],i=[],n=this.items.length;n--;)if(!this.items[n].removed){var a=this.items[n].getBBox();t.push(a.x),e.push(a.y),r.push(a.x+a.width),i.push(a.y+a.height)}return t=G[z](0,t),e=G[z](0,e),r=W[z](0,r),i=W[z](0,i),{x:t,y:e,x2:r,y2:i,width:r-t,height:i-e}},Pe.clone=function(t){t=this.paper.set();for(var e=0,r=this.items.length;e<r;e++)t.push(this.items[e].clone());return t},Pe.toString=function(){return"Raphaël‘s set"},Pe.glow=function(t){var e=this.paper.set();return this.forEach(function(r,i){var n=r.glow(t);null!=n&&n.forEach(function(t,r){e.push(t)})}),e},Pe.isPointInside=function(t,e){var r=!1;return this.forEach(function(i){if(i.isPointInside(t,e))return r=!0,!1}),r},e.registerFont=function(t){if(!t.face)return t;this.fonts=this.fonts||{};var e={w:t.w,face:{},glyphs:{}},r=t.face["font-family"];for(var i in t.face)t.face[T](i)&&(e.face[i]=t.face[i]);if(this.fonts[r]?this.fonts[r].push(e):this.fonts[r]=[e],!t.svg){e.face["units-per-em"]=ut(t.face["units-per-em"],10);for(var n in t.glyphs)if(t.glyphs[T](n)){var a=t.glyphs[n];if(e.glyphs[n]={w:a.w,k:{},d:a.d&&"M"+a.d.replace(/[mlcxtrv]/g,function(t){return{l:"L",c:"C",x:"z",t:"m",r:"l",v:"c"}[t]||"M"})+"z"},a.k)for(var s in a.k)a[T](s)&&(e.glyphs[n].k[s]=a.k[s])}}return t},M.getFont=function(t,r,i,n){if(n=n||"normal",i=i||"normal",r=+r||{normal:400,bold:700,lighter:300,bolder:800}[r]||400,e.fonts){var a=e.fonts[t];if(!a){var s=new RegExp("(^|\\s)"+t.replace(/[^\w\d\s+!~.:_-]/g,R)+"(\\s|$)","i");for(var o in e.fonts)if(e.fonts[T](o)&&s.test(o)){a=e.fonts[o];break}}var l;if(a)for(var h=0,u=a.length;h<u&&(l=a[h],l.face["font-weight"]!=r||l.face["font-style"]!=i&&l.face["font-style"]||l.face["font-stretch"]!=n);h++);return l}},M.print=function(t,r,i,n,a,s,o,l){s=s||"middle",o=W(G(o||0,1),-1),l=W(G(l||1,3),1);var h=j(i)[q](R),u=0,c=0,f=R,p;if(e.is(n,"string")&&(n=this.getFont(n)),n){p=(a||16)/n.face["units-per-em"];for(var d=n.face.bbox[q](k),g=+d[0],x=d[3]-d[1],v=0,y=+d[1]+("baseline"==s?x+ +n.face.descent:x/2),m=0,b=h.length;m<b;m++){if("\n"==h[m])u=0,w=0,c=0,v+=x*l;else{var _=c&&n.glyphs[h[m-1]]||{},w=n.glyphs[h[m]];u+=c?(_.w||n.w)+(_.k&&_.k[h[m]]||0)+n.w*o:0,c=1}w&&w.d&&(f+=e.transformPath(w.d,["t",u*p,v*p,"s",p,p,g,y,"t",(t-g)/p,(r-y)/p]))}}return this.path(f).attr({fill:"#000",stroke:"none"})},M.add=function(t){if(e.is(t,"array"))for(var r=this.set(),i=0,n=t.length,a;i<n;i++)a=t[i]||{},B[T](a.type)&&r.push(this[a.type]().attr(a));return r},e.format=function(t,r){var i=e.is(r,Q)?[0][P](r):arguments;return t&&e.is(t,Z)&&i.length-1&&(t=t.replace(C,function(t,e){return null==i[++e]?R:i[e]})),t||R},e.fullfill=function(){var t=/\{([^\}]+)\}/g,e=/(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g,r=function(t,r,i){var n=i;return r.replace(e,function(t,e,r,i,a){e=e||i,n&&(e in n&&(n=n[e]),"function"==typeof n&&a&&(n=n()))}),n=(null==n||n==i?t:n)+""};return function(e,i){return String(e).replace(t,function(t,e){return r(t,e,i)})}}(),e.ninja=function(){if(E.was)A.win.Raphael=E.is;else{window.Raphael=void 0;try{delete window.Raphael}catch(t){}}return e},e.st=Pe,t.on("raphael.DOMload",function(){w=!0}),function(t,r,i){function n(){/in/.test(t.readyState)?setTimeout(n,9):e.eve("raphael.DOMload")}null==t.readyState&&t.addEventListener&&(t.addEventListener(r,i=function(){t.removeEventListener(r,i,!1),t.readyState="complete"},!1),t.readyState="loading"),n()}(document,"DOMContentLoaded"),e}.apply(e,i),!(void 0!==n&&(t.exports=n))},function(t,e,r){var i,n;!function(r){var a="0.4.2",s="hasOwnProperty",o=/[\.\/]/,l="*",h=function(){},u=function(t,e){return t-e},c,f,p={n:{}},d=function(t,e){t=String(t);var r=p,i=f,n=Array.prototype.slice.call(arguments,2),a=d.listeners(t),s=0,o=!1,l,h=[],g={},x=[],v=c,y=[];c=t,f=0;for(var m=0,b=a.length;m<b;m++)"zIndex"in a[m]&&(h.push(a[m].zIndex),a[m].zIndex<0&&(g[a[m].zIndex]=a[m]));for(h.sort(u);h[s]<0;)if(l=g[h[s++]],x.push(l.apply(e,n)),f)return f=i,x;for(m=0;m<b;m++)if(l=a[m],"zIndex"in l)if(l.zIndex==h[s]){if(x.push(l.apply(e,n)),f)break;do if(s++,l=g[h[s]],l&&x.push(l.apply(e,n)),f)break;while(l)}else g[l.zIndex]=l;else if(x.push(l.apply(e,n)),f)break;return f=i,c=v,x.length?x:null};d._events=p,d.listeners=function(t){var e=t.split(o),r=p,i,n,a,s,h,u,c,f,d=[r],g=[];for(s=0,h=e.length;s<h;s++){for(f=[],u=0,c=d.length;u<c;u++)for(r=d[u].n,n=[r[e[s]],r[l]],a=2;a--;)i=n[a],i&&(f.push(i),g=g.concat(i.f||[]));d=f}return g},d.on=function(t,e){if(t=String(t),"function"!=typeof e)return function(){};for(var r=t.split(o),i=p,n=0,a=r.length;n<a;n++)i=i.n,i=i.hasOwnProperty(r[n])&&i[r[n]]||(i[r[n]]={n:{}});for(i.f=i.f||[],n=0,a=i.f.length;n<a;n++)if(i.f[n]==e)return h;return i.f.push(e),function(t){+t==+t&&(e.zIndex=+t)}},d.f=function(t){var e=[].slice.call(arguments,1);return function(){d.apply(null,[t,null].concat(e).concat([].slice.call(arguments,0)))}},d.stop=function(){f=1},d.nt=function(t){return t?new RegExp("(?:\\.|\\/|^)"+t+"(?:\\.|\\/|$)").test(c):c},d.nts=function(){return c.split(o)},d.off=d.unbind=function(t,e){if(!t)return void(d._events=p={n:{}});var r=t.split(o),i,n,a,h,u,c,f,g=[p];for(h=0,u=r.length;h<u;h++)for(c=0;c<g.length;c+=a.length-2){if(a=[c,1],i=g[c].n,r[h]!=l)i[r[h]]&&a.push(i[r[h]]);else for(n in i)i[s](n)&&a.push(i[n]);g.splice.apply(g,a)}for(h=0,u=g.length;h<u;h++)for(i=g[h];i.n;){if(e){if(i.f){for(c=0,f=i.f.length;c<f;c++)if(i.f[c]==e){i.f.splice(c,1);break}!i.f.length&&delete i.f}for(n in i.n)if(i.n[s](n)&&i.n[n].f){var x=i.n[n].f;for(c=0,f=x.length;c<f;c++)if(x[c]==e){x.splice(c,1);break}!x.length&&delete i.n[n].f}}else{delete i.f;for(n in i.n)i.n[s](n)&&i.n[n].f&&delete i.n[n].f}i=i.n}},d.once=function(t,e){var r=function(){return d.unbind(t,r),e.apply(this,arguments)};return d.on(t,r)},d.version=a,d.toString=function(){return"You are running Eve "+a},"undefined"!=typeof t&&t.exports?t.exports=d:(i=[],n=function(){return d}.apply(e,i),!(void 0!==n&&(t.exports=n)))}(this)},function(t,e,r){var i,n;i=[r(1)],n=function(t){if(!t||t.svg){var e="hasOwnProperty",r=String,i=parseFloat,n=parseInt,a=Math,s=a.max,o=a.abs,l=a.pow,h=/[, ]+/,u=t.eve,c="",f=" ",p="http://www.w3.org/1999/xlink",d={block:"M5,0 0,2.5 5,5z",classic:"M5,0 0,2.5 5,5 3.5,3 3.5,2z",diamond:"M2.5,0 5,2.5 2.5,5 0,2.5z",open:"M6,1 1,3.5 6,6",oval:"M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"},g={};t.toString=function(){return"Your browser supports SVG.\nYou are running Raphaël "+this.version};var x=function(i,n){if(n){"string"==typeof i&&(i=x(i));for(var a in n)n[e](a)&&("xlink:"==a.substring(0,6)?i.setAttributeNS(p,a.substring(6),r(n[a])):i.setAttribute(a,r(n[a])))}else i=t._g.doc.createElementNS("http://www.w3.org/2000/svg",i),i.style&&(i.style.webkitTapHighlightColor="rgba(0,0,0,0)");return i},v=function(e,n){var h="linear",u=e.id+n,f=.5,p=.5,d=e.node,g=e.paper,v=d.style,y=t._g.doc.getElementById(u);if(!y){if(n=r(n).replace(t._radial_gradient,function(t,e,r){if(h="radial",e&&r){f=i(e),p=i(r);var n=2*(p>.5)-1;l(f-.5,2)+l(p-.5,2)>.25&&(p=a.sqrt(.25-l(f-.5,2))*n+.5)&&.5!=p&&(p=p.toFixed(5)-1e-5*n)}return c}),n=n.split(/\s*\-\s*/),"linear"==h){var b=n.shift();if(b=-i(b),isNaN(b))return null;var _=[0,0,a.cos(t.rad(b)),a.sin(t.rad(b))],w=1/(s(o(_[2]),o(_[3]))||1);_[2]*=w,_[3]*=w,_[2]<0&&(_[0]=-_[2],_[2]=0),_[3]<0&&(_[1]=-_[3],_[3]=0)}var k=t._parseDots(n);if(!k)return null;if(u=u.replace(/[\(\)\s,\xb0#]/g,"_"),e.gradient&&u!=e.gradient.id&&(g.defs.removeChild(e.gradient),delete e.gradient),!e.gradient){y=x(h+"Gradient",{id:u}),e.gradient=y,x(y,"radial"==h?{fx:f,fy:p}:{x1:_[0],y1:_[1],x2:_[2],y2:_[3],gradientTransform:e.matrix.invert()}),g.defs.appendChild(y);for(var B=0,C=k.length;B<C;B++)y.appendChild(x("stop",{offset:k[B].offset?k[B].offset:B?"100%":"0%","stop-color":k[B].color||"#fff","stop-opacity":isFinite(k[B].opacity)?k[B].opacity:1}))}}return x(d,{fill:m(u),opacity:1,"fill-opacity":1}),v.fill=c,v.opacity=1,v.fillOpacity=1,1},y=function(){var t=document.documentMode;return t&&(9===t||10===t)},m=function(t){if(y())return"url('#"+t+"')";var e=document.location,r=e.protocol+"//"+e.host+e.pathname+e.search;return"url('"+r+"#"+t+"')"},b=function(t){var e=t.getBBox(1);x(t.pattern,{patternTransform:t.matrix.invert()+" translate("+e.x+","+e.y+")"})},_=function(i,n,a){if("path"==i.type){for(var s=r(n).toLowerCase().split("-"),o=i.paper,l=a?"end":"start",h=i.node,u=i.attrs,f=u["stroke-width"],p=s.length,v="classic",y,m,b,_,w,k=3,B=3,C=5;p--;)switch(s[p]){case"block":case"classic":case"oval":case"diamond":case"open":case"none":v=s[p];break;case"wide":B=5;break;case"narrow":B=2;break;case"long":k=5;break;case"short":k=2}if("open"==v?(k+=2,B+=2,C+=2,b=1,_=a?4:1,w={fill:"none",stroke:u.stroke}):(_=b=k/2,w={fill:u.stroke,stroke:"none"}),i._.arrows?a?(i._.arrows.endPath&&g[i._.arrows.endPath]--,i._.arrows.endMarker&&g[i._.arrows.endMarker]--):(i._.arrows.startPath&&g[i._.arrows.startPath]--,i._.arrows.startMarker&&g[i._.arrows.startMarker]--):i._.arrows={},"none"!=v){var S="raphael-marker-"+v,T="raphael-marker-"+l+v+k+B+"-obj"+i.id;t._g.doc.getElementById(S)?g[S]++:(o.defs.appendChild(x(x("path"),{"stroke-linecap":"round",d:d[v],id:S})),g[S]=1);var A=t._g.doc.getElementById(T),E;A?(g[T]++,E=A.getElementsByTagName("use")[0]):(A=x(x("marker"),{id:T,markerHeight:B,markerWidth:k,orient:"auto",refX:_,refY:B/2}),E=x(x("use"),{"xlink:href":"#"+S,transform:(a?"rotate(180 "+k/2+" "+B/2+") ":c)+"scale("+k/C+","+B/C+")","stroke-width":(1/((k/C+B/C)/2)).toFixed(4)}),A.appendChild(E),o.defs.appendChild(A),g[T]=1),x(E,w);var N=b*("diamond"!=v&&"oval"!=v);a?(y=i._.arrows.startdx*f||0,m=t.getTotalLength(u.path)-N*f):(y=N*f,m=t.getTotalLength(u.path)-(i._.arrows.enddx*f||0)),w={},w["marker-"+l]="url(#"+T+")",(m||y)&&(w.d=t.getSubpath(u.path,y,m)),x(h,w),i._.arrows[l+"Path"]=S,i._.arrows[l+"Marker"]=T,i._.arrows[l+"dx"]=N,i._.arrows[l+"Type"]=v,i._.arrows[l+"String"]=n}else a?(y=i._.arrows.startdx*f||0,m=t.getTotalLength(u.path)-y):(y=0,m=t.getTotalLength(u.path)-(i._.arrows.enddx*f||0)),i._.arrows[l+"Path"]&&x(h,{d:t.getSubpath(u.path,y,m)}),delete i._.arrows[l+"Path"],delete i._.arrows[l+"Marker"],delete i._.arrows[l+"dx"],delete i._.arrows[l+"Type"],delete i._.arrows[l+"String"];for(w in g)if(g[e](w)&&!g[w]){var M=t._g.doc.getElementById(w);M&&M.parentNode.removeChild(M)}}},w={"-":[3,1],".":[1,1],"-.":[3,1,1,1],"-..":[3,1,1,1,1,1],". ":[1,3],"- ":[4,3],"--":[8,3],"- .":[4,3,1,3],"--.":[8,3,1,3],"--..":[8,3,1,3,1,3]},k=function(t,e,i){if(e=w[r(e).toLowerCase()]){for(var n=t.attrs["stroke-width"]||"1",a={round:n,square:n,butt:0}[t.attrs["stroke-linecap"]||i["stroke-linecap"]]||0,s=[],o=e.length;o--;)s[o]=e[o]*n+(o%2?1:-1)*a;x(t.node,{"stroke-dasharray":s.join(",")})}else x(t.node,{"stroke-dasharray":"none"})},B=function(i,a){var l=i.node,u=i.attrs,f=l.style.visibility;l.style.visibility="hidden";for(var d in a)if(a[e](d)){if(!t._availableAttrs[e](d))continue;var g=a[d];switch(u[d]=g,d){case"blur":i.blur(g);break;case"title":var y=l.getElementsByTagName("title");if(y.length&&(y=y[0]))y.firstChild.nodeValue=g;else{y=x("title");var m=t._g.doc.createTextNode(g);y.appendChild(m),l.appendChild(y)}break;case"href":case"target":var w=l.parentNode;if("a"!=w.tagName.toLowerCase()){var B=x("a");w.insertBefore(B,l),B.appendChild(l),w=B}"target"==d?w.setAttributeNS(p,"show","blank"==g?"new":g):w.setAttributeNS(p,d,g);break;case"cursor":l.style.cursor=g;break;case"transform":i.transform(g);break;case"arrow-start":_(i,g);break;case"arrow-end":_(i,g,1);break;case"clip-rect":var C=r(g).split(h);if(4==C.length){i.clip&&i.clip.parentNode.parentNode.removeChild(i.clip.parentNode);var T=x("clipPath"),A=x("rect");T.id=t.createUUID(),x(A,{x:C[0],y:C[1],width:C[2],height:C[3]}),T.appendChild(A),i.paper.defs.appendChild(T),x(l,{"clip-path":"url(#"+T.id+")"}),i.clip=A}if(!g){var E=l.getAttribute("clip-path");if(E){var N=t._g.doc.getElementById(E.replace(/(^url\(#|\)$)/g,c));N&&N.parentNode.removeChild(N),x(l,{"clip-path":c}),delete i.clip}}break;case"path":"path"==i.type&&(x(l,{d:g?u.path=t._pathToAbsolute(g):"M0,0"}),i._.dirty=1,i._.arrows&&("startString"in i._.arrows&&_(i,i._.arrows.startString),"endString"in i._.arrows&&_(i,i._.arrows.endString,1)));break;case"width":if(l.setAttribute(d,g),i._.dirty=1,!u.fx)break;d="x",g=u.x;case"x":u.fx&&(g=-u.x-(u.width||0));case"rx":if("rx"==d&&"rect"==i.type)break;case"cx":l.setAttribute(d,g),i.pattern&&b(i),i._.dirty=1;break;case"height":if(l.setAttribute(d,g),i._.dirty=1,!u.fy)break;d="y",g=u.y;case"y":u.fy&&(g=-u.y-(u.height||0));case"ry":if("ry"==d&&"rect"==i.type)break;case"cy":l.setAttribute(d,g),i.pattern&&b(i),i._.dirty=1;break;case"r":"rect"==i.type?x(l,{rx:g,ry:g}):l.setAttribute(d,g),i._.dirty=1;break;case"src":"image"==i.type&&l.setAttributeNS(p,"href",g);break;case"stroke-width":1==i._.sx&&1==i._.sy||(g/=s(o(i._.sx),o(i._.sy))||1),l.setAttribute(d,g),u["stroke-dasharray"]&&k(i,u["stroke-dasharray"],a),i._.arrows&&("startString"in i._.arrows&&_(i,i._.arrows.startString),"endString"in i._.arrows&&_(i,i._.arrows.endString,1));break;case"stroke-dasharray":k(i,g,a);break;case"fill":var M=r(g).match(t._ISURL);if(M){T=x("pattern");var L=x("image");T.id=t.createUUID(),x(T,{x:0,y:0,patternUnits:"userSpaceOnUse",height:1,width:1}),x(L,{x:0,y:0,"xlink:href":M[1]}),T.appendChild(L),function(e){t._preload(M[1],function(){var t=this.offsetWidth,r=this.offsetHeight;x(e,{width:t,height:r}),x(L,{width:t,height:r})})}(T),i.paper.defs.appendChild(T),x(l,{fill:"url(#"+T.id+")"}),i.pattern=T,i.pattern&&b(i);break}var z=t.getRGB(g);if(z.error){if(("circle"==i.type||"ellipse"==i.type||"r"!=r(g).charAt())&&v(i,g)){
	if("opacity"in u||"fill-opacity"in u){var P=t._g.doc.getElementById(l.getAttribute("fill").replace(/^url\(#|\)$/g,c));if(P){var F=P.getElementsByTagName("stop");x(F[F.length-1],{"stop-opacity":("opacity"in u?u.opacity:1)*("fill-opacity"in u?u["fill-opacity"]:1)})}}u.gradient=g,u.fill="none";break}}else delete a.gradient,delete u.gradient,!t.is(u.opacity,"undefined")&&t.is(a.opacity,"undefined")&&x(l,{opacity:u.opacity}),!t.is(u["fill-opacity"],"undefined")&&t.is(a["fill-opacity"],"undefined")&&x(l,{"fill-opacity":u["fill-opacity"]});z[e]("opacity")&&x(l,{"fill-opacity":z.opacity>1?z.opacity/100:z.opacity});case"stroke":z=t.getRGB(g),l.setAttribute(d,z.hex),"stroke"==d&&z[e]("opacity")&&x(l,{"stroke-opacity":z.opacity>1?z.opacity/100:z.opacity}),"stroke"==d&&i._.arrows&&("startString"in i._.arrows&&_(i,i._.arrows.startString),"endString"in i._.arrows&&_(i,i._.arrows.endString,1));break;case"gradient":("circle"==i.type||"ellipse"==i.type||"r"!=r(g).charAt())&&v(i,g);break;case"opacity":u.gradient&&!u[e]("stroke-opacity")&&x(l,{"stroke-opacity":g>1?g/100:g});case"fill-opacity":if(u.gradient){P=t._g.doc.getElementById(l.getAttribute("fill").replace(/^url\(#|\)$/g,c)),P&&(F=P.getElementsByTagName("stop"),x(F[F.length-1],{"stop-opacity":g}));break}default:"font-size"==d&&(g=n(g,10)+"px");var R=d.replace(/(\-.)/g,function(t){return t.substring(1).toUpperCase()});l.style[R]=g,i._.dirty=1,l.setAttribute(d,g)}}S(i,a),l.style.visibility=f},C=1.2,S=function(i,a){if("text"==i.type&&(a[e]("text")||a[e]("font")||a[e]("font-size")||a[e]("x")||a[e]("y"))){var s=i.attrs,o=i.node,l=o.firstChild?n(t._g.doc.defaultView.getComputedStyle(o.firstChild,c).getPropertyValue("font-size"),10):10;if(a[e]("text")){for(s.text=a.text;o.firstChild;)o.removeChild(o.firstChild);for(var h=r(a.text).split("\n"),u=[],f,p=0,d=h.length;p<d;p++)f=x("tspan"),p&&x(f,{dy:l*C,x:s.x}),f.appendChild(t._g.doc.createTextNode(h[p])),o.appendChild(f),u[p]=f}else for(u=o.getElementsByTagName("tspan"),p=0,d=u.length;p<d;p++)p?x(u[p],{dy:l*C,x:s.x}):x(u[0],{dy:0});x(o,{x:s.x,y:s.y}),i._.dirty=1;var g=i._getBBox(),v=s.y-(g.y+g.height/2);g.height&&v&&t.is(v,"finite")&&x(u[0],{dy:v})}},T=function(t){return t.parentNode&&"a"===t.parentNode.tagName.toLowerCase()?t.parentNode:t},A=function(e,r){var i=0,n=0;this[0]=this.node=e,e.raphael=!0,this.id=t._oid++,e.raphaelid=this.id,this.matrix=t.matrix(),this.realPath=null,this.paper=r,this.attrs=this.attrs||{},this._={transform:[],sx:1,sy:1,deg:0,dx:0,dy:0,dirty:1},!r.bottom&&(r.bottom=this),this.prev=r.top,r.top&&(r.top.next=this),r.top=this,this.next=null},E=t.el;A.prototype=E,E.constructor=A,t._engine.path=function(t,e){var r=x("path");e.canvas&&e.canvas.appendChild(r);var i=new A(r,e);return i.type="path",B(i,{fill:"none",stroke:"#000",path:t}),i},E.rotate=function(t,e,n){if(this.removed)return this;if(t=r(t).split(h),t.length-1&&(e=i(t[1]),n=i(t[2])),t=i(t[0]),null==n&&(e=n),null==e||null==n){var a=this.getBBox(1);e=a.x+a.width/2,n=a.y+a.height/2}return this.transform(this._.transform.concat([["r",t,e,n]])),this},E.scale=function(t,e,n,a){if(this.removed)return this;if(t=r(t).split(h),t.length-1&&(e=i(t[1]),n=i(t[2]),a=i(t[3])),t=i(t[0]),null==e&&(e=t),null==a&&(n=a),null==n||null==a)var s=this.getBBox(1);return n=null==n?s.x+s.width/2:n,a=null==a?s.y+s.height/2:a,this.transform(this._.transform.concat([["s",t,e,n,a]])),this},E.translate=function(t,e){return this.removed?this:(t=r(t).split(h),t.length-1&&(e=i(t[1])),t=i(t[0])||0,e=+e||0,this.transform(this._.transform.concat([["t",t,e]])),this)},E.transform=function(r){var i=this._;if(null==r)return i.transform;if(t._extractTransform(this,r),this.clip&&x(this.clip,{transform:this.matrix.invert()}),this.pattern&&b(this),this.node&&x(this.node,{transform:this.matrix}),1!=i.sx||1!=i.sy){var n=this.attrs[e]("stroke-width")?this.attrs["stroke-width"]:1;this.attr({"stroke-width":n})}return i.transform=this.matrix.toTransformString(),this},E.hide=function(){return this.removed||(this.node.style.display="none"),this},E.show=function(){return this.removed||(this.node.style.display=""),this},E.remove=function(){var e=T(this.node);if(!this.removed&&e.parentNode){var r=this.paper;r.__set__&&r.__set__.exclude(this),u.unbind("raphael.*.*."+this.id),this.gradient&&r.defs.removeChild(this.gradient),t._tear(this,r),e.parentNode.removeChild(e),this.removeData();for(var i in this)this[i]="function"==typeof this[i]?t._removedFactory(i):null;this.removed=!0}},E._getBBox=function(){if("none"==this.node.style.display){this.show();var t=!0}var e=!1,r;this.paper.canvas.parentElement?r=this.paper.canvas.parentElement.style:this.paper.canvas.parentNode&&(r=this.paper.canvas.parentNode.style),r&&"none"==r.display&&(e=!0,r.display="");var i={};try{i=this.node.getBBox()}catch(n){i={x:this.node.clientLeft,y:this.node.clientTop,width:this.node.clientWidth,height:this.node.clientHeight}}finally{i=i||{},e&&(r.display="none")}return t&&this.hide(),i},E.attr=function(r,i){if(this.removed)return this;if(null==r){var n={};for(var a in this.attrs)this.attrs[e](a)&&(n[a]=this.attrs[a]);return n.gradient&&"none"==n.fill&&(n.fill=n.gradient)&&delete n.gradient,n.transform=this._.transform,n}if(null==i&&t.is(r,"string")){if("fill"==r&&"none"==this.attrs.fill&&this.attrs.gradient)return this.attrs.gradient;if("transform"==r)return this._.transform;for(var s=r.split(h),o={},l=0,c=s.length;l<c;l++)r=s[l],r in this.attrs?o[r]=this.attrs[r]:t.is(this.paper.customAttributes[r],"function")?o[r]=this.paper.customAttributes[r].def:o[r]=t._availableAttrs[r];return c-1?o:o[s[0]]}if(null==i&&t.is(r,"array")){for(o={},l=0,c=r.length;l<c;l++)o[r[l]]=this.attr(r[l]);return o}if(null!=i){var f={};f[r]=i}else null!=r&&t.is(r,"object")&&(f=r);for(var p in f)u("raphael.attr."+p+"."+this.id,this,f[p]);for(p in this.paper.customAttributes)if(this.paper.customAttributes[e](p)&&f[e](p)&&t.is(this.paper.customAttributes[p],"function")){var d=this.paper.customAttributes[p].apply(this,[].concat(f[p]));this.attrs[p]=f[p];for(var g in d)d[e](g)&&(f[g]=d[g])}return B(this,f),this},E.toFront=function(){if(this.removed)return this;var e=T(this.node);e.parentNode.appendChild(e);var r=this.paper;return r.top!=this&&t._tofront(this,r),this},E.toBack=function(){if(this.removed)return this;var e=T(this.node),r=e.parentNode;r.insertBefore(e,r.firstChild),t._toback(this,this.paper);var i=this.paper;return this},E.insertAfter=function(e){if(this.removed||!e)return this;var r=T(this.node),i=T(e.node||e[e.length-1].node);return i.nextSibling?i.parentNode.insertBefore(r,i.nextSibling):i.parentNode.appendChild(r),t._insertafter(this,e,this.paper),this},E.insertBefore=function(e){if(this.removed||!e)return this;var r=T(this.node),i=T(e.node||e[0].node);return i.parentNode.insertBefore(r,i),t._insertbefore(this,e,this.paper),this},E.blur=function(e){var r=this;if(0!==+e){var i=x("filter"),n=x("feGaussianBlur");r.attrs.blur=e,i.id=t.createUUID(),x(n,{stdDeviation:+e||1.5}),i.appendChild(n),r.paper.defs.appendChild(i),r._blur=i,x(r.node,{filter:"url(#"+i.id+")"})}else r._blur&&(r._blur.parentNode.removeChild(r._blur),delete r._blur,delete r.attrs.blur),r.node.removeAttribute("filter");return r},t._engine.circle=function(t,e,r,i){var n=x("circle");t.canvas&&t.canvas.appendChild(n);var a=new A(n,t);return a.attrs={cx:e,cy:r,r:i,fill:"none",stroke:"#000"},a.type="circle",x(n,a.attrs),a},t._engine.rect=function(t,e,r,i,n,a){var s=x("rect");t.canvas&&t.canvas.appendChild(s);var o=new A(s,t);return o.attrs={x:e,y:r,width:i,height:n,rx:a||0,ry:a||0,fill:"none",stroke:"#000"},o.type="rect",x(s,o.attrs),o},t._engine.ellipse=function(t,e,r,i,n){var a=x("ellipse");t.canvas&&t.canvas.appendChild(a);var s=new A(a,t);return s.attrs={cx:e,cy:r,rx:i,ry:n,fill:"none",stroke:"#000"},s.type="ellipse",x(a,s.attrs),s},t._engine.image=function(t,e,r,i,n,a){var s=x("image");x(s,{x:r,y:i,width:n,height:a,preserveAspectRatio:"none"}),s.setAttributeNS(p,"href",e),t.canvas&&t.canvas.appendChild(s);var o=new A(s,t);return o.attrs={x:r,y:i,width:n,height:a,src:e},o.type="image",o},t._engine.text=function(e,r,i,n){var a=x("text");e.canvas&&e.canvas.appendChild(a);var s=new A(a,e);return s.attrs={x:r,y:i,"text-anchor":"middle",text:n,"font-family":t._availableAttrs["font-family"],"font-size":t._availableAttrs["font-size"],stroke:"none",fill:"#000"},s.type="text",B(s,s.attrs),s},t._engine.setSize=function(t,e){return this.width=t||this.width,this.height=e||this.height,this.canvas.setAttribute("width",this.width),this.canvas.setAttribute("height",this.height),this._viewBox&&this.setViewBox.apply(this,this._viewBox),this},t._engine.create=function(){var e=t._getContainer.apply(0,arguments),r=e&&e.container,i=e.x,n=e.y,a=e.width,s=e.height;if(!r)throw new Error("SVG container not found.");var o=x("svg"),l="overflow:hidden;",h;return i=i||0,n=n||0,a=a||512,s=s||342,x(o,{height:s,version:1.1,width:a,xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink"}),1==r?(o.style.cssText=l+"position:absolute;left:"+i+"px;top:"+n+"px",t._g.doc.body.appendChild(o),h=1):(o.style.cssText=l+"position:relative",r.firstChild?r.insertBefore(o,r.firstChild):r.appendChild(o)),r=new t._Paper,r.width=a,r.height=s,r.canvas=o,r.clear(),r._left=r._top=0,h&&(r.renderfix=function(){}),r.renderfix(),r},t._engine.setViewBox=function(t,e,r,i,n){u("raphael.setViewBox",this,this._viewBox,[t,e,r,i,n]);var a=this.getSize(),o=s(r/a.width,i/a.height),l=this.top,h=n?"xMidYMid meet":"xMinYMin",c,p;for(null==t?(this._vbSize&&(o=1),delete this._vbSize,c="0 0 "+this.width+f+this.height):(this._vbSize=o,c=t+f+e+f+r+f+i),x(this.canvas,{viewBox:c,preserveAspectRatio:h});o&&l;)p="stroke-width"in l.attrs?l.attrs["stroke-width"]:1,l.attr({"stroke-width":p}),l._.dirty=1,l._.dirtyT=1,l=l.prev;return this._viewBox=[t,e,r,i,!!n],this},t.prototype.renderfix=function(){var t=this.canvas,e=t.style,r;try{r=t.getScreenCTM()||t.createSVGMatrix()}catch(i){r=t.createSVGMatrix()}var n=-r.e%1,a=-r.f%1;(n||a)&&(n&&(this._left=(this._left+n)%1,e.left=this._left+"px"),a&&(this._top=(this._top+a)%1,e.top=this._top+"px"))},t.prototype.clear=function(){t.eve("raphael.clear",this);for(var e=this.canvas;e.firstChild;)e.removeChild(e.firstChild);this.bottom=this.top=null,(this.desc=x("desc")).appendChild(t._g.doc.createTextNode("Created with Raphaël "+t.version)),e.appendChild(this.desc),e.appendChild(this.defs=x("defs"))},t.prototype.remove=function(){u("raphael.remove",this),this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas);for(var e in this)this[e]="function"==typeof this[e]?t._removedFactory(e):null};var N=t.st;for(var M in E)E[e](M)&&!N[e](M)&&(N[M]=function(t){return function(){var e=arguments;return this.forEach(function(r){r[t].apply(r,e)})}}(M))}}.apply(e,i),!(void 0!==n&&(t.exports=n))},function(t,e,r){var i,n;i=[r(1)],n=function(t){if(!t||t.vml){var e="hasOwnProperty",r=String,i=parseFloat,n=Math,a=n.round,s=n.max,o=n.min,l=n.abs,h="fill",u=/[, ]+/,c=t.eve,f=" progid:DXImageTransform.Microsoft",p=" ",d="",g={M:"m",L:"l",C:"c",Z:"x",m:"t",l:"r",c:"v",z:"x"},x=/([clmz]),?([^clmz]*)/gi,v=/ progid:\S+Blur\([^\)]+\)/g,y=/-?[^,\s-]+/g,m="position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",b=21600,_={path:1,rect:1,image:1},w={circle:1,ellipse:1},k=function(e){var i=/[ahqstv]/gi,n=t._pathToAbsolute;if(r(e).match(i)&&(n=t._path2curve),i=/[clmz]/g,n==t._pathToAbsolute&&!r(e).match(i)){var s=r(e).replace(x,function(t,e,r){var i=[],n="m"==e.toLowerCase(),s=g[e];return r.replace(y,function(t){n&&2==i.length&&(s+=i+g["m"==e?"l":"L"],i=[]),i.push(a(t*b))}),s+i});return s}var o=n(e),l,h;s=[];for(var u=0,c=o.length;u<c;u++){l=o[u],h=o[u][0].toLowerCase(),"z"==h&&(h="x");for(var f=1,v=l.length;f<v;f++)h+=a(l[f]*b)+(f!=v-1?",":d);s.push(h)}return s.join(p)},B=function(e,r,i){var n=t.matrix();return n.rotate(-e,.5,.5),{dx:n.x(r,i),dy:n.y(r,i)}},C=function(t,e,r,i,n,a){var s=t._,o=t.matrix,u=s.fillpos,c=t.node,f=c.style,d=1,g="",x,v=b/e,y=b/r;if(f.visibility="hidden",e&&r){if(c.coordsize=l(v)+p+l(y),f.rotation=a*(e*r<0?-1:1),a){var m=B(a,i,n);i=m.dx,n=m.dy}if(e<0&&(g+="x"),r<0&&(g+=" y")&&(d=-1),f.flip=g,c.coordorigin=i*-v+p+n*-y,u||s.fillsize){var _=c.getElementsByTagName(h);_=_&&_[0],c.removeChild(_),u&&(m=B(a,o.x(u[0],u[1]),o.y(u[0],u[1])),_.position=m.dx*d+p+m.dy*d),s.fillsize&&(_.size=s.fillsize[0]*l(e)+p+s.fillsize[1]*l(r)),c.appendChild(_)}f.visibility="visible"}};t.toString=function(){return"Your browser doesn’t support SVG. Falling down to VML.\nYou are running Raphaël "+this.version};var S=function(t,e,i){for(var n=r(e).toLowerCase().split("-"),a=i?"end":"start",s=n.length,o="classic",l="medium",h="medium";s--;)switch(n[s]){case"block":case"classic":case"oval":case"diamond":case"open":case"none":o=n[s];break;case"wide":case"narrow":h=n[s];break;case"long":case"short":l=n[s]}var u=t.node.getElementsByTagName("stroke")[0];u[a+"arrow"]=o,u[a+"arrowlength"]=l,u[a+"arrowwidth"]=h},T=function(n,l){n.attrs=n.attrs||{};var c=n.node,f=n.attrs,g=c.style,x,v=_[n.type]&&(l.x!=f.x||l.y!=f.y||l.width!=f.width||l.height!=f.height||l.cx!=f.cx||l.cy!=f.cy||l.rx!=f.rx||l.ry!=f.ry||l.r!=f.r),y=w[n.type]&&(f.cx!=l.cx||f.cy!=l.cy||f.r!=l.r||f.rx!=l.rx||f.ry!=l.ry),m=n;for(var B in l)l[e](B)&&(f[B]=l[B]);if(v&&(f.path=t._getPath[n.type](n),n._.dirty=1),l.href&&(c.href=l.href),l.title&&(c.title=l.title),l.target&&(c.target=l.target),l.cursor&&(g.cursor=l.cursor),"blur"in l&&n.blur(l.blur),(l.path&&"path"==n.type||v)&&(c.path=k(~r(f.path).toLowerCase().indexOf("r")?t._pathToAbsolute(f.path):f.path),n._.dirty=1,"image"==n.type&&(n._.fillpos=[f.x,f.y],n._.fillsize=[f.width,f.height],C(n,1,1,0,0,0))),"transform"in l&&n.transform(l.transform),y){var T=+f.cx,E=+f.cy,N=+f.rx||+f.r||0,L=+f.ry||+f.r||0;c.path=t.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x",a((T-N)*b),a((E-L)*b),a((T+N)*b),a((E+L)*b),a(T*b)),n._.dirty=1}if("clip-rect"in l){var z=r(l["clip-rect"]).split(u);if(4==z.length){z[2]=+z[2]+ +z[0],z[3]=+z[3]+ +z[1];var P=c.clipRect||t._g.doc.createElement("div"),F=P.style;F.clip=t.format("rect({1}px {2}px {3}px {0}px)",z),c.clipRect||(F.position="absolute",F.top=0,F.left=0,F.width=n.paper.width+"px",F.height=n.paper.height+"px",c.parentNode.insertBefore(P,c),P.appendChild(c),c.clipRect=P)}l["clip-rect"]||c.clipRect&&(c.clipRect.style.clip="auto")}if(n.textpath){var R=n.textpath.style;l.font&&(R.font=l.font),l["font-family"]&&(R.fontFamily='"'+l["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g,d)+'"'),l["font-size"]&&(R.fontSize=l["font-size"]),l["font-weight"]&&(R.fontWeight=l["font-weight"]),l["font-style"]&&(R.fontStyle=l["font-style"])}if("arrow-start"in l&&S(m,l["arrow-start"]),"arrow-end"in l&&S(m,l["arrow-end"],1),null!=l.opacity||null!=l["stroke-width"]||null!=l.fill||null!=l.src||null!=l.stroke||null!=l["stroke-width"]||null!=l["stroke-opacity"]||null!=l["fill-opacity"]||null!=l["stroke-dasharray"]||null!=l["stroke-miterlimit"]||null!=l["stroke-linejoin"]||null!=l["stroke-linecap"]){var I=c.getElementsByTagName(h),j=!1;if(I=I&&I[0],!I&&(j=I=M(h)),"image"==n.type&&l.src&&(I.src=l.src),l.fill&&(I.on=!0),null!=I.on&&"none"!=l.fill&&null!==l.fill||(I.on=!1),I.on&&l.fill){var q=r(l.fill).match(t._ISURL);if(q){I.parentNode==c&&c.removeChild(I),I.rotate=!0,I.src=q[1],I.type="tile";var D=n.getBBox(1);I.position=D.x+p+D.y,n._.fillpos=[D.x,D.y],t._preload(q[1],function(){n._.fillsize=[this.offsetWidth,this.offsetHeight]})}else I.color=t.getRGB(l.fill).hex,I.src=d,I.type="solid",t.getRGB(l.fill).error&&(m.type in{circle:1,ellipse:1}||"r"!=r(l.fill).charAt())&&A(m,l.fill,I)&&(f.fill="none",f.gradient=l.fill,I.rotate=!1)}if("fill-opacity"in l||"opacity"in l){var V=((+f["fill-opacity"]+1||2)-1)*((+f.opacity+1||2)-1)*((+t.getRGB(l.fill).o+1||2)-1);V=o(s(V,0),1),I.opacity=V,I.src&&(I.color="none")}c.appendChild(I);var O=c.getElementsByTagName("stroke")&&c.getElementsByTagName("stroke")[0],Y=!1;!O&&(Y=O=M("stroke")),(l.stroke&&"none"!=l.stroke||l["stroke-width"]||null!=l["stroke-opacity"]||l["stroke-dasharray"]||l["stroke-miterlimit"]||l["stroke-linejoin"]||l["stroke-linecap"])&&(O.on=!0),("none"==l.stroke||null===l.stroke||null==O.on||0==l.stroke||0==l["stroke-width"])&&(O.on=!1);var W=t.getRGB(l.stroke);O.on&&l.stroke&&(O.color=W.hex),V=((+f["stroke-opacity"]+1||2)-1)*((+f.opacity+1||2)-1)*((+W.o+1||2)-1);var G=.75*(i(l["stroke-width"])||1);if(V=o(s(V,0),1),null==l["stroke-width"]&&(G=f["stroke-width"]),l["stroke-width"]&&(O.weight=G),G&&G<1&&(V*=G)&&(O.weight=1),O.opacity=V,l["stroke-linejoin"]&&(O.joinstyle=l["stroke-linejoin"]||"miter"),O.miterlimit=l["stroke-miterlimit"]||8,l["stroke-linecap"]&&(O.endcap="butt"==l["stroke-linecap"]?"flat":"square"==l["stroke-linecap"]?"square":"round"),"stroke-dasharray"in l){var H={"-":"shortdash",".":"shortdot","-.":"shortdashdot","-..":"shortdashdotdot",". ":"dot","- ":"dash","--":"longdash","- .":"dashdot","--.":"longdashdot","--..":"longdashdotdot"};O.dashstyle=H[e](l["stroke-dasharray"])?H[l["stroke-dasharray"]]:d}Y&&c.appendChild(O)}if("text"==m.type){m.paper.canvas.style.display=d;var X=m.paper.span,U=100,$=f.font&&f.font.match(/\d+(?:\.\d*)?(?=px)/);g=X.style,f.font&&(g.font=f.font),f["font-family"]&&(g.fontFamily=f["font-family"]),f["font-weight"]&&(g.fontWeight=f["font-weight"]),f["font-style"]&&(g.fontStyle=f["font-style"]),$=i(f["font-size"]||$&&$[0])||10,g.fontSize=$*U+"px",m.textpath.string&&(X.innerHTML=r(m.textpath.string).replace(/</g,"&#60;").replace(/&/g,"&#38;").replace(/\n/g,"<br>"));var Z=X.getBoundingClientRect();m.W=f.w=(Z.right-Z.left)/U,m.H=f.h=(Z.bottom-Z.top)/U,m.X=f.x,m.Y=f.y+m.H/2,("x"in l||"y"in l)&&(m.path.v=t.format("m{0},{1}l{2},{1}",a(f.x*b),a(f.y*b),a(f.x*b)+1));for(var Q=["x","y","text","font","font-family","font-weight","font-style","font-size"],J=0,K=Q.length;J<K;J++)if(Q[J]in l){m._.dirty=1;break}switch(f["text-anchor"]){case"start":m.textpath.style["v-text-align"]="left",m.bbx=m.W/2;break;case"end":m.textpath.style["v-text-align"]="right",m.bbx=-m.W/2;break;default:m.textpath.style["v-text-align"]="center",m.bbx=0}m.textpath.style["v-text-kern"]=!0}},A=function(e,a,s){e.attrs=e.attrs||{};var o=e.attrs,l=Math.pow,h,u,c="linear",f=".5 .5";if(e.attrs.gradient=a,a=r(a).replace(t._radial_gradient,function(t,e,r){return c="radial",e&&r&&(e=i(e),r=i(r),l(e-.5,2)+l(r-.5,2)>.25&&(r=n.sqrt(.25-l(e-.5,2))*(2*(r>.5)-1)+.5),f=e+p+r),d}),a=a.split(/\s*\-\s*/),"linear"==c){var g=a.shift();if(g=-i(g),isNaN(g))return null}var x=t._parseDots(a);if(!x)return null;if(e=e.shape||e.node,x.length){e.removeChild(s),s.on=!0,s.method="none",s.color=x[0].color,s.color2=x[x.length-1].color;for(var v=[],y=0,m=x.length;y<m;y++)x[y].offset&&v.push(x[y].offset+p+x[y].color);s.colors=v.length?v.join():"0% "+s.color,"radial"==c?(s.type="gradientTitle",s.focus="100%",s.focussize="0 0",s.focusposition=f,s.angle=0):(s.type="gradient",s.angle=(270-g)%360),e.appendChild(s)}return 1},E=function(e,r){this[0]=this.node=e,e.raphael=!0,this.id=t._oid++,e.raphaelid=this.id,this.X=0,this.Y=0,this.attrs={},this.paper=r,this.matrix=t.matrix(),this._={transform:[],sx:1,sy:1,dx:0,dy:0,deg:0,dirty:1,dirtyT:1},!r.bottom&&(r.bottom=this),this.prev=r.top,r.top&&(r.top.next=this),r.top=this,this.next=null},N=t.el;E.prototype=N,N.constructor=E,N.transform=function(e){if(null==e)return this._.transform;var i=this.paper._viewBoxShift,n=i?"s"+[i.scale,i.scale]+"-1-1t"+[i.dx,i.dy]:d,a;i&&(a=e=r(e).replace(/\.{3}|\u2026/g,this._.transform||d)),t._extractTransform(this,n+e);var s=this.matrix.clone(),o=this.skew,l=this.node,h,u=~r(this.attrs.fill).indexOf("-"),c=!r(this.attrs.fill).indexOf("url(");if(s.translate(1,1),c||u||"image"==this.type)if(o.matrix="1 0 0 1",o.offset="0 0",h=s.split(),u&&h.noRotation||!h.isSimple){l.style.filter=s.toFilter();var f=this.getBBox(),g=this.getBBox(1),x=f.x-g.x,v=f.y-g.y;l.coordorigin=x*-b+p+v*-b,C(this,1,1,x,v,0)}else l.style.filter=d,C(this,h.scalex,h.scaley,h.dx,h.dy,h.rotate);else l.style.filter=d,o.matrix=r(s),o.offset=s.offset();return null!==a&&(this._.transform=a,t._extractTransform(this,a)),this},N.rotate=function(t,e,n){if(this.removed)return this;if(null!=t){if(t=r(t).split(u),t.length-1&&(e=i(t[1]),n=i(t[2])),t=i(t[0]),null==n&&(e=n),null==e||null==n){var a=this.getBBox(1);e=a.x+a.width/2,n=a.y+a.height/2}return this._.dirtyT=1,this.transform(this._.transform.concat([["r",t,e,n]])),this}},N.translate=function(t,e){return this.removed?this:(t=r(t).split(u),t.length-1&&(e=i(t[1])),t=i(t[0])||0,e=+e||0,this._.bbox&&(this._.bbox.x+=t,this._.bbox.y+=e),this.transform(this._.transform.concat([["t",t,e]])),this)},N.scale=function(t,e,n,a){if(this.removed)return this;if(t=r(t).split(u),t.length-1&&(e=i(t[1]),n=i(t[2]),a=i(t[3]),isNaN(n)&&(n=null),isNaN(a)&&(a=null)),t=i(t[0]),null==e&&(e=t),null==a&&(n=a),null==n||null==a)var s=this.getBBox(1);return n=null==n?s.x+s.width/2:n,a=null==a?s.y+s.height/2:a,this.transform(this._.transform.concat([["s",t,e,n,a]])),this._.dirtyT=1,this},N.hide=function(){return!this.removed&&(this.node.style.display="none"),this},N.show=function(){return!this.removed&&(this.node.style.display=d),this},N.auxGetBBox=t.el.getBBox,N.getBBox=function(){var t=this.auxGetBBox();if(this.paper&&this.paper._viewBoxShift){var e={},r=1/this.paper._viewBoxShift.scale;return e.x=t.x-this.paper._viewBoxShift.dx,e.x*=r,e.y=t.y-this.paper._viewBoxShift.dy,e.y*=r,e.width=t.width*r,e.height=t.height*r,e.x2=e.x+e.width,e.y2=e.y+e.height,e}return t},N._getBBox=function(){return this.removed?{}:{x:this.X+(this.bbx||0)-this.W/2,y:this.Y-this.H,width:this.W,height:this.H}},N.remove=function(){if(!this.removed&&this.node.parentNode){this.paper.__set__&&this.paper.__set__.exclude(this),t.eve.unbind("raphael.*.*."+this.id),t._tear(this,this.paper),this.node.parentNode.removeChild(this.node),this.shape&&this.shape.parentNode.removeChild(this.shape);for(var e in this)this[e]="function"==typeof this[e]?t._removedFactory(e):null;this.removed=!0}},N.attr=function(r,i){if(this.removed)return this;if(null==r){var n={};for(var a in this.attrs)this.attrs[e](a)&&(n[a]=this.attrs[a]);return n.gradient&&"none"==n.fill&&(n.fill=n.gradient)&&delete n.gradient,n.transform=this._.transform,n}if(null==i&&t.is(r,"string")){if(r==h&&"none"==this.attrs.fill&&this.attrs.gradient)return this.attrs.gradient;for(var s=r.split(u),o={},l=0,f=s.length;l<f;l++)r=s[l],r in this.attrs?o[r]=this.attrs[r]:t.is(this.paper.customAttributes[r],"function")?o[r]=this.paper.customAttributes[r].def:o[r]=t._availableAttrs[r];return f-1?o:o[s[0]]}if(this.attrs&&null==i&&t.is(r,"array")){for(o={},l=0,f=r.length;l<f;l++)o[r[l]]=this.attr(r[l]);return o}var p;null!=i&&(p={},p[r]=i),null==i&&t.is(r,"object")&&(p=r);for(var d in p)c("raphael.attr."+d+"."+this.id,this,p[d]);if(p){for(d in this.paper.customAttributes)if(this.paper.customAttributes[e](d)&&p[e](d)&&t.is(this.paper.customAttributes[d],"function")){var g=this.paper.customAttributes[d].apply(this,[].concat(p[d]));this.attrs[d]=p[d];for(var x in g)g[e](x)&&(p[x]=g[x])}p.text&&"text"==this.type&&(this.textpath.string=p.text),T(this,p)}return this},N.toFront=function(){return!this.removed&&this.node.parentNode.appendChild(this.node),this.paper&&this.paper.top!=this&&t._tofront(this,this.paper),this},N.toBack=function(){return this.removed?this:(this.node.parentNode.firstChild!=this.node&&(this.node.parentNode.insertBefore(this.node,this.node.parentNode.firstChild),t._toback(this,this.paper)),this)},N.insertAfter=function(e){return this.removed?this:(e.constructor==t.st.constructor&&(e=e[e.length-1]),e.node.nextSibling?e.node.parentNode.insertBefore(this.node,e.node.nextSibling):e.node.parentNode.appendChild(this.node),t._insertafter(this,e,this.paper),this)},N.insertBefore=function(e){return this.removed?this:(e.constructor==t.st.constructor&&(e=e[0]),e.node.parentNode.insertBefore(this.node,e.node),t._insertbefore(this,e,this.paper),this)},N.blur=function(e){var r=this.node.runtimeStyle,i=r.filter;return i=i.replace(v,d),0!==+e?(this.attrs.blur=e,r.filter=i+p+f+".Blur(pixelradius="+(+e||1.5)+")",r.margin=t.format("-{0}px 0 0 -{0}px",a(+e||1.5))):(r.filter=i,r.margin=0,delete this.attrs.blur),this},t._engine.path=function(t,e){var r=M("shape");r.style.cssText=m,r.coordsize=b+p+b,r.coordorigin=e.coordorigin;var i=new E(r,e),n={fill:"none",stroke:"#000"};t&&(n.path=t),i.type="path",i.path=[],i.Path=d,T(i,n),e.canvas&&e.canvas.appendChild(r);var a=M("skew");return a.on=!0,r.appendChild(a),i.skew=a,i.transform(d),i},t._engine.rect=function(e,r,i,n,a,s){var o=t._rectPath(r,i,n,a,s),l=e.path(o),h=l.attrs;return l.X=h.x=r,l.Y=h.y=i,l.W=h.width=n,l.H=h.height=a,h.r=s,h.path=o,l.type="rect",l},t._engine.ellipse=function(t,e,r,i,n){var a=t.path(),s=a.attrs;return a.X=e-i,a.Y=r-n,a.W=2*i,a.H=2*n,a.type="ellipse",T(a,{cx:e,cy:r,rx:i,ry:n}),a},t._engine.circle=function(t,e,r,i){var n=t.path(),a=n.attrs;return n.X=e-i,n.Y=r-i,n.W=n.H=2*i,n.type="circle",T(n,{cx:e,cy:r,r:i}),n},t._engine.image=function(e,r,i,n,a,s){var o=t._rectPath(i,n,a,s),l=e.path(o).attr({stroke:"none"}),u=l.attrs,c=l.node,f=c.getElementsByTagName(h)[0];return u.src=r,l.X=u.x=i,l.Y=u.y=n,l.W=u.width=a,l.H=u.height=s,u.path=o,l.type="image",f.parentNode==c&&c.removeChild(f),f.rotate=!0,f.src=r,f.type="tile",l._.fillpos=[i,n],l._.fillsize=[a,s],c.appendChild(f),C(l,1,1,0,0,0),l},t._engine.text=function(e,i,n,s){var o=M("shape"),l=M("path"),h=M("textpath");i=i||0,n=n||0,s=s||"",l.v=t.format("m{0},{1}l{2},{1}",a(i*b),a(n*b),a(i*b)+1),l.textpathok=!0,h.string=r(s),h.on=!0,o.style.cssText=m,o.coordsize=b+p+b,o.coordorigin="0 0";var u=new E(o,e),c={fill:"#000",stroke:"none",font:t._availableAttrs.font,text:s};u.shape=o,u.path=l,u.textpath=h,u.type="text",u.attrs.text=r(s),u.attrs.x=i,u.attrs.y=n,u.attrs.w=1,u.attrs.h=1,T(u,c),o.appendChild(h),o.appendChild(l),e.canvas.appendChild(o);var f=M("skew");return f.on=!0,o.appendChild(f),u.skew=f,u.transform(d),u},t._engine.setSize=function(e,r){var i=this.canvas.style;return this.width=e,this.height=r,e==+e&&(e+="px"),r==+r&&(r+="px"),i.width=e,i.height=r,i.clip="rect(0 "+e+" "+r+" 0)",this._viewBox&&t._engine.setViewBox.apply(this,this._viewBox),this},t._engine.setViewBox=function(e,r,i,n,a){t.eve("raphael.setViewBox",this,this._viewBox,[e,r,i,n,a]);var s=this.getSize(),o=s.width,l=s.height,h,u;return a&&(h=l/n,u=o/i,i*h<o&&(e-=(o-i*h)/2/h),n*u<l&&(r-=(l-n*u)/2/u)),this._viewBox=[e,r,i,n,!!a],this._viewBoxShift={dx:-e,dy:-r,scale:s},this.forEach(function(t){t.transform("...")}),this};var M;t._engine.initWin=function(t){var e=t.document;e.styleSheets.length<31?e.createStyleSheet().addRule(".rvml","behavior:url(#default#VML)"):e.styleSheets[0].addRule(".rvml","behavior:url(#default#VML)");try{!e.namespaces.rvml&&e.namespaces.add("rvml","urn:schemas-microsoft-com:vml"),M=function(t){return e.createElement("<rvml:"+t+' class="rvml">')}}catch(r){M=function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="rvml">')}}},t._engine.initWin(t._g.win),t._engine.create=function(){var e=t._getContainer.apply(0,arguments),r=e.container,i=e.height,n,a=e.width,s=e.x,o=e.y;if(!r)throw new Error("VML container not found.");var l=new t._Paper,h=l.canvas=t._g.doc.createElement("div"),u=h.style;return s=s||0,o=o||0,a=a||512,i=i||342,l.width=a,l.height=i,a==+a&&(a+="px"),i==+i&&(i+="px"),l.coordsize=1e3*b+p+1e3*b,l.coordorigin="0 0",l.span=t._g.doc.createElement("span"),l.span.style.cssText="position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;",h.appendChild(l.span),u.cssText=t.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden",a,i),1==r?(t._g.doc.body.appendChild(h),u.left=s+"px",u.top=o+"px",u.position="absolute"):r.firstChild?r.insertBefore(h,r.firstChild):r.appendChild(h),l.renderfix=function(){},l},t.prototype.clear=function(){t.eve("raphael.clear",this),this.canvas.innerHTML=d,this.span=t._g.doc.createElement("span"),this.span.style.cssText="position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;",this.canvas.appendChild(this.span),this.bottom=this.top=null},t.prototype.remove=function(){t.eve("raphael.remove",this),this.canvas.parentNode.removeChild(this.canvas);for(var e in this)this[e]="function"==typeof this[e]?t._removedFactory(e):null;return!0};var L=t.st;for(var z in N)N[e](z)&&!L[e](z)&&(L[z]=function(t){return function(){var e=arguments;return this.forEach(function(r){r[t].apply(r,e)})}}(z))}}.apply(e,i),!(void 0!==n&&(t.exports=n))}])});

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _raphael = __webpack_require__(330);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Raphael bar chart renderer.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var ANIMATION_DURATION = 700;
	var EMPHASIS_OPACITY = 1;
	var DE_EMPHASIS_OPACITY = 0.3;
	var DEFAULT_LUMINANC = 0.2;
	var BAR_HOVER_SPARE_SIZE = 8;
	var SERIES_EXTRA_VISUAL_AREA_FOR_ZERO = 2;
	var SERIES_EXTRA_VISUAL_OPACITY_FOR_ZERO = 0.4;
	
	/**
	 * @classdesc RaphaelBarChart is graph renderer for bar, column chart.
	 * @class RaphaelBarChart
	 * @private
	 */
	
	var RaphaelBarChart = function () {
	    function RaphaelBarChart() {
	        _classCallCheck(this, RaphaelBarChart);
	    }
	
	    /**
	     * Render function of bar chart
	     * @param {object} paper paper object
	     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data
	     * @returns {Array.<object>} seriesSet
	     */
	    RaphaelBarChart.prototype.render = function render(paper, data) {
	        var groupBounds = data.groupBounds,
	            theme = data.theme,
	            seriesDataModel = data.seriesDataModel,
	            chartType = data.chartType,
	            options = data.options;
	
	
	        if (!groupBounds) {
	            return null;
	        }
	
	        this.paper = paper;
	
	        this.theme = theme;
	        this.seriesDataModel = seriesDataModel;
	        this.chartType = chartType;
	
	        this.paper.setStart();
	
	        this.options = options;
	        this.theme = theme;
	        this.groupBars = this._renderBars(groupBounds);
	        this.groupBorders = this._renderBarBorders(groupBounds);
	
	        this.overlay = this._renderOverlay();
	        this.groupBounds = groupBounds;
	
	        return this.paper.setFinish();
	    };
	
	    /**
	     * Render overlay.
	     * @returns {object} raphael object
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._renderOverlay = function _renderOverlay() {
	        var bound = {
	            width: 1,
	            height: 1,
	            left: 0,
	            top: 0
	        };
	        var attributes = {
	            'fill-opacity': 0
	        };
	        var overlay = this._renderBar(bound, '#fff', attributes);
	
	        overlay.node.setAttribute('class', 'auto-shape-rendering');
	
	        return overlay;
	    };
	
	    /**
	     * Render rect
	     * @param {{left: number, top: number, width: number, height: number}} bound bound
	     * @param {string} color series color
	     * @param {object} [attributes] - attributes
	     * @returns {object} bar rect
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._renderBar = function _renderBar(bound, color, attributes) {
	        if (bound.width < 0 || bound.height < 0) {
	            return null;
	        }
	
	        var rect = _raphaelRenderUtil2['default'].renderRect(this.paper, bound, Object.assign({
	            fill: color,
	            stroke: 'none'
	        }, attributes)).toFront();
	
	        rect.node.setAttribute('class', 'auto-shape-rendering');
	
	        return rect;
	    };
	
	    /**
	     * Render bars.
	     * @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} groupBounds bounds
	     * @returns {Array.<Array.<object>>} bars
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._renderBars = function _renderBars(groupBounds) {
	        var _this = this;
	
	        var colors = this.theme.colors;
	        var colorByPoint = this.options.colorByPoint;
	
	        var groupBars = groupBounds.map(function (bounds, groupIndex) {
	            return bounds.map(function (bound, index) {
	                if (!bound) {
	                    return null;
	                }
	
	                var item = _this.seriesDataModel.getSeriesItem(groupIndex, index);
	                var color = colorByPoint ? colors[groupIndex] : colors[index];
	                var rect = _this._renderBar(bound.start, color);
	
	                return {
	                    rect: rect,
	                    color: color,
	                    bound: bound.end,
	                    item: item,
	                    groupIndex: groupIndex,
	                    index: index,
	                    isRange: item.isRange
	                };
	            });
	        });
	
	        return groupBars;
	    };
	
	    /**
	     * Make rect points.
	     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
	     * @returns {{
	     *      leftTop: {left: number, top: number},
	     *      rightTop: {left: number, top: number},
	     *      rightBottom: {left: number, top: number},
	     *      leftBottom: {left: number, top: number}
	     * }} rect points
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._makeRectPoints = function _makeRectPoints(bound) {
	        return {
	            leftTop: {
	                left: Math.ceil(bound.left),
	                top: Math.ceil(bound.top)
	            },
	            rightTop: {
	                left: Math.ceil(bound.left + bound.width),
	                top: Math.ceil(bound.top)
	            },
	            rightBottom: {
	                left: Math.ceil(bound.left + bound.width),
	                top: Math.ceil(bound.top + bound.height)
	            },
	            leftBottom: {
	                left: Math.ceil(bound.left),
	                top: Math.ceil(bound.top + bound.height)
	            }
	        };
	    };
	
	    /**
	     * Make top line path.
	     * @param {object} points points
	     *      @param {{left: number, top: number}} points.leftTop left top
	     *      @param {{left: number, top: number}} points.rightTop right top
	     * @param {string} chartType chart type
	     * @param {Item} item item
	     * @returns {string} top line path
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._makeTopLinePath = function _makeTopLinePath(points, chartType, item) {
	        var value = item.value;
	
	        var linePath = null;
	
	        if (chartType === 'bar' || value >= 0 || item.isRange) {
	            var cloneLeftTop = _tuiCodeSnippet2['default'].extend({}, points.leftTop);
	            cloneLeftTop.left -= chartType === 'column' || value < 0 ? 1 : 0;
	            linePath = _raphaelRenderUtil2['default'].makeLinePath(cloneLeftTop, points.rightTop).join(' ');
	        }
	
	        return linePath;
	    };
	
	    /**
	     * Make right line path.
	     * @param {object} points points
	     *      @param {{left: number, top: number}} points.rightTop right top
	     *      @param {{left: number, top: number}} points.rightBottom right bottom
	     * @param {string} chartType chart type
	     * @param {Item} item item
	     * @returns {string} top line path
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._makeRightLinePath = function _makeRightLinePath(points, chartType, item) {
	        var linePath = null;
	
	        if (chartType === 'column' || item.value >= 0 || item.isRange) {
	            linePath = _raphaelRenderUtil2['default'].makeLinePath(points.rightTop, points.rightBottom).join(' ');
	        }
	
	        return linePath;
	    };
	
	    /**
	     * Make bottom line path.
	     * @param {object} points points
	     *      @param {{left: number, top: number}} points.lefBottom left bottom
	     *      @param {{left: number, top: number}} points.rightBottom right bottom
	     * @param {string} chartType chart type
	     * @param {Item} item item
	     * @returns {string} top line path
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._makeBottomLinePath = function _makeBottomLinePath(points, chartType, item) {
	        var linePath = null;
	
	        if (chartType === 'bar' || item.value < 0 || item.isRange) {
	            linePath = _raphaelRenderUtil2['default'].makeLinePath(points.leftBottom, points.rightBottom).join(' ');
	        }
	
	        return linePath;
	    };
	
	    /**
	     * Make left line path.
	     * @param {object} points points
	     *      @param {{left: number, top: number}} points.lefTop left top
	     *      @param {{left: number, top: number}} points.leftBottom left bottom
	     * @param {string} chartType chart type
	     * @param {Item} item item
	     * @returns {string} top line path
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._makeLeftLinePath = function _makeLeftLinePath(points, chartType, item) {
	        var linePath = null;
	
	        if (chartType === 'column' || item.value < 0 || item.isRange) {
	            linePath = _raphaelRenderUtil2['default'].makeLinePath(points.leftTop, points.leftBottom).join(' ');
	        }
	
	        return linePath;
	    };
	
	    /**
	     * Make border lines paths.
	     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
	     * @param {string} chartType chart type
	     * @param {Item} item item
	     * @returns {{top: string, right: string, bottom: string, left: string}} paths
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._makeBorderLinesPaths = function _makeBorderLinesPaths(bound, chartType, item) {
	        var points = this._makeRectPoints(bound);
	        var paths = {
	            top: this._makeTopLinePath(points, chartType, item),
	            right: this._makeRightLinePath(points, chartType, item),
	            bottom: this._makeBottomLinePath(points, chartType, item),
	            left: this._makeLeftLinePath(points, chartType, item)
	        };
	
	        return _tuiCodeSnippet2['default'].filter(paths, function (path) {
	            return path;
	        });
	    };
	
	    /**
	     * Render border lines;
	     * @param {{left: number, top:number, width: number, height: number}} bound bar bound
	     * @param {string} borderColor border color
	     * @param {string} chartType chart type
	     * @param {Item} item item
	     * @returns {object} raphael object
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._renderBorderLines = function _renderBorderLines(bound, borderColor, chartType, item) {
	        var borderLinePaths = this._makeBorderLinesPaths(bound, chartType, item);
	        var lines = {};
	
	        Object.entries(borderLinePaths).forEach(function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2),
	                name = _ref2[0],
	                path = _ref2[1];
	
	            lines[name] = _raphaelRenderUtil2['default'].renderLine(self.paper, path, borderColor, 1);
	        });
	
	        return lines;
	    };
	
	    /**
	     * Render bar borders.
	     * @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} groupBounds bounds
	     * @returns {Array.<Array.<object>>} borders
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._renderBarBorders = function _renderBarBorders(groupBounds) {
	        var _this2 = this;
	
	        var borderColor = this.theme.borderColor;
	
	
	        if (!borderColor) {
	            return null;
	        }
	
	        var groupBorders = _tuiCodeSnippet2['default'].map(groupBounds, function (bounds, groupIndex) {
	            return _tuiCodeSnippet2['default'].map(bounds, function (bound, index) {
	                if (!bound) {
	                    return null;
	                }
	
	                var seriesItem = _this2.seriesDataModel.getSeriesItem(groupIndex, index);
	
	                return _this2._renderBorderLines(bound.start, borderColor, self.chartType, seriesItem);
	            });
	        });
	
	        return groupBorders;
	    };
	
	    /**
	     * Animate rect.
	     * @param {object} rect raphael object
	     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._animateRect = function _animateRect(rect, bound) {
	        rect.animate({
	            x: bound.width ? bound.left : bound.left - SERIES_EXTRA_VISUAL_AREA_FOR_ZERO / 2,
	            y: bound.height ? bound.top : bound.top - SERIES_EXTRA_VISUAL_AREA_FOR_ZERO / 2,
	            width: bound.width ? bound.width : SERIES_EXTRA_VISUAL_AREA_FOR_ZERO,
	            height: bound.height ? bound.height : SERIES_EXTRA_VISUAL_AREA_FOR_ZERO,
	            opacity: bound.height && bound.width ? 1 : SERIES_EXTRA_VISUAL_OPACITY_FOR_ZERO
	        }, ANIMATION_DURATION, '>');
	    };
	
	    /**
	     * Animate borders.
	     * @param {Array.<object>} lines raphael objects
	     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
	     * @param {string} chartType chart type
	     * @param {Item} item item
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._animateBorders = function _animateBorders(lines, bound, chartType, item) {
	        var paths = this._makeBorderLinesPaths(bound, chartType, item);
	
	        _tuiCodeSnippet2['default'].forEach(lines, function (line, name) {
	            line.animate({
	                path: paths[name]
	            }, ANIMATION_DURATION, '>');
	        });
	    };
	
	    /**
	     * Animate.
	     * @param {function} onFinish finish callback function
	     */
	
	
	    RaphaelBarChart.prototype.animate = function animate(onFinish) {
	        var _this3 = this;
	
	        var groupBorders = this.groupBorders || [];
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupBars, function (bar, groupIndex, index) {
	            var lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
	            if (!bar) {
	                return;
	            }
	            _this3._animateRect(bar.rect, bar.bound);
	            if (lines) {
	                _this3._animateBorders(lines, bar.bound, _this3.chartType, bar.item);
	            }
	        });
	
	        if (onFinish) {
	            this.callbackTimeout = setTimeout(function () {
	                onFinish();
	                delete _this3.callbackTimeout;
	            }, ANIMATION_DURATION);
	        }
	    };
	
	    /**
	     * Show animation.
	     * @param {{groupIndex: number, index:number}} data show info
	     */
	
	
	    RaphaelBarChart.prototype.showAnimation = function showAnimation(data) {
	        var bar = this.groupBars[data.groupIndex][data.index];
	        var bound = bar.bound;
	
	
	        this.overlay.attr({
	            width: bound.width + BAR_HOVER_SPARE_SIZE,
	            height: bound.height + BAR_HOVER_SPARE_SIZE,
	            stroke: '#fff',
	            'stroke-width': '1',
	            x: bound.left - 4,
	            y: bound.top - 4,
	            'fill-opacity': 1
	        });
	
	        this.resortBarIndex(data.groupIndex);
	        this.overlay.toFront();
	        bar.rect.toFront();
	
	        if (this.labelSet) {
	            this.labelSet.toFront();
	        }
	        this.overlay.node.setAttribute('filter', 'url(#shadow)');
	    };
	
	    /**
	     * Hide animation.
	     * @param {{groupIndex: number, index:number}} data show info
	     */
	
	
	    RaphaelBarChart.prototype.hideAnimation = function hideAnimation(data) {
	        this.resortBarIndex(data.groupIndex);
	        this.overlay.attr({
	            width: 1,
	            height: 1,
	            x: 0,
	            y: 0,
	            'fill-opacity': 0
	        });
	
	        if (this.labelSet) {
	            this.labelSet.toFront();
	        }
	    };
	
	    /**
	     * reindexing bar in group
	     * @param {number} groupIndex - group index
	     */
	
	
	    RaphaelBarChart.prototype.resortBarIndex = function resortBarIndex(groupIndex) {
	        this.groupBars[groupIndex].forEach(function (barItem) {
	            barItem.rect.toFront();
	        });
	    };
	
	    /**
	     * Update rect bound
	     * @param {object} rect raphael object
	     * @param {{left: number, top: number, width: number, height: number}} bound bound
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._updateRectBound = function _updateRectBound(rect, bound) {
	        rect.attr({
	            x: bound.left,
	            y: bound.top,
	            width: bound.width,
	            height: bound.height
	        });
	    };
	
	    /**
	     * Resize graph of bar type chart.
	     * @param {object} params parameters
	     *      @param {{width: number, height:number}} params.dimension dimension
	     *      @param {Array.<Array.<{
	     *                  left:number, top:number, width: number, height: number
	     *              }>>} params.groupBounds group bounds
	     */
	
	
	    RaphaelBarChart.prototype.resize = function resize(params) {
	        var _this4 = this;
	
	        var groupBorders = this.groupBorders || [];
	        var dimension = params.dimension,
	            groupBounds = params.groupBounds;
	
	
	        this.groupBounds = groupBounds;
	        this.paper.setSize(dimension.width, dimension.height);
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupBars, function (bar, groupIndex, index) {
	            if (!bar) {
	                return;
	            }
	
	            var lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
	            var bound = groupBounds[groupIndex][index].end;
	
	            bar.bound = bound;
	            _raphaelRenderUtil2['default'].updateRectBound(bar.rect, bound);
	
	            if (lines) {
	                _this4._updateBordersPath(lines, bound, _this4.chartType, bar.item);
	            }
	        });
	    };
	
	    /**
	     * Change borders color.
	     * @param {Array.<object>} lines raphael objects
	     * @param {borderColor} borderColor border color
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._changeBordersColor = function _changeBordersColor(lines, borderColor) {
	        _tuiCodeSnippet2['default'].forEach(lines, function (line) {
	            line.attr({ stroke: borderColor });
	        });
	    };
	
	    /**
	     * Change bar color.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     * @param {string} color fill color
	     * @param {?string} borderColor stroke color
	     * @private
	     */
	
	
	    RaphaelBarChart.prototype._changeBarColor = function _changeBarColor(indexes, color, borderColor) {
	        var bar = this.groupBars[indexes.groupIndex][indexes.index];
	
	        bar.rect.attr({
	            fill: color
	        });
	
	        if (borderColor) {
	            var lines = this.groupBorders[indexes.groupIndex][indexes.index];
	            this._changeBordersColor(lines, borderColor);
	        }
	    };
	
	    /**
	     * Select series.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     */
	
	
	    RaphaelBarChart.prototype.selectSeries = function selectSeries(indexes) {
	        var bar = this.groupBars[indexes.groupIndex][indexes.index];
	        var objColor = _raphael2['default'].color(bar.color);
	        var selectionColorTheme = this.theme.selectionColor;
	        var color = selectionColorTheme || _raphaelRenderUtil2['default'].makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);
	        var borderColor = this.theme.borderColor;
	
	
	        if (borderColor) {
	            var objBorderColor = _raphael2['default'].color(borderColor);
	            borderColor = _raphaelRenderUtil2['default'].makeChangedLuminanceColor(objBorderColor.hex, DEFAULT_LUMINANC);
	        }
	
	        this._changeBarColor(indexes, color, borderColor);
	    };
	
	    /**
	     * Unselect series.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     */
	
	
	    RaphaelBarChart.prototype.unselectSeries = function unselectSeries(indexes) {
	        var bar = this.groupBars[indexes.groupIndex][indexes.index];
	        var borderColor = this.theme.borderColor;
	
	        this._changeBarColor(indexes, bar.color, borderColor);
	    };
	
	    /**
	     * Select legend.
	     * @param {?number} legendIndex legend index
	     */
	
	
	    RaphaelBarChart.prototype.selectLegend = function selectLegend(legendIndex) {
	        var groupBorders = this.groupBorders || [];
	        var noneSelected = _tuiCodeSnippet2['default'].isNull(legendIndex);
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupBars, function (bar, groupIndex, index) {
	            if (!bar) {
	                return;
	            }
	
	            var lines = groupBorders[groupIndex] && groupBorders[groupIndex][index];
	            var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	
	            bar.rect.attr({ 'fill-opacity': opacity });
	            if (lines) {
	                _tuiCodeSnippet2['default'].forEach(lines, function (line) {
	                    line.attr({ 'stroke-opacity': opacity });
	                });
	            }
	        });
	    };
	
	    RaphaelBarChart.prototype.renderSeriesLabel = function renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme, isStacked) {
	        var textAnchor = isStacked || this.chartType === 'column' ? 'middle' : 'start';
	        var attributes = {
	            'font-size': labelTheme.fontSize,
	            'font-family': labelTheme.fontFamily,
	            'font-weight': labelTheme.fontWeight,
	            fill: labelTheme.color,
	            opacity: 0,
	            'text-anchor': textAnchor
	        };
	        var labelSet = this.labelSet = paper.set();
	
	        groupLabels.forEach(function (categoryLabel, categoryIndex) {
	            categoryLabel.forEach(function (label, seriesIndex) {
	                var position = groupPositions[categoryIndex][seriesIndex];
	                var endLabel = _raphaelRenderUtil2['default'].renderText(paper, position.end, label.end, attributes);
	                var enaLabelNodeStyle = endLabel.node.style;
	
	                enaLabelNodeStyle.userSelect = 'none';
	                enaLabelNodeStyle.cursor = 'default';
	
	                labelSet.push(endLabel);
	
	                if (position.start) {
	                    var startLabel = _raphaelRenderUtil2['default'].renderText(paper, position.start, label.start, attributes);
	                    startLabel.node.style.userSelect = 'none';
	                    startLabel.node.style.cursor = 'default';
	
	                    labelSet.push(startLabel);
	                }
	            });
	        });
	
	        return labelSet;
	    };
	
	    return RaphaelBarChart;
	}();
	
	exports['default'] = RaphaelBarChart;

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _raphael = __webpack_require__(330);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var LINE_HEIGHT_FOR_CALCULATE = 1.11; /**
	                                       * @fileoverview Util for raphael rendering.
	                                       * @author NHN.
	                                       *         FE Development Lab <dl_javascript@nhn.com>
	                                       */
	
	var storeForGetTextDimension = {
	    cacheFontInfo: '',
	    elementForTextSize: null,
	    canvasElement: getCanvasForTextDimension()
	};
	
	/**
	 * Util for raphael rendering.
	 * @module raphaelRenderUtil
	 * @private
	 */
	exports['default'] = {
	
	    /**
	     * Make line path.
	     * @memberOf module:raphaelRenderUtil
	     * @param {{top: number, left: number}} fromPos from position
	     * @param {{top: number, left: number}} toPos to position
	     * @param {number} width width
	     * @returns {string} path
	     */
	    makeLinePath: function makeLinePath(fromPos, toPos) {
	        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	
	        var fromPoint = [fromPos.left, fromPos.top];
	        var toPoint = [toPos.left, toPos.top];
	        var additionalPoint = width % 2 / 2;
	
	        fromPoint.forEach(function (from, index) {
	            if (from === toPoint[index]) {
	                fromPoint[index] = toPoint[index] = Math.round(from) - additionalPoint;
	            }
	        });
	
	        return ['M'].concat(fromPoint, ['L'], toPoint);
	    },
	
	
	    /**
	     * Render line.
	     * @memberOf module:raphaelRenderUtil
	     * @param {object} paper raphael paper
	     * @param {string} path line path
	     * @param {string} color line color
	     * @param {number} strokeWidth stroke width
	     * @returns {object} raphael line
	     */
	    renderLine: function renderLine(paper, path, color, strokeWidth) {
	        var line = paper.path([path]);
	        var strokeStyle = {
	            stroke: color,
	            'stroke-width': _tuiCodeSnippet2['default'].isUndefined(strokeWidth) ? 2 : strokeWidth,
	            'stroke-linecap': 'butt'
	        };
	        if (color === 'transparent') {
	            strokeStyle.stroke = '#fff';
	            strokeStyle['stroke-opacity'] = 0;
	        }
	
	        line.attr(strokeStyle).node.setAttribute('class', 'auto-shape-rendering');
	
	        return line;
	    },
	
	
	    /**
	     * text ellipsis for fixed width
	     * @param {string} text - target text
	     * @param {number} fixedWidth - width for elipsis
	     * @param {object} theme - lable theme
	     * @returns {string}
	     */
	    getEllipsisText: function getEllipsisText(text, fixedWidth, theme) {
	        var textArray = text.split('');
	        var textLength = textArray.length;
	        var dotWidth = this.getRenderedTextSize('.', theme.fontSize, theme.fontFamily).width;
	        var newString = '';
	        var textWidth = dotWidth * 2;
	
	        for (var i = 0; i < textLength; i += 1) {
	            textWidth += this.getRenderedTextSize(textArray[i], theme.fontSize, theme.fontFamily).width;
	            if (textWidth >= fixedWidth) {
	                newString += '..';
	                break;
	            }
	            newString += textArray[i];
	        }
	
	        return newString;
	    },
	
	
	    /**
	     * Render text
	     * @param {object} paper - Raphael paper object
	     * @param {{left: number, top: number}} pos - text object position
	     * @param {string} text - text content
	     * @param {object} [attributes] - text object's attributes
	     * @returns {object}
	     */
	    renderText: function renderText(paper, pos, text, attributes) {
	        var textObj = paper.text(pos.left, pos.top, _tuiCodeSnippet2['default'].decodeHTMLEntity(String(text)));
	
	        if (attributes) {
	            if (attributes['dominant-baseline']) {
	                textObj.node.setAttribute('dominant-baseline', attributes['dominant-baseline']);
	            } else {
	                textObj.node.setAttribute('dominant-baseline', 'central');
	            }
	
	            textObj.attr(attributes);
	        }
	
	        return textObj;
	    },
	
	
	    /**
	     * Render area graph.
	     * @param {object} paper raphael paper
	     * @param {string} path path
	     * @param {object} fillStyle fill style
	     *      @param {string} fillStyle.fill fill color
	     *      @param {?number} fillStyle.opacity fill opacity
	     *      @param {string} fillStyle.stroke stroke color
	     *      @param {?number} fillStyle.stroke-opacity stroke opacity
	     * @returns {Array.<object>} raphael object
	     */
	    renderArea: function renderArea(paper, path, fillStyle) {
	        var area = paper.path(path);
	
	        fillStyle = Object.assign({
	            'stroke-opacity': 0
	        }, fillStyle);
	        area.attr(fillStyle);
	
	        return area;
	    },
	
	
	    /**
	     * Render circle.
	     * @param {object} paper - raphael object
	     * @param {{left: number, top: number}} position - position
	     * @param {number} radius - radius
	     * @param {object} attributes - attributes
	     * @returns {object}
	     */
	    renderCircle: function renderCircle(paper, position, radius, attributes) {
	        var circle = paper.circle(position.left, position.top, radius);
	
	        if (attributes) {
	            circle.attr(attributes);
	        }
	
	        return circle;
	    },
	
	
	    /**
	     * Render rect.
	     * @param {object} paper - raphael object
	     * @param {{left: number, top: number, width: number, height, number}} bound - bound
	     * @param {object} attributes - attributes
	     * @returns {*}
	     */
	    renderRect: function renderRect(paper, bound, attributes) {
	        var rect = paper.rect(bound.left, bound.top, bound.width, bound.height);
	
	        if (attributes) {
	            rect.attr(attributes);
	        }
	
	        return rect;
	    },
	
	
	    /**
	     * Update rect bound
	     * @param {object} rect raphael object
	     * @param {{left: number, top: number, width: number, height: number}} bound bound
	     */
	    updateRectBound: function updateRectBound(rect, bound) {
	        rect.attr({
	            x: bound.left,
	            y: bound.top,
	            width: bound.width,
	            height: bound.height
	        });
	    },
	
	
	    /**
	     * Render items of line type chart.
	     * @param {Array.<Array.<object>>} groupItems group items
	     * @param {function} funcRenderItem function
	     */
	    forEach2dArray: function forEach2dArray(groupItems, funcRenderItem) {
	        if (groupItems) {
	            groupItems.forEach(function (items, groupIndex) {
	                items.forEach(function (item, index) {
	                    funcRenderItem(item, groupIndex, index);
	                });
	            });
	        }
	    },
	
	
	    /**
	     * Make changed luminance color.
	     * @param {string} hex hax color
	     * @param {number} lum luminance
	     * @returns {string} changed color
	     */
	    makeChangedLuminanceColor: function makeChangedLuminanceColor(hex, lum) {
	        hex = hex.replace('#', '');
	        lum = lum || 0;
	
	        var changedHex = _tuiCodeSnippet2['default'].range(3).map(function (index) {
	            var hd = parseInt(hex.substr(index * 2, 2), 16);
	            var newHd = hd + hd * lum;
	
	            newHd = Math.round(Math.min(Math.max(0, newHd), 255)).toString(16);
	
	            return _renderUtil2['default'].formatToZeroFill(newHd, 2);
	        }).join('');
	
	        return '#' + changedHex;
	    },
	
	
	    /**
	     * Get rendered text element size
	     * @param {string} text text content
	     * @param {number} fontSize font-size attribute
	     * @param {string} fontFamily font-family attribute
	     * @returns {{
	     *     width: number,
	     *     height: number
	     * }}
	     */
	    getRenderedTextSize: function getRenderedTextSize(text) {
	        var fontSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 11;
	        var fontFamily = arguments[2];
	        var canvasElement = storeForGetTextDimension.canvasElement;
	
	
	        if (canvasElement) {
	            return this._getTextDimensionWithCanvas(text, fontSize, fontFamily);
	        }
	
	        return this._getTextDimensionUseHtmlElement(text, fontSize, fontFamily);
	    },
	
	
	    /**
	     * Get rendered text element size (Use Canvas)
	     * @param {string} text text content
	     * @param {number} fontSize font-size attribute
	     * @param {string} fontFamily font-family attribute
	     * @returns {{
	     *     width: number,
	     *     height: number
	     * }}
	     * @private
	     */
	    _getTextDimensionWithCanvas: function _getTextDimensionWithCanvas(text, fontSize, fontFamily) {
	        var canvasElement = storeForGetTextDimension.canvasElement,
	            cacheFontInfo = storeForGetTextDimension.cacheFontInfo;
	
	        var ctx = canvasElement.getContext('2d');
	        var fontInfo = fontSize + 'px ' + fontFamily;
	
	        if (cacheFontInfo !== fontInfo) {
	            storeForGetTextDimension.cacheFontInfo = fontInfo;
	            ctx.font = fontInfo;
	        }
	
	        return {
	            width: ctx.measureText(text).width,
	            height: fontSize * LINE_HEIGHT_FOR_CALCULATE
	        };
	    },
	
	
	    /**
	     * Get rendered text element size (Use HTMLElement)
	     * @param {string} text text content
	     * @param {number} fontSize font-size attribute
	     * @param {string} fontFamily font-family attribute
	     * @returns {{
	     *     width: number,
	     *     height: number
	     * }}
	     * @private
	     */
	    _getTextDimensionUseHtmlElement: function _getTextDimensionUseHtmlElement(text, fontSize, fontFamily) {
	        var cacheFontInfo = storeForGetTextDimension.cacheFontInfo;
	        var elementForTextSize = storeForGetTextDimension.elementForTextSize;
	
	        if (!elementForTextSize) {
	            elementForTextSize = document.createElement('div');
	            var elementStyle = elementForTextSize.style;
	            this._setBasicHtmlElementStyleForGetTextSize(elementStyle);
	
	            document.body.appendChild(elementForTextSize);
	            storeForGetTextDimension.elementForTextSize = elementForTextSize;
	        }
	
	        var fontInfo = fontSize + 'px ' + fontFamily;
	
	        if (cacheFontInfo !== fontInfo) {
	            var _elementStyle = elementForTextSize.style;
	
	            _elementStyle.fontFamily = fontFamily;
	            _elementStyle.fontSize = fontSize + 'px';
	
	            storeForGetTextDimension.cacheFontInfo = fontInfo;
	        }
	
	        elementForTextSize.innerHTML = text;
	
	        return {
	            width: elementForTextSize.clientWidth,
	            height: elementForTextSize.clientHeight
	        };
	    },
	
	
	    /**
	     * Set basic style for get text dimension element
	     * @param {object} elementStyle style object for the element to get the text dimension
	     */
	    _setBasicHtmlElementStyleForGetTextSize: function _setBasicHtmlElementStyleForGetTextSize(elementStyle) {
	        elementStyle.visibility = 'hidden';
	        elementStyle.position = 'absolute';
	        elementStyle.margin = 0;
	        elementStyle.padding = 0;
	        elementStyle.lineHeight = LINE_HEIGHT_FOR_CALCULATE;
	        elementStyle.whiteSpace = 'nowrap';
	    },
	
	
	    /**
	     * Animate given element's opacity
	     * @param {object} element element
	     * @param {number} startOpacity endOpacity default is '0'
	     * @param {number} endOpacity endOpacity default is '1'
	     * @param {number} duration endOpacity default is '600'
	     */
	    animateOpacity: function animateOpacity(element, startOpacity, endOpacity, duration) {
	        var animationDuration = isNumber(duration) ? duration : 600;
	        var animationStartOpacity = isNumber(startOpacity) ? startOpacity : 0;
	        var animationEndOpacity = isNumber(endOpacity) ? endOpacity : 1;
	        var animation = _raphael2['default'].animation({
	            opacity: animationEndOpacity
	        }, animationDuration);
	
	        element.attr({
	            opacity: animationStartOpacity
	        });
	
	        element.animate(animation);
	    }
	};
	
	/**
	 * Return boolean value for given parameter is number or not
	 * @param {*} numberSuspect number suspect
	 * @returns {boolean}
	 */
	
	function isNumber(numberSuspect) {
	    return _tuiCodeSnippet2['default'].isExisty(numberSuspect) && typeof numberSuspect === 'number';
	}
	
	/**
	 * check supports canvas text
	 * @returns {?HTMLElement}
	 */
	function getCanvasForTextDimension() {
	    var isSupportCanvasContext = !!document.createElement('canvas').getContext;
	
	    if (!isSupportCanvasContext) {
	        return null;
	    }
	
	    var canvas = document.createElement('canvas');
	    var context = canvas.getContext('2d');
	
	    if (typeof context.fillText === 'function') {
	        return canvas;
	    }
	
	    return null;
	}

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

	/*!
	 * tui-code-snippet.js
	 * @version 1.5.0
	 * @author NHNEnt FE Development Lab <dl_javascript@nhnent.com>
	 * @license MIT
	 */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["util"] = factory();
		else
			root["tui"] = root["tui"] || {}, root["tui"]["util"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "dist";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {
	
		'use strict';
	
		/**
		 * @fileoverview
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 * @namespace tui.util
		 * @example
		 * // node, commonjs
		 * var util = require('tui-code-snippet');
		 * @example
		 * // distribution file, script
		 * <script src='path-to/tui-code-snippt.js'></script>
		 * <script>
		 * var util = tui.util;
		 * <script>
		 */
		var util = {};
		var object = __webpack_require__(1);
		var extend = object.extend;
	
		extend(util, object);
		extend(util, __webpack_require__(3));
		extend(util, __webpack_require__(2));
		extend(util, __webpack_require__(4));
		extend(util, __webpack_require__(5));
		extend(util, __webpack_require__(6));
		extend(util, __webpack_require__(7));
		extend(util, __webpack_require__(8));
		extend(util, __webpack_require__(9));
	
		util.browser = __webpack_require__(10);
		util.popup = __webpack_require__(11);
		util.formatDate = __webpack_require__(12);
		util.defineClass = __webpack_require__(13);
		util.defineModule = __webpack_require__(14);
		util.defineNamespace = __webpack_require__(15);
		util.CustomEvents = __webpack_require__(16);
		util.Enum = __webpack_require__(17);
		util.ExMap = __webpack_require__(18);
		util.HashMap = __webpack_require__(20);
		util.Map = __webpack_require__(19);
	
		module.exports = util;
	
	
	/***/ }),
	/* 1 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview This module has some functions for handling a plain object, json.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var type = __webpack_require__(2);
		var array = __webpack_require__(3);
	
		/**
		 * The last id of stamp
		 * @type {number}
		 * @private
		 */
		var lastId = 0;
	
		/**
		 * Extend the target object from other objects.
		 * @param {object} target - Object that will be extended
		 * @param {...object} objects - Objects as sources
		 * @returns {object} Extended object
		 * @memberof tui.util
		 */
		function extend(target, objects) { // eslint-disable-line no-unused-vars
		    var hasOwnProp = Object.prototype.hasOwnProperty;
		    var source, prop, i, len;
	
		    for (i = 1, len = arguments.length; i < len; i += 1) {
		        source = arguments[i];
		        for (prop in source) {
		            if (hasOwnProp.call(source, prop)) {
		                target[prop] = source[prop];
		            }
		        }
		    }
	
		    return target;
		}
	
		/**
		 * Assign a unique id to an object
		 * @param {object} obj - Object that will be assigned id.
		 * @returns {number} Stamped id
		 * @memberof tui.util
		 */
		function stamp(obj) {
		    if (!obj.__fe_id) {
		        lastId += 1;
		        obj.__fe_id = lastId; // eslint-disable-line camelcase
		    }
	
		    return obj.__fe_id;
		}
	
		/**
		 * Verify whether an object has a stamped id or not.
		 * @param {object} obj - adjusted object
		 * @returns {boolean}
		 * @memberof tui.util
		 */
		function hasStamp(obj) {
		    return type.isExisty(pick(obj, '__fe_id'));
		}
	
		/**
		 * Reset the last id of stamp
		 * @private
		 */
		function resetLastId() {
		    lastId = 0;
		}
	
		/**
		 * Return a key-list(array) of a given object
		 * @param {object} obj - Object from which a key-list will be extracted
		 * @returns {Array} A key-list(array)
		 * @memberof tui.util
		 */
		function keys(obj) {
		    var keyArray = [];
		    var key;
	
		    for (key in obj) {
		        if (obj.hasOwnProperty(key)) {
		            keyArray.push(key);
		        }
		    }
	
		    return keyArray;
		}
	
		/**
		 * Return the equality for multiple objects(jsonObjects).<br>
		 *  See {@link http://stackoverflow.com/questions/1068834/object-comparison-in-javascript}
		 * @param {...object} object - Multiple objects for comparing.
		 * @returns {boolean} Equality
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var jsonObj1 = {name:'milk', price: 1000};
		 * var jsonObj2 = {name:'milk', price: 1000};
		 * var jsonObj3 = {name:'milk', price: 1000};
		 * util.compareJSON(jsonObj1, jsonObj2, jsonObj3);   // true
		 *
		 * var jsonObj4 = {name:'milk', price: 1000};
		 * var jsonObj5 = {name:'beer', price: 3000};
		 * util.compareJSON(jsonObj4, jsonObj5); // false
		 */
		function compareJSON(object) {
		    var argsLen = arguments.length;
		    var i = 1;
	
		    if (argsLen < 1) {
		        return true;
		    }
	
		    for (; i < argsLen; i += 1) {
		        if (!isSameObject(object, arguments[i])) {
		            return false;
		        }
		    }
	
		    return true;
		}
	
		/**
		 * @param {*} x - object to compare
		 * @param {*} y - object to compare
		 * @returns {boolean} - whether object x and y is same or not
		 * @private
		 */
		function isSameObject(x, y) { // eslint-disable-line complexity
		    var leftChain = [];
		    var rightChain = [];
		    var p;
	
		    // remember that NaN === NaN returns false
		    // and isNaN(undefined) returns true
		    if (isNaN(x) &&
		        isNaN(y) &&
		        type.isNumber(x) &&
		        type.isNumber(y)) {
		        return true;
		    }
	
		    // Compare primitives and functions.
		    // Check if both arguments link to the same object.
		    // Especially useful on step when comparing prototypes
		    if (x === y) {
		        return true;
		    }
	
		    // Works in case when functions are created in constructor.
		    // Comparing dates is a common scenario. Another built-ins?
		    // We can even handle functions passed across iframes
		    if ((type.isFunction(x) && type.isFunction(y)) ||
		        (x instanceof Date && y instanceof Date) ||
		        (x instanceof RegExp && y instanceof RegExp) ||
		        (x instanceof String && y instanceof String) ||
		        (x instanceof Number && y instanceof Number)) {
		        return x.toString() === y.toString();
		    }
	
		    // At last checking prototypes as good a we can
		    if (!(x instanceof Object && y instanceof Object)) {
		        return false;
		    }
	
		    if (x.isPrototypeOf(y) ||
		        y.isPrototypeOf(x) ||
		        x.constructor !== y.constructor ||
		        x.prototype !== y.prototype) {
		        return false;
		    }
	
		    // check for infinitive linking loops
		    if (array.inArray(x, leftChain) > -1 ||
		        array.inArray(y, rightChain) > -1) {
		        return false;
		    }
	
		    // Quick checking of one object beeing a subset of another.
		    for (p in y) {
		        if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
		            return false;
		        } else if (typeof y[p] !== typeof x[p]) {
		            return false;
		        }
		    }
	
		    // This for loop executes comparing with hasOwnProperty() and typeof for each property in 'x' object,
		    // and verifying equality for x[property] and y[property].
		    for (p in x) {
		        if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
		            return false;
		        } else if (typeof y[p] !== typeof x[p]) {
		            return false;
		        }
	
		        if (typeof (x[p]) === 'object' || typeof (x[p]) === 'function') {
		            leftChain.push(x);
		            rightChain.push(y);
	
		            if (!isSameObject(x[p], y[p])) {
		                return false;
		            }
	
		            leftChain.pop();
		            rightChain.pop();
		        } else if (x[p] !== y[p]) {
		            return false;
		        }
		    }
	
		    return true;
		}
		/* eslint-enable complexity */
	
		/**
		 * Retrieve a nested item from the given object/array
		 * @param {object|Array} obj - Object for retrieving
		 * @param {...string|number} paths - Paths of property
		 * @returns {*} Value
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var obj = {
		 *     'key1': 1,
		 *     'nested' : {
		 *         'key1': 11,
		 *         'nested': {
		 *             'key1': 21
		 *         }
		 *     }
		 * };
		 * util.pick(obj, 'nested', 'nested', 'key1'); // 21
		 * util.pick(obj, 'nested', 'nested', 'key2'); // undefined
		 *
		 * var arr = ['a', 'b', 'c'];
		 * util.pick(arr, 1); // 'b'
		 */
		function pick(obj, paths) { // eslint-disable-line no-unused-vars
		    var args = arguments;
		    var target = args[0];
		    var i = 1;
		    var length = args.length;
	
		    for (; i < length; i += 1) {
		        if (type.isUndefined(target) ||
		            type.isNull(target)) {
		            return;
		        }
	
		        target = target[args[i]];
		    }
	
		    return target; // eslint-disable-line consistent-return
		}
	
		module.exports = {
		    extend: extend,
		    stamp: stamp,
		    hasStamp: hasStamp,
		    resetLastId: resetLastId,
		    keys: Object.prototype.keys || keys,
		    compareJSON: compareJSON,
		    pick: pick
		};
	
	
	/***/ }),
	/* 2 */
	/***/ (function(module, exports) {
	
		/**
		 * @fileoverview This module provides some functions to check the type of variable
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var toString = Object.prototype.toString;
	
		/**
		 * Check whether the given variable is existing or not.<br>
		 *  If the given variable is not null and not undefined, returns true.
		 * @param {*} param - Target for checking
		 * @returns {boolean} Is existy?
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * util.isExisty(''); //true
		 * util.isExisty(0); //true
		 * util.isExisty([]); //true
		 * util.isExisty({}); //true
		 * util.isExisty(null); //false
		 * util.isExisty(undefined); //false
		*/
		function isExisty(param) {
		    return !isUndefined(param) && !isNull(param);
		}
	
		/**
		 * Check whether the given variable is undefined or not.<br>
		 *  If the given variable is undefined, returns true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is undefined?
		 * @memberof tui.util
		 */
		function isUndefined(obj) {
		    return obj === undefined; // eslint-disable-line no-undefined
		}
	
		/**
		 * Check whether the given variable is null or not.<br>
		 *  If the given variable(arguments[0]) is null, returns true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is null?
		 * @memberof tui.util
		 */
		function isNull(obj) {
		    return obj === null;
		}
	
		/**
		 * Check whether the given variable is truthy or not.<br>
		 *  If the given variable is not null or not undefined or not false, returns true.<br>
		 *  (It regards 0 as true)
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is truthy?
		 * @memberof tui.util
		 */
		function isTruthy(obj) {
		    return isExisty(obj) && obj !== false;
		}
	
		/**
		 * Check whether the given variable is falsy or not.<br>
		 *  If the given variable is null or undefined or false, returns true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is falsy?
		 * @memberof tui.util
		 */
		function isFalsy(obj) {
		    return !isTruthy(obj);
		}
	
		/**
		 * Check whether the given variable is an arguments object or not.<br>
		 *  If the given variable is an arguments object, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is arguments?
		 * @memberof tui.util
		 */
		function isArguments(obj) {
		    var result = isExisty(obj) &&
		        ((toString.call(obj) === '[object Arguments]') || !!obj.callee);
	
		    return result;
		}
	
		/**
		 * Check whether the given variable is an instance of Array or not.<br>
		 *  If the given variable is an instance of Array, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is array instance?
		 * @memberof tui.util
		 */
		function isArray(obj) {
		    return obj instanceof Array;
		}
	
		/**
		 * Check whether the given variable is an object or not.<br>
		 *  If the given variable is an object, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is object?
		 * @memberof tui.util
		 */
		function isObject(obj) {
		    return obj === Object(obj);
		}
	
		/**
		 * Check whether the given variable is a function or not.<br>
		 *  If the given variable is a function, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is function?
		 * @memberof tui.util
		 */
		function isFunction(obj) {
		    return obj instanceof Function;
		}
	
		/**
		 * Check whether the given variable is a number or not.<br>
		 *  If the given variable is a number, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is number?
		 * @memberof tui.util
		 */
		function isNumber(obj) {
		    return typeof obj === 'number' || obj instanceof Number;
		}
	
		/**
		 * Check whether the given variable is a string or not.<br>
		 *  If the given variable is a string, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is string?
		 * @memberof tui.util
		 */
		function isString(obj) {
		    return typeof obj === 'string' || obj instanceof String;
		}
	
		/**
		 * Check whether the given variable is a boolean or not.<br>
		 *  If the given variable is a boolean, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is boolean?
		 * @memberof tui.util
		 */
		function isBoolean(obj) {
		    return typeof obj === 'boolean' || obj instanceof Boolean;
		}
	
		/**
		 * Check whether the given variable is an instance of Array or not.<br>
		 *  If the given variable is an instance of Array, return true.<br>
		 *  (It is used for multiple frame environments)
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is an instance of array?
		 * @memberof tui.util
		 */
		function isArraySafe(obj) {
		    return toString.call(obj) === '[object Array]';
		}
	
		/**
		 * Check whether the given variable is a function or not.<br>
		 *  If the given variable is a function, return true.<br>
		 *  (It is used for multiple frame environments)
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is a function?
		 * @memberof tui.util
		 */
		function isFunctionSafe(obj) {
		    return toString.call(obj) === '[object Function]';
		}
	
		/**
		 * Check whether the given variable is a number or not.<br>
		 *  If the given variable is a number, return true.<br>
		 *  (It is used for multiple frame environments)
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is a number?
		 * @memberof tui.util
		 */
		function isNumberSafe(obj) {
		    return toString.call(obj) === '[object Number]';
		}
	
		/**
		 * Check whether the given variable is a string or not.<br>
		 *  If the given variable is a string, return true.<br>
		 *  (It is used for multiple frame environments)
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is a string?
		 * @memberof tui.util
		 */
		function isStringSafe(obj) {
		    return toString.call(obj) === '[object String]';
		}
	
		/**
		 * Check whether the given variable is a boolean or not.<br>
		 *  If the given variable is a boolean, return true.<br>
		 *  (It is used for multiple frame environments)
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is a boolean?
		 * @memberof tui.util
		 */
		function isBooleanSafe(obj) {
		    return toString.call(obj) === '[object Boolean]';
		}
	
		/**
		 * Check whether the given variable is a instance of HTMLNode or not.<br>
		 *  If the given variables is a instance of HTMLNode, return true.
		 * @param {*} html - Target for checking
		 * @returns {boolean} Is HTMLNode ?
		 * @memberof tui.util
		 */
		function isHTMLNode(html) {
		    if (typeof HTMLElement === 'object') {
		        return (html && (html instanceof HTMLElement || !!html.nodeType));
		    }
	
		    return !!(html && html.nodeType);
		}
	
		/**
		 * Check whether the given variable is a HTML tag or not.<br>
		 *  If the given variables is a HTML tag, return true.
		 * @param {*} html - Target for checking
		 * @returns {Boolean} Is HTML tag?
		 * @memberof tui.util
		 */
		function isHTMLTag(html) {
		    if (typeof HTMLElement === 'object') {
		        return (html && (html instanceof HTMLElement));
		    }
	
		    return !!(html && html.nodeType && html.nodeType === 1);
		}
	
		/**
		 * Check whether the given variable is empty(null, undefined, or empty array, empty object) or not.<br>
		 *  If the given variables is empty, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is empty?
		 * @memberof tui.util
		 */
		function isEmpty(obj) {
		    if (!isExisty(obj) || _isEmptyString(obj)) {
		        return true;
		    }
	
		    if (isArray(obj) || isArguments(obj)) {
		        return obj.length === 0;
		    }
	
		    if (isObject(obj) && !isFunction(obj)) {
		        return !_hasOwnProperty(obj);
		    }
	
		    return true;
		}
	
		/**
		 * Check whether given argument is empty string
		 * @param {*} obj - Target for checking
		 * @returns {boolean} whether given argument is empty string
		 * @memberof tui.util
		 * @private
		 */
		function _isEmptyString(obj) {
		    return isString(obj) && obj === '';
		}
	
		/**
		 * Check whether given argument has own property
		 * @param {Object} obj - Target for checking
		 * @returns {boolean} - whether given argument has own property
		 * @memberof tui.util
		 * @private
		 */
		function _hasOwnProperty(obj) {
		    var key;
		    for (key in obj) {
		        if (obj.hasOwnProperty(key)) {
		            return true;
		        }
		    }
	
		    return false;
		}
	
		/**
		 * Check whether the given variable is not empty
		 * (not null, not undefined, or not empty array, not empty object) or not.<br>
		 *  If the given variables is not empty, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is not empty?
		 * @memberof tui.util
		 */
		function isNotEmpty(obj) {
		    return !isEmpty(obj);
		}
	
		/**
		 * Check whether the given variable is an instance of Date or not.<br>
		 *  If the given variables is an instance of Date, return true.
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is an instance of Date?
		 * @memberof tui.util
		 */
		function isDate(obj) {
		    return obj instanceof Date;
		}
	
		/**
		 * Check whether the given variable is an instance of Date or not.<br>
		 *  If the given variables is an instance of Date, return true.<br>
		 *  (It is used for multiple frame environments)
		 * @param {*} obj - Target for checking
		 * @returns {boolean} Is an instance of Date?
		 * @memberof tui.util
		 */
		function isDateSafe(obj) {
		    return toString.call(obj) === '[object Date]';
		}
	
		module.exports = {
		    isExisty: isExisty,
		    isUndefined: isUndefined,
		    isNull: isNull,
		    isTruthy: isTruthy,
		    isFalsy: isFalsy,
		    isArguments: isArguments,
		    isArray: isArray,
		    isArraySafe: isArraySafe,
		    isObject: isObject,
		    isFunction: isFunction,
		    isFunctionSafe: isFunctionSafe,
		    isNumber: isNumber,
		    isNumberSafe: isNumberSafe,
		    isDate: isDate,
		    isDateSafe: isDateSafe,
		    isString: isString,
		    isStringSafe: isStringSafe,
		    isBoolean: isBoolean,
		    isBooleanSafe: isBooleanSafe,
		    isHTMLNode: isHTMLNode,
		    isHTMLTag: isHTMLTag,
		    isEmpty: isEmpty,
		    isNotEmpty: isNotEmpty
		};
	
	
	/***/ }),
	/* 3 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview This module has some functions for handling array.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var collection = __webpack_require__(4);
		var type = __webpack_require__(2);
	
		var aps = Array.prototype.slice;
		var util;
	
		/**
		 * Generate an integer Array containing an arithmetic progression.
		 * @param {number} start - start index
		 * @param {number} stop - stop index
		 * @param {number} step - next visit index = current index + step
		 * @returns {Array}
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * util.range(5); // [0, 1, 2, 3, 4]
		 * util.range(1, 5); // [1,2,3,4]
		 * util.range(2, 10, 2); // [2,4,6,8]
		 * util.range(10, 2, -2); // [10,8,6,4]
		 */
		var range = function(start, stop, step) {
		    var arr = [];
		    var flag;
	
		    if (type.isUndefined(stop)) {
		        stop = start || 0;
		        start = 0;
		    }
	
		    step = step || 1;
		    flag = step < 0 ? -1 : 1;
		    stop *= flag;
	
		    for (; start * flag < stop; start += step) {
		        arr.push(start);
		    }
	
		    return arr;
		};
	
		/* eslint-disable valid-jsdoc */
		/**
		 * Zip together multiple lists into a single array
		 * @param {...Array}
		 * @returns {Array}
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var result = util.zip([1, 2, 3], ['a', 'b','c'], [true, false, true]);
		 * console.log(result[0]); // [1, 'a', true]
		 * console.log(result[1]); // [2, 'b', false]
		 * console.log(result[2]); // [3, 'c', true]
		 */
		var zip = function() {/* eslint-enable valid-jsdoc */
		    var arr2d = aps.call(arguments);
		    var result = [];
	
		    collection.forEach(arr2d, function(arr) {
		        collection.forEach(arr, function(value, index) {
		            if (!result[index]) {
		                result[index] = [];
		            }
		            result[index].push(value);
		        });
		    });
	
		    return result;
		};
	
		/**
		 * Returns the first index at which a given element can be found in the array
		 * from start index(default 0), or -1 if it is not present.<br>
		 * It compares searchElement to elements of the Array using strict equality
		 * (the same method used by the ===, or triple-equals, operator).
		 * @param {*} searchElement Element to locate in the array
		 * @param {Array} array Array that will be traversed.
		 * @param {number} startIndex Start index in array for searching (default 0)
		 * @returns {number} the First index at which a given element, or -1 if it is not present
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var arr = ['one', 'two', 'three', 'four'];
		 * var idx1 = util.inArray('one', arr, 3); // -1
		 * var idx2 = util.inArray('one', arr); // 0
		 */
		var inArray = function(searchElement, array, startIndex) {
		    var i;
		    var length;
		    startIndex = startIndex || 0;
	
		    if (!type.isArray(array)) {
		        return -1;
		    }
	
		    if (Array.prototype.indexOf) {
		        return Array.prototype.indexOf.call(array, searchElement, startIndex);
		    }
	
		    length = array.length;
		    for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
		        if (array[i] === searchElement) {
		            return i;
		        }
		    }
	
		    return -1;
		};
	
		util = {
		    inArray: inArray,
		    range: range,
		    zip: zip
		};
	
		module.exports = util;
	
	
	/***/ }),
	/* 4 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview This module has some functions for handling object as collection.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var type = __webpack_require__(2);
		var object = __webpack_require__(1);
	
		/**
		 * Execute the provided callback once for each element present
		 * in the array(or Array-like object) in ascending order.<br>
		 * If the callback function returns false, the loop will be stopped.<br>
		 * Callback function(iteratee) is invoked with three arguments:
		 *  - The value of the element
		 *  - The index of the element
		 *  - The array(or Array-like object) being traversed
		 * @param {Array} arr The array(or Array-like object) that will be traversed
		 * @param {function} iteratee Callback function
		 * @param {Object} [context] Context(this) of callback function
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var sum = 0;
		 *
		 * util.forEachArray([1,2,3], function(value){
		 *     sum += value;
		 * });
		 * alert(sum); // 6
		 */
		function forEachArray(arr, iteratee, context) {
		    var index = 0;
		    var len = arr.length;
	
		    context = context || null;
	
		    for (; index < len; index += 1) {
		        if (iteratee.call(context, arr[index], index, arr) === false) {
		            break;
		        }
		    }
		}
	
		/**
		 * Execute the provided callback once for each property of object which actually exist.<br>
		 * If the callback function returns false, the loop will be stopped.<br>
		 * Callback function(iteratee) is invoked with three arguments:
		 *  - The value of the property
		 *  - The name of the property
		 *  - The object being traversed
		 * @param {Object} obj The object that will be traversed
		 * @param {function} iteratee  Callback function
		 * @param {Object} [context] Context(this) of callback function
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var sum = 0;
		 *
		 * util.forEachOwnProperties({a:1,b:2,c:3}, function(value){
		 *     sum += value;
		 * });
		 * alert(sum); // 6
		 **/
		function forEachOwnProperties(obj, iteratee, context) {
		    var key;
	
		    context = context || null;
	
		    for (key in obj) {
		        if (obj.hasOwnProperty(key)) {
		            if (iteratee.call(context, obj[key], key, obj) === false) {
		                break;
		            }
		        }
		    }
		}
	
		/**
		 * Execute the provided callback once for each property of object(or element of array) which actually exist.<br>
		 * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).<br>
		 * If the callback function returns false, the loop will be stopped.<br>
		 * Callback function(iteratee) is invoked with three arguments:
		 *  - The value of the property(or The value of the element)
		 *  - The name of the property(or The index of the element)
		 *  - The object being traversed
		 * @param {Object} obj The object that will be traversed
		 * @param {function} iteratee Callback function
		 * @param {Object} [context] Context(this) of callback function
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var sum = 0;
		 *
		 * util.forEach([1,2,3], function(value){
		 *     sum += value;
		 * });
		 * alert(sum); // 6
		 *
		 * // In case of Array-like object
		 * var array = Array.prototype.slice.call(arrayLike); // change to array
		 * util.forEach(array, function(value){
		 *     sum += value;
		 * });
		 */
		function forEach(obj, iteratee, context) {
		    if (type.isArray(obj)) {
		        forEachArray(obj, iteratee, context);
		    } else {
		        forEachOwnProperties(obj, iteratee, context);
		    }
		}
	
		/**
		 * Execute the provided callback function once for each element in an array, in order,
		 * and constructs a new array from the results.<br>
		 * If the object is Array-like object(ex-arguments object),
		 * It needs to transform to Array.(see 'ex2' of forEach example)<br>
		 * Callback function(iteratee) is invoked with three arguments:
		 *  - The value of the property(or The value of the element)
		 *  - The name of the property(or The index of the element)
		 *  - The object being traversed
		 * @param {Object} obj The object that will be traversed
		 * @param {function} iteratee Callback function
		 * @param {Object} [context] Context(this) of callback function
		 * @returns {Array} A new array composed of returned values from callback function
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var result = util.map([0,1,2,3], function(value) {
		 *     return value + 1;
		 * });
		 *
		 * alert(result);  // 1,2,3,4
		 */
		function map(obj, iteratee, context) {
		    var resultArray = [];
	
		    context = context || null;
	
		    forEach(obj, function() {
		        resultArray.push(iteratee.apply(context, arguments));
		    });
	
		    return resultArray;
		}
	
		/**
		 * Execute the callback function once for each element present in the array(or Array-like object or plain object).<br>
		 * If the object is Array-like object(ex-arguments object),
		 * It needs to transform to Array.(see 'ex2' of forEach example)<br>
		 * Callback function(iteratee) is invoked with four arguments:
		 *  - The previousValue
		 *  - The currentValue
		 *  - The index
		 *  - The object being traversed
		 * @param {Object} obj The object that will be traversed
		 * @param {function} iteratee Callback function
		 * @param {Object} [context] Context(this) of callback function
		 * @returns {*} The result value
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var result = util.reduce([0,1,2,3], function(stored, value) {
		 *     return stored + value;
		 * });
		 *
		 * alert(result); // 6
		 */
		function reduce(obj, iteratee, context) {
		    var index = 0;
		    var keys, length, store;
	
		    context = context || null;
	
		    if (!type.isArray(obj)) {
		        keys = object.keys(obj);
		        length = keys.length;
		        store = obj[keys[index += 1]];
		    } else {
		        length = obj.length;
		        store = obj[index];
		    }
	
		    index += 1;
		    for (; index < length; index += 1) {
		        store = iteratee.call(context, store, obj[keys ? keys[index] : index]);
		    }
	
		    return store;
		}
	
		/**
		 * Transform the Array-like object to Array.<br>
		 * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
		 * @param {*} arrayLike Array-like object
		 * @returns {Array} Array
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var arrayLike = {
		 *     0: 'one',
		 *     1: 'two',
		 *     2: 'three',
		 *     3: 'four',
		 *     length: 4
		 * };
		 * var result = util.toArray(arrayLike);
		 *
		 * alert(result instanceof Array); // true
		 * alert(result); // one,two,three,four
		 */
		function toArray(arrayLike) {
		    var arr;
		    try {
		        arr = Array.prototype.slice.call(arrayLike);
		    } catch (e) {
		        arr = [];
		        forEachArray(arrayLike, function(value) {
		            arr.push(value);
		        });
		    }
	
		    return arr;
		}
	
		/**
		 * Create a new array or plain object with all elements(or properties)
		 * that pass the test implemented by the provided function.<br>
		 * Callback function(iteratee) is invoked with three arguments:
		 *  - The value of the property(or The value of the element)
		 *  - The name of the property(or The index of the element)
		 *  - The object being traversed
		 * @param {Object} obj Object(plain object or Array) that will be traversed
		 * @param {function} iteratee Callback function
		 * @param {Object} [context] Context(this) of callback function
		 * @returns {Object} plain object or Array
		 * @memberof tui.util
		 * @example
		  * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var result1 = util.filter([0,1,2,3], function(value) {
		 *     return (value % 2 === 0);
		 * });
		 * alert(result1); // [0, 2]
		 *
		 * var result2 = util.filter({a : 1, b: 2, c: 3}, function(value) {
		 *     return (value % 2 !== 0);
		 * });
		 * alert(result2.a); // 1
		 * alert(result2.b); // undefined
		 * alert(result2.c); // 3
		 */
		function filter(obj, iteratee, context) {
		    var result, add;
	
		    context = context || null;
	
		    if (!type.isObject(obj) || !type.isFunction(iteratee)) {
		        throw new Error('wrong parameter');
		    }
	
		    if (type.isArray(obj)) {
		        result = [];
		        add = function(subResult, args) {
		            subResult.push(args[0]);
		        };
		    } else {
		        result = {};
		        add = function(subResult, args) {
		            subResult[args[1]] = args[0];
		        };
		    }
	
		    forEach(obj, function() {
		        if (iteratee.apply(context, arguments)) {
		            add(result, arguments);
		        }
		    }, context);
	
		    return result;
		}
	
		/**
		 * fetching a property
		 * @param {Array} arr target collection
		 * @param {String|Number} property property name
		 * @returns {Array}
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var objArr = [
		 *     {'abc': 1, 'def': 2, 'ghi': 3},
		 *     {'abc': 4, 'def': 5, 'ghi': 6},
		 *     {'abc': 7, 'def': 8, 'ghi': 9}
		 * ];
		 * var arr2d = [
		 *     [1, 2, 3],
		 *     [4, 5, 6],
		 *     [7, 8, 9]
		 * ];
		 * util.pluck(objArr, 'abc'); // [1, 4, 7]
		 * util.pluck(arr2d, 2); // [3, 6, 9]
		 */
		function pluck(arr, property) {
		    var result = map(arr, function(item) {
		        return item[property];
		    });
	
		    return result;
		}
	
		module.exports = {
		    forEachOwnProperties: forEachOwnProperties,
		    forEachArray: forEachArray,
		    forEach: forEach,
		    toArray: toArray,
		    map: map,
		    reduce: reduce,
		    filter: filter,
		    pluck: pluck
		};
	
	
	/***/ }),
	/* 5 */
	/***/ (function(module, exports) {
	
		/**
		 * @fileoverview This module provides a bind() function for context binding.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		/**
		 * Create a new function that, when called, has its this keyword set to the provided value.
		 * @param {function} fn A original function before binding
		 * @param {*} obj context of function in arguments[0]
		 * @returns {function()} A new bound function with context that is in arguments[1]
		 * @memberof tui.util
		 */
		function bind(fn, obj) {
		    var slice = Array.prototype.slice;
		    var args;
	
		    if (fn.bind) {
		        return fn.bind.apply(fn, slice.call(arguments, 1));
		    }
	
		    /* istanbul ignore next */
		    args = slice.call(arguments, 2);
	
		    /* istanbul ignore next */
		    return function() {
		        /* istanbul ignore next */
		        return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		    };
		}
	
		module.exports = {
		    bind: bind
		};
	
	
	/***/ }),
	/* 6 */
	/***/ (function(module, exports) {
	
		/**
		 * @fileoverview This module provides some simple function for inheritance.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		/**
		 * Create a new object with the specified prototype object and properties.
		 * @param {Object} obj This object will be a prototype of the newly-created object.
		 * @returns {Object}
		 * @memberof tui.util
		 */
		function createObject(obj) {
		    function F() {} // eslint-disable-line require-jsdoc
		    F.prototype = obj;
	
		    return new F();
		}
	
		/**
		 * Provide a simple inheritance in prototype-oriented.<br>
		 * Caution :
		 *  Don't overwrite the prototype of child constructor.
		 *
		 * @param {function} subType Child constructor
		 * @param {function} superType Parent constructor
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * // Parent constructor
		 * function Animal(leg) {
		 *     this.leg = leg;
		 * }
		 * Animal.prototype.growl = function() {
		 *     // ...
		 * };
		 *
		 * // Child constructor
		 * function Person(name) {
		 *     this.name = name;
		 * }
		 *
		 * // Inheritance
		 * util.inherit(Person, Animal);
		 *
		 * // After this inheritance, please use only the extending of property.
		 * // Do not overwrite prototype.
		 * Person.prototype.walk = function(direction) {
		 *     // ...
		 * };
		 */
		function inherit(subType, superType) {
		    var prototype = createObject(superType.prototype);
		    prototype.constructor = subType;
		    subType.prototype = prototype;
		}
	
		module.exports = {
		    createObject: createObject,
		    inherit: inherit
		};
	
	
	/***/ }),
	/* 7 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview This module has some functions for handling the string.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var collection = __webpack_require__(4);
		var object = __webpack_require__(1);
		/**
		 * Transform the given HTML Entity string into plain string
		 * @param {String} htmlEntity - HTML Entity type string
		 * @returns {String} Plain string
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 *  var htmlEntityString = "A &#39;quote&#39; is &lt;b&gt;bold&lt;/b&gt;"
		 *  var result = util.decodeHTMLEntity(htmlEntityString); //"A 'quote' is <b>bold</b>"
		 */
		function decodeHTMLEntity(htmlEntity) {
		    var entities = {
		        '&quot;': '"',
		        '&amp;': '&',
		        '&lt;': '<',
		        '&gt;': '>',
		        '&#39;': '\'',
		        '&nbsp;': ' '
		    };
	
		    return htmlEntity.replace(/&amp;|&lt;|&gt;|&quot;|&#39;|&nbsp;/g, function(m0) {
		        return entities[m0] ? entities[m0] : m0;
		    });
		}
	
		/**
		 * Transform the given string into HTML Entity string
		 * @param {String} html - String for encoding
		 * @returns {String} HTML Entity
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 *  var htmlEntityString = "<script> alert('test');</script><a href='test'>";
		 *  var result = util.encodeHTMLEntity(htmlEntityString);
		 * //"&lt;script&gt; alert(&#39;test&#39;);&lt;/script&gt;&lt;a href=&#39;test&#39;&gt;"
		 */
		function encodeHTMLEntity(html) {
		    var entities = {
		        '"': 'quot',
		        '&': 'amp',
		        '<': 'lt',
		        '>': 'gt',
		        '\'': '#39'
		    };
	
		    return html.replace(/[<>&"']/g, function(m0) {
		        return entities[m0] ? '&' + entities[m0] + ';' : m0;
		    });
		}
	
		/**
		 * Return whether the string capable to transform into plain string is in the given string or not.
		 * @param {String} string - test string
		 * @memberof tui.util
		 * @returns {boolean}
		 */
		function hasEncodableString(string) {
		    return (/[<>&"']/).test(string);
		}
	
		/**
		 * Return duplicate charters
		 * @param {string} operandStr1 The operand string
		 * @param {string} operandStr2 The operand string
		 * @private
		 * @memberof tui.util
		 * @returns {string}
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * util.getDuplicatedChar('fe dev', 'nhn entertainment'); // 'e'
		 * util.getDuplicatedChar('fdsa', 'asdf'); // 'asdf'
		 */
		function getDuplicatedChar(operandStr1, operandStr2) {
		    var i = 0;
		    var len = operandStr1.length;
		    var pool = {};
		    var dupl, key;
	
		    for (; i < len; i += 1) {
		        key = operandStr1.charAt(i);
		        pool[key] = 1;
		    }
	
		    for (i = 0, len = operandStr2.length; i < len; i += 1) {
		        key = operandStr2.charAt(i);
		        if (pool[key]) {
		            pool[key] += 1;
		        }
		    }
	
		    pool = collection.filter(pool, function(item) {
		        return item > 1;
		    });
	
		    pool = object.keys(pool).sort();
		    dupl = pool.join('');
	
		    return dupl;
		}
	
		module.exports = {
		    decodeHTMLEntity: decodeHTMLEntity,
		    encodeHTMLEntity: encodeHTMLEntity,
		    hasEncodableString: hasEncodableString,
		    getDuplicatedChar: getDuplicatedChar
		};
	
	
	/***/ }),
	/* 8 */
	/***/ (function(module, exports) {
	
		/**
		 * @fileoverview collections of some technic methods.
		 * @author NHN Ent. FE Development Lab <e0242.nhnent.com>
		 */
	
		'use strict';
	
		var tricks = {};
		var aps = Array.prototype.slice;
	
		/**
		 * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed
		 * since the last time the debouced function was invoked.
		 * @param {function} fn The function to debounce.
		 * @param {number} [delay=0] The number of milliseconds to delay
		 * @memberof tui.util
		 * @returns {function} debounced function.
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * function someMethodToInvokeDebounced() {}
		 *
		 * var debounced = util.debounce(someMethodToInvokeDebounced, 300);
		 *
		 * // invoke repeatedly
		 * debounced();
		 * debounced();
		 * debounced();
		 * debounced();
		 * debounced();
		 * debounced();    // last invoke of debounced()
		 *
		 * // invoke someMethodToInvokeDebounced() after 300 milliseconds.
		 */
		function debounce(fn, delay) {
		    var timer, args;
	
		    /* istanbul ignore next */
		    delay = delay || 0;
	
		    function debounced() { // eslint-disable-line require-jsdoc
		        args = aps.call(arguments);
	
		        window.clearTimeout(timer);
		        timer = window.setTimeout(function() {
		            fn.apply(null, args);
		        }, delay);
		    }
	
		    return debounced;
		}
	
		/**
		 * return timestamp
		 * @memberof tui.util
		 * @returns {number} The number of milliseconds from Jan. 1970 00:00:00 (GMT)
		 */
		function timestamp() {
		    return Number(new Date());
		}
	
		/**
		 * Creates a throttled function that only invokes fn at most once per every interval milliseconds.
		 *
		 * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)
		 *
		 * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.
		 * @param {function} fn function to throttle
		 * @param {number} [interval=0] the number of milliseconds to throttle invocations to.
		 * @memberof tui.util
		 * @returns {function} throttled function
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * function someMethodToInvokeThrottled() {}
		 *
		 * var throttled = util.throttle(someMethodToInvokeThrottled, 300);
		 *
		 * // invoke repeatedly
		 * throttled();    // invoke (leading)
		 * throttled();
		 * throttled();    // invoke (near 300 milliseconds)
		 * throttled();
		 * throttled();
		 * throttled();    // invoke (near 600 milliseconds)
		 * // ...
		 * // invoke (trailing)
		 *
		 * // if you need reuse throttled method. then invoke reset()
		 * throttled.reset();
		 */
		function throttle(fn, interval) {
		    var base;
		    var isLeading = true;
		    var tick = function(_args) {
		        fn.apply(null, _args);
		        base = null;
		    };
		    var debounced, stamp, args;
	
		    /* istanbul ignore next */
		    interval = interval || 0;
	
		    debounced = tricks.debounce(tick, interval);
	
		    function throttled() { // eslint-disable-line require-jsdoc
		        args = aps.call(arguments);
	
		        if (isLeading) {
		            tick(args);
		            isLeading = false;
	
		            return;
		        }
	
		        stamp = tricks.timestamp();
	
		        base = base || stamp;
	
		        // pass array directly because `debounce()`, `tick()` are already use
		        // `apply()` method to invoke developer's `fn` handler.
		        //
		        // also, this `debounced` line invoked every time for implements
		        // `trailing` features.
		        debounced(args);
	
		        if ((stamp - base) >= interval) {
		            tick(args);
		        }
		    }
	
		    function reset() { // eslint-disable-line require-jsdoc
		        isLeading = true;
		        base = null;
		    }
	
		    throttled.reset = reset;
	
		    return throttled;
		}
	
		tricks.timestamp = timestamp;
		tricks.debounce = debounce;
		tricks.throttle = throttle;
	
		module.exports = tricks;
	
	
	/***/ }),
	/* 9 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview This module has some functions for handling object as collection.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
		'use strict';
	
		var object = __webpack_require__(1);
		var collection = __webpack_require__(4);
		var type = __webpack_require__(2);
		var ms7days = 7 * 24 * 60 * 60 * 1000;
	
		/**
		 * Check if the date has passed 7 days
		 * @param {number} date - milliseconds
		 * @returns {boolean}
		 * @ignore
		 */
		function isExpired(date) {
		    var now = new Date().getTime();
	
		    return now - date > ms7days;
		}
	
		/**
		 * Send hostname on DOMContentLoaded.
		 * To prevent hostname set tui.usageStatistics to false.
		 * @param {string} appName - application name
		 * @param {string} trackingId - GA tracking ID
		 * @ignore
		 */
		function sendHostname(appName, trackingId) {
		    var url = 'https://www.google-analytics.com/collect';
		    var hostname = location.hostname;
		    var hitType = 'event';
		    var eventCategory = 'use';
		    var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
		    var date = window.localStorage.getItem(applicationKeyForStorage);
	
		    // skip if the flag is defined and is set to false explicitly
		    if (!type.isUndefined(window.tui) && window.tui.usageStatistics === false) {
		        return;
		    }
	
		    // skip if not pass seven days old
		    if (date && !isExpired(date)) {
		        return;
		    }
	
		    window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());
	
		    setTimeout(function() {
		        if (document.readyState === 'interactive' || document.readyState === 'complete') {
		            imagePing(url, {
		                v: 1,
		                t: hitType,
		                tid: trackingId,
		                cid: hostname,
		                dp: hostname,
		                dh: appName,
		                el: appName,
		                ec: eventCategory
		            });
		        }
		    }, 1000);
		}
	
		/**
		 * Request image ping.
		 * @param {String} url url for ping request
		 * @param {Object} trackingInfo infos for make query string
		 * @returns {HTMLElement}
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * util.imagePing('https://www.google-analytics.com/collect', {
		 *     v: 1,
		 *     t: 'event',
		 *     tid: 'trackingid',
		 *     cid: 'cid',
		 *     dp: 'dp',
		 *     dh: 'dh'
		 * });
		 */
		function imagePing(url, trackingInfo) {
		    var queryString = collection.map(object.keys(trackingInfo), function(key, index) {
		        var startWith = index === 0 ? '' : '&';
	
		        return startWith + key + '=' + trackingInfo[key];
		    }).join('');
		    var trackingElement = document.createElement('img');
	
		    trackingElement.src = url + '?' + queryString;
	
		    trackingElement.style.display = 'none';
		    document.body.appendChild(trackingElement);
		    document.body.removeChild(trackingElement);
	
		    return trackingElement;
		}
	
		module.exports = {
		    imagePing: imagePing,
		    sendHostname: sendHostname
		};
	
	
	/***/ }),
	/* 10 */
	/***/ (function(module, exports) {
	
		/**
		 * @fileoverview This module detects the kind of well-known browser and version.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		/**
		 * This object has an information that indicate the kind of browser.<br>
		 * The list below is a detectable browser list.
		 *  - ie8 ~ ie11
		 *  - chrome
		 *  - firefox
		 *  - safari
		 *  - edge
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * util.browser.chrome === true; // chrome
		 * util.browser.firefox === true; // firefox
		 * util.browser.safari === true; // safari
		 * util.browser.msie === true; // IE
		 * util.browser.edge === true; // edge
		 * util.browser.others === true; // other browser
		 * util.browser.version; // browser version
		 */
		var browser = {
		    chrome: false,
		    firefox: false,
		    safari: false,
		    msie: false,
		    edge: false,
		    others: false,
		    version: 0
		};
	
		var nav = window.navigator;
		var appName = nav.appName.replace(/\s/g, '_');
		var userAgent = nav.userAgent;
	
		var rIE = /MSIE\s([0-9]+[.0-9]*)/;
		var rIE11 = /Trident.*rv:11\./;
		var rEdge = /Edge\/(\d+)\./;
		var versionRegex = {
		    firefox: /Firefox\/(\d+)\./,
		    chrome: /Chrome\/(\d+)\./,
		    safari: /Version\/([\d.]+).*Safari\/(\d+)/
		};
	
		var key, tmp;
	
		var detector = {
		    Microsoft_Internet_Explorer: function() { // eslint-disable-line camelcase
		        var detectedVersion = userAgent.match(rIE);
	
		        if (detectedVersion) { // ie8 ~ ie10
		            browser.msie = true;
		            browser.version = parseFloat(detectedVersion[1]);
		        } else { // no version information
		            browser.others = true;
		        }
		    },
		    Netscape: function() { // eslint-disable-line complexity
		        var detected = false;
	
		        if (rIE11.exec(userAgent)) {
		            browser.msie = true;
		            browser.version = 11;
		            detected = true;
		        } else if (rEdge.exec(userAgent)) {
		            browser.edge = true;
		            browser.version = userAgent.match(rEdge)[1];
		            detected = true;
		        } else {
		            for (key in versionRegex) {
		                if (versionRegex.hasOwnProperty(key)) {
		                    tmp = userAgent.match(versionRegex[key]);
		                    if (tmp && tmp.length > 1) { // eslint-disable-line max-depth
		                        browser[key] = detected = true;
		                        browser.version = parseFloat(tmp[1] || 0);
		                        break;
		                    }
		                }
		            }
		        }
		        if (!detected) {
		            browser.others = true;
		        }
		    }
		};
	
		var fn = detector[appName];
	
		if (fn) {
		    detector[appName]();
		}
	
		module.exports = browser;
	
	
	/***/ }),
	/* 11 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview This module has some methods for handling popup-window
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var collection = __webpack_require__(4);
		var type = __webpack_require__(2);
		var func = __webpack_require__(5);
		var browser = __webpack_require__(10);
		var object = __webpack_require__(1);
	
		var popupId = 0;
	
		/**
		 * Popup management class
		 * @constructor
		 * @memberof tui.util
		 * @example
		 * // node, commonjs
		 * var popup = require('tui-code-snippet').popup;
		 * @example
		 * // distribution file, script
		 * <script src='path-to/tui-code-snippt.js'></script>
		 * <script>
		 * var popup = tui.util.popup;
		 * <script>
		 */
		function Popup() {
		    /**
		     * Caching the window-contexts of opened popups
		     * @type {Object}
		     */
		    this.openedPopup = {};
	
		    /**
		     * In IE7, an error occurs when the closeWithParent property attaches to window object.<br>
		     * So, It is for saving the value of closeWithParent instead of attaching to window object.
		     * @type {Object}
		     */
		    this.closeWithParentPopup = {};
	
		    /**
		     * Post data bridge for IE11 popup
		     * @type {string}
		     */
		    this.postBridgeUrl = '';
		}
	
		/**********
		 * public methods
		 **********/
	
		/**
		 * Returns a popup-list administered by current window.
		 * @param {string} [key] The key of popup.
		 * @returns {Object} popup window list object
		 */
		Popup.prototype.getPopupList = function(key) {
		    var target;
		    if (type.isExisty(key)) {
		        target = this.openedPopup[key];
		    } else {
		        target = this.openedPopup;
		    }
	
		    return target;
		};
	
		/**
		 * Open popup
		 * Caution:
		 *  In IE11, when transfer data to popup by POST, must set the postBridgeUrl.
		 *
		 * @param {string} url - popup url
		 * @param {Object} options - popup options
		 *     @param {string} [options.popupName] - Key of popup window.<br>
		 *      If the key is set, when you try to open by this key, the popup of this key is focused.<br>
		 *      Or else a new popup window having this key is opened.
		 *
		 *     @param {string} [options.popupOptionStr=""] - Option string of popup window<br>
		 *      It is same with the third parameter of window.open() method.<br>
		 *      See {@link http://www.w3schools.com/jsref/met_win_open.asp}
		 *
		 *     @param {boolean} [options.closeWithParent=true] - Is closed when parent window closed?
		 *
		 *     @param {boolean} [options.useReload=false] - This property indicates whether reload the popup or not.<br>
		 *      If true, the popup will be reloaded when you try to re-open the popup that has been opened.<br>
		 *      When transmit the POST-data, some browsers alert a message for confirming whether retransmit or not.
		 *
		 *     @param {string} [options.postBridgeUrl='']
		 *      Use this url to avoid a certain bug occuring when transmitting POST data to the popup in IE11.<br>
		 *      This specific buggy situation is known to happen because IE11 tries to open the requested url<br>
		 *      not in a new popup window as intended, but in a new tab.<br>
		 *      See {@link http://wiki.nhnent.com/pages/viewpage.action?pageId=240562844}
		 *
		 *     @param {string} [options.method=get]
		 *     The method of transmission when the form-data is transmitted to popup-window.
		 *
		 *     @param {Object} [options.param=null]
		 *     Using as parameters for transmission when the form-data is transmitted to popup-window.
		 */
		Popup.prototype.openPopup = function(url, options) { // eslint-disable-line complexity
		    var popup, formElement, useIEPostBridge;
	
		    options = object.extend({
		        popupName: 'popup_' + popupId + '_' + Number(new Date()),
		        popupOptionStr: '',
		        useReload: true,
		        closeWithParent: true,
		        method: 'get',
		        param: {}
		    }, options || {});
	
		    options.method = options.method.toUpperCase();
	
		    this.postBridgeUrl = options.postBridgeUrl || this.postBridgeUrl;
	
		    useIEPostBridge = options.method === 'POST' && options.param &&
		            browser.msie && browser.version === 11;
	
		    if (!type.isExisty(url)) {
		        throw new Error('Popup#open() need popup url.');
		    }
	
		    popupId += 1;
	
		    /*
		     * In form-data transmission
		     * 1. Create a form before opening a popup.
		     * 2. Transmit the form-data.
		     * 3. Remove the form after transmission.
		     */
		    if (options.param) {
		        if (options.method === 'GET') {
		            url = url + (/\?/.test(url) ? '&' : '?') + this._parameterize(options.param);
		        } else if (options.method === 'POST') {
		            if (!useIEPostBridge) {
		                formElement = this.createForm(url, options.param, options.method, options.popupName);
		                url = 'about:blank';
		            }
		        }
		    }
	
		    popup = this.openedPopup[options.popupName];
	
		    if (!type.isExisty(popup)) {
		        this.openedPopup[options.popupName] = popup = this._open(useIEPostBridge, options.param,
		            url, options.popupName, options.popupOptionStr);
		    } else if (popup.closed) {
		        this.openedPopup[options.popupName] = popup = this._open(useIEPostBridge, options.param,
		            url, options.popupName, options.popupOptionStr);
		    } else {
		        if (options.useReload) {
		            popup.location.replace(url);
		        }
		        popup.focus();
		    }
	
		    this.closeWithParentPopup[options.popupName] = options.closeWithParent;
	
		    if (!popup || popup.closed || type.isUndefined(popup.closed)) {
		        alert('please enable popup windows for this website');
		    }
	
		    if (options.param && options.method === 'POST' && !useIEPostBridge) {
		        if (popup) {
		            formElement.submit();
		        }
		        if (formElement.parentNode) {
		            formElement.parentNode.removeChild(formElement);
		        }
		    }
	
		    window.onunload = func.bind(this.closeAllPopup, this);
		};
	
		/**
		 * Close the popup
		 * @param {boolean} [skipBeforeUnload] - If true, the 'window.onunload' will be null and skip unload event.
		 * @param {Window} [popup] - Window-context of popup for closing. If omit this, current window-context will be closed.
		 */
		Popup.prototype.close = function(skipBeforeUnload, popup) {
		    var target = popup || window;
		    skipBeforeUnload = type.isExisty(skipBeforeUnload) ? skipBeforeUnload : false;
	
		    if (skipBeforeUnload) {
		        window.onunload = null;
		    }
	
		    if (!target.closed) {
		        target.opener = window.location.href;
		        target.close();
		    }
		};
	
		/**
		 * Close all the popups in current window.
		 * @param {boolean} closeWithParent - If true, popups having the closeWithParentPopup property as true will be closed.
		 */
		Popup.prototype.closeAllPopup = function(closeWithParent) {
		    var hasArg = type.isExisty(closeWithParent);
	
		    collection.forEachOwnProperties(this.openedPopup, function(popup, key) {
		        if ((hasArg && this.closeWithParentPopup[key]) || !hasArg) {
		            this.close(false, popup);
		        }
		    }, this);
		};
	
		/**
		 * Activate(or focus) the popup of the given name.
		 * @param {string} popupName - Name of popup for activation
		 */
		Popup.prototype.focus = function(popupName) {
		    this.getPopupList(popupName).focus();
		};
	
		/**
		 * Return an object made of parsing the query string.
		 * @returns {Object} An object having some information of the query string.
		 * @private
		 */
		Popup.prototype.parseQuery = function() {
		    var param = {};
		    var search, pair;
	
		    search = window.location.search.substr(1);
		    collection.forEachArray(search.split('&'), function(part) {
		        pair = part.split('=');
		        param[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
		    });
	
		    return param;
		};
	
		/**
		 * Create a hidden form from the given arguments and return this form.
		 * @param {string} action - URL for form transmission
		 * @param {Object} [data] - Data for form transmission
		 * @param {string} [method] - Method of transmission
		 * @param {string} [target] - Target of transmission
		 * @param {HTMLElement} [container] - Container element of form.
		 * @returns {HTMLElement} Form element
		 */
		Popup.prototype.createForm = function(action, data, method, target, container) {
		    var form = document.createElement('form'),
		        input;
	
		    container = container || document.body;
	
		    form.method = method || 'POST';
		    form.action = action || '';
		    form.target = target || '';
		    form.style.display = 'none';
	
		    collection.forEachOwnProperties(data, function(value, key) {
		        input = document.createElement('input');
		        input.name = key;
		        input.type = 'hidden';
		        input.value = value;
		        form.appendChild(input);
		    });
	
		    container.appendChild(form);
	
		    return form;
		};
	
		/**********
		 * private methods
		 **********/
	
		/**
		 * Return an query string made by parsing the given object
		 * @param {Object} obj - An object that has information for query string
		 * @returns {string} - Query string
		 * @private
		 */
		Popup.prototype._parameterize = function(obj) {
		    var query = [];
	
		    collection.forEachOwnProperties(obj, function(value, key) {
		        query.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
		    });
	
		    return query.join('&');
		};
	
		/**
		 * Open popup
		 * @param {boolean} useIEPostBridge - A switch option whether to use alternative
		 *                                  of tossing POST data to the popup window in IE11
		 * @param {Object} param - A data for tossing to popup
		 * @param {string} url - Popup url
		 * @param {string} popupName - Popup name
		 * @param {string} optionStr - Setting for popup, ex) 'width=640,height=320,scrollbars=yes'
		 * @returns {Window} Window context of popup
		 * @private
		 */
		Popup.prototype._open = function(useIEPostBridge, param, url, popupName, optionStr) {
		    var popup;
	
		    if (useIEPostBridge) {
		        popup = window.open(this.postBridgeUrl, popupName, optionStr);
		        setTimeout(function() {
		            popup.redirect(url, param);
		        }, 100);
		    } else {
		        popup = window.open(url, popupName, optionStr);
		    }
	
		    return popup;
		};
	
		module.exports = new Popup();
	
	
	/***/ }),
	/* 12 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview This module has a function for date format.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var type = __webpack_require__(2);
		var object = __webpack_require__(1);
	
		var tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*A/gi;
		var MONTH_STR = [
		    'Invalid month', 'January', 'February', 'March', 'April', 'May',
		    'June', 'July', 'August', 'September', 'October', 'November', 'December'
		];
		var MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
		var replaceMap = {
		    M: function(date) {
		        return Number(date.month);
		    },
		    MM: function(date) {
		        var month = date.month;
	
		        return (Number(month) < 10) ? '0' + month : month;
		    },
		    MMM: function(date) {
		        return MONTH_STR[Number(date.month)].substr(0, 3);
		    },
		    MMMM: function(date) {
		        return MONTH_STR[Number(date.month)];
		    },
		    D: function(date) {
		        return Number(date.date);
		    },
		    d: function(date) {
		        return replaceMap.D(date); // eslint-disable-line new-cap
		    },
		    DD: function(date) {
		        var dayInMonth = date.date;
	
		        return (Number(dayInMonth) < 10) ? '0' + dayInMonth : dayInMonth;
		    },
		    dd: function(date) {
		        return replaceMap.DD(date); // eslint-disable-line new-cap
		    },
		    YY: function(date) {
		        return Number(date.year) % 100;
		    },
		    yy: function(date) {
		        return replaceMap.YY(date); // eslint-disable-line new-cap
		    },
		    YYYY: function(date) {
		        var prefix = '20',
		            year = date.year;
		        if (year > 69 && year < 100) {
		            prefix = '19';
		        }
	
		        return (Number(year) < 100) ? prefix + String(year) : year;
		    },
		    yyyy: function(date) {
		        return replaceMap.YYYY(date); // eslint-disable-line new-cap
		    },
		    A: function(date) {
		        return date.meridiem;
		    },
		    a: function(date) {
		        return date.meridiem;
		    },
		    hh: function(date) {
		        var hour = date.hour;
	
		        return (Number(hour) < 10) ? '0' + hour : hour;
		    },
		    HH: function(date) {
		        return replaceMap.hh(date);
		    },
		    h: function(date) {
		        return String(Number(date.hour));
		    },
		    H: function(date) {
		        return replaceMap.h(date);
		    },
		    m: function(date) {
		        return String(Number(date.minute));
		    },
		    mm: function(date) {
		        var minute = date.minute;
	
		        return (Number(minute) < 10) ? '0' + minute : minute;
		    }
		};
	
		/**
		 * Check whether the given variables are valid date or not.
		 * @param {number} year - Year
		 * @param {number} month - Month
		 * @param {number} date - Day in month.
		 * @returns {boolean} Is valid?
		 * @private
		 */
		function isValidDate(year, month, date) { // eslint-disable-line complexity
		    var isValidYear, isValidMonth, isValid, lastDayInMonth;
	
		    year = Number(year);
		    month = Number(month);
		    date = Number(date);
	
		    isValidYear = (year > -1 && year < 100) || ((year > 1969) && (year < 2070));
		    isValidMonth = (month > 0) && (month < 13);
	
		    if (!isValidYear || !isValidMonth) {
		        return false;
		    }
	
		    lastDayInMonth = MONTH_DAYS[month];
		    if (month === 2 && year % 4 === 0) {
		        if (year % 100 !== 0 || year % 400 === 0) {
		            lastDayInMonth = 29;
		        }
		    }
	
		    isValid = (date > 0) && (date <= lastDayInMonth);
	
		    return isValid;
		}
	
		/**
		 * Return a string that transformed from the given form and date.
		 * @param {string} form - Date form
		 * @param {Date|Object} date - Date object
		 * @param {{meridiemSet: {AM: string, PM: string}}} option - Option
		 * @returns {boolean|string} A transformed string or false.
		 * @memberof tui.util
		 * @example
		 *  // key             | Shorthand
		 *  // --------------- |-----------------------
		 *  // years           | YY / YYYY / yy / yyyy
		 *  // months(n)       | M / MM
		 *  // months(str)     | MMM / MMMM
		 *  // days            | D / DD / d / dd
		 *  // hours           | H / HH / h / hh
		 *  // minutes         | m / mm
		 *  // meridiem(AM,PM) | A / a
		 *
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var dateStr1 = util.formatDate('yyyy-MM-dd', {
		 *     year: 2014,
		 *     month: 12,
		 *     date: 12
		 * });
		 * alert(dateStr1); // '2014-12-12'
		 *
		 * var dateStr2 = util.formatDate('MMM DD YYYY HH:mm', {
		 *     year: 1999,
		 *     month: 9,
		 *     date: 9,
		 *     hour: 0,
		 *     minute: 2
		 * });
		 * alert(dateStr2); // 'Sep 09 1999 00:02'
		 *
		 * var dt = new Date(2010, 2, 13),
		 *     dateStr3 = util.formatDate('yyyy년 M월 dd일', dt);
		 * alert(dateStr3); // '2010년 3월 13일'
		 *
		 * var option4 = {
		 *     meridiemSet: {
		 *         AM: '오전',
		 *         PM: '오후'
		 *     }
		 * };
		 * var date4 = {year: 1999, month: 9, date: 9, hour: 13, minute: 2};
		 * var dateStr4 = util.formatDate('yyyy-MM-dd A hh:mm', date4, option4));
		 * alert(dateStr4); // '1999-09-09 오후 01:02'
		 */
		function formatDate(form, date, option) { // eslint-disable-line complexity
		    var am = object.pick(option, 'meridiemSet', 'AM') || 'AM';
		    var pm = object.pick(option, 'meridiemSet', 'PM') || 'PM';
		    var meridiem, nDate, resultStr;
	
		    if (type.isDate(date)) {
		        nDate = {
		            year: date.getFullYear(),
		            month: date.getMonth() + 1,
		            date: date.getDate(),
		            hour: date.getHours(),
		            minute: date.getMinutes()
		        };
		    } else {
		        nDate = {
		            year: date.year,
		            month: date.month,
		            date: date.date,
		            hour: date.hour,
		            minute: date.minute
		        };
		    }
	
		    if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
		        return false;
		    }
	
		    nDate.meridiem = '';
		    if (/([^\\]|^)[aA]\b/.test(form)) {
		        meridiem = (nDate.hour > 11) ? pm : am;
		        if (nDate.hour > 12) { // See the clock system: https://en.wikipedia.org/wiki/12-hour_clock
		            nDate.hour %= 12;
		        }
		        if (nDate.hour === 0) {
		            nDate.hour = 12;
		        }
		        nDate.meridiem = meridiem;
		    }
	
		    resultStr = form.replace(tokens, function(key) {
		        if (key.indexOf('\\') > -1) { // escape character
		            return key.replace(/\\/, '');
		        }
	
		        return replaceMap[key](nDate) || '';
		    });
	
		    return resultStr;
		}
	
		module.exports = formatDate;
	
	
	/***/ }),
	/* 13 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview
		 *  This module provides a function to make a constructor
		 * that can inherit from the other constructors like the CLASS easily.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var inherit = __webpack_require__(6).inherit;
		var extend = __webpack_require__(1).extend;
	
		/**
		 * Help a constructor to be defined and to inherit from the other constructors
		 * @param {*} [parent] Parent constructor
		 * @param {Object} props Members of constructor
		 *  @param {Function} props.init Initialization method
		 *  @param {Object} [props.static] Static members of constructor
		 * @returns {*} Constructor
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var Parent = util.defineClass({
		 *     init: function() { // constuructor
		 *         this.name = 'made by def';
		 *     },
		 *     method: function() {
		 *         // ...
		 *     },
		 *     static: {
		 *         staticMethod: function() {
		 *              // ...
		 *         }
		 *     }
		 * });
		 *
		 * var Child = util.defineClass(Parent, {
		 *     childMethod: function() {}
		 * });
		 *
		 * Parent.staticMethod();
		 *
		 * var parentInstance = new Parent();
		 * console.log(parentInstance.name); //made by def
		 * parentInstance.staticMethod(); // Error
		 *
		 * var childInstance = new Child();
		 * childInstance.method();
		 * childInstance.childMethod();
		 */
		function defineClass(parent, props) {
		    var obj;
	
		    if (!props) {
		        props = parent;
		        parent = null;
		    }
	
		    obj = props.init || function() {};
	
		    if (parent) {
		        inherit(obj, parent);
		    }
	
		    if (props.hasOwnProperty('static')) {
		        extend(obj, props['static']);
		        delete props['static'];
		    }
	
		    extend(obj.prototype, props);
	
		    return obj;
		}
	
		module.exports = defineClass;
	
	
	/***/ }),
	/* 14 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview Define module
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javscript@nhnent.com>
		 * @dependency type.js, defineNamespace.js
		 */
	
		'use strict';
	
		var defineNamespace = __webpack_require__(15);
		var type = __webpack_require__(2);
	
		var INITIALIZATION_METHOD_NAME = 'initialize';
	
		/**
		 * Define module
		 * @param {string} namespace - Namespace of module
		 * @param {Object} moduleDefinition - Object literal for module
		 * @returns {Object} Defined module
		 * @memberof tui.util
		 * @example
		  * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var myModule = util.defineModule('modules.myModule', {
		 *     name: 'john',
		 *     message: '',
		 *     initialize: function() {
		 *        this.message = 'hello world';
		 *     },
		 *     getMessage: function() {
		 *         return this.name + ': ' + this.message
		 *     }
		 * });
		 *
		 * console.log(myModule.getMessage());  // 'john: hello world';
		 */
		function defineModule(namespace, moduleDefinition) {
		    var base = moduleDefinition || {};
	
		    if (type.isFunction(base[INITIALIZATION_METHOD_NAME])) {
		        base[INITIALIZATION_METHOD_NAME]();
		    }
	
		    return defineNamespace(namespace, base);
		}
	
		module.exports = defineModule;
	
	
	/***/ }),
	/* 15 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview Define namespace
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 * @dependency object.js, collection.js
		 */
	
		'use strict';
	
		var collection = __webpack_require__(4);
		var object = __webpack_require__(1);
	
		/**
		 * Define namespace
		 * @param {string} namespace - Namespace (ex- 'foo.bar.baz')
		 * @param {(object|function)} props - A set of modules or one module
		 * @param {boolean} [isOverride] - Override the props to the namespace.<br>
		 *                                  (It removes previous properties of this namespace)
		 * @returns {(object|function)} Defined namespace
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var util = require('tui-code-snippet'); // node, commonjs
		 * var util = tui.util; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var neComp = util.defineNamespace;
		 * neComp.listMenu = defineClass({
		 *     init: function() {
		 *         // ...
		 *     }
		 * });
		 */
		function defineNamespace(namespace, props, isOverride) {
		    var names, result, prevLast, last;
	
		    names = namespace.split('.');
		    names.unshift(window);
	
		    result = collection.reduce(names, function(obj, name) {
		        obj[name] = obj[name] || {};
	
		        return obj[name];
		    });
	
		    if (isOverride) {
		        last = names.pop();
		        prevLast = object.pick.apply(null, names);
		        result = prevLast[last] = props;
		    } else {
		        object.extend(result, props);
		    }
	
		    return result;
		}
	
		module.exports = defineNamespace;
	
	
	/***/ }),
	/* 16 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview
		 *  This module provides some functions for custom events.<br>
		 *  And it is implemented in the observer design pattern.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var collection = __webpack_require__(4);
		var type = __webpack_require__(2);
		var object = __webpack_require__(1);
	
		var R_EVENTNAME_SPLIT = /\s+/g;
	
		/**
		 * A unit of event handler item.
		 * @ignore
		 * @typedef {object} HandlerItem
		 * @property {function} fn - event handler
		 * @property {object} ctx - context of event handler
		 */
	
		/**
		 * @class
		 * @memberof tui.util
		 * @example
		 * // node, commonjs
		 * var CustomEvents = require('tui-code-snippet').CustomEvents;
		 * @example
		 * // distribution file, script
		 * <script src='path-to/tui-code-snippt.js'></script>
		 * <script>
		 * var CustomEvents = tui.util.CustomEvents;
		 * </script>
		 */
		function CustomEvents() {
		    /**
		     * @type {HandlerItem[]}
		     */
		    this.events = null;
	
		    /**
		     * only for checking specific context event was binded
		     * @type {object[]}
		     */
		    this.contexts = null;
		}
	
		/**
		 * Mixin custom events feature to specific constructor
		 * @param {function} func - constructor
		 * @example
		 * //-- #1. Get Module --//
		 * var CustomEvents = require('tui-code-snippet').CustomEvents; // node, commonjs
		 * var CustomEvents = tui.util.CustomEvents; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var model;
		 * function Model() {
		 *     this.name = '';
		 * }
		 * CustomEvents.mixin(Model);
		 *
		 * model = new Model();
		 * model.on('change', function() { this.name = 'model'; }, this);
		 * model.fire('change');
		 * alert(model.name); // 'model';
		 */
		CustomEvents.mixin = function(func) {
		    object.extend(func.prototype, CustomEvents.prototype);
		};
	
		/**
		 * Get HandlerItem object
		 * @param {function} handler - handler function
		 * @param {object} [context] - context for handler
		 * @returns {HandlerItem} HandlerItem object
		 * @private
		 */
		CustomEvents.prototype._getHandlerItem = function(handler, context) {
		    var item = {handler: handler};
	
		    if (context) {
		        item.context = context;
		    }
	
		    return item;
		};
	
		/**
		 * Get event object safely
		 * @param {string} [eventName] - create sub event map if not exist.
		 * @returns {(object|array)} event object. if you supplied `eventName`
		 *  parameter then make new array and return it
		 * @private
		 */
		CustomEvents.prototype._safeEvent = function(eventName) {
		    var events = this.events;
		    var byName;
	
		    if (!events) {
		        events = this.events = {};
		    }
	
		    if (eventName) {
		        byName = events[eventName];
	
		        if (!byName) {
		            byName = [];
		            events[eventName] = byName;
		        }
	
		        events = byName;
		    }
	
		    return events;
		};
	
		/**
		 * Get context array safely
		 * @returns {array} context array
		 * @private
		 */
		CustomEvents.prototype._safeContext = function() {
		    var context = this.contexts;
	
		    if (!context) {
		        context = this.contexts = [];
		    }
	
		    return context;
		};
	
		/**
		 * Get index of context
		 * @param {object} ctx - context that used for bind custom event
		 * @returns {number} index of context
		 * @private
		 */
		CustomEvents.prototype._indexOfContext = function(ctx) {
		    var context = this._safeContext();
		    var index = 0;
	
		    while (context[index]) {
		        if (ctx === context[index][0]) {
		            return index;
		        }
	
		        index += 1;
		    }
	
		    return -1;
		};
	
		/**
		 * Memorize supplied context for recognize supplied object is context or
		 *  name: handler pair object when off()
		 * @param {object} ctx - context object to memorize
		 * @private
		 */
		CustomEvents.prototype._memorizeContext = function(ctx) {
		    var context, index;
	
		    if (!type.isExisty(ctx)) {
		        return;
		    }
	
		    context = this._safeContext();
		    index = this._indexOfContext(ctx);
	
		    if (index > -1) {
		        context[index][1] += 1;
		    } else {
		        context.push([ctx, 1]);
		    }
		};
	
		/**
		 * Forget supplied context object
		 * @param {object} ctx - context object to forget
		 * @private
		 */
		CustomEvents.prototype._forgetContext = function(ctx) {
		    var context, contextIndex;
	
		    if (!type.isExisty(ctx)) {
		        return;
		    }
	
		    context = this._safeContext();
		    contextIndex = this._indexOfContext(ctx);
	
		    if (contextIndex > -1) {
		        context[contextIndex][1] -= 1;
	
		        if (context[contextIndex][1] <= 0) {
		            context.splice(contextIndex, 1);
		        }
		    }
		};
	
		/**
		 * Bind event handler
		 * @param {(string|{name:string, handler:function})} eventName - custom
		 *  event name or an object {eventName: handler}
		 * @param {(function|object)} [handler] - handler function or context
		 * @param {object} [context] - context for binding
		 * @private
		 */
		CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
		    var events = this._safeEvent(eventName);
		    this._memorizeContext(context);
		    events.push(this._getHandlerItem(handler, context));
		};
	
		/**
		 * Bind event handlers
		 * @param {(string|{name:string, handler:function})} eventName - custom
		 *  event name or an object {eventName: handler}
		 * @param {(function|object)} [handler] - handler function or context
		 * @param {object} [context] - context for binding
		 * //-- #1. Get Module --//
		 * var CustomEvents = require('tui-code-snippet').CustomEvents; // node, commonjs
		 * var CustomEvents = tui.util.CustomEvents; // distribution file
		 *
		 * //-- #2. Use property --//
		 * // # 2.1 Basic Usage
		 * CustomEvents.on('onload', handler);
		 *
		 * // # 2.2 With context
		 * CustomEvents.on('onload', handler, myObj);
		 *
		 * // # 2.3 Bind by object that name, handler pairs
		 * CustomEvents.on({
		 *     'play': handler,
		 *     'pause': handler2
		 * });
		 *
		 * // # 2.4 Bind by object that name, handler pairs with context object
		 * CustomEvents.on({
		 *     'play': handler
		 * }, myObj);
		 */
		CustomEvents.prototype.on = function(eventName, handler, context) {
		    var self = this;
	
		    if (type.isString(eventName)) {
		        // [syntax 1, 2]
		        eventName = eventName.split(R_EVENTNAME_SPLIT);
		        collection.forEach(eventName, function(name) {
		            self._bindEvent(name, handler, context);
		        });
		    } else if (type.isObject(eventName)) {
		        // [syntax 3, 4]
		        context = handler;
		        collection.forEach(eventName, function(func, name) {
		            self.on(name, func, context);
		        });
		    }
		};
	
		/**
		 * Bind one-shot event handlers
		 * @param {(string|{name:string,handler:function})} eventName - custom
		 *  event name or an object {eventName: handler}
		 * @param {function|object} [handler] - handler function or context
		 * @param {object} [context] - context for binding
		 */
		CustomEvents.prototype.once = function(eventName, handler, context) {
		    var self = this;
	
		    if (type.isObject(eventName)) {
		        context = handler;
		        collection.forEach(eventName, function(func, name) {
		            self.once(name, func, context);
		        });
	
		        return;
		    }
	
		    function onceHandler() { // eslint-disable-line require-jsdoc
		        handler.apply(context, arguments);
		        self.off(eventName, onceHandler, context);
		    }
	
		    this.on(eventName, onceHandler, context);
		};
	
		/**
		 * Splice supplied array by callback result
		 * @param {array} arr - array to splice
		 * @param {function} predicate - function return boolean
		 * @private
		 */
		CustomEvents.prototype._spliceMatches = function(arr, predicate) {
		    var i = 0;
		    var len;
	
		    if (!type.isArray(arr)) {
		        return;
		    }
	
		    for (len = arr.length; i < len; i += 1) {
		        if (predicate(arr[i]) === true) {
		            arr.splice(i, 1);
		            len -= 1;
		            i -= 1;
		        }
		    }
		};
	
		/**
		 * Get matcher for unbind specific handler events
		 * @param {function} handler - handler function
		 * @returns {function} handler matcher
		 * @private
		 */
		CustomEvents.prototype._matchHandler = function(handler) {
		    var self = this;
	
		    return function(item) {
		        var needRemove = handler === item.handler;
	
		        if (needRemove) {
		            self._forgetContext(item.context);
		        }
	
		        return needRemove;
		    };
		};
	
		/**
		 * Get matcher for unbind specific context events
		 * @param {object} context - context
		 * @returns {function} object matcher
		 * @private
		 */
		CustomEvents.prototype._matchContext = function(context) {
		    var self = this;
	
		    return function(item) {
		        var needRemove = context === item.context;
	
		        if (needRemove) {
		            self._forgetContext(item.context);
		        }
	
		        return needRemove;
		    };
		};
	
		/**
		 * Get matcher for unbind specific hander, context pair events
		 * @param {function} handler - handler function
		 * @param {object} context - context
		 * @returns {function} handler, context matcher
		 * @private
		 */
		CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
		    var self = this;
	
		    return function(item) {
		        var matchHandler = (handler === item.handler);
		        var matchContext = (context === item.context);
		        var needRemove = (matchHandler && matchContext);
	
		        if (needRemove) {
		            self._forgetContext(item.context);
		        }
	
		        return needRemove;
		    };
		};
	
		/**
		 * Unbind event by event name
		 * @param {string} eventName - custom event name to unbind
		 * @param {function} [handler] - handler function
		 * @private
		 */
		CustomEvents.prototype._offByEventName = function(eventName, handler) {
		    var self = this;
		    var forEach = collection.forEachArray;
		    var andByHandler = type.isFunction(handler);
		    var matchHandler = self._matchHandler(handler);
	
		    eventName = eventName.split(R_EVENTNAME_SPLIT);
	
		    forEach(eventName, function(name) {
		        var handlerItems = self._safeEvent(name);
	
		        if (andByHandler) {
		            self._spliceMatches(handlerItems, matchHandler);
		        } else {
		            forEach(handlerItems, function(item) {
		                self._forgetContext(item.context);
		            });
	
		            self.events[name] = [];
		        }
		    });
		};
	
		/**
		 * Unbind event by handler function
		 * @param {function} handler - handler function
		 * @private
		 */
		CustomEvents.prototype._offByHandler = function(handler) {
		    var self = this;
		    var matchHandler = this._matchHandler(handler);
	
		    collection.forEach(this._safeEvent(), function(handlerItems) {
		        self._spliceMatches(handlerItems, matchHandler);
		    });
		};
	
		/**
		 * Unbind event by object(name: handler pair object or context object)
		 * @param {object} obj - context or {name: handler} pair object
		 * @param {function} handler - handler function
		 * @private
		 */
		CustomEvents.prototype._offByObject = function(obj, handler) {
		    var self = this;
		    var matchFunc;
	
		    if (this._indexOfContext(obj) < 0) {
		        collection.forEach(obj, function(func, name) {
		            self.off(name, func);
		        });
		    } else if (type.isString(handler)) {
		        matchFunc = this._matchContext(obj);
	
		        self._spliceMatches(this._safeEvent(handler), matchFunc);
		    } else if (type.isFunction(handler)) {
		        matchFunc = this._matchHandlerAndContext(handler, obj);
	
		        collection.forEach(this._safeEvent(), function(handlerItems) {
		            self._spliceMatches(handlerItems, matchFunc);
		        });
		    } else {
		        matchFunc = this._matchContext(obj);
	
		        collection.forEach(this._safeEvent(), function(handlerItems) {
		            self._spliceMatches(handlerItems, matchFunc);
		        });
		    }
		};
	
		/**
		 * Unbind custom events
		 * @param {(string|object|function)} eventName - event name or context or
		 *  {name: handler} pair object or handler function
		 * @param {(function)} handler - handler function
		 * @example
		 * //-- #1. Get Module --//
		 * var CustomEvents = require('tui-code-snippet').CustomEvents; // node, commonjs
		 * var CustomEvents = tui.util.CustomEvents; // distribution file
		 *
		 * //-- #2. Use property --//
		 * // # 2.1 off by event name
		 * CustomEvents.off('onload');
		 *
		 * // # 2.2 off by event name and handler
		 * CustomEvents.off('play', handler);
		 *
		 * // # 2.3 off by handler
		 * CustomEvents.off(handler);
		 *
		 * // # 2.4 off by context
		 * CustomEvents.off(myObj);
		 *
		 * // # 2.5 off by context and handler
		 * CustomEvents.off(myObj, handler);
		 *
		 * // # 2.6 off by context and event name
		 * CustomEvents.off(myObj, 'onload');
		 *
		 * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
		 * CustomEvents.off({
		 *   'play': handler,
		 *   'pause': handler2
		 * });
		 *
		 * // # 2.8 off the all events
		 * CustomEvents.off();
		 */
		CustomEvents.prototype.off = function(eventName, handler) {
		    if (type.isString(eventName)) {
		        // [syntax 1, 2]
		        this._offByEventName(eventName, handler);
		    } else if (!arguments.length) {
		        // [syntax 8]
		        this.events = {};
		        this.contexts = [];
		    } else if (type.isFunction(eventName)) {
		        // [syntax 3]
		        this._offByHandler(eventName);
		    } else if (type.isObject(eventName)) {
		        // [syntax 4, 5, 6]
		        this._offByObject(eventName, handler);
		    }
		};
	
		/**
		 * Fire custom event
		 * @param {string} eventName - name of custom event
		 */
		CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
		    this.invoke.apply(this, arguments);
		};
	
		/**
		 * Fire a event and returns the result of operation 'boolean AND' with all
		 *  listener's results.
		 *
		 * So, It is different from {@link CustomEvents#fire}.
		 *
		 * In service code, use this as a before event in component level usually
		 *  for notifying that the event is cancelable.
		 * @param {string} eventName - Custom event name
		 * @param {...*} data - Data for event
		 * @returns {boolean} The result of operation 'boolean AND'
		 * @example
		 * var map = new Map();
		 * map.on({
		 *     'beforeZoom': function() {
		 *         // It should cancel the 'zoom' event by some conditions.
		 *         if (that.disabled && this.getState()) {
		 *             return false;
		 *         }
		 *         return true;
		 *     }
		 * });
		 *
		 * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
		 *     // if true,
		 *     // doSomething
		 * }
		 */
		CustomEvents.prototype.invoke = function(eventName) {
		    var events, args, index, item;
	
		    if (!this.hasListener(eventName)) {
		        return true;
		    }
	
		    events = this._safeEvent(eventName);
		    args = Array.prototype.slice.call(arguments, 1);
		    index = 0;
	
		    while (events[index]) {
		        item = events[index];
	
		        if (item.handler.apply(item.context, args) === false) {
		            return false;
		        }
	
		        index += 1;
		    }
	
		    return true;
		};
	
		/**
		 * Return whether at least one of the handlers is registered in the given
		 *  event name.
		 * @param {string} eventName - Custom event name
		 * @returns {boolean} Is there at least one handler in event name?
		 */
		CustomEvents.prototype.hasListener = function(eventName) {
		    return this.getListenerLength(eventName) > 0;
		};
	
		/**
		 * Return a count of events registered.
		 * @param {string} eventName - Custom event name
		 * @returns {number} number of event
		 */
		CustomEvents.prototype.getListenerLength = function(eventName) {
		    var events = this._safeEvent(eventName);
	
		    return events.length;
		};
	
		module.exports = CustomEvents;
	
	
	/***/ }),
	/* 17 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview This module provides a Enum Constructor.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 * @example
		 * // node, commonjs
		 * var Enum = require('tui-code-snippet').Enum;
		 * @example
		 * // distribution file, script
		 * <script src='path-to/tui-code-snippt.js'></script>
		 * <script>
		 * var Enum = tui.util.Enum;
		 * <script>
		 */
	
		'use strict';
	
		var collection = __webpack_require__(4);
		var type = __webpack_require__(2);
	
		/**
		 * Check whether the defineProperty() method is supported.
		 * @type {boolean}
		 * @ignore
		 */
		var isSupportDefinedProperty = (function() {
		    try {
		        Object.defineProperty({}, 'x', {});
	
		        return true;
		    } catch (e) {
		        return false;
		    }
		})();
	
		/**
		 * A unique value of a constant.
		 * @type {number}
		 * @ignore
		 */
		var enumValue = 0;
	
		/**
		 * Make a constant-list that has unique values.<br>
		 * In modern browsers (except IE8 and lower),<br>
		 *  a value defined once can not be changed.
		 *
		 * @param {...string|string[]} itemList Constant-list (An array of string is available)
		 * @class
		 * @memberof tui.util
		 * @example
		 * //-- #1. Get Module --//
		 * var Enum = require('tui-code-snippet').Enum; // node, commonjs
		 * var Enum = tui.util.Enum; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var MYENUM = new Enum('TYPE1', 'TYPE2');
		 * var MYENUM2 = new Enum(['TYPE1', 'TYPE2']);
		 *
		 * //usage
		 * if (value === MYENUM.TYPE1) {
		 *      ....
		 * }
		 *
		 * //add (If a duplicate name is inputted, will be disregarded.)
		 * MYENUM.set('TYPE3', 'TYPE4');
		 *
		 * //get name of a constant by a value
		 * MYENUM.getName(MYENUM.TYPE1); // 'TYPE1'
		 *
		 * // In modern browsers (except IE8 and lower), a value can not be changed in constants.
		 * var originalValue = MYENUM.TYPE1;
		 * MYENUM.TYPE1 = 1234; // maybe TypeError
		 * MYENUM.TYPE1 === originalValue; // true
		 **/
		function Enum(itemList) {
		    if (itemList) {
		        this.set.apply(this, arguments);
		    }
		}
	
		/**
		 * Define a constants-list
		 * @param {...string|string[]} itemList Constant-list (An array of string is available)
		 */
		Enum.prototype.set = function(itemList) {
		    var self = this;
	
		    if (!type.isArray(itemList)) {
		        itemList = collection.toArray(arguments);
		    }
	
		    collection.forEach(itemList, function itemListIteratee(item) {
		        self._addItem(item);
		    });
		};
	
		/**
		 * Return a key of the constant.
		 * @param {number} value A value of the constant.
		 * @returns {string|undefined} Key of the constant.
		 */
		Enum.prototype.getName = function(value) {
		    var self = this;
		    var foundedKey;
	
		    collection.forEach(this, function(itemValue, key) { // eslint-disable-line consistent-return
		        if (self._isEnumItem(key) && value === itemValue) {
		            foundedKey = key;
	
		            return false;
		        }
		    });
	
		    return foundedKey;
		};
	
		/**
		 * Create a constant.
		 * @private
		 * @param {string} name Constant name. (It will be a key of a constant)
		 */
		Enum.prototype._addItem = function(name) {
		    var value;
	
		    if (!this.hasOwnProperty(name)) {
		        value = this._makeEnumValue();
	
		        if (isSupportDefinedProperty) {
		            Object.defineProperty(this, name, {
		                enumerable: true,
		                configurable: false,
		                writable: false,
		                value: value
		            });
		        } else {
		            this[name] = value;
		        }
		    }
		};
	
		/**
		 * Return a unique value for assigning to a constant.
		 * @private
		 * @returns {number} A unique value
		 */
		Enum.prototype._makeEnumValue = function() {
		    var value;
	
		    value = enumValue;
		    enumValue += 1;
	
		    return value;
		};
	
		/**
		 * Return whether a constant from the given key is in instance or not.
		 * @param {string} key - A constant key
		 * @returns {boolean} Result
		 * @private
		 */
		Enum.prototype._isEnumItem = function(key) {
		    return type.isNumber(this[key]);
		};
	
		module.exports = Enum;
	
	
	/***/ }),
	/* 18 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview
		 *  Implements the ExMap (Extended Map) object.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var collection = __webpack_require__(4);
		var Map = __webpack_require__(19);
	
		// Caching tui.util for performance enhancing
		var mapAPIsForRead = ['get', 'has', 'forEach', 'keys', 'values', 'entries'];
		var mapAPIsForDelete = ['delete', 'clear'];
	
		/**
		 * The ExMap object is Extended Version of the tui.util.Map object.<br>
		 * and added some useful feature to make it easy to manage the Map object.
		 * @constructor
		 * @param {Array} initData - Array of key-value pairs (2-element Arrays).
		 *      Each key-value pair will be added to the new Map
		 * @memberof tui.util
		 * @example
		 * // node, commonjs
		 * var ExMap = require('tui-code-snippet').ExMap;
		 * @example
		 * // distribution file, script
		 * <script src='path-to/tui-code-snippt.js'></script>
		 * <script>
		 * var ExMap = tui.util.ExMap;
		 * <script>
		 */
		function ExMap(initData) {
		    this._map = new Map(initData);
		    this.size = this._map.size;
		}
	
		collection.forEachArray(mapAPIsForRead, function(name) {
		    ExMap.prototype[name] = function() {
		        return this._map[name].apply(this._map, arguments);
		    };
		});
	
		collection.forEachArray(mapAPIsForDelete, function(name) {
		    ExMap.prototype[name] = function() {
		        var result = this._map[name].apply(this._map, arguments);
		        this.size = this._map.size;
	
		        return result;
		    };
		});
	
		ExMap.prototype.set = function() {
		    this._map.set.apply(this._map, arguments);
		    this.size = this._map.size;
	
		    return this;
		};
	
		/**
		 * Sets all of the key-value pairs in the specified object to the Map object.
		 * @param  {Object} object - Plain object that has a key-value pair
		 */
		ExMap.prototype.setObject = function(object) {
		    collection.forEachOwnProperties(object, function(value, key) {
		        this.set(key, value);
		    }, this);
		};
	
		/**
		 * Removes the elements associated with keys in the specified array.
		 * @param  {Array} keys - Array that contains keys of the element to remove
		 */
		ExMap.prototype.deleteByKeys = function(keys) {
		    collection.forEachArray(keys, function(key) {
		        this['delete'](key);
		    }, this);
		};
	
		/**
		 * Sets all of the key-value pairs in the specified Map object to this Map object.
		 * @param  {Map} map - Map object to be merged into this Map object
		 */
		ExMap.prototype.merge = function(map) {
		    map.forEach(function(value, key) {
		        this.set(key, value);
		    }, this);
		};
	
		/**
		 * Looks through each key-value pair in the map and returns the new ExMap object of
		 * all key-value pairs that pass a truth test implemented by the provided function.
		 * @param  {function} predicate - Function to test each key-value pair of the Map object.<br>
		 *      Invoked with arguments (value, key). Return true to keep the element, false otherwise.
		 * @returns {ExMap} A new ExMap object
		 */
		ExMap.prototype.filter = function(predicate) {
		    var filtered = new ExMap();
	
		    this.forEach(function(value, key) {
		        if (predicate(value, key)) {
		            filtered.set(key, value);
		        }
		    });
	
		    return filtered;
		};
	
		module.exports = ExMap;
	
	
	/***/ }),
	/* 19 */
	/***/ (function(module, exports, __webpack_require__) {
	
		
		/**
		 * @fileoverview
		 *  Implements the Map object.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var collection = __webpack_require__(4);
		var type = __webpack_require__(2);
		var array = __webpack_require__(3);
		var browser = __webpack_require__(10);
		var func = __webpack_require__(5);
	
		/**
		 * Using undefined for a key can be ambiguous if there's deleted item in the array,<br>
		 * which is also undefined when accessed by index.<br>
		 * So use this unique object as an undefined key to distinguish it from deleted keys.
		 * @private
		 * @constant
		 */
		var _KEY_FOR_UNDEFINED = {};
	
		/**
		 * For using NaN as a key, use this unique object as a NaN key.<br>
		 * This makes it easier and faster to compare an object with each keys in the array<br>
		 * through no exceptional comapring for NaN.
		 * @private
		 * @constant
		 */
		var _KEY_FOR_NAN = {};
	
		/**
		 * Constructor of MapIterator<br>
		 * Creates iterator object with new keyword.
		 * @constructor
		 * @param  {Array} keys - The array of keys in the map
		 * @param  {function} valueGetter - Function that returns certain value,
		 *      taking key and keyIndex as arguments.
		 * @ignore
		 */
		function MapIterator(keys, valueGetter) {
		    this._keys = keys;
		    this._valueGetter = valueGetter;
		    this._length = this._keys.length;
		    this._index = -1;
		    this._done = false;
		}
	
		/**
		 * Implementation of Iterator protocol.
		 * @returns {{done: boolean, value: *}} Object that contains done(boolean) and value.
		 */
		MapIterator.prototype.next = function() {
		    var data = {};
		    do {
		        this._index += 1;
		    } while (type.isUndefined(this._keys[this._index]) && this._index < this._length);
	
		    if (this._index >= this._length) {
		        data.done = true;
		    } else {
		        data.done = false;
		        data.value = this._valueGetter(this._keys[this._index], this._index);
		    }
	
		    return data;
		};
	
		/**
		 * The Map object implements the ES6 Map specification as closely as possible.<br>
		 * For using objects and primitive values as keys, this object uses array internally.<br>
		 * So if the key is not a string, get(), set(), has(), delete() will operates in O(n),<br>
		 * and it can cause performance issues with a large dataset.
		 *
		 * Features listed below are not supported. (can't be implented without native support)
		 * - Map object is iterable<br>
		 * - Iterable object can be used as an argument of constructor
		 *
		 * If the browser supports full implementation of ES6 Map specification, native Map obejct
		 * will be used internally.
		 * @class
		 * @param  {Array} initData - Array of key-value pairs (2-element Arrays).
		 *      Each key-value pair will be added to the new Map
		 * @memberof tui.util
		 * @example
		 * // node, commonjs
		 * var Map = require('tui-code-snippet').Map;
		 * @example
		 * // distribution file, script
		 * <script src='path-to/tui-code-snippt.js'></script>
		 * <script>
		 * var Map = tui.util.Map;
		 * <script>
		 */
		function Map(initData) {
		    this._valuesForString = {};
		    this._valuesForIndex = {};
		    this._keys = [];
	
		    if (initData) {
		        this._setInitData(initData);
		    }
	
		    this.size = 0;
		}
	
		/* eslint-disable no-extend-native */
		/**
		 * Add all elements in the initData to the Map object.
		 * @private
		 * @param  {Array} initData - Array of key-value pairs to add to the Map object
		 */
		Map.prototype._setInitData = function(initData) {
		    if (!type.isArray(initData)) {
		        throw new Error('Only Array is supported.');
		    }
		    collection.forEachArray(initData, function(pair) {
		        this.set(pair[0], pair[1]);
		    }, this);
		};
	
		/**
		 * Returns true if the specified value is NaN.<br>
		 * For unsing NaN as a key, use this method to test equality of NaN<br>
		 * because === operator doesn't work for NaN.
		 * @private
		 * @param {*} value - Any object to be tested
		 * @returns {boolean} True if value is NaN, false otherwise.
		 */
		Map.prototype._isNaN = function(value) {
		    return typeof value === 'number' && value !== value; // eslint-disable-line no-self-compare
		};
	
		/**
		 * Returns the index of the specified key.
		 * @private
		 * @param  {*} key - The key object to search for.
		 * @returns {number} The index of the specified key
		 */
		Map.prototype._getKeyIndex = function(key) {
		    var result = -1;
		    var value;
	
		    if (type.isString(key)) {
		        value = this._valuesForString[key];
		        if (value) {
		            result = value.keyIndex;
		        }
		    } else {
		        result = array.inArray(key, this._keys);
		    }
	
		    return result;
		};
	
		/**
		 * Returns the original key of the specified key.
		 * @private
		 * @param  {*} key - key
		 * @returns {*} Original key
		 */
		Map.prototype._getOriginKey = function(key) {
		    var originKey = key;
		    if (key === _KEY_FOR_UNDEFINED) {
		        originKey = undefined; // eslint-disable-line no-undefined
		    } else if (key === _KEY_FOR_NAN) {
		        originKey = NaN;
		    }
	
		    return originKey;
		};
	
		/**
		 * Returns the unique key of the specified key.
		 * @private
		 * @param  {*} key - key
		 * @returns {*} Unique key
		 */
		Map.prototype._getUniqueKey = function(key) {
		    var uniqueKey = key;
		    if (type.isUndefined(key)) {
		        uniqueKey = _KEY_FOR_UNDEFINED;
		    } else if (this._isNaN(key)) {
		        uniqueKey = _KEY_FOR_NAN;
		    }
	
		    return uniqueKey;
		};
	
		/**
		 * Returns the value object of the specified key.
		 * @private
		 * @param  {*} key - The key of the value object to be returned
		 * @param  {number} keyIndex - The index of the key
		 * @returns {{keyIndex: number, origin: *}} Value object
		 */
		Map.prototype._getValueObject = function(key, keyIndex) { // eslint-disable-line consistent-return
		    if (type.isString(key)) {
		        return this._valuesForString[key];
		    }
	
		    if (type.isUndefined(keyIndex)) {
		        keyIndex = this._getKeyIndex(key);
		    }
		    if (keyIndex >= 0) {
		        return this._valuesForIndex[keyIndex];
		    }
		};
	
		/**
		 * Returns the original value of the specified key.
		 * @private
		 * @param  {*} key - The key of the value object to be returned
		 * @param  {number} keyIndex - The index of the key
		 * @returns {*} Original value
		 */
		Map.prototype._getOriginValue = function(key, keyIndex) {
		    return this._getValueObject(key, keyIndex).origin;
		};
	
		/**
		 * Returns key-value pair of the specified key.
		 * @private
		 * @param  {*} key - The key of the value object to be returned
		 * @param  {number} keyIndex - The index of the key
		 * @returns {Array} Key-value Pair
		 */
		Map.prototype._getKeyValuePair = function(key, keyIndex) {
		    return [this._getOriginKey(key), this._getOriginValue(key, keyIndex)];
		};
	
		/**
		 * Creates the wrapper object of original value that contains a key index
		 * and returns it.
		 * @private
		 * @param  {type} origin - Original value
		 * @param  {type} keyIndex - Index of the key
		 * @returns {{keyIndex: number, origin: *}} Value object
		 */
		Map.prototype._createValueObject = function(origin, keyIndex) {
		    return {
		        keyIndex: keyIndex,
		        origin: origin
		    };
		};
	
		/**
		 * Sets the value for the key in the Map object.
		 * @param  {*} key - The key of the element to add to the Map object
		 * @param  {*} value - The value of the element to add to the Map object
		 * @returns {Map} The Map object
		 */
		Map.prototype.set = function(key, value) {
		    var uniqueKey = this._getUniqueKey(key);
		    var keyIndex = this._getKeyIndex(uniqueKey);
		    var valueObject;
	
		    if (keyIndex < 0) {
		        keyIndex = this._keys.push(uniqueKey) - 1;
		        this.size += 1;
		    }
		    valueObject = this._createValueObject(value, keyIndex);
	
		    if (type.isString(key)) {
		        this._valuesForString[key] = valueObject;
		    } else {
		        this._valuesForIndex[keyIndex] = valueObject;
		    }
	
		    return this;
		};
	
		/**
		 * Returns the value associated to the key, or undefined if there is none.
		 * @param  {*} key - The key of the element to return
		 * @returns {*} Element associated with the specified key
		 */
		Map.prototype.get = function(key) {
		    var uniqueKey = this._getUniqueKey(key);
		    var value = this._getValueObject(uniqueKey);
	
		    return value && value.origin;
		};
	
		/**
		 * Returns a new Iterator object that contains the keys for each element
		 * in the Map object in insertion order.
		 * @returns {Iterator} A new Iterator object
		 */
		Map.prototype.keys = function() {
		    return new MapIterator(this._keys, func.bind(this._getOriginKey, this));
		};
	
		/**
		 * Returns a new Iterator object that contains the values for each element
		 * in the Map object in insertion order.
		 * @returns {Iterator} A new Iterator object
		 */
		Map.prototype.values = function() {
		    return new MapIterator(this._keys, func.bind(this._getOriginValue, this));
		};
	
		/**
		 * Returns a new Iterator object that contains the [key, value] pairs
		 * for each element in the Map object in insertion order.
		 * @returns {Iterator} A new Iterator object
		 */
		Map.prototype.entries = function() {
		    return new MapIterator(this._keys, func.bind(this._getKeyValuePair, this));
		};
	
		/**
		 * Returns a boolean asserting whether a value has been associated to the key
		 * in the Map object or not.
		 * @param  {*} key - The key of the element to test for presence
		 * @returns {boolean} True if an element with the specified key exists;
		 *          Otherwise false
		 */
		Map.prototype.has = function(key) {
		    return !!this._getValueObject(key);
		};
	
		/**
		 * Removes the specified element from a Map object.
		 * @param {*} key - The key of the element to remove
		 * @function delete
		 * @memberof tui.util.Map.prototype
		 */
		// cannot use reserved keyword as a property name in IE8 and under.
		Map.prototype['delete'] = function(key) {
		    var keyIndex;
	
		    if (type.isString(key)) {
		        if (this._valuesForString[key]) {
		            keyIndex = this._valuesForString[key].keyIndex;
		            delete this._valuesForString[key];
		        }
		    } else {
		        keyIndex = this._getKeyIndex(key);
		        if (keyIndex >= 0) {
		            delete this._valuesForIndex[keyIndex];
		        }
		    }
	
		    if (keyIndex >= 0) {
		        delete this._keys[keyIndex];
		        this.size -= 1;
		    }
		};
	
		/**
		 * Executes a provided function once per each key/value pair in the Map object,
		 * in insertion order.
		 * @param  {function} callback - Function to execute for each element
		 * @param  {thisArg} thisArg - Value to use as this when executing callback
		 */
		Map.prototype.forEach = function(callback, thisArg) {
		    thisArg = thisArg || this;
		    collection.forEachArray(this._keys, function(key) {
		        if (!type.isUndefined(key)) {
		            callback.call(thisArg, this._getValueObject(key).origin, key, this);
		        }
		    }, this);
		};
	
		/**
		 * Removes all elements from a Map object.
		 */
		Map.prototype.clear = function() {
		    Map.call(this);
		};
		/* eslint-enable no-extend-native */
	
		// Use native Map object if exists.
		// But only latest versions of Chrome and Firefox support full implementation.
		(function() {
		    if (window.Map && (
		        (browser.firefox && browser.version >= 37) ||
		            (browser.chrome && browser.version >= 42)
		    )
		    ) {
		        Map = window.Map; // eslint-disable-line no-func-assign
		    }
		})();
	
		module.exports = Map;
	
	
	/***/ }),
	/* 20 */
	/***/ (function(module, exports, __webpack_require__) {
	
		/**
		 * @fileoverview This module provides the HashMap constructor.
		 * @author NHN Ent.
		 *         FE Development Lab <dl_javascript@nhnent.com>
		 */
	
		'use strict';
	
		var collection = __webpack_require__(4);
		var type = __webpack_require__(2);
		/**
		 * All the data in hashMap begin with _MAPDATAPREFIX;
		 * @type {string}
		 * @private
		 */
		var _MAPDATAPREFIX = 'å';
	
		/**
		 * HashMap can handle the key-value pairs.<br>
		 * Caution:<br>
		 *  HashMap instance has a length property but is not an instance of Array.
		 * @param {Object} [obj] A initial data for creation.
		 * @constructor
		 * @memberof tui.util
		 * @deprecated since version 1.3.0
		 * @example
		 * // node, commonjs
		 * var HashMap = require('tui-code-snippet').HashMap;
		 * var hm = new tui.util.HashMap({
		  'mydata': {
		    'hello': 'imfine'
		  },
		  'what': 'time'
		});
		 * @example
		 * // distribution file, script
		 * <script src='path-to/tui-code-snippt.js'></script>
		 * <script>
		 * var HashMap = tui.util.HashMap;
		 * <script>
		 * var hm = new tui.util.HashMap({
		  'mydata': {
		    'hello': 'imfine'
		  },
		  'what': 'time'
		});
		 */
		function HashMap(obj) {
		    /**
		     * size
		     * @type {number}
		     */
		    this.length = 0;
	
		    if (obj) {
		        this.setObject(obj);
		    }
		}
	
		/**
		 * Set a data from the given key with value or the given object.
		 * @param {string|Object} key A string or object for key
		 * @param {*} [value] A data
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm = new HashMap();
		 * hm.set('key', 'value');
		 * hm.set({
		 *     'key1': 'data1',
		 *     'key2': 'data2'
		 * });
		 */
		HashMap.prototype.set = function(key, value) {
		    if (arguments.length === 2) {
		        this.setKeyValue(key, value);
		    } else {
		        this.setObject(key);
		    }
		};
	
		/**
		 * Set a data from the given key with value.
		 * @param {string} key A string for key
		 * @param {*} value A data
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm = new HashMap();
		 * hm.setKeyValue('key', 'value');
		 */
		HashMap.prototype.setKeyValue = function(key, value) {
		    if (!this.has(key)) {
		        this.length += 1;
		    }
		    this[this.encodeKey(key)] = value;
		};
	
		/**
		 * Set a data from the given object.
		 * @param {Object} obj A object for data
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm = new HashMap();
		 * hm.setObject({
		 *     'key1': 'data1',
		 *     'key2': 'data2'
		 * });
		 */
		HashMap.prototype.setObject = function(obj) {
		    var self = this;
	
		    collection.forEachOwnProperties(obj, function(value, key) {
		        self.setKeyValue(key, value);
		    });
		};
	
		/**
		 * Merge with the given another hashMap.
		 * @param {HashMap} hashMap Another hashMap instance
		 */
		HashMap.prototype.merge = function(hashMap) {
		    var self = this;
	
		    hashMap.each(function(value, key) {
		        self.setKeyValue(key, value);
		    });
		};
	
		/**
		 * Encode the given key for hashMap.
		 * @param {string} key A string for key
		 * @returns {string} A encoded key
		 * @private
		 */
		HashMap.prototype.encodeKey = function(key) {
		    return _MAPDATAPREFIX + key;
		};
	
		/**
		 * Decode the given key in hashMap.
		 * @param {string} key A string for key
		 * @returns {string} A decoded key
		 * @private
		 */
		HashMap.prototype.decodeKey = function(key) {
		    var decodedKey = key.split(_MAPDATAPREFIX);
	
		    return decodedKey[decodedKey.length - 1];
		};
	
		/**
		 * Return the value from the given key.
		 * @param {string} key A string for key
		 * @returns {*} The value from a key
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm = new HashMap();
		 * hm.set('key', 'value');
		 * hm.get('key') // value
		 */
		HashMap.prototype.get = function(key) {
		    return this[this.encodeKey(key)];
		};
	
		/**
		 * Check the existence of a value from the key.
		 * @param {string} key A string for key
		 * @returns {boolean} Indicating whether a value exists or not.
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm = new HashMap();
		 * hm.set('key', 'value');
		 * hm.has('key') // true
		 */
		HashMap.prototype.has = function(key) {
		    return this.hasOwnProperty(this.encodeKey(key));
		};
	
		/**
		 * Remove a data(key-value pairs) from the given key or the given key-list.
		 * @param {...string|string[]} key A string for key
		 * @returns {string|string[]} A removed data
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm = new HashMap();
		 * hm.set('key', 'value');
		 * hm.set('key2', 'value');
		 *
		 * hm.remove('key');
		 * hm.remove('key', 'key2');
		 * hm.remove(['key', 'key2']);
		 */
		HashMap.prototype.remove = function(key) {
		    if (arguments.length > 1) {
		        key = collection.toArray(arguments);
		    }
	
		    return type.isArray(key) ? this.removeByKeyArray(key) : this.removeByKey(key);
		};
	
		/**
		 * Remove data(key-value pair) from the given key.
		 * @param {string} key A string for key
		 * @returns {*|null} A removed data
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm = new HashMap();
		 * hm.set('key', 'value');
		 * hm.removeByKey('key')
		 */
		HashMap.prototype.removeByKey = function(key) {
		    var data = this.has(key) ? this.get(key) : null;
	
		    if (data !== null) {
		        delete this[this.encodeKey(key)];
		        this.length -= 1;
		    }
	
		    return data;
		};
	
		/**
		 * Remove a data(key-value pairs) from the given key-list.
		 * @param {string[]} keyArray An array of keys
		 * @returns {string[]} A removed data
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm = new HashMap();
		 * hm.set('key', 'value');
		 * hm.set('key2', 'value');
		 * hm.removeByKeyArray(['key', 'key2']);
		 */
		HashMap.prototype.removeByKeyArray = function(keyArray) {
		    var data = [];
		    var self = this;
	
		    collection.forEach(keyArray, function(key) {
		        data.push(self.removeByKey(key));
		    });
	
		    return data;
		};
	
		/**
		 * Remove all the data
		 */
		HashMap.prototype.removeAll = function() {
		    var self = this;
	
		    this.each(function(value, key) {
		        self.remove(key);
		    });
		};
	
		/**
		 * Execute the provided callback once for each all the data.
		 * @param {Function} iteratee Callback function
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm = new HashMap();
		 * hm.set('key', 'value');
		 * hm.set('key2', 'value');
		 *
		 * hm.each(function(value, key) {
		 *     //do something...
		 * });
		 */
		HashMap.prototype.each = function(iteratee) {
		    var self = this;
		    var flag;
	
		    collection.forEachOwnProperties(this, function(value, key) { // eslint-disable-line consistent-return
		        if (key.charAt(0) === _MAPDATAPREFIX) {
		            flag = iteratee(value, self.decodeKey(key));
		        }
	
		        if (flag === false) {
		            return flag;
		        }
		    });
		};
	
		/**
		 * Return the key-list stored.
		 * @returns {Array} A key-list
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 *  var hm = new HashMap();
		 *  hm.set('key', 'value');
		 *  hm.set('key2', 'value');
		 *  hm.keys();  //['key', 'key2');
		 */
		HashMap.prototype.keys = function() {
		    var keys = [];
		    var self = this;
	
		    this.each(function(value, key) {
		        keys.push(self.decodeKey(key));
		    });
	
		    return keys;
		};
	
		/**
		 * Work similarly to Array.prototype.map().<br>
		 * It executes the provided callback that checks conditions once for each element of hashMap,<br>
		 *  and returns a new array having elements satisfying the conditions
		 * @param {Function} condition A function that checks conditions
		 * @returns {Array} A new array having elements satisfying the conditions
		 * @example
		 * //-- #1. Get Module --//
		 * var HashMap = require('tui-code-snippet').HashMap; // node, commonjs
		 * var HashMap = tui.util.HashMap; // distribution file
		 *
		 * //-- #2. Use property --//
		 * var hm1 = new HashMap();
		 * hm1.set('key', 'value');
		 * hm1.set('key2', 'value');
		 *
		 * hm1.find(function(value, key) {
		 *     return key === 'key2';
		 * }); // ['value']
		 *
		 * var hm2 = new HashMap({
		 *     'myobj1': {
		 *         visible: true
		 *     },
		 *     'mybobj2': {
		 *         visible: false
		 *     }
		 * });
		 *
		 * hm2.find(function(obj, key) {
		 *     return obj.visible === true;
		 * }); // [{visible: true}];
		 */
		HashMap.prototype.find = function(condition) {
		    var founds = [];
	
		    this.each(function(value, key) {
		        if (condition(value, key)) {
		            founds.push(value);
		        }
		    });
	
		    return founds;
		};
	
		/**
		 * Return a new Array having all values.
		 * @returns {Array} A new array having all values
		 */
		HashMap.prototype.toArray = function() {
		    var result = [];
	
		    this.each(function(v) {
		        result.push(v);
		    });
	
		    return result;
		};
	
		module.exports = HashMap;
	
	
	/***/ })
	/******/ ])
	});
	;

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
	                                                                                                                                                                                                     * @fileoverview Util for rendering.
	                                                                                                                                                                                                     * @author NHN.
	                                                                                                                                                                                                     *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                     */
	
	var browser = _tuiCodeSnippet2['default'].browser;
	
	var _isOldBrowser = browser.msie && browser.version <= 8;
	var hasComputedStyle = window.getComputedStyle || false;
	var CLIP_RECT_ID = 'clipRectForAnimation';
	var lineBaseChartCount = 0;
	
	/**
	 * Util for rendering.
	 * @module renderUtil
	 * @private */
	var renderUtil = {
	    /**
	     * Concat string.
	     * @params {...string} target strings
	     * @returns {string} concat string
	     * @memberof module:renderUtil
	     */
	    concatStr: function concatStr() {
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return String.prototype.concat.apply('', args);
	    },
	
	
	    /**
	     * oneline trim tag for template literal
	     * @params {...string} target strings
	     * @returns {string} templating string
	     * @memberof module:renderUtil
	     */
	    oneLineTrim: function oneLineTrim() {
	        var normalTag = function normalTag(template) {
	            for (var _len2 = arguments.length, expressions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	                expressions[_key2 - 1] = arguments[_key2];
	            }
	
	            return template.reduce(function (accumulator, part, i) {
	                return accumulator + expressions[i - 1] + part;
	            });
	        };
	
	        return normalTag.apply(undefined, arguments).replace(/\n\s*/g, '');
	    },
	
	
	    /**
	     * Make cssText for font.
	     * @param {{fontSize: number, fontFamily: string, color: string}} theme font theme
	     * @returns {string} cssText
	     * @memberof module:renderUtil
	     */
	    makeFontCssText: function makeFontCssText() {
	        var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	
	        var cssTexts = [];
	
	        if (theme.fontSize) {
	            cssTexts.push(this.concatStr('font-size:', theme.fontSize, 'px'));
	        }
	
	        if (theme.fontFamily) {
	            cssTexts.push(this.concatStr('font-family:', theme.fontFamily));
	        }
	
	        if (theme.color) {
	            cssTexts.push(this.concatStr('color:', theme.color));
	        }
	
	        if (theme.fontWeight) {
	            cssTexts.push(this.concatStr('font-weight:', theme.fontWeight));
	        }
	
	        return cssTexts.length ? cssTexts.join(';') : '';
	    },
	
	
	    /**
	     * Make caching key.
	     * @param {string} label labek
	     * @param {{fontSize: number, fontFamily: string}} theme theme
	     * @param {string} offsetType offset type (offsetWidth or offsetHeight)
	     * @returns {string} key
	     * @private
	     */
	    _makeCachingKey: function _makeCachingKey(label, theme, offsetType) {
	        var keys = [label, offsetType];
	
	        _tuiCodeSnippet2['default'].forEach(theme, function (key, value) {
	            keys.push(key + value);
	        });
	
	        return keys.join('-');
	    },
	
	
	    /**
	     * Add css style.
	     * @param {HTMLElement} div div element
	     * @param {{fontSize: number, fontFamily: string, cssText: string}} theme theme
	     * @private
	     */
	    _addCssStyle: function _addCssStyle(div) {
	        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	            fontSize = _ref.fontSize,
	            fontFamily = _ref.fontFamily,
	            fontWeight = _ref.fontWeight,
	            cssText = _ref.cssText;
	
	        div.style.fontSize = (fontSize || _const2['default'].DEFAULT_LABEL_FONT_SIZE) + 'px';
	
	        if (fontFamily) {
	            div.style.fontFamily = fontFamily;
	        }
	
	        if (fontWeight) {
	            div.style.fontWeight = fontWeight;
	        }
	
	        if (cssText) {
	            div.style.cssText += cssText;
	        }
	    },
	
	
	    /**
	     * Size cache.
	     * @type {object}
	     * @private
	     */
	    sizeCache: {},
	
	    /**
	     * Get rendered label size (width or height).
	     * @memberOf module:renderUtil
	     * @param {string | number} label label
	     * @param {object} theme theme
	     * @param {string} offsetType offset type (offsetWidth or offsetHeight)
	     * @returns {number} size
	     * @private
	     */
	    _getRenderedLabelSize: function _getRenderedLabelSize() {
	        var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	        var theme = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	        var offsetType = arguments[2];
	
	        label = String(label);
	
	        if (!label) {
	            return 0;
	        }
	
	        var key = this._makeCachingKey(label, theme, offsetType);
	        var labelSize = this.sizeCache[key];
	
	        if (!labelSize) {
	            var div = this._createSizeCheckEl();
	            var span = div.firstChild;
	
	            span.innerHTML = label;
	
	            this._addCssStyle(div, theme);
	
	            document.body.appendChild(div);
	            labelSize = span[offsetType];
	            document.body.removeChild(div);
	
	            this.sizeCache[key] = labelSize;
	        }
	
	        return labelSize;
	    },
	
	
	    checkEl: null,
	    /**
	     * Create element for size check.
	     * @memberof module:renderUtil
	     * @returns {HTMLElement} element
	     * @private
	     */
	    _createSizeCheckEl: function _createSizeCheckEl() {
	        if (!this.checkEl) {
	            var div = _domHandler2['default'].create('DIV', 'tui-chart-size-check-element');
	            var span = _domHandler2['default'].create('SPAN');
	            div.appendChild(span);
	            this.checkEl = div;
	        } else {
	            this.checkEl.style.cssText = '';
	        }
	
	        return this.checkEl;
	    },
	
	
	    /**
	     * Get rendered label width.
	     * @memberof module:renderUtil
	     * @param {string} label label
	     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
	     * @returns {number} width
	     */
	    getRenderedLabelWidth: function getRenderedLabelWidth(label, theme) {
	        return this._getRenderedLabelSize(label, theme, 'offsetWidth');
	    },
	
	
	    /**
	     * Get rendered label height.
	     * @memberof module:renderUtil
	     * @param {string} label label
	     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
	     * @returns {number} height
	     */
	    getRenderedLabelHeight: function getRenderedLabelHeight(label, theme) {
	        return this._getRenderedLabelSize(label, theme, 'offsetHeight');
	    },
	
	
	    /**
	     * Get Rendered Labels Max Size(width or height).
	     * @memberof module:renderUtil
	     * @param {string[]} labels labels
	     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
	     * @param {function} iteratee iteratee
	     * @returns {number} max size (width or height)
	     * @private
	     */
	    _getRenderedLabelsMaxSize: function _getRenderedLabelsMaxSize(labels, theme, iteratee) {
	        var maxSize = 0;
	
	        if (labels && labels.length) {
	            var sizes = _tuiCodeSnippet2['default'].map(labels, function (label) {
	                return iteratee(label, theme);
	            });
	            maxSize = _arrayUtil2['default'].max(sizes);
	        }
	
	        return maxSize;
	    },
	
	
	    /**
	     * Get rendered labels max width.
	     * @memberof module:renderUtil
	     * @param {string[]} labels labels
	     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
	     * @returns {number} max width
	     * @private
	     */
	    getRenderedLabelsMaxWidth: function getRenderedLabelsMaxWidth(labels, theme) {
	        var iteratee = _tuiCodeSnippet2['default'].bind(this.getRenderedLabelWidth, this);
	        var maxWidth = this._getRenderedLabelsMaxSize(labels, theme, iteratee);
	
	        return maxWidth;
	    },
	
	
	    /**
	     * Get rendered labels max height.
	     * @memberof module:renderUtil
	     * @param {string[]} labels labels
	     * @param {{fontSize: number, fontFamily: string, color: string}} theme label theme
	     * @returns {number} max height
	     */
	    getRenderedLabelsMaxHeight: function getRenderedLabelsMaxHeight(labels, theme) {
	        var iteratee = _tuiCodeSnippet2['default'].bind(this.getRenderedLabelHeight, this);
	        var maxHeight = this._getRenderedLabelsMaxSize(labels, theme, iteratee);
	
	        return maxHeight;
	    },
	
	
	    /**
	     * Render dimension.
	     * @memberof module:renderUtil
	     * @param {HTMLElement} el target element
	     * @param {{width: number, height: number}} dimension dimension
	     */
	    renderDimension: function renderDimension(el, _ref2) {
	        var _ref2$width = _ref2.width,
	            width = _ref2$width === undefined ? 0 : _ref2$width,
	            _ref2$height = _ref2.height,
	            height = _ref2$height === undefined ? 0 : _ref2$height;
	
	        el.style.cssText = [this.concatStr('width:', width, 'px'), this.concatStr('height:', height, 'px')].join(';');
	    },
	
	
	    /**
	     * Render position(top, right).
	     * @memberof module:renderUtil
	     * @param {HTMLElement} el target element
	     * @param {{top: number, left: number, right: number}} position position
	     */
	    renderPosition: function renderPosition(el, position) {
	        if (_tuiCodeSnippet2['default'].isUndefined(position)) {
	            return;
	        }
	
	        _tuiCodeSnippet2['default'].forEachArray(['top', 'bottom', 'left', 'right'], function (key) {
	            var value = position[key];
	
	            if (_tuiCodeSnippet2['default'].isNumber(value)) {
	                el.style[key] = value + 'px';
	            }
	        });
	    },
	
	
	    /**
	     * Render background.
	     * @memberof module:renderUtil
	     * @param {HTMLElement} el target element
	     * @param {string} background background option
	     */
	    renderBackground: function renderBackground(el, background) {
	        if (background) {
	            el.style.background = background;
	        }
	    },
	
	
	    /**
	     * Render font family.
	     * @memberof module:renderUtil
	     * @param {HTMLElement} el target element
	     * @param {string} fontFamily font family option
	     */
	    renderFontFamily: function renderFontFamily(el, fontFamily) {
	        if (!fontFamily) {
	            return;
	        }
	
	        el.style.fontFamily = fontFamily;
	    },
	
	
	    /**
	     * Render title.
	     * @memberof module:renderUtil
	     * @param {string} title title
	     * @param {{fontSize: number, color: string, background: string}} theme title theme
	     * @param {string} className css class name
	     * @returns {HTMLElement} title element
	     */
	    renderTitle: function renderTitle(title, theme, className) {
	        if (!title) {
	            return null;
	        }
	
	        var cssText = renderUtil.makeFontCssText(theme);
	        var elTitle = _domHandler2['default'].create('DIV', className);
	        elTitle.innerHTML = title;
	
	        if (theme.background) {
	            cssText += ';' + this.concatStr('background:', theme.background);
	        }
	
	        elTitle.style.cssText = cssText;
	
	        return elTitle;
	    },
	
	
	    /**
	     * Expand dimension.
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }} bound series bound
	     * @returns {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }} expended bound
	     * @memberof module:renderUtil
	     */
	    expandBound: function expandBound(_ref3) {
	        var dimension = _ref3.dimension,
	            position = _ref3.position;
	
	        return {
	            dimension: {
	                width: dimension.width + _const2['default'].SERIES_EXPAND_SIZE * 2,
	                height: dimension.height + _const2['default'].SERIES_EXPAND_SIZE * 2
	            },
	            position: {
	                left: position.left - _const2['default'].SERIES_EXPAND_SIZE,
	                top: position.top - _const2['default'].SERIES_EXPAND_SIZE
	            }
	        };
	    },
	
	
	    /**
	     * Proper case.
	     * @param {string} value - string value
	     * @returns {string}
	     */
	    _properCase: function _properCase(value) {
	        return value.substring(0, 1).toUpperCase() + value.substring(1);
	    },
	
	
	    /**
	     * Make mouse event detector name.
	     * @param {string} prefix prefix
	     * @param {string} value value
	     * @param {string} suffix suffix
	     * @returns {string} mouse event detector name
	     * @memberof module:renderUtil
	     */
	    makeMouseEventDetectorName: function makeMouseEventDetectorName(prefix, value, suffix) {
	        return prefix + this._properCase(value) + this._properCase(suffix);
	    },
	
	
	    /**
	     * Format value.
	     * @param {object} params - raw data
	     *     @param {number} params.value value
	     *     @param {Array.<function>} params.formatFunctions - functions for format
	     *     @param {string} params.chartType - type of chart
	     *     @param {string} params.areaType - type of area like yAxis, xAxis, series, circleLegend
	     *     @param {string} [params.valueType] - type of value
	     *     @param {string} [params.legendName] - legendName
	     * @returns {string} formatted value
	     * @memberof module:renderUtil
	     */
	    formatValue: function formatValue(params) {
	        var value = params.value,
	            formatFunctions = params.formatFunctions,
	            _params$valueType = params.valueType,
	            valueType = _params$valueType === undefined ? 'value' : _params$valueType,
	            areaType = params.areaType,
	            legendName = params.legendName,
	            chartType = params.chartType;
	
	        var fns = [String(value)].concat(_toConsumableArray(formatFunctions || []));
	
	        return _tuiCodeSnippet2['default'].reduce(fns, function (stored, fn) {
	            return fn(stored, chartType, areaType, valueType, legendName);
	        });
	    },
	
	    /**
	     * Format values.
	     * @param {Array.<number>} values values
	     * @param {Array.<function>} formatFunctions functions for format
	     * @param {object} typeInfos - type of chart
	     *     @param {string} typeInfos.chartType - type of chart
	     *     @param {string} typeInfos.areaType - type of area like yAxis, xAxis, series, circleLegend
	     *     @param {string} typeInfos.valueType - type of value
	     * @returns {Array.<string>}
	     * @memberof module:renderUtil
	     */
	    formatValues: function formatValues(values, formatFunctions) {
	        var typeInfos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	        var chartType = typeInfos.chartType,
	            areaType = typeInfos.areaType,
	            valueType = typeInfos.valueType;
	
	
	        if (!formatFunctions || !formatFunctions.length) {
	            return values;
	        }
	
	        return _tuiCodeSnippet2['default'].map(values, function (value) {
	            return renderUtil.formatValue({
	                value: value,
	                formatFunctions: formatFunctions,
	                chartType: chartType,
	                areaType: areaType,
	                valueType: valueType
	            });
	        });
	    },
	
	
	    /**
	     * Format date.
	     * @param {string | number | date} value - value
	     * @param {string} format - date format
	     * @returns {string}
	     * @memberof module:renderUtil
	     */
	    formatDate: function formatDate(value) {
	        var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _const2['default'].DEFAULT_DATE_FORMAT;
	
	        var date = _tuiCodeSnippet2['default'].isDate(value) ? value : new Date(value);
	
	        return _tuiCodeSnippet2['default'].formatDate(format, date) || value;
	    },
	
	
	    /**
	     * Format dates.
	     * @param {Array.<string | number | date>} values - values
	     * @param {string} format - date format
	     * @returns {Array}
	     * @memberof module:renderUtil
	     */
	    formatDates: function formatDates(values) {
	        var _this = this;
	
	        var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _const2['default'].DEFAULT_DATE_FORMAT;
	
	        return _tuiCodeSnippet2['default'].map(values, function (value) {
	            return _this.formatDate(value, format);
	        });
	    },
	
	
	    /**
	     * Cancel animation
	     * @param {{id: number}} animation animaion object
	     * @memberof module:renderUtil
	     */
	    cancelAnimation: function cancelAnimation(animation) {
	        if (animation && animation.id) {
	            cancelAnimationFrame(animation.id);
	            delete animation.id;
	        }
	    },
	
	
	    /**
	     * Start animation.
	     * @param {number} animationTime - animation time
	     * @param {function} onAnimation - animation callback function
	     * @param {function} onCompleted - completed callback function
	     * @returns {{id: number}} requestAnimationFrame id
	     * @memberof module:renderUtil
	     */
	    startAnimation: function startAnimation(animationTime, onAnimation, onCompleted) {
	        var animation = {};
	        var startTime = new Date().getTime();
	
	        /**
	         * Animate.
	         */
	        function animate() {
	            var diffTime = new Date().getTime() - startTime;
	            var ratio = Math.min(diffTime / animationTime, 1);
	
	            onAnimation(ratio);
	
	            if (ratio === 1) {
	                delete animation.id;
	                if (onCompleted) {
	                    onCompleted();
	                }
	            } else {
	                animation.id = requestAnimationFrame(animate);
	            }
	        }
	
	        animation.id = requestAnimationFrame(animate);
	
	        return animation;
	    },
	
	
	    /**
	     * Whether oldBrowser or not.
	     * @memberof module:renderUtil
	     * @returns {boolean} result boolean
	     */
	    isOldBrowser: function isOldBrowser() {
	        return _isOldBrowser;
	    },
	
	
	    /**
	     * Format to zero fill.
	     * @param {string} value target value
	     * @param {number} len length of result
	     * @returns {string} formatted value
	     * @private
	     */
	    formatToZeroFill: function formatToZeroFill(value, len) {
	        var zero = '0';
	
	        value = String(value);
	
	        if (value.length >= len) {
	            return value;
	        }
	
	        while (value.length < len) {
	            value = zero + value;
	        }
	
	        return value;
	    },
	
	
	    /**
	     * Format to Decimal.
	     * @param {string} value target value
	     * @param {number} len length of under decimal point
	     * @returns {string} formatted value
	     * @memberof module:renderUtil
	     */
	    formatToDecimal: function formatToDecimal(value, len) {
	        var DECIMAL = 10;
	        var pow = Math.pow(DECIMAL, len);
	
	        if (len === 0) {
	            return Math.round(value);
	        }
	
	        value = Math.round(value * pow) / pow;
	        value = parseFloat(value).toFixed(len);
	
	        return value;
	    },
	
	
	    /**
	     * Format to Comma.
	     * @param {string} value target value
	     * @returns {string} formatted value
	     * @private
	     */
	    formatToComma: function formatToComma(value) {
	        value = String(value);
	        var comma = ',';
	        var betweenLen = 3;
	        var orgValue = value;
	        var sign = value.indexOf('-') > -1 ? '-' : '';
	        var underPointValue = '';
	        var values = void 0;
	        var lastIndex = void 0;
	        var formattedValue = void 0;
	
	        if (value.indexOf('.') > -1) {
	            values = value.split('.');
	            value = String(Math.abs(values[0]));
	            underPointValue = '.' + values[1];
	        } else {
	            value = String(Math.abs(value));
	        }
	
	        if (value.length <= betweenLen) {
	            formattedValue = orgValue;
	        } else {
	            var _ref4;
	
	            values = value.split('').reverse();
	            lastIndex = values.length - 1;
	            values = _tuiCodeSnippet2['default'].map(values, function (char, index) {
	                var result = [char];
	                if (index < lastIndex && (index + 1) % betweenLen === 0) {
	                    result.push(comma);
	                }
	
	                return result;
	            });
	            formattedValue = sign + (_ref4 = []).concat.apply(_ref4, _toConsumableArray(values)).reverse().join('') + underPointValue;
	        }
	
	        return formattedValue;
	    },
	
	
	    /**
	     * Make cssText from map.
	     * @param {object} cssMap - css map
	     * @returns {string}
	     * @memberof module:renderUtil
	     */
	    makeCssTextFromMap: function makeCssTextFromMap(cssMap) {
	        return _tuiCodeSnippet2['default'].map(cssMap, function (value, name) {
	            return renderUtil.concatStr(name, ':', value);
	        }).join(';');
	    },
	
	
	    /**
	     * Perse String.
	     * @param {string} value - string
	     * @returns {string}
	     */
	    _perseString: function _perseString(value) {
	        return typeof value === 'string' || typeof value === 'number' ? String(value) : '';
	    },
	
	
	    /**
	     * Add prefix or suffix to label.
	     * @param {array} labels - labels
	     * @param {string} prefix - string
	     * @param {string} suffix - string
	     * @returns {array}
	     * @memberof module:renderUtil
	     */
	    addPrefixSuffix: function addPrefixSuffix(labels) {
	        var _this2 = this;
	
	        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	        var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	
	        prefix = this._perseString(prefix);
	        suffix = this._perseString(suffix);
	
	        if (!(prefix === '' && suffix === '')) {
	            return _tuiCodeSnippet2['default'].map(labels, function (label) {
	                return _this2.addPrefixSuffixItem(label, prefix, suffix);
	            });
	        }
	
	        return labels;
	    },
	
	
	    /**
	     * Add prefix or suffix for one item
	     * @param {string} label - labels
	     * @param {string} prefix - string
	     * @param {string} suffix - string
	     * @returns {string}
	     * @memberof module:renderUtil
	     */
	    addPrefixSuffixItem: function addPrefixSuffixItem(label) {
	        var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	        var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	
	        prefix = this._perseString(prefix);
	        suffix = this._perseString(suffix);
	
	        return prefix + label + suffix;
	    },
	
	
	    /**
	     * Returns element's style value defined at css file
	     * @param {HTMLElement} target - Current element
	     * @returns {Object} Style object of element
	     * @memberof module:renderUtil
	     */
	    getStyle: function getStyle(target) {
	        var computedObj = void 0;
	
	        if (hasComputedStyle) {
	            computedObj = window.getComputedStyle(target, '');
	        } else {
	            computedObj = target.currentStyle;
	        }
	
	        return computedObj;
	    },
	
	
	    /**
	     * Get clip rect id
	     * @returns {string} create unique id by line base chart count
	     */
	    generateClipRectId: function generateClipRectId() {
	        var id = CLIP_RECT_ID + lineBaseChartCount;
	        lineBaseChartCount += 1;
	
	        return id;
	    }
	};
	
	/**
	 * Set css opacity.
	 * @param {HTMLElement | Array.<HTMLElement>} elements - elements
	 * @param {function} iteratee - iteratee
	 * @ignore
	 */
	function setOpacity(elements, iteratee) {
	    elements = _tuiCodeSnippet2['default'].isArray(elements) ? elements : [elements];
	    _tuiCodeSnippet2['default'].forEachArray(elements, iteratee);
	}
	
	/**
	 * Make filter opacity css string.
	 * @param {number} opacity - opacity
	 * @returns {string}
	 * @ignore
	 */
	function makeCssFilterOpacityString(opacity) {
	    return 'alpha(opacity=' + opacity * _const2['default'].OLD_BROWSER_OPACITY_100 + ')';
	}
	
	if (_isOldBrowser) {
	    /**
	     * Make opacity css text for old browser(IE7, IE8).
	     * @param {number} opacity - opacity
	     * @returns {string}
	     */
	    renderUtil.makeOpacityCssText = function (opacity) {
	        var cssText = '';
	
	        if (_tuiCodeSnippet2['default'].isExisty(opacity)) {
	            var cssOpacityString = makeCssFilterOpacityString(opacity);
	            cssText = ';filter:' + cssOpacityString;
	        }
	
	        return cssText;
	    };
	
	    /**
	     * Set css opacity for old browser(IE7, IE8).
	     * @param {HTMLElement | Array.<HTMLElement>} elements - elements
	     * @param {number} opacity - opacity
	     */
	    renderUtil.setOpacity = function (elements, opacity) {
	        var filter = makeCssFilterOpacityString(opacity);
	        setOpacity(elements, function (element) {
	            element.style.filter = filter;
	        });
	    };
	} else {
	    /**
	     * Make opacity css text for browser supporting opacity property of CSS3.
	     * @param {number} opacity - opacity
	     * @returns {string}
	     */
	    renderUtil.makeOpacityCssText = function (opacity) {
	        var cssText = '';
	
	        if (_tuiCodeSnippet2['default'].isExisty(opacity)) {
	            cssText = ';opacity:' + opacity;
	        }
	
	        return cssText;
	    };
	
	    /**
	     * Set css opacity for browser supporting opacity property of CSS3.
	     * @param {HTMLElement | Array.<HTMLElement>} elements - elements
	     * @param {number} opacity - opacity
	     */
	    renderUtil.setOpacity = function (elements, opacity) {
	        setOpacity(elements, function (element) {
	            element.style.opacity = opacity;
	        });
	    };
	}
	
	exports['default'] = renderUtil;

/***/ }),
/* 335 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	/**
	 * @fileoverview Chart const
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	/**
	 * Chart const
	 * @readonly
	 * @enum {number|string}
	 * @private
	 */
	exports['default'] = {
	  /** tui class names
	   * @type {string}
	   */
	  CLASS_NAME_LEGEND_LABEL: 'tui-chart-legend-label',
	  /** @type {string} */
	  CLASS_NAME_LEGEND_CHECKBOX: 'tui-chart-legend-checkbox',
	  /** @type {string} */
	  CLASS_NAME_SERIES_LABEL: 'tui-chart-series-label',
	  /** @type {string} */
	  CLASS_NAME_SERIES_LEGEND: 'tui-chart-series-legend',
	  /** @type {string} */
	  CLASS_NAME_RESET_ZOOM_BTN: 'tui-chart-reset-zoom-btn',
	  /** @type {string} */
	  CLASS_NAME_ZOOM_OUT_BTN: 'tui-chart-zoom-out-btn',
	  /** @type {string} */
	  CLASS_NAME_CHART_EXPORT_MENU_AREA: 'tui-chart-chartExportMenu-area',
	  /** @type {string} */
	  CLASS_NAME_CHART_EXPORT_MENU_ITEM: 'tui-chart-chartExportMenu-item',
	  /** @type {string} */
	  CLASS_NAME_CHART_EXPORT_MENU_BUTTON: 'tui-chart-chartExportMenu-button',
	  /** @type {string} */
	  CLASS_NAME_CHART_EXPORT_MENU_HEAD: 'tui-chart-chartExportMenu-head',
	  CLASS_NAME_CHART_EXPORT_MENU_BODY: 'tui-chart-chartExportMenu-body',
	  CLASS_NAME_TOOLTIP_VALUE: 'tui-chart-tooltip-value',
	  /** @type {string} */
	  CLASS_NAME_TOOLTIP_HEAD: 'tui-chart-tooltip-head',
	  /** @type {string} */
	  CLASS_NAME_TOOLTIP_BODY: 'tui-chart-tooltip-body',
	  /** @type {string} */
	  CLASS_NAME_SVG_AUTOSHAPE: 'auto-shape-rendering',
	  /** chart type
	   * @type {string}
	   */
	  CHART_TYPE_BAR: 'bar',
	  /** @type {string} */
	  CHART_TYPE_COLUMN: 'column',
	  /** @type {string} */
	  CHART_TYPE_LINE: 'line',
	  /** @type {string} */
	  CHART_TYPE_AREA: 'area',
	  /** @type {string} */
	  CHART_TYPE_COMBO: 'combo',
	  /** @type {string} */
	  CHART_TYPE_COLUMN_LINE_COMBO: 'columnLineCombo',
	  /** @type {string} */
	  CHART_TYPE_LINE_SCATTER_COMBO: 'lineScatterCombo',
	  /** @type {string} */
	  CHART_TYPE_LINE_AREA_COMBO: 'lineAreaCombo',
	  /** @type {string} */
	  CHART_TYPE_PIE_DONUT_COMBO: 'pieDonutCombo',
	  /** @type {string} */
	  CHART_TYPE_PIE: 'pie',
	  /** @type {string} */
	  CHART_TYPE_BUBBLE: 'bubble',
	  /** @type {string} */
	  CHART_TYPE_SCATTER: 'scatter',
	  /** @type {string} */
	  CHART_TYPE_HEATMAP: 'heatmap',
	  /** @type {string} */
	  CHART_TYPE_TREEMAP: 'treemap',
	  /** @type {string} */
	  CHART_TYPE_MAP: 'map',
	  /** @type {string} */
	  CHART_TYPE_RADIAL: 'radial',
	  /** @type {string} */
	  CHART_TYPE_BOXPLOT: 'boxplot',
	  /** @type {string} */
	  CHART_TYPE_BULLET: 'bullet',
	  /** chart padding */
	  CHART_PADDING: 10,
	  /** chart default width */
	  CHART_DEFAULT_WIDTH: 500,
	  /** chart default height */
	  CHART_DEFAULT_HEIGHT: 400,
	  /** overlapping width of xAxis and yAxis */
	  OVERLAPPING_WIDTH: 1,
	  /** rendered text padding */
	  TEXT_PADDING: 2,
	  /** series expand size */
	  SERIES_EXPAND_SIZE: 10,
	  /** series area vertical padding */
	  SERIES_AREA_V_PADDING: 10,
	  /** series label padding */
	  SERIES_LABEL_PADDING: 5,
	  /** series event margins for the value zero */
	  SERIES_EXTRA_EVENT_AREA_FOR_ZERO: 2,
	  /** default font size of title */
	  DEFAULT_TITLE_FONT_SIZE: 14,
	  /** default font size of axis title */
	  DEFAULT_AXIS_TITLE_FONT_SIZE: 10,
	  /** default font size of label */
	  DEFAULT_LABEL_FONT_SIZE: 12,
	  /** default font size of series label */
	  DEFAULT_SERIES_LABEL_FONT_SIZE: 11,
	  /** default graph plugin
	   * @type {string}
	   */
	  DEFAULT_PLUGIN: 'Raphael',
	  /** default tick color
	   * @type {string}
	   */
	  DEFAULT_TICK_COLOR: 'black',
	  /** default theme name
	   * @type {string}
	   */
	  DEFAULT_THEME_NAME: 'default',
	  MAX_HEIGHT_WORD: 'A',
	  /** stack type
	   * @type {string}
	   */
	  NORMAL_STACK_TYPE: 'normal',
	  /** @type {string} */
	  PERCENT_STACK_TYPE: 'percent',
	  /** default stack
	   * @type {string}
	   */
	  DEFAULT_STACK: '___DEFAULT___STACK___',
	  /** dummy key
	   * @type {string}
	   */
	  DUMMY_KEY: '___DUMMY___KEY___',
	  /** root id of treemap
	   * @type {string}
	   */
	  TREEMAP_ROOT_ID: '___TUI_TREEMAP_ROOT___',
	  /** id prefix of treemap
	   * @type {string}
	   */
	  TREEMAP_ID_PREFIX: '___TUI_TREEMAP_ID___',
	  /** prefix for caching seriesItems
	   * @type {string}
	   */
	  TREEMAP_DEPTH_KEY_PREFIX: '___TUI_TREEMAP_DEPTH___',
	  /** @type {string} */
	  TREEMAP_PARENT_KEY_PREFIX: '___TUI_TREEMAP_PARENT___',
	  /** @type {string} */
	  TREEMAP_LEAF_KEY_PREFIX: '___TUI_TREEMAP_LEAF___',
	  /** @type {string} */
	  TREEMAP_LIMIT_DEPTH_KEY_PREFIX: '___TUI_TREEMAP_LIMIT_DEPTH___',
	  /** default border color for treemap chart
	   * @type {string}
	   */
	  TREEMAP_DEFAULT_BORDER: '#ffffff',
	  TREEMAP_DEFAULT_BORDER_WIDTH: 4,
	  /** empty axis label */
	  EMPTY_AXIS_LABEL: '',
	  /** angel */
	  ANGLE_85: 85,
	  ANGLE_90: 90,
	  ANGLE_360: 360,
	  /** radian */
	  RAD: Math.PI / 180,
	  RERENDER_TIME: 700,
	  ADDING_DATA_ANIMATION_DURATION: 300,
	  /** series label align outer
	   * @type {string}
	   */
	  LABEL_ALIGN_OUTER: 'outer',
	  /** @type {string} */
	  LEGEND_ALIGN_TOP: 'top',
	  /** @type {string} */
	  LEGEND_ALIGN_BOTTOM: 'bottom',
	  /** @type {string} */
	  LEGEND_ALIGN_LEFT: 'left',
	  /** @type {number} */
	  LEGEND_PAGINATION_BUTTON_WIDTH: 20,
	  /** @type {number} */
	  LEGEND_PAGINATION_BUTTON_PADDING_RIGHT: 6,
	  /** series outer label padding */
	  SERIES_OUTER_LABEL_PADDING: 20,
	  /** default ratio for pie graph */
	  PIE_GRAPH_DEFAULT_RATIO: 0.9,
	  /** small ratio for pie graph */
	  PIE_GRAPH_SMALL_RATIO: 0.75,
	  /** pie chart legend label size */
	  PIE_GRAPH_LEGEND_LABEL_SIZE: 16,
	  /** pie chart legend label size */
	  PIE_GRAPH_LEGEND_LABEL_INTERVAL: 20,
	  /** tick count for spectrum legend */
	  SPECTRUM_LEGEND_TICK_COUNT: 4,
	  /** legend & lable concat separator */
	  LABEL_SEPARATOR: '\n',
	  /** default position ratio of map chart label
	   * @type {object}
	   */
	  MAP_CHART_LABEL_DEFAULT_POSITION_RATIO: {
	    x: 0.5,
	    y: 0.5
	  },
	  /** map chart zoom area width */
	  MAP_CHART_ZOOM_AREA_WIDTH: 24,
	  /** map chart zoom area height */
	  MAP_CHART_ZOOM_AREA_HEIGHT: 58,
	  /** dot radius */
	  DOT_RADIUS: 4,
	  /** radius for circle of scatter chart*/
	  SCATTER_RADIUS: 7,
	  /**
	   * theme properties
	   * @type {{yAxis: Array.<string>, series: Array.<string>}}
	   */
	  THEME_PROPS_MAP: {
	    yAxis: ['tickColor', 'title', 'label'],
	    series: ['label', 'colors', 'borderColor', 'borderWidth', 'selectionColor', 'startColor', 'endColor', 'overColor', 'dot', 'ranges']
	  },
	  /** title area width padding */
	  TITLE_AREA_WIDTH_PADDING: 20,
	  /** chart export menu width, height */
	  CHART_EXPORT_MENU_SIZE: 24,
	  /** top margin of x axis label */
	  XAXIS_LABEL_TOP_MARGIN: 10,
	  /** right padding of vertical label */
	  V_LABEL_RIGHT_PADDING: 10,
	  /** tooltip prefix
	   * @type {string}
	   */
	  TOOLTIP_PREFIX: 'tui-chart-tooltip',
	  /** tooltip z-index **/
	  TOOLTIP_ZINDEX: 500,
	  /** tooltip animation time */
	  TOOLTIP_ANIMATION_TIME: 100,
	  /** tooltip animation time for pie chart */
	  TOOLTIP_PIE_ANIMATION_TIME: 50,
	  /** minimum pixel type step size */
	  MIN_PIXEL_TYPE_STEP_SIZE: 45,
	  /** maximum pixel type step size */
	  MAX_PIXEL_TYPE_STEP_SIZE: 65,
	  /** axis scale for percent stack option
	   * @type {object}
	   */
	  PERCENT_STACKED_AXIS_SCALE: {
	    limit: {
	      min: 0,
	      max: 100
	    },
	    step: 25,
	    labels: [0, 25, 50, 75, 100]
	  },
	  /** axis scale for minus percent stack option
	   * @type {object}
	   */
	  MINUS_PERCENT_STACKED_AXIS_SCALE: {
	    limit: {
	      min: -100,
	      max: 0
	    },
	    step: 25,
	    labels: [0, -25, -50, -75, -100]
	  },
	  /** axis scale of dual percent stack option
	   * @type {object}
	   */
	  DUAL_PERCENT_STACKED_AXIS_SCALE: {
	    limit: {
	      min: -100,
	      max: 100
	    },
	    step: 25,
	    labels: [-100, -75, -50, -25, 0, 25, 50, 75, 100]
	  },
	  /** axis scale of diverging percent stack option
	   * @type {object}
	   */
	  DIVERGING_PERCENT_STACKED_AXIS_SCALE: {
	    limit: {
	      min: -100,
	      max: 100
	    },
	    step: 25,
	    labels: [100, 75, 50, 25, 0, 25, 50, 75, 100]
	  },
	  /**
	   * datetime axis type
	   * @type {string}
	   */
	  AXIS_TYPE_DATETIME: 'datetime',
	  /**
	   * default dateFormat
	   * @type {string}
	   */
	  DEFAULT_DATE_FORMAT: 'YYYY.MM.DD hh:mm:dd',
	  /**
	   * date type
	   * @type {string}
	   */
	  DATE_TYPE_YEAR: 'year',
	  DATE_TYPE_MONTH: 'month',
	  DATE_TYPE_WEEK: 'week',
	  DATE_TYPE_DATE: 'date',
	  DATE_TYPE_HOUR: 'hour',
	  DATE_TYPE_MINUTE: 'minute',
	  DATE_TYPE_SECOND: 'second',
	  /** title add padding */
	  TITLE_PADDING: 20,
	  TITLE_ALIGN_CENTER: 'center',
	  TITLE_ALIGN_RIGHT: 'right',
	  TITLE_ALIGN_LEFT: 'left',
	  /** default header height */
	  DEFAULT_HEADER_HEIGHT: 10,
	  /** legend area horizontal padding */
	  LEGEND_AREA_H_PADDING: 15,
	  /** legend area vertical padding */
	  LEGEND_AREA_V_PADDING: 7,
	  /** legend checkbox width */
	  LEGEND_CHECKBOX_SIZE: 14,
	  LEGEND_ICON_WIDTH: 10,
	  LEGEND_ICON_HEIGHT: 10,
	  /** lgend label left padding */
	  LEGEND_LABEL_LEFT_PADDING: 8,
	  /** vertical legend right padding */
	  LEGEND_V_LABEL_RIGHT_PADDING: 20,
	  /** horizontal legend right padding */
	  LEGEND_H_LABEL_RIGHT_PADDING: 25,
	  /** lgend line icon svg path */
	  LEGEND_LINE_ICON_PATH: 'M1,9 L1,3 C1,1.8954305 1.8954305,1 3,1 L3,1 C4.1045695,1 5,1.8954305 5,3 L5,7 C5,8.1045695 5.8954305,9 7,9 L7,9 C8.1045695,9 9,8.1045695 9,7 L9,1',
	  MIN_LEGEND_WIDTH: 100,
	  /** map legend area padding */
	  MAP_LEGEND_AREA_PADDING_WIDE: 22,
	  /** vertical map legend area padding */
	  VERTICAL_MAP_LEGEND_AREA_TOP_PADDING: 26,
	  /** map legend padding before spectrum graph area */
	  MAP_LEGEND_AREA_PADDING_NARROW: 10,
	  /** map legend tooltip vertical padding */
	  MAP_LEGEND_TOOLTIP_VERTICAL_PADDING: 4,
	  /** map legend tooltip horizontal padding */
	  MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING: 6,
	  /** map legend wedge size */
	  MAP_LEGEND_WEDGE_SIZE: 4,
	  /** map legend padding between wedge and spectrum graph */
	  MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE: 4,
	  /** vertical map legend height */
	  VERTICAL_MAP_LEGEND_HEIGHT: 320,
	  /** horizontal map legend height */
	  HORIZONTAL_MAP_LEGEND_WIDTH: 400,
	  /** map legend graph size */
	  MAP_LEGEND_GRAPH_SIZE: 6,
	  /** map legend label padding */
	  MAP_LEGEND_LABEL_PADDING: 5,
	  CIRCLE_LEGEND_LABEL_FONT_SIZE: 9,
	  CIRCLE_LEGEND_PADDING: 10,
	  HALF_RATIO: 0.5,
	  AXIS_BACKGROUND_RIGHT_PADDING: 4,
	  /** X-AXIS LABEL PADDING */
	  X_AXIS_LABEL_PADDING: 7,
	  /** X-AXIS title padding */
	  X_AXIS_TITLE_PADDING: 5,
	  /** Y-AXIS LABEL PADDING */
	  Y_AXIS_LABEL_PADDING: 17,
	  Y_AXIS_TITLE_PADDING: 7,
	  /** rotations degree candidates */
	  DEGREE_CANDIDATES: [25, 45, 65, 85],
	  /**
	   * auto tick interval
	   * @type {string}
	   */
	  TICK_INTERVAL_AUTO: 'auto',
	  /** yAxis align option
	   * @type {string}
	   */
	  YAXIS_ALIGN_CENTER: 'center',
	  /** xAxis label gutter */
	  XAXIS_LABEL_GUTTER: 2,
	  /**
	   * Standard multiple nums of axis
	   * @type {Array}
	   */
	  AXIS_STANDARD_MULTIPLE_NUMS: [1, 2, 5, 10, 20, 50, 100],
	  /**
	   * Last standard multiple num of axis
	   */
	  AXIS_LAST_STANDARD_MULTIPLE_NUM: 100,
	  AXIS_EDGE_RATIO: 8,
	  /** label padding top */
	  LABEL_PADDING_TOP: 7,
	  /** line margin top */
	  LINE_MARGIN_TOP: 14,
	  /** tooltip gap */
	  TOOLTIP_GAP: 5,
	  /** tooltip direction
	   * @type {string}
	   */
	  TOOLTIP_DIRECTION_FORWARD: 'forword',
	  /** @type {string} */
	  TOOLTIP_DIRECTION_CENTER: 'center',
	  /** @type {string} */
	  TOOLTIP_DIRECTION_BACKWARD: 'backword',
	  /** tooltip align options
	   * @type {string}
	   */
	  TOOLTIP_DEFAULT_ALIGN_OPTION: 'center top',
	  /** @type {string} */
	  TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION: 'right middle',
	  /** @type {string} */
	  TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION: 'right middle',
	  /** @type {string} */
	  TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION: 'center bottom',
	  /** hide delay */
	  HIDE_DELAY: 200,
	  OLD_BROWSER_OPACITY_100: 100,
	  SERIES_LABEL_OPACITY: 0.3,
	  WHEEL_TICK: 120,
	  MAX_ZOOM_MAGN: 5,
	  ZOOM_POSITION_TOP_EXIST_TITLE: 5,
	  ZOOM_POSITION_TOP_NONE_TITLE: 1,
	  FF_WHEELDELTA_ADJUSTING_VALUE: -40,
	  IE7_ROTATION_FILTER_STYLE_MAP: {
	    25: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' + ' M11=0.9063077870366499, M12=0.42261826174069944, M21=-0.42261826174069944, M22=0.9063077870366499)"',
	    45: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' + ' M11=0.7071067811865476, M12=0.7071067811865475, M21=-0.7071067811865475, M22=0.7071067811865476)"',
	    65: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' + ' M11=0.42261826174069944, M12=0.9063077870366499, M21=-0.9063077870366499, M22=0.42261826174069944)"',
	    85: ' style="filter: progid:DXImageTransform.Microsoft.Matrix(SizingMethod=\'auto expand\',' + ' M11=0.08715574274765814, M12=0.9961946980917455, M21=-0.9961946980917455, M22=0.08715574274765814)"'
	  },
	  /** prefix for public event
	   * @type {string}
	   */
	  PUBLIC_EVENT_PREFIX: 'public_',
	  /** public event map
	   * @type {object}
	   */
	  PUBLIC_EVENT_MAP: {
	    load: true,
	    selectLegend: true,
	    selectSeries: true,
	    unselectSeries: true,
	    beforeShowTooltip: true,
	    afterShowTooltip: true,
	    beforeHideTooltip: true,
	    changeCheckedLegends: true,
	    zoom: true
	  },
	  /** for radial */
	  RADIAL_PLOT_PADDING: 15, // Prevent cross paper boundaries by line width
	  RADIAL_MARGIN_FOR_CATEGORY: 60,
	  RADIAL_CATEGORY_PADDING: 20,
	
	  COMPONENT_TYPE_DOM: 'DOM',
	  COMPONENT_TYPE_RAPHAEL: 'Raphael',
	
	  IMAGE_EXTENSIONS: ['png', 'jpeg'],
	  DATA_EXTENSIONS: ['xls', 'csv'],
	
	  GUIDE_AREACHART_AREAOPACITY_TYPE: 'areaOpacity should be a number between 0 and 1',
	
	  /** for bullet */
	  BULLET_TYPE_ACTUAL: 'Actual',
	  BULLET_TYPE_RANGE: 'Ranges',
	  BULLET_TYPE_MARKER: 'Markers',
	  BULLET_MARKER_STROKE_TICK: 3,
	  BULLET_MARKER_BUFFER_POSITION: 5,
	  BULLET_RANGES_HEIGHT_RATIO: 0.7,
	  BULLET_ACTUAL_HEIGHT_RATIO: 0.28,
	  BULLET_MARKERS_HEIGHT_RATIO: 0.55,
	  BULLET_MARKER_DETECT_PADDING: 3
	};

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
	                                                                                                                                                                                                     * @fileoverview DOM Handler.
	                                                                                                                                                                                                     * @author NHN.
	                                                                                                                                                                                                     *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                     */
	
	/**
	 * DOM Handler.
	 * @module domHandler
	 * @private */
	exports['default'] = {
	    /**
	     * Create element.
	     * @memberOf module:domHandler
	     * @param {string} tag html tag
	     * @param {string} newClass class name
	     * @returns {HTMLElement} created element
	     */
	    create: function create(tag, newClass) {
	        var el = document.createElement(tag);
	
	        if (newClass) {
	            this.addClass(el, newClass);
	        }
	
	        return el;
	    },
	
	
	    /**
	     * Get class names.
	     * @memberOf module:domHandler
	     * @param {HTMLElement} el target element
	     * @returns {Array} names
	     * @private
	     */
	    _getClassNames: function _getClassNames(el) {
	        var className = void 0;
	        var classNames = void 0;
	
	        if (el.classList) {
	            classNames = [].concat(_toConsumableArray(el.classList));
	        } else {
	            className = el.className || '';
	            classNames = className && _tuiCodeSnippet2['default'].isString(className) ? className.split(' ') : [];
	        }
	
	        return classNames;
	    },
	
	
	    /**
	     * Add css class to target element.
	     * @memberOf module:domHandler
	     * @param {HTMLElement} el target element
	     * @param {string} newClass add class name
	     */
	    addClass: function addClass(el, newClass) {
	        if (!el || !newClass) {
	            return;
	        }
	
	        var classNames = this._getClassNames(el);
	        var index = _tuiCodeSnippet2['default'].inArray(newClass, classNames);
	
	        if (index > -1) {
	            return;
	        }
	
	        classNames.push(newClass);
	        el.className = classNames.join(' ');
	    },
	
	
	    /**
	     * Remove css class from target element.
	     * @memberOf module:domHandler
	     * @param {HTMLElement} el target element
	     * @param {string} rmClass remove class name
	     */
	    removeClass: function removeClass(el, rmClass) {
	        var classNames = this._getClassNames(el);
	        var index = _tuiCodeSnippet2['default'].inArray(rmClass, classNames);
	
	        if (index === -1) {
	            return;
	        }
	
	        classNames.splice(index, 1);
	        el.className = classNames.join(' ');
	    },
	
	
	    /**
	     * Whether class exist or not.
	     * @memberOf module:domHandler
	     * @param {HTMLElement} el target element
	     * @param {string} findClass target css class
	     * @returns {boolean} has class
	     */
	    hasClass: function hasClass(el, findClass) {
	        var classNames = this._getClassNames(el);
	        var index = _tuiCodeSnippet2['default'].inArray(findClass, classNames);
	
	        return index > -1;
	    },
	
	
	    /**
	     * Find parent by class name.
	     * @memberOf module:domHandler
	     * @param {HTMLElement} el target element
	     * @param {string} className target css class
	     * @param {string} lastClass last css class
	     * @returns {HTMLElement} result element
	     */
	    findParentByClass: function findParentByClass(el, className, lastClass) {
	        var parent = el.parentNode;
	        var result = void 0;
	
	        if (!parent) {
	            result = null;
	        } else if (this.hasClass(parent, className)) {
	            result = parent;
	        } else if (parent.nodeName === 'BODY' || this.hasClass(parent, lastClass)) {
	            result = null;
	        } else {
	            result = this.findParentByClass(parent, className, lastClass);
	        }
	
	        return result;
	    },
	
	
	    /**
	     * Append child element.
	     * @memberOf module:domHandler
	     * @param {HTMLElement} container container element
	     * @param {HTMLElement} children child element
	     */
	    append: function append(container, children) {
	        if (!container || !children) {
	            return;
	        }
	        children = _tuiCodeSnippet2['default'].isArray(children) ? children : [children];
	
	        _tuiCodeSnippet2['default'].forEachArray(children, function (child) {
	            if (!child) {
	                return;
	            }
	            container.appendChild(child);
	        });
	    }
	};

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
	                                                                                                                                                                                                     * @fileoverview Util for array.
	                                                                                                                                                                                                     * @author NHN.
	                                                                                                                                                                                                     *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                     */
	
	
	/**
	 * Pick minimum value from value array.
	 * @memberOf module:arrayUtil
	 * @param {Array} arr value array
	 * @param {?function} condition condition function
	 * @param {?object} context target context
	 * @returns {*} minimum value
	 */
	function min(arr, condition, context) {
	    var result = void 0;
	
	    if (!condition) {
	        result = Math.min.apply(Math, _toConsumableArray(arr));
	    } else {
	        var _arr = _slicedToArray(arr, 1);
	
	        result = _arr[0];
	
	        var rest = arr.slice(1);
	        var minValue = condition.call(context, result, 0);
	
	        rest.forEach(function (item, index) {
	            var compareValue = condition.call(context, item, index + 1);
	            if (compareValue < minValue) {
	                minValue = compareValue;
	                result = item;
	            }
	        });
	    }
	
	    return result;
	}
	
	/**
	 * Pick maximum value from value array.
	 * @memberOf module:arrayUtil
	 * @param {Array} arr value array
	 * @param {?function} [condition] condition function
	 * @param {?object} [context] target context
	 * @returns {*} maximum value
	 */
	function max(arr, condition, context) {
	    var result = void 0;
	
	    if (!condition) {
	        result = Math.max.apply(Math, _toConsumableArray(arr));
	    } else {
	        var _arr2 = _slicedToArray(arr, 1);
	
	        result = _arr2[0];
	
	        var rest = arr.slice(1);
	        var maxValue = condition.call(context, result, 0);
	        _tuiCodeSnippet2['default'].forEachArray(rest, function (item, index) {
	            var compareValue = condition.call(context, item, index + 1);
	            if (compareValue > maxValue) {
	                maxValue = compareValue;
	                result = item;
	            }
	        });
	    }
	
	    return result;
	}
	
	/**
	 * Whether one of them is true or not.
	 * @memberOf module:arrayUtil
	 * @param {Array} collection target collection
	 * @param {function} condition condition function
	 * @param {?object} context target context
	 * @returns {boolean} result boolean
	 */
	function any(collection, condition, context) {
	    var result = false;
	    _tuiCodeSnippet2['default'].forEach(collection, function (item, key) {
	        if (condition.call(context, item, key, collection)) {
	            result = true;
	        }
	
	        return !result;
	    });
	
	    return result;
	}
	
	/**
	 * All of them is true or not.
	 * @memberOf module:arrayUtil
	 * @param {Array} collection target collection
	 * @param {function} condition condition function
	 * @param {?object} context target context
	 * @returns {boolean} result boolean
	 */
	function all(collection, condition, context) {
	    var result = !!(collection || []).length;
	    _tuiCodeSnippet2['default'].forEach(collection, function (item, key) {
	        if (!condition.call(context, item, key, collection)) {
	            result = false;
	        }
	
	        return result !== false;
	    });
	
	    return result;
	}
	
	/**
	 * Make unique values.
	 * @memberOf module:arrayUtil
	 * @param {Array} arr target array
	 * @param {?boolean} sorted whether sorted or not.
	 * @param {?function} iteratee iteratee function
	 * @param {?object} context target context
	 * @returns {Array} unique values
	 */
	function unique(arr, sorted, iteratee, context) {
	    var result = [];
	
	    if (!_tuiCodeSnippet2['default'].isBoolean(sorted)) {
	        context = iteratee;
	        iteratee = sorted;
	        sorted = false;
	    }
	
	    iteratee = iteratee || function (value) {
	        return value;
	    };
	
	    if (sorted) {
	        var prevValue = void 0;
	        _tuiCodeSnippet2['default'].forEachArray(arr, function (value, index) {
	            value = iteratee.call(context, value, index, arr);
	            if (!index || prevValue !== value) {
	                result.push(value);
	            }
	            prevValue = value;
	        });
	    } else {
	        _tuiCodeSnippet2['default'].forEachArray(arr, function (value, index) {
	            value = iteratee.call(context, value, index, arr);
	            if (_tuiCodeSnippet2['default'].inArray(value, result) === -1) {
	                result.push(value);
	            }
	        });
	    }
	
	    return result;
	}
	
	/**
	 * Array pivot.
	 * @memberOf module:arrayUtil
	 * @param {Array.<Array>} arr2d target 2d array
	 * @returns {Array.<Array>} pivoted 2d array
	 */
	function pivot(arr2d) {
	    var result = [];
	    var len = max(arr2d.map(function (arr) {
	        return arr.length;
	    }));
	
	    arr2d.forEach(function (arr) {
	        for (var index = 0; index < len; index += 1) {
	            if (!result[index]) {
	                result[index] = [];
	            }
	            result[index].push(arr[index]);
	        }
	    });
	
	    return result;
	}
	
	/**
	 * find index from date type array
	 * @memberOf module:arrayUtil
	 * @param {Array} dateArray date type value array
	 * @param {Date} date target date
	 * @returns {number} index
	 */
	function findIndexFromDateTypeArray(dateArray, date) {
	    var dateValue = Number(date);
	    var foundIndex = -1;
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = dateArray.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var _step$value = _slicedToArray(_step.value, 2),
	                idx = _step$value[0],
	                value = _step$value[1];
	
	            if (Number(value) === dateValue) {
	                foundIndex = idx;
	                break;
	            }
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator['return']) {
	                _iterator['return']();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return foundIndex;
	}
	
	exports['default'] = {
	    min: min,
	    max: max,
	    any: any,
	    all: all,
	    unique: unique,
	    pivot: pivot,
	    findIndexFromDateTypeArray: findIndexFromDateTypeArray
	};

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _templateObject = _taggedTemplateLiteral(['\n            M', ',', '\n            V', '\n        '], ['\n            M', ',', '\n            V', '\n        ']);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _raphael = __webpack_require__(330);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Raphael boxplot chart renderer.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var ANIMATION_DURATION = 700;
	var EMPHASIS_OPACITY = 1;
	var DE_EMPHASIS_OPACITY = 0.3;
	var DEFAULT_LUMINANC = 0.2;
	var EDGE_LINE_WIDTH = 1;
	var MEDIAN_LINE_WIDTH = 1;
	var WHISKER_LINE_WIDTH = 1;
	
	/**
	 * @classdesc RaphaelBoxplotChart is graph renderer for bar, column chart.
	 * @class RaphaelBoxplotChart
	 * @private
	 */
	
	var RaphaelBoxplotChart = function () {
	    function RaphaelBoxplotChart() {
	        _classCallCheck(this, RaphaelBoxplotChart);
	    }
	
	    /**
	     * Render function of bar chart
	     * @param {object} paper paper object
	     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data
	     * @returns {Array.<object>} seriesSet
	     */
	    RaphaelBoxplotChart.prototype.render = function render(paper, data) {
	        var groupBounds = data.groupBounds;
	
	
	        if (!groupBounds) {
	            return null;
	        }
	
	        this.paper = paper;
	
	        this.theme = data.theme;
	        this.options = data.options;
	        this.seriesDataModel = data.seriesDataModel;
	        this.chartType = data.chartType;
	
	        this.paper.setStart();
	        this.groupWhiskers = [];
	        this.groupMedians = [];
	        this.groupBoxes = this._renderBoxplots(groupBounds);
	        this.groupBorders = this._renderBoxBorders(groupBounds);
	
	        this.circleOverlay = this._renderCircleOverlay();
	        this.groupBounds = groupBounds;
	
	        return this.paper.setFinish();
	    };
	
	    /**
	     * Render overlay.
	     * @returns {object} raphael object
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._renderCircleOverlay = function _renderCircleOverlay() {
	        var position = {
	            left: 0,
	            top: 0
	        };
	        var attributes = {
	            'fill-opacity': 0
	        };
	
	        return _raphaelRenderUtil2['default'].renderCircle(this.paper, position, 0, _tuiCodeSnippet2['default'].extend({
	            'stroke-width': 0
	        }, attributes));
	    };
	
	    /**
	     * Render rect
	     * @param {{left: number, top: number, width: number, height: number}} bound bound
	     * @param {string} color series color
	     * @param {object} [attributes] - attributes
	     * @returns {object} bar rect
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._renderBox = function _renderBox(bound, color, attributes) {
	        if (bound.width < 0 || bound.height < 0) {
	            return null;
	        }
	
	        var rect = _raphaelRenderUtil2['default'].renderRect(this.paper, bound, _tuiCodeSnippet2['default'].extend({
	            fill: color,
	            stroke: 'none'
	        }, attributes));
	
	        return rect;
	    };
	
	    /**
	     * Render boxes.
	     * @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} groupBounds bounds
	     * @returns {Array.<Array.<object>>} bars
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._renderBoxes = function _renderBoxes(groupBounds) {
	        var _this = this;
	
	        var colors = this.theme.colors;
	        var colorByPoint = this.options.colorByPoint;
	
	
	        return groupBounds.map(function (bounds, groupIndex) {
	            return bounds.map(function (bound, index) {
	                if (!bound) {
	                    return null;
	                }
	
	                var item = _this.seriesDataModel.getSeriesItem(groupIndex, index);
	                var color = colorByPoint ? colors[groupIndex] : colors[index];
	                var rect = void 0;
	
	                if (bound.start) {
	                    rect = _this._renderBox(bound.start, color);
	                }
	
	                return {
	                    rect: rect,
	                    color: color,
	                    bound: bound.end,
	                    item: item,
	                    groupIndex: groupIndex,
	                    index: index
	                };
	            });
	        });
	    };
	
	    /**
	     * Render boxplots.
	     * @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} groupBounds bounds
	     * @returns {Array.<Array.<object>>} bars
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._renderBoxplots = function _renderBoxplots(groupBounds) {
	        var groupBoxes = this._renderBoxes(groupBounds);
	
	        this.groupWhiskers = this._renderWhiskers(groupBounds);
	        this.groupMedians = this._renderMedianLines(groupBounds);
	        this.groupOutliers = this._renderOutliers(groupBounds);
	
	        return groupBoxes;
	    };
	
	    RaphaelBoxplotChart.prototype._renderWhisker = function _renderWhisker(end, start, color) {
	        var paper = this.paper;
	
	        var topDistance = start.top - end.top;
	        var whiskerDirection = topDistance > 0 ? 1 : -1;
	        var left = end.left,
	            width = end.width;
	
	        var quartileWidth = width / 4;
	        var edgePath = 'M' + (left + quartileWidth) + ',' + end.top + 'H' + (left + quartileWidth * 3);
	        var whiskerPath = _renderUtil2['default'].oneLineTrim(_templateObject, left + quartileWidth * 2, end.top, end.top + Math.abs(topDistance) * whiskerDirection);
	
	        var edge = _raphaelRenderUtil2['default'].renderLine(paper, edgePath, color, EDGE_LINE_WIDTH);
	        var whisker = _raphaelRenderUtil2['default'].renderLine(paper, whiskerPath, color, WHISKER_LINE_WIDTH);
	        var whiskers = [];
	
	        edge.attr({
	            opacity: 0
	        });
	        whisker.attr({
	            opacity: 0
	        });
	
	        whiskers.push(edge);
	        whiskers.push(whisker);
	
	        return whiskers;
	    };
	
	    RaphaelBoxplotChart.prototype._renderWhiskers = function _renderWhiskers(groupBounds) {
	        var _this2 = this;
	
	        var colors = this.theme.colors;
	        var colorByPoint = this.options.colorByPoint;
	
	        var groupWhiskers = [];
	
	        groupBounds.forEach(function (bounds, groupIndex) {
	            var whiskers = [];
	
	            bounds.forEach(function (bound, index) {
	                var color = colorByPoint ? colors[groupIndex] : colors[index];
	
	                if (!bound) {
	                    return;
	                }
	
	                whiskers = whiskers.concat(_this2._renderWhisker(bound.min, bound.start, color));
	                whiskers = whiskers.concat(_this2._renderWhisker(bound.max, bound.end, color));
	            });
	
	            groupWhiskers.push(whiskers);
	        });
	
	        return groupWhiskers;
	    };
	
	    RaphaelBoxplotChart.prototype._renderMedianLine = function _renderMedianLine(bound) {
	        var width = bound.width;
	
	        var medianLinePath = 'M' + bound.left + ',' + bound.top + ',H' + (bound.left + width);
	        var median = _raphaelRenderUtil2['default'].renderLine(this.paper, medianLinePath, '#ffffff', MEDIAN_LINE_WIDTH);
	
	        median.attr({
	            opacity: 0
	        });
	
	        return median;
	    };
	
	    RaphaelBoxplotChart.prototype._renderMedianLines = function _renderMedianLines(groupBounds) {
	        var _this3 = this;
	
	        var groupMedians = [];
	
	        groupBounds.forEach(function (bounds) {
	            var medians = [];
	
	            bounds.forEach(function (bound) {
	                if (!bound) {
	                    return;
	                }
	
	                medians.push(_this3._renderMedianLine(bound.median));
	            });
	            groupMedians.push(medians);
	        });
	
	        return groupMedians;
	    };
	
	    RaphaelBoxplotChart.prototype._renderOutlier = function _renderOutlier(bound, color) {
	        var outlier = _raphaelRenderUtil2['default'].renderCircle(this.paper, {
	            left: bound.left,
	            top: bound.top
	        }, 3.5, {
	            stroke: color,
	            'stroke-width': 2
	        });
	
	        outlier.attr({
	            opacity: 0
	        });
	
	        return outlier;
	    };
	
	    RaphaelBoxplotChart.prototype._renderOutliers = function _renderOutliers(groupBounds) {
	        var _this4 = this;
	
	        var colors = this.theme.colors;
	        var colorByPoint = this.options.colorByPoint;
	
	        var groupOutliers = [];
	
	        groupBounds.forEach(function (bounds, groupIndex) {
	            var outliers = [];
	            bounds.forEach(function (bound, index) {
	                var color = colorByPoint ? colors[groupIndex] : colors[index];
	                var seriesOutliers = [];
	
	                if (!bound) {
	                    return;
	                }
	
	                if (bound.outliers.length) {
	                    bound.outliers.forEach(function (outlier) {
	                        seriesOutliers.push(_this4._renderOutlier(outlier, color));
	                    });
	                }
	                outliers.push(seriesOutliers);
	            });
	            groupOutliers.push(outliers);
	        });
	
	        return groupOutliers;
	    };
	
	    /**
	     * Make rect points.
	     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
	     * @returns {{
	     *      leftTop: {left: number, top: number},
	     *      rightTop: {left: number, top: number},
	     *      rightBottom: {left: number, top: number},
	     *      leftBottom: {left: number, top: number}
	     * }} rect points
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._makeRectPoints = function _makeRectPoints(bound) {
	        return {
	            leftTop: {
	                left: Math.ceil(bound.left),
	                top: Math.ceil(bound.top)
	            },
	            rightTop: {
	                left: Math.ceil(bound.left + bound.width),
	                top: Math.ceil(bound.top)
	            },
	            rightBottom: {
	                left: Math.ceil(bound.left + bound.width),
	                top: Math.ceil(bound.top + bound.height)
	            },
	            leftBottom: {
	                left: Math.ceil(bound.left),
	                top: Math.ceil(bound.top + bound.height)
	            }
	        };
	    };
	
	    /**
	     * Render border lines;
	     * @param {{left: number, top:number, width: number, height: number}} bound bar bound
	     * @param {string} borderColor border color
	     * @param {string} chartType chart type
	     * @param {Item} item item
	     * @returns {object} raphael object
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._renderBorderLines = function _renderBorderLines(bound, borderColor, chartType, item) {
	        var _this5 = this;
	
	        var borderLinePaths = this._makeBorderLinesPaths(bound, chartType, item);
	        var lines = {};
	
	        Object.entries(borderLinePaths).forEach(function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2),
	                name = _ref2[0],
	                path = _ref2[1];
	
	            lines[name] = _raphaelRenderUtil2['default'].renderLine(_this5.paper, path, borderColor, 1);
	        });
	
	        return lines;
	    };
	
	    /**
	     * Render bar borders.
	     * @param {Array.<Array.<{left: number, top:number, width: number, height: number}>>} groupBounds bounds
	     * @returns {Array.<Array.<object>>} borders
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._renderBoxBorders = function _renderBoxBorders(groupBounds) {
	        var _this6 = this;
	
	        var borderColor = this.theme.borderColor;
	
	
	        if (!borderColor) {
	            return null;
	        }
	
	        var groupBorders = groupBounds.map(function (bounds, groupIndex) {
	            return bounds.map(function (bound, index) {
	                if (!bound) {
	                    return null;
	                }
	                var seriesItem = _this6.seriesDataModel.getSeriesItem(groupIndex, index);
	
	                return _this6._renderBorderLines(bound.start, borderColor, _this6.chartType, seriesItem);
	            });
	        });
	
	        return groupBorders;
	    };
	
	    /**
	     * Animate rect.
	     * @param {object} rect raphael object
	     * @param {{left: number, top:number, width: number, height: number}} bound rect bound
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._animateRect = function _animateRect(rect, bound) {
	        rect.animate({
	            x: bound.left,
	            y: bound.top,
	            width: bound.width,
	            height: bound.height
	        }, ANIMATION_DURATION, '>');
	    };
	
	    /**
	     * Animate.
	     * @param {function} onFinish finish callback function
	     */
	
	
	    RaphaelBoxplotChart.prototype.animate = function animate(onFinish) {
	        var _this7 = this;
	
	        var animation = _raphael2['default'].animation({
	            opacity: 1
	        }, ANIMATION_DURATION);
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupBoxes, function (box) {
	            if (!box) {
	                return;
	            }
	            _this7._animateRect(box.rect, box.bound);
	        });
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupWhiskers, function (whisker) {
	            whisker.animate(animation.delay(ANIMATION_DURATION));
	        });
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupMedians, function (median) {
	            median.animate(animation.delay(ANIMATION_DURATION));
	        });
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupOutliers, function (outliers) {
	            outliers.forEach(function (outlier) {
	                outlier.animate(animation.delay(ANIMATION_DURATION));
	            });
	        });
	
	        if (onFinish) {
	            this.callbackTimeout = setTimeout(function () {
	                onFinish();
	                delete _this7.callbackTimeout;
	            }, ANIMATION_DURATION);
	        }
	    };
	
	    /**
	     * Show animation.
	     * @param {{groupIndex: number, index:number}} data show info
	     */
	
	
	    RaphaelBoxplotChart.prototype.showAnimation = function showAnimation(data) {
	        if (_tuiCodeSnippet2['default'].isNumber(data.outlierIndex)) {
	            this.showOutlierAnimation(data);
	        } else {
	            this.showRectAnimation(data);
	        }
	    };
	
	    /**
	     * Show animation.
	     * @param {{groupIndex: number, index:number}} data show info
	     */
	
	
	    RaphaelBoxplotChart.prototype.showRectAnimation = function showRectAnimation(data) {
	        var bar = this.groupBoxes[data.groupIndex][data.index];
	        this.hoveredBar = bar.rect;
	
	        this.hoveredBar.attr({
	            stroke: '#ffffff',
	            'stroke-width': 4
	        });
	        this.hoveredBar.node.setAttribute('filter', 'url(#shadow)');
	    };
	
	    /**
	     * Show animation.
	     * @param {{groupIndex: number, index:number}} data show info
	     */
	
	
	    RaphaelBoxplotChart.prototype.showOutlierAnimation = function showOutlierAnimation(data) {
	        var targetAttr = this.groupOutliers[data.groupIndex][data.index][data.outlierIndex].attr();
	
	        this.circleOverlay.attr({
	            r: targetAttr.r,
	            cx: targetAttr.cx,
	            cy: targetAttr.cy,
	            fill: targetAttr.stroke,
	            'fill-opacity': 1,
	            stroke: targetAttr.stroke,
	            'stroke-width': 4
	        });
	    };
	
	    /**
	     * Hide animation.
	     */
	
	
	    RaphaelBoxplotChart.prototype.hideAnimation = function hideAnimation() {
	        this.circleOverlay.attr({
	            width: 1,
	            height: 1,
	            x: 0,
	            y: 0,
	            'fill-opacity': 0,
	            'stroke-width': 2
	        });
	        this.hoveredBar.attr({
	            stroke: 'none'
	        });
	        this.hoveredBar.node.setAttribute('filter', 'none');
	    };
	
	    /**
	     * Update rect bound
	     * @param {object} rect raphael object
	     * @param {{left: number, top: number, width: number, height: number}} bound bound
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._updateRectBound = function _updateRectBound(rect, bound) {
	        rect.attr({
	            x: bound.left,
	            y: bound.top,
	            width: bound.width,
	            height: bound.height
	        });
	    };
	
	    /**
	     * Resize graph of bar type chart.
	     * @param {object} params parameters
	     *      @param {{width: number, height:number}} params.dimension dimension
	     *      @param {Array.<Array.<{
	     *                  left:number, top:number, width: number, height: number
	     *              }>>} params.groupBounds group bounds
	     */
	
	
	    RaphaelBoxplotChart.prototype.resize = function resize(params) {
	        var dimension = params.dimension,
	            groupBounds = params.groupBounds;
	
	
	        this.groupBounds = groupBounds;
	        this.paper.setSize(dimension.width, dimension.height);
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupBoxes, function (bar, groupIndex, index) {
	            if (!bar) {
	                return;
	            }
	
	            var bound = groupBounds[groupIndex][index].end;
	            bar.bound = bound;
	            _raphaelRenderUtil2['default'].updateRectBound(bar.rect, bound);
	        });
	    };
	
	    /**
	     * Change borders color.
	     * @param {Array.<object>} lines raphael objects
	     * @param {borderColor} borderColor border color
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._changeBordersColor = function _changeBordersColor(lines, borderColor) {
	        lines.forEach(function (line) {
	            line.attr({ stroke: borderColor });
	        });
	    };
	
	    /**
	     * Change bar color.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     * @param {string} color fill color
	     * @param {?string} borderColor stroke color
	     * @private
	     */
	
	
	    RaphaelBoxplotChart.prototype._changeBoxColor = function _changeBoxColor(indexes, color, borderColor) {
	        var bar = this.groupBoxes[indexes.groupIndex][indexes.index];
	
	        bar.rect.attr({
	            stroke: color
	        });
	
	        if (borderColor) {
	            var lines = this.groupBorders[indexes.groupIndex][indexes.index];
	            this._changeBordersColor(lines, borderColor);
	        }
	    };
	
	    /**
	     * Select series.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     */
	
	
	    RaphaelBoxplotChart.prototype.selectSeries = function selectSeries(indexes) {
	        var bar = this.groupBoxes[indexes.groupIndex][indexes.index];
	        var objColor = _raphael2['default'].color(bar.color);
	        var selectionColorTheme = this.theme.selectionColor;
	        var makeColor = _raphaelRenderUtil2['default'].makeChangedLuminanceColor;
	        var color = selectionColorTheme || makeColor(objColor.hex, DEFAULT_LUMINANC);
	        var borderColor = this.theme.borderColor;
	
	
	        if (borderColor) {
	            var objBorderColor = _raphael2['default'].color(borderColor);
	            borderColor = _raphaelRenderUtil2['default'].makeChangedLuminanceColor(objBorderColor.hex, DEFAULT_LUMINANC);
	        }
	
	        this._changeBoxColor(indexes, color, borderColor);
	    };
	
	    /**
	     * Unselect series.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     */
	
	
	    RaphaelBoxplotChart.prototype.unselectSeries = function unselectSeries(indexes) {
	        var bar = this.groupBoxes[indexes.groupIndex][indexes.index];
	        var borderColor = this.theme.borderColor;
	
	        this._changeBoxColor(indexes, bar.color, borderColor);
	    };
	
	    /**
	     * Select legend.
	     * @param {?number} legendIndex legend index
	     */
	
	
	    RaphaelBoxplotChart.prototype.selectLegend = function selectLegend(legendIndex) {
	        var noneSelected = _tuiCodeSnippet2['default'].isNull(legendIndex);
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupBoxes, function (box, groupIndex, index) {
	            if (!box) {
	                return;
	            }
	
	            var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	
	            box.rect.attr({ 'stroke-opacity': opacity });
	        });
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupWhiskers, function (whisker, groupIndex, index) {
	            var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	
	            whisker.attr({ 'stroke-opacity': opacity });
	        });
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupMedians, function (median, groupIndex, index) {
	            var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	
	            median.attr({ 'stroke-opacity': opacity });
	        });
	    };
	
	    RaphaelBoxplotChart.prototype.renderSeriesLabel = function renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme, isStacked) {
	        var attributes = {
	            'font-size': labelTheme.fontSize,
	            'font-family': labelTheme.fontFamily,
	            'font-weight': labelTheme.fontWeight,
	            fill: labelTheme.color,
	            opacity: 0,
	            'text-anchor': isStacked ? 'middle' : 'start'
	        };
	        var labelSet = paper.set();
	
	        groupLabels.forEach(function (categoryLabel, categoryIndex) {
	            categoryLabel.forEach(function (label, seriesIndex) {
	                var position = groupPositions[categoryIndex][seriesIndex];
	                var endLabel = _raphaelRenderUtil2['default'].renderText(paper, position.end, label.end, attributes);
	
	                endLabel.node.style.userSelect = 'none';
	                endLabel.node.style.cursor = 'default';
	                endLabel.node.setAttribute('filter', 'url(#glow)');
	
	                labelSet.push(endLabel);
	
	                if (position.start) {
	                    var startLabel = _raphaelRenderUtil2['default'].renderText(paper, position.start, label.start, attributes);
	                    startLabel.node.style.userSelect = 'none';
	                    startLabel.node.style.cursor = 'default';
	                    startLabel.node.setAttribute('filter', 'url(#glow)');
	
	                    labelSet.push(startLabel);
	                }
	            });
	        });
	
	        return labelSet;
	    };
	
	    return RaphaelBoxplotChart;
	}();
	
	exports['default'] = RaphaelBoxplotChart;

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Raphael bullet chart renderer.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var browser = _tuiCodeSnippet2['default'].browser;
	
	var IS_LTE_IE8 = browser.msie && browser.version <= 8;
	var ANIMATION_DURATION = 700;
	var ANIMATION_DELAY = 700;
	var EMPHASIS_OPACITY = 1;
	var DE_EMPHASIS_OPACITY = 0.3;
	var EVENT_DETECTOR_PADDING = 20;
	
	/**
	 * @classdesc RaphaelBulletChart is graph renderer for bullet chart.
	 * @class RaphaelBulletChart
	 * @private
	 */
	
	var RaphaelBulletChart = function () {
	    function RaphaelBulletChart() {
	        _classCallCheck(this, RaphaelBulletChart);
	    }
	
	    /**
	     * Render function of bar chart
	     * @param {object} paper paper object
	     * @param {{size: object, model: object, options: object, tooltipPosition: string}} data chart data
	     * @returns {Array.<object>} seriesSet
	     */
	    RaphaelBulletChart.prototype.render = function render(paper, data) {
	        var groupBounds = data.groupBounds,
	            seriesDataModel = data.seriesDataModel;
	
	
	        if (!groupBounds || !groupBounds.length) {
	            return null;
	        }
	
	        this.paper = paper;
	        this.theme = data.theme;
	        this.dimension = data.dimension;
	        this.position = data.position;
	        this.options = data.options;
	        this.chartType = data.chartType;
	        this.isVertical = data.isVertical;
	
	        this.seriesDataModel = seriesDataModel;
	        this.maxRangeCount = seriesDataModel.maxRangeCount;
	        this.maxMarkerCount = seriesDataModel.maxMarkerCount;
	
	        this._graphColors = [];
	
	        this.rangeOpacities = {};
	
	        this.paper.setStart();
	
	        this._renderBounds(groupBounds);
	
	        return this.paper.setFinish();
	    };
	
	    /**
	     * Get range opacity by index
	     * If rangeOpacities[index] not exists, create and store. then use it next time
	     * @param {number} index - ranges index
	     * @returns {number} - opacity of ranges bar at index
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._getRangeOpacity = function _getRangeOpacity(index) {
	        var maxRangeCount = this.maxRangeCount;
	
	        if (this.prevMaxRangeCount !== maxRangeCount) {
	            this._updateOpacityStep(maxRangeCount);
	        }
	
	        if (index < maxRangeCount && !this.rangeOpacities[index]) {
	            this.rangeOpacities[index] = 1 - this.opacityStep * (index + 1);
	        }
	
	        return this.rangeOpacities[index];
	    };
	
	    /**
	     * Update opacity step using maxRangeCount
	     * @param {number} maxRangeCount - maximum count of ranges bar among series graphes
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._updateOpacityStep = function _updateOpacityStep(maxRangeCount) {
	        this.rangeOpacities = {};
	        this.opacityStep = Number(1 / (maxRangeCount + 1)).toFixed(2);
	        this.prevMaxRangeCount = maxRangeCount;
	    };
	
	    /**
	     * Render bullet graph using groupBounds model
	     * @param {Array.<object>} groupBounds - bounds data for rendering bullet graph
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._renderBounds = function _renderBounds(groupBounds) {
	        var _this = this;
	
	        var rangeThemes = this.theme.ranges;
	        var paper = this.paper;
	
	
	        this.groupBars = [];
	        this.groupLines = [];
	
	        groupBounds.forEach(function (bounds, groupIndex) {
	            var seriesColor = _this.theme.colors[groupIndex];
	            var rangeIndex = 0;
	            var barSet = paper.set();
	            var lineSet = paper.set();
	
	            bounds.forEach(function (bound) {
	                var type = bound.type;
	
	
	                if (type === _const2['default'].BULLET_TYPE_ACTUAL) {
	                    barSet.push(_this._renderActual(bound, seriesColor));
	                } else if (type === _const2['default'].BULLET_TYPE_RANGE) {
	                    barSet.push(_this._renderRange(bound, seriesColor, rangeIndex, rangeThemes[rangeIndex]));
	                    rangeIndex += 1;
	                } else if (type === _const2['default'].BULLET_TYPE_MARKER) {
	                    lineSet.push(_this._renderMarker(bound, seriesColor));
	                }
	            });
	
	            _this.groupBars.push(barSet);
	            _this.groupLines.push(lineSet);
	        }, this);
	    };
	
	    /**
	     * Render actual bar
	     * @param {object} bound - bound model on start point
	     * @param {string} seriesColor - series color for painting actual bar
	     * @returns {Element} - rendered actual bar
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._renderActual = function _renderActual(bound, seriesColor) {
	        if (!bound) {
	            return null;
	        }
	
	        return this._renderBar(bound, seriesColor);
	    };
	
	    /**
	     * Render range bar
	     * @param {object} bound - bound model on start point
	     * @param {string} seriesColor - series color for painting range bar
	     * @param {number} rangeIndex - ranges index
	     * @param {object} rangeTheme - range theme
	     * @returns {Element} - rendered range bar
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._renderRange = function _renderRange(bound, seriesColor, rangeIndex, rangeTheme) {
	        var opacity = this._getRangeOpacity(rangeIndex);
	        var attr = { opacity: opacity };
	        var color = seriesColor;
	
	        if (!bound) {
	            return null;
	        }
	
	        if (rangeTheme) {
	            color = rangeTheme.color || color;
	            attr.opacity = rangeTheme.opacity || opacity;
	        }
	
	        return this._renderBar(bound, color, attr);
	    };
	
	    /**
	     * Create bar type element using passing arguments
	     * @param {object} bound - bound data for render rect element
	     * @param {string} color - hex type color string
	     * @param {object} attributes - styling attributes
	     * @returns {Element} - svg rect element
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._renderBar = function _renderBar(bound, color, attributes) {
	        if (bound.width < 0 || bound.height < 0) {
	            return null;
	        }
	
	        return _raphaelRenderUtil2['default'].renderRect(this.paper, bound, _tuiCodeSnippet2['default'].extend({
	            fill: color,
	            stroke: 'none'
	        }, attributes));
	    };
	
	    /**
	     * Render marker
	     * @param {object} bound - bound model of marker
	     * @param {string} seriesColor - series color for painting marker
	     * @returns {Element} - rendered marker
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._renderMarker = function _renderMarker(bound, seriesColor) {
	        if (!bound) {
	            return null;
	        }
	
	        return this._renderLine(bound, seriesColor);
	    };
	
	    /**
	     * Create line element using passing arguments
	     * @param {object} bound - bound data for render path element
	     * @param {string} color - hex type color string
	     * @returns {Element} - svg rect element
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._renderLine = function _renderLine(bound, color) {
	        var top = bound.top,
	            left = bound.left,
	            length = bound.length;
	
	        var endPosition = this.isVertical ? 'L' + (left + length) + ',' + top : 'L' + left + ',' + (top + length);
	        var path = 'M' + left + ',' + (top + endPosition);
	
	        return _raphaelRenderUtil2['default'].renderLine(this.paper, path, color, _const2['default'].BULLET_MARKER_STROKE_TICK);
	    };
	
	    /**
	     * Animate.
	     * @param {function} onFinish finish callback function
	     * @param {Array.<object>} seriesSet series set
	     */
	
	
	    RaphaelBulletChart.prototype.animate = function animate(onFinish, seriesSet) {
	        var _this2 = this;
	
	        var paper = this.paper,
	            dimension = this.dimension,
	            position = this.position;
	
	        var clipRectId = this._getClipRectId();
	        var clipRectWidth = dimension.width - EVENT_DETECTOR_PADDING;
	        var clipRectHeight = dimension.height - EVENT_DETECTOR_PADDING;
	        var startDimension = {};
	        var animateAttr = {};
	        var clipRect = this.clipRect;
	
	
	        if (this.isVertical) {
	            startDimension.width = clipRectWidth;
	            startDimension.height = 0;
	            animateAttr.height = clipRectHeight;
	        } else {
	            startDimension.width = 0;
	            startDimension.height = clipRectHeight;
	            animateAttr.width = clipRectWidth;
	        }
	
	        // Animation was implemented using <clipPath> SVG element
	        // As Browser compatibility of <clipPath> is IE9+,
	        // No Animation on IE8
	        if (!IS_LTE_IE8 && dimension) {
	            if (!clipRect) {
	                clipRect = createClipPathRectWithLayout(paper, position, startDimension, clipRectId);
	                this.clipRect = clipRect;
	            } else {
	                clipRect.attr({
	                    x: position.left,
	                    y: position.top
	                });
	                clipRect.attr(startDimension);
	            }
	
	            seriesSet.forEach(function (element) {
	                if (element.type === 'set') {
	                    element.forEach(function (item) {
	                        item.node.setAttribute('clip-path', 'url(#' + clipRectId + ')');
	                    });
	                } else {
	                    element.node.setAttribute('clip-path', 'url(#' + clipRectId + ')');
	                }
	            });
	
	            clipRect.animate(animateAttr, ANIMATION_DURATION, '>', onFinish);
	        }
	
	        if (onFinish) {
	            this.callbackTimeout = setTimeout(function () {
	                onFinish();
	                delete _this2.callbackTimeout;
	            }, ANIMATION_DELAY);
	        }
	    };
	
	    /**
	     * Resize bullet chart
	     * @param {object} params parameters
	     *      @param {{width: number, height:number}} params.dimension dimension
	     *      @param {Array.<Array.<{
	     *                  left:number, top:number, width: number, height: number
	     *              }>>} params.groupBounds group bounds
	     */
	
	
	    RaphaelBulletChart.prototype.resize = function resize(params) {
	        var dimension = params.dimension,
	            groupBounds = params.groupBounds;
	        var width = dimension.width,
	            height = dimension.height;
	
	
	        this.dimension = params.dimension;
	        this.groupBounds = groupBounds;
	        this.resizeClipRect(width, height);
	        this.paper.setSize(width, height);
	    };
	
	    /**
	     * Resize clip rect size
	     * @param {number} width series width
	     * @param {number} height series height
	     */
	
	
	    RaphaelBulletChart.prototype.resizeClipRect = function resizeClipRect(width, height) {
	        var clipRect = this.paper.getById(this._getClipRectId() + '_rect');
	
	        // Animation was implemented using <clipPath> SVG element
	        // As Browser compatibility of <clipPath> is IE9+,
	        // No Animation on IE8
	        if (clipRect) {
	            clipRect.attr({
	                width: width,
	                height: height
	            });
	        }
	    };
	
	    /**
	     * set clip rect position
	     * @param {object} position series position
	     */
	
	
	    RaphaelBulletChart.prototype.setClipRectPosition = function setClipRectPosition(position) {
	        var clipRect = this.paper.getById(this._getClipRectId() + '_rect');
	
	        clipRect.attr({
	            x: position.left,
	            y: position.top
	        });
	    };
	
	    /**
	     * Set clip rect id
	     * @returns {string} id - clip rect id
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._getClipRectId = function _getClipRectId() {
	        if (!this.clipRectId) {
	            this.clipRectId = _renderUtil2['default'].generateClipRectId();
	        }
	
	        return this.clipRectId;
	    };
	
	    /**
	     * Change borders color.
	     * @param {Array.<object>} lines raphael objects
	     * @param {borderColor} borderColor border color
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._changeBordersColor = function _changeBordersColor(lines, borderColor) {
	        lines.forEach(function (line) {
	            line.attr({ stroke: borderColor });
	        });
	    };
	
	    /**
	     * Select legend.
	     * @param {?number} legendIndex legend index
	     */
	
	
	    RaphaelBulletChart.prototype.selectLegend = function selectLegend(legendIndex) {
	        var _this3 = this;
	
	        var allEmphasized = _tuiCodeSnippet2['default'].isNull(legendIndex);
	
	        this.groupBars.forEach(function (bars, groupIndex) {
	            var opacity = allEmphasized || legendIndex === groupIndex ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	
	            _this3.groupBars[groupIndex].attr({ 'fill-opacity': opacity });
	            _this3.groupLabels[groupIndex].attr({ opacity: opacity });
	
	            _this3.groupLabels[groupIndex].forEach(function (label) {
	                label.attr({ opacity: opacity });
	            });
	        });
	    };
	
	    /**
	     * @param {object} paper - raphael paper
	     * @param {Array.<object>} positionData - series label positions
	     * @param {Array.<string>} labelData - series labels
	     * @param {object} labelTheme - series text theme
	     * @returns {object} - rendered label set
	     */
	
	
	    RaphaelBulletChart.prototype.renderSeriesLabel = function renderSeriesLabel(paper, positionData, labelData, labelTheme) {
	        var _this4 = this;
	
	        var attributes = {
	            'font-size': labelTheme.fontSize,
	            'font-family': labelTheme.fontFamily,
	            'font-weight': labelTheme.fontWeight,
	            fill: labelTheme.color,
	            opacity: 0,
	            'text-anchor': this.isVertical ? 'middle' : 'start'
	        };
	        var set = paper.set();
	
	        this.groupLabels = labelData.map(function (labels, groupIndex) {
	            var labelSet = paper.set();
	            labels.forEach(function (label, index) {
	                var labelElement = _this4._renderLabel(paper, positionData[groupIndex][index], attributes, label);
	                labelSet.push(labelElement);
	                set.push(labelElement);
	            });
	
	            return labelSet;
	        }, this);
	
	        return set;
	    };
	
	    /**
	     * @param {object} paper - raphael paper
	     * @param {Array.<object>} position - series label positions
	     * @param {Array.<string>} attributes - label text attributes
	     * @param {string} labelText - label text
	     * @returns {object} - rendered label object
	     * @private
	     */
	
	
	    RaphaelBulletChart.prototype._renderLabel = function _renderLabel(paper, position, attributes, labelText) {
	        var label = _raphaelRenderUtil2['default'].renderText(paper, position, labelText, attributes);
	        var node = label.node;
	        var style = node.style;
	
	        style.userSelect = 'none';
	        style.cursor = 'default';
	        node.setAttribute('filter', 'url(#glow)');
	
	        return label;
	    };
	
	    /**
	     * @param {number} index - series index
	     * @returns {Array.<object>} - color and opacity of series
	     */
	
	
	    RaphaelBulletChart.prototype.getGraphColors = function getGraphColors() {
	        var _this5 = this;
	
	        if (!this._graphColors.length) {
	            this._graphColors = this.groupBars.map(function (barSet, groupIndex) {
	                var barColors = [];
	                var markerCount = _this5.groupLines[groupIndex].length;
	
	                barSet.forEach(function (item) {
	                    barColors.push(item.attrs.fill);
	                });
	
	                var legendColor = barColors[barColors.length - 1];
	
	                for (var i = 0; i <= markerCount; i += 1) {
	                    barColors.push(legendColor);
	                }
	
	                return barColors;
	            });
	        }
	
	        return this._graphColors;
	    };
	
	    return RaphaelBulletChart;
	}();
	
	/**
	 * Create clip rect with layout
	 * @param {object} paper Raphael paper
	 * @param {object} position position
	 * @param {object} dimension dimension
	 * @param {string} id ID string
	 * @returns {object}
	 * @ignore
	 */
	
	
	function createClipPathRectWithLayout(paper, position, dimension, id) {
	    var clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
	    var rect = paper.rect(position.left, position.top, dimension.width, dimension.height);
	
	    rect.id = id + '_rect';
	    clipPath.id = id;
	
	    clipPath.appendChild(rect.node);
	    paper.defs.appendChild(clipPath);
	
	    return rect;
	}
	
	exports['default'] = RaphaelBulletChart;

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _raphaelLineTypeBase = __webpack_require__(341);
	
	var _raphaelLineTypeBase2 = _interopRequireDefault(_raphaelLineTypeBase);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Raphael line chart renderer.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var EMPHASIS_OPACITY = 1;
	var DE_EMPHASIS_OPACITY = 0.3;
	
	var RaphaelLineChart = function (_RaphaelLineBase) {
	    _inherits(RaphaelLineChart, _RaphaelLineBase);
	
	    /**
	     * RaphaelLineCharts is graph renderer for line chart.
	     * @constructs RaphaelLineChart
	     * @private
	     * @private
	     * @extends RaphaelLineTypeBase
	     */
	    function RaphaelLineChart() {
	        _classCallCheck(this, RaphaelLineChart);
	
	        /**
	         * selected legend index
	         * @type {?number}
	         */
	        var _this = _possibleConstructorReturn(this, _RaphaelLineBase.call(this));
	
	        _this.selectedLegendIndex = null;
	
	        /**
	         * type of chart
	         * @type {string}
	         */
	        _this.chartType = 'line';
	
	        /**
	         * Line width
	         * @type {number}
	         */
	        _this.lineWidth = 6;
	        return _this;
	    }
	
	    /**
	     * Render function of line chart.
	     * @param {object} [paper] - raphael paper
	     * @param {{groupPositions: Array.<Array>, dimension: object, theme: object, options: object}} data render data
	     * @returns {object} paper raphael paper
	     */
	
	
	    RaphaelLineChart.prototype.render = function render(paper, data) {
	        var dimension = data.dimension,
	            groupPositions = data.groupPositions,
	            theme = data.theme,
	            options = data.options,
	            position = data.position;
	        var colors = theme.colors;
	
	        var opacity = options.showDot ? 1 : 0;
	        var isSpline = options.spline;
	        var lineWidth = this.lineWidth = _tuiCodeSnippet2['default'].isNumber(options.pointWidth) ? options.pointWidth : this.lineWidth;
	        var borderStyle = this.makeBorderStyle(theme.dot.strokeColor, opacity, theme.dot.strokeWidth);
	        var outDotStyle = this.makeOutDotStyle(opacity, borderStyle);
	        var groupPaths = void 0;
	
	        if (isSpline) {
	            groupPaths = this._getSplineLinesPath(groupPositions, options.connectNulls);
	        } else {
	            groupPaths = this._getLinesPath(groupPositions, options.connectNulls);
	        }
	
	        this.paper = paper;
	        this.theme = theme;
	        this.isSpline = isSpline;
	        this.dimension = dimension;
	        this.position = position;
	
	        paper.setStart();
	
	        this.groupLines = this._renderLines(paper, groupPaths, colors, lineWidth);
	        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
	        this.groupDots = this._renderDots(paper, groupPositions, colors, opacity);
	
	        if (options.allowSelect) {
	            this.selectionDot = this._makeSelectionDot(paper);
	            this.selectionColor = theme.selectionColor;
	        }
	        this.colors = colors;
	        this.borderStyle = borderStyle;
	        this.outDotStyle = outDotStyle;
	        this.groupPositions = groupPositions;
	        this.groupPaths = groupPaths;
	        this.dotOpacity = opacity;
	        delete this.pivotGroupDots;
	
	        if (paper.raphael.svg) {
	            this.appendShadowFilterToDefs();
	        }
	
	        return paper.setFinish();
	    };
	
	    RaphaelLineChart.prototype.appendShadowFilterToDefs = function appendShadowFilterToDefs() {
	        var filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
	        var feOffset = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
	        var feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
	        var feBlend = document.createElementNS('http://www.w3.org/2000/svg', 'feBlend');
	
	        filter.setAttributeNS(null, 'id', 'shadow');
	        filter.setAttributeNS(null, 'x', '-50%');
	        filter.setAttributeNS(null, 'y', '-50%');
	        filter.setAttributeNS(null, 'width', '180%');
	        filter.setAttributeNS(null, 'height', '180%');
	        feOffset.setAttributeNS(null, 'result', 'offOut');
	        feOffset.setAttributeNS(null, 'in', 'SourceAlpha');
	        feOffset.setAttributeNS(null, 'dx', '0');
	        feOffset.setAttributeNS(null, 'dy', '0');
	        feGaussianBlur.setAttributeNS(null, 'result', 'blurOut');
	        feGaussianBlur.setAttributeNS(null, 'in', 'offOut');
	        feGaussianBlur.setAttributeNS(null, 'stdDeviation', '2');
	        feBlend.setAttributeNS(null, 'in', 'SourceGraphic');
	        feBlend.setAttributeNS(null, 'in2', 'blurOut');
	        feBlend.setAttributeNS(null, 'mode', 'normal');
	        filter.appendChild(feOffset);
	        filter.appendChild(feGaussianBlur);
	        filter.appendChild(feBlend);
	        this.paper.defs.appendChild(filter);
	    };
	
	    /**
	     * Get lines path.
	     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
	     * @param {boolean} [connectNulls] - boolean value connect nulls or not
	     * @returns {Array.<Array.<string>>} path
	     * @private
	     */
	
	
	    RaphaelLineChart.prototype._getLinesPath = function _getLinesPath(groupPositions, connectNulls) {
	        var _this2 = this;
	
	        return groupPositions.map(function (positions) {
	            return _this2._makeLinesPath(positions, null, connectNulls);
	        });
	    };
	
	    /**
	     * Get spline lines path.
	     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
	     * @param {boolean} [connectNulls] - boolean value connect nulls or not
	     * @returns {Array} path
	     * @private
	     */
	
	
	    RaphaelLineChart.prototype._getSplineLinesPath = function _getSplineLinesPath(groupPositions, connectNulls) {
	        var _this3 = this;
	
	        return groupPositions.map(function (positions) {
	            return _this3._makeSplineLinesPath(positions, { connectNulls: connectNulls });
	        });
	    };
	
	    /**
	     * Render lines.
	     * @param {object} paper raphael paper
	     * @param {Array.<Array.<string>>} groupPaths paths
	     * @param {string[]} colors line colors
	     * @param {?number} strokeWidth stroke width
	     * @returns {Array.<Array.<object>>} lines
	     * @private
	     */
	
	
	    RaphaelLineChart.prototype._renderLines = function _renderLines(paper, groupPaths, colors, strokeWidth) {
	        return groupPaths.map(function (path, groupIndex) {
	            var color = colors[groupIndex] || 'transparent';
	            var line = _raphaelRenderUtil2['default'].renderLine(paper, path.join(' '), color, strokeWidth);
	            line.node.setAttribute('class', 'auto-shape-rendering');
	
	            return line;
	        });
	    };
	
	    /**
	     * Resize graph of line chart.
	     * @param {object} params parameters
	     *      @param {{width: number, height:number}} params.dimension dimension
	     *      @param {Array.<Array.<{left:number, top:number}>>} params.groupPositions group positions
	     */
	
	
	    RaphaelLineChart.prototype.resize = function resize(params) {
	        var _this4 = this;
	
	        var dimension = params.dimension,
	            groupPositions = params.groupPositions;
	
	
	        this.resizeClipRect(dimension.width, dimension.height);
	
	        this.groupPositions = groupPositions;
	        this.groupPaths = this.isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);
	        this.paper.setSize(dimension.width, dimension.height);
	        this.tooltipLine.attr({ top: dimension.height });
	
	        this.groupPaths.forEach(function (path, groupIndex) {
	            _this4.groupLines[groupIndex].attr({ path: path.join(' ') });
	
	            _this4.groupDots[groupIndex].forEach(function (item, index) {
	                if (item.endDot) {
	                    _this4._moveDot(item.endDot.dot, groupPositions[groupIndex][index]);
	                }
	            });
	        });
	    };
	
	    /**
	     * Select legend.
	     * @param {?number} legendIndex legend index
	     */
	
	
	    RaphaelLineChart.prototype.selectLegend = function selectLegend(legendIndex) {
	        var _this5 = this;
	
	        var noneSelected = _tuiCodeSnippet2['default'].isNull(legendIndex);
	
	        if (this.selectedLegendIndex && this.selectedLegendIndex !== -1) {
	            this.resetSeriesOrder(this.selectedLegendIndex);
	        }
	
	        this.selectedLegendIndex = legendIndex;
	
	        this.groupLines.forEach(function (line, groupIndex) {
	            var isSelectedLegend = legendIndex === groupIndex;
	            var opacity = noneSelected || isSelectedLegend ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	            var groupDots = _this5.groupDots[groupIndex];
	
	            line.attr({ 'stroke-opacity': opacity });
	
	            if (isSelectedLegend) {
	                _this5.moveSeriesToFront(line, groupDots);
	            }
	        });
	
	        if (noneSelected) {
	            this.groupLines.forEach(function (line, groupIndex) {
	                _this5.moveSeriesToFront(line, _this5.groupDots[groupIndex]);
	            });
	        }
	    };
	
	    /**
	     * Reset series order after selected to be same to when it is first rendered
	     * @param {number} legendIndex - legend index to reset series order
	     * @ignore
	     */
	
	
	    RaphaelLineChart.prototype.resetSeriesOrder = function resetSeriesOrder(legendIndex) {
	        var frontLine = legendIndex + 1 < this.groupLines.length ? this.groupLines[legendIndex + 1] : null;
	
	        if (frontLine) {
	            this.groupLines[legendIndex].insertBefore(frontLine);
	            this.groupDots[legendIndex].forEach(function (item) {
	                if (item && item.endDot) {
	                    item.endDot.dot.insertBefore(frontLine);
	                }
	            });
	        }
	    };
	
	    /**
	     * @param {SVGElement} lineType - line or area graph
	     * @param {Array.<SVGElement>} dots - dot type element
	     * @ignore
	     * @override
	     */
	
	
	    RaphaelLineChart.prototype.moveSeriesToFront = function moveSeriesToFront(lineType, dots) {
	        lineType.toFront();
	
	        dots.forEach(function (item) {
	            item.endDot.dot.toFront();
	        });
	    };
	
	    /**
	     * Animate for adding data.
	     * @param {object} data - data for graph rendering
	     * @param {number} tickSize - tick size
	     * @param {Array.<Array.<object>>} groupPositions - group positions
	     * @param {boolean} [shiftingOption] - shifting option
	     */
	
	
	    RaphaelLineChart.prototype.animateForAddingData = function animateForAddingData(data, tickSize, groupPositions, shiftingOption) {
	        var _this6 = this;
	
	        var isSpline = data.options.spline;
	        var groupPaths = isSpline ? this._getSplineLinesPath(groupPositions) : this._getLinesPath(groupPositions);
	        var additionalIndex = 0;
	
	        if (!groupPositions.length) {
	            return;
	        }
	
	        if (shiftingOption) {
	            additionalIndex = 1;
	        }
	
	        this.groupLines.forEach(function (line, groupIndex) {
	            var dots = _this6.groupDots[groupIndex];
	            var groupPosition = groupPositions[groupIndex];
	
	            if (shiftingOption) {
	                _this6._removeFirstDot(dots);
	            }
	
	            dots.forEach(function (item, index) {
	                var position = groupPosition[index + additionalIndex];
	                _this6._animateByPosition(item.endDot.dot, position, tickSize);
	            });
	
	            _this6._animateByPath(line, groupPaths[groupIndex], tickSize);
	        });
	    };
	
	    RaphaelLineChart.prototype.renderSeriesLabel = function renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme) {
	        var attributes = {
	            'font-size': labelTheme.fontSize,
	            'font-family': labelTheme.fontFamily,
	            'font-weight': labelTheme.fontWeight,
	            fill: labelTheme.color,
	            'text-anchor': 'middle',
	            opacity: 0
	        };
	        var set = paper.set();
	
	        groupLabels.forEach(function (categoryLabel, categoryIndex) {
	            categoryLabel.forEach(function (label, seriesIndex) {
	                var position = groupPositions[categoryIndex][seriesIndex];
	                var endLabel = _raphaelRenderUtil2['default'].renderText(paper, position.end, label.end, attributes);
	
	                set.push(endLabel);
	
	                endLabel.node.style.userSelect = 'none';
	                endLabel.node.style.cursor = 'default';
	                endLabel.node.setAttribute('filter', 'url(#glow)');
	
	                if (position.start) {
	                    var startLabel = _raphaelRenderUtil2['default'].renderText(paper, position.start, label.start, attributes);
	
	                    startLabel.node.style.userSelect = 'none';
	                    startLabel.node.style.cursor = 'default';
	                    startLabel.node.setAttribute('filter', 'url(#glow)');
	
	                    set.push(startLabel);
	                }
	            });
	        });
	
	        return set;
	    };
	
	    return RaphaelLineChart;
	}(_raphaelLineTypeBase2['default']);
	
	exports['default'] = RaphaelLineChart;

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview RaphaelLineTypeBase is base class for line type renderer.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var browser = _tuiCodeSnippet2['default'].browser;
	
	var IS_LTE_IE8 = browser.msie && browser.version <= 8;
	var ANIMATION_DURATION = 700;
	var DEFAULT_DOT_RADIUS = 6;
	var SELECTION_DOT_RADIUS = 7;
	var DE_EMPHASIS_OPACITY = 0.3;
	var MOVING_ANIMATION_DURATION = 300;
	var CHART_HOVER_STATUS_OVER = 'over';
	var CHART_HOVER_STATUS_OUT = 'out';
	
	/**
	 * @classdesc RaphaelLineTypeBase is base for line type renderer.
	 * @class RaphaelLineTypeBase
	 * @private
	 */
	
	var RaphaelLineTypeBase = function () {
	    function RaphaelLineTypeBase() {
	        _classCallCheck(this, RaphaelLineTypeBase);
	    }
	
	    /**
	     * Make lines path.
	     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
	     * @param {?string} [posTopType='top'] position top type
	     * @param {boolean} [connectNulls] - boolean value connect nulls or not
	     * @returns {Array.<string | number>} paths
	     * @private
	     */
	    RaphaelLineTypeBase.prototype._makeLinesPath = function _makeLinesPath(positions, posTopType, connectNulls) {
	        var _ref;
	
	        var path = [];
	        var prevMissing = false;
	
	        posTopType = posTopType || 'top';
	        [].concat(positions).forEach(function (position) {
	            var pathCommand = prevMissing && !connectNulls ? 'M' : 'L';
	
	            if (position) {
	                path.push([pathCommand, position.left, position[posTopType]]);
	                if (prevMissing) {
	                    prevMissing = false;
	                }
	            } else {
	                prevMissing = true;
	            }
	        });
	
	        path = (_ref = []).concat.apply(_ref, _toConsumableArray(path));
	
	        if (path.length > 0) {
	            path[0] = 'M';
	        }
	
	        return path;
	    };
	
	    /**
	     * Get anchor. (http://raphaeljs.com/analytics.js)
	     * @param {{left: number, top: number}} fromPos from position
	     * @param {{left: number, top: number}} pos position
	     * @param {{left: number, top: number}} nextPos next position
	     * @param {?boolean} [isReverseDirection] - True when the line is drawn from right to left
	     * @returns {{x1: number, y1: number, x2: number, y2: number}} anchor
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._getAnchor = function _getAnchor(fromPos, pos, nextPos, isReverseDirection) {
	        var l1 = (pos.left - fromPos.left) / 2;
	        var l2 = (nextPos.left - pos.left) / 2;
	        var a = void 0,
	            b = void 0;
	
	        if (isReverseDirection) {
	            a = Math.atan((fromPos.left - pos.left) / Math.abs(fromPos.top - pos.top));
	            b = Math.atan((pos.left - nextPos.left) / Math.abs(nextPos.top - pos.top));
	        } else {
	            a = Math.atan((pos.left - fromPos.left) / Math.abs(pos.top - fromPos.top));
	            b = Math.atan((nextPos.left - pos.left) / Math.abs(pos.top - nextPos.top));
	        }
	
	        a = fromPos.top < pos.top ? Math.PI - a : a;
	        b = nextPos.top < pos.top ? Math.PI - b : b;
	        var alpha = Math.PI / 2 - (a + b) % (Math.PI * 2) / 2;
	        var dx1 = l1 * Math.sin(alpha + a);
	        var dy1 = l1 * Math.cos(alpha + a);
	        var dx2 = l2 * Math.sin(alpha + b);
	        var dy2 = l2 * Math.cos(alpha + b);
	        var result = {
	            x1: pos.left - dx1,
	            y1: pos.top + dy1,
	            x2: pos.left + dx2,
	            y2: pos.top + dy2
	        };
	
	        if (isReverseDirection) {
	            result.y1 = pos.top - dy1;
	            result.y2 = pos.top - dy2;
	        }
	
	        return result;
	    };
	
	    /**
	     * Get spline positions groups which is divided with null data value.
	     * If series has not divided positions, it returns only one positions group.
	     * @param {Array.<object>} positions positions array
	     * @param {boolean} connectNulls option of connect line of both null data's side
	     * @Returns {Array.<Array.<object>>}
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._getSplinePositionsGroups = function _getSplinePositionsGroups(positions, connectNulls) {
	        var positionsGroups = [];
	        var positionsGroup = [];
	        positions.forEach(function (position, index) {
	            var isLastIndex = index === positions.length - 1;
	
	            if (position) {
	                positionsGroup.push(position);
	            }
	
	            if (!position && positionsGroup.length > 0 && !connectNulls || isLastIndex) {
	                positionsGroups.push(positionsGroup);
	                positionsGroup = [];
	            }
	        });
	
	        return positionsGroups;
	    };
	
	    /**
	     * Get spline partial paths
	     * @param {Array.<Array.<object>>} positionsGroups positions groups
	     * @param {?boolean} [isReverseDirection] - True when the line is drawn from right to left
	     * @returns {Array.<Array.<Array>>}
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._getSplinePartialPaths = function _getSplinePartialPaths(positionsGroups, isReverseDirection) {
	        var _this = this;
	
	        var paths = [];
	        var lastPos = void 0,
	            positionsLen = void 0,
	            fromPos = void 0,
	            middlePositions = void 0,
	            path = void 0;
	
	        positionsGroups.forEach(function (dataPositions) {
	            var _dataPositions = _slicedToArray(dataPositions, 1),
	                prevPos = _dataPositions[0];
	
	            var firstPos = prevPos;
	            positionsLen = dataPositions.length;
	            fromPos = firstPos;
	            lastPos = dataPositions[positionsLen - 1];
	            middlePositions = dataPositions.slice(1).slice(0, positionsLen - 2);
	
	            path = middlePositions.map(function (position, index) {
	                var nextPos = dataPositions[index + 2];
	                var anchor = _this._getAnchor(fromPos, position, nextPos, isReverseDirection);
	
	                fromPos = position;
	
	                if (Math.abs(anchor.y1 - prevPos.top) > Math.abs(prevPos.top - position.top)) {
	                    anchor.y1 = position.top;
	                }
	
	                if (Math.abs(anchor.y2 - nextPos.top) > Math.abs(nextPos.top - position.top)) {
	                    anchor.y2 = position.top;
	                }
	
	                prevPos = position;
	
	                return [anchor.x1, anchor.y1, position.left, position.top, anchor.x2, anchor.y2];
	            });
	
	            path.push([lastPos.left, lastPos.top, lastPos.left, lastPos.top]);
	            path.unshift(['M', firstPos.left, firstPos.top, 'C', firstPos.left, firstPos.top]);
	            paths.push(path);
	        });
	
	        return paths;
	    };
	
	    /**
	     * Make spline lines path.
	     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
	     * @param {?object} [makeLineOptions] - options for make spline line
	     *   @param {?boolean} [makeLineOptions.connectNulls] - boolean value connect nulls or not
	     *   @param {?boolean} [makeLineOptions.isReverseDirection] - True when the line is drawn from right to left
	     *   @param {?boolean} [makeLineOptions.isBeConnected] - True when part of another line.
	     * @returns {Array.<string | number>} paths
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._makeSplineLinesPath = function _makeSplineLinesPath(positions) {
	        var makeLineOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	        var positionsGroups = this._getSplinePositionsGroups(positions, makeLineOptions.connectNulls);
	        var partialPaths = this._getSplinePartialPaths(positionsGroups, makeLineOptions.isReverseDirection);
	        var path = [];
	
	        partialPaths.forEach(function (partialPath) {
	            path = path.concat(partialPath);
	        });
	
	        if (makeLineOptions.isBeConnected) {
	            path[0] = path[0].slice(3);
	        }
	
	        return path;
	    };
	
	    /**
	     * Render tooltip line.
	     * @param {object} paper raphael paper
	     * @param {number} height height
	     * @returns {object} raphael object
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._renderTooltipLine = function _renderTooltipLine(paper, height) {
	        var linePath = _raphaelRenderUtil2['default'].makeLinePath({
	            left: 10,
	            top: height
	        }, {
	            left: 10,
	            top: 0
	        });
	
	        return _raphaelRenderUtil2['default'].renderLine(paper, linePath, 'transparent', 1);
	    };
	
	    RaphaelLineTypeBase.prototype.appendShadowFilterToDefs = function appendShadowFilterToDefs() {
	        var filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
	        var feOffset = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
	        var feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
	        var feBlend = document.createElementNS('http://www.w3.org/2000/svg', 'feBlend');
	
	        filter.setAttributeNS(null, 'id', 'shadow');
	        filter.setAttributeNS(null, 'x', '-50%');
	        filter.setAttributeNS(null, 'y', '-50%');
	        filter.setAttributeNS(null, 'width', '180%');
	        filter.setAttributeNS(null, 'height', '180%');
	        feOffset.setAttributeNS(null, 'result', 'offOut');
	        feOffset.setAttributeNS(null, 'in', 'SourceAlpha');
	        feOffset.setAttributeNS(null, 'dx', '0');
	        feOffset.setAttributeNS(null, 'dy', '0');
	        feGaussianBlur.setAttributeNS(null, 'result', 'blurOut');
	        feGaussianBlur.setAttributeNS(null, 'in', 'offOut');
	        feGaussianBlur.setAttributeNS(null, 'stdDeviation', '2');
	        feBlend.setAttributeNS(null, 'in', 'SourceGraphic');
	        feBlend.setAttributeNS(null, 'in2', 'blurOut');
	        feBlend.setAttributeNS(null, 'mode', 'normal');
	        filter.appendChild(feOffset);
	        filter.appendChild(feGaussianBlur);
	        filter.appendChild(feBlend);
	        this.paper.defs.appendChild(filter);
	    };
	
	    /**
	     * Make border style.
	     * @param {string} borderColor border color
	     * @param {number} opacity opacity
	     * @param {number} borderWidth border width
	     * @returns {{stroke: string, stroke-width: number, strike-opacity: number}} border style
	     */
	
	
	    RaphaelLineTypeBase.prototype.makeBorderStyle = function makeBorderStyle(borderColor, opacity, borderWidth) {
	        var borderStyle = {
	            'stroke-width': borderWidth,
	            'stroke-opacity': opacity
	        };
	
	        if (borderColor) {
	            borderStyle.stroke = borderColor;
	        }
	
	        return borderStyle;
	    };
	
	    /**
	     * Make dot style for mouseout event.
	     * @param {number} opacity opacity
	     * @param {object} borderStyle border style
	     * @returns {{fill-opacity: number, stroke-opacity: number, r: number}} style
	     */
	
	
	    RaphaelLineTypeBase.prototype.makeOutDotStyle = function makeOutDotStyle(opacity, borderStyle) {
	        var outDotStyle = {
	            'fill-opacity': opacity,
	            'stroke-opacity': opacity,
	            r: DEFAULT_DOT_RADIUS
	        };
	
	        if (borderStyle) {
	            _tuiCodeSnippet2['default'].extend(outDotStyle, borderStyle);
	        }
	
	        return outDotStyle;
	    };
	
	    /**
	     * Render dot.
	     * @param {object} paper raphael papaer
	     * @param {{left: number, top: number}} position dot position
	     * @param {string} color dot color
	     * @param {number} opacity opacity
	     * @returns {object} raphael dot
	     */
	
	
	    RaphaelLineTypeBase.prototype.renderDot = function renderDot(paper, position, color, opacity) {
	        var dotTheme = this.theme && this.theme.dot || { dot: {} };
	        var raphaelDot = void 0;
	
	        if (position) {
	            var dot = paper.circle(position.left, position.top, !_tuiCodeSnippet2['default'].isUndefined(dotTheme.radius) ? dotTheme.radius : DEFAULT_DOT_RADIUS);
	            var dotStyle = {
	                fill: dotTheme.fillColor || color,
	                'fill-opacity': _tuiCodeSnippet2['default'].isNumber(opacity) ? opacity : dotTheme.fillOpacity,
	                stroke: dotTheme.strokeColor || color,
	                'stroke-opacity': _tuiCodeSnippet2['default'].isNumber(opacity) ? opacity : dotTheme.strokeOpacity,
	                'stroke-width': dotTheme.strokeWidth
	            };
	
	            dot.attr(dotStyle);
	
	            raphaelDot = {
	                dot: dot,
	                color: color
	            };
	        }
	
	        return raphaelDot;
	    };
	
	    /**
	     * Move dots to front.
	     * @param {Array.<{startDot: {dot: object}, endDot: {dot: object}}>} dots - dots
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._moveDotsToFront = function _moveDotsToFront(dots) {
	        _raphaelRenderUtil2['default'].forEach2dArray(dots, function (dotInfo) {
	            dotInfo.endDot.dot.toFront();
	            if (dotInfo.startDot) {
	                dotInfo.startDot.dot.toFront();
	            }
	        });
	    };
	
	    /**
	     * Render dots.
	     * @param {object} paper raphael paper
	     * @param {Array.<Array.<object>>} groupPositions positions
	     * @param {string[]} colors colors
	     * @param {number} opacity opacity
	     * @param {Array.<object>} [seriesSet] series set
	     * @returns {Array.<object>} dots
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._renderDots = function _renderDots(paper, groupPositions, colors, opacity, seriesSet) {
	        var _this2 = this;
	
	        var dots = groupPositions.map(function (positions, groupIndex) {
	            var color = colors[groupIndex];
	
	            return Object.values(positions).map(function (position) {
	                var dotMap = {
	                    endDot: _this2.renderDot(paper, position, color, opacity)
	                };
	
	                if (_this2.hasRangeData) {
	                    var startPosition = _tuiCodeSnippet2['default'].extend({}, position);
	                    startPosition.top = startPosition.startTop;
	                    dotMap.startDot = _this2.renderDot(paper, startPosition, color, opacity);
	                }
	
	                if (seriesSet) {
	                    seriesSet.push(dotMap.endDot.dot);
	                    if (dotMap.startDot) {
	                        seriesSet.push(dotMap.startDot.dot);
	                    }
	                }
	
	                return dotMap;
	            });
	        });
	
	        return dots;
	    };
	
	    /**
	     * Get center position
	     * @param {{left: number, top: number}} fromPos from position
	     * @param {{left: number, top: number}} toPos to position
	     * @returns {{left: number, top: number}} position
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._getCenter = function _getCenter(fromPos, toPos) {
	        return {
	            left: (fromPos.left + toPos.left) / 2,
	            top: (fromPos.top + toPos.top) / 2
	        };
	    };
	
	    /**
	     * Show dot.
	     * @param {object} dotInformation raphael object
	     * @param {number} groupIndex seriesIndex
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._showDot = function _showDot(dotInformation, groupIndex) {
	        var hoverTheme = this.theme.dot.hover;
	        var attributes = {
	            'fill-opacity': hoverTheme.fillOpacity,
	            stroke: hoverTheme.strokeColor || dotInformation.color,
	            'stroke-opacity': hoverTheme.strokeOpacity,
	            'stroke-width': hoverTheme.strokeWidth,
	            r: hoverTheme.radius,
	            filter: 'url(#shadow)'
	        };
	
	        this._setPrevDotAttributes(groupIndex, dotInformation.dot);
	
	        if (hoverTheme.fillColor) {
	            attributes.fill = hoverTheme.fillColor;
	        }
	
	        dotInformation.dot.attr(attributes);
	        if (dotInformation.dot.node) {
	            dotInformation.dot.node.setAttribute('filter', 'url(#shadow)');
	        }
	        dotInformation.dot.toFront();
	    };
	
	    /**
	     * temp save dot style attribute
	     * @param {number} groupIndex seriesIndex
	     * @param {object} dot raphael circle object
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._setPrevDotAttributes = function _setPrevDotAttributes(groupIndex, dot) {
	        if (!this._prevDotAttributes) {
	            this._prevDotAttributes = {};
	        }
	        this._prevDotAttributes[groupIndex] = dot.attr();
	    };
	
	    /**
	     * Update line stroke width.
	     * @param {string} changeType over or out
	     * @param {object} line raphael object
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._updateLineStrokeOpacity = function _updateLineStrokeOpacity(changeType, line) {
	        var opacity = 1;
	        var isSelectedLegend = !_tuiCodeSnippet2['default'].isNull(this.selectedLegendIndex);
	        if (this.groupLines) {
	            if (changeType === CHART_HOVER_STATUS_OVER || isSelectedLegend) {
	                opacity = this.chartType === 'radial' && this.showArea ? 0 : DE_EMPHASIS_OPACITY;
	            }
	
	            if (changeType === CHART_HOVER_STATUS_OUT && isSelectedLegend) {
	                line = this.getLine(this.selectedLegendIndex);
	            }
	
	            this.groupLines.forEach(function (otherLine) {
	                otherLine.attr({
	                    'stroke-opacity': opacity
	                });
	            });
	            line.attr({
	                'stroke-opacity': 1
	            });
	        }
	    };
	
	    /**
	     * Get the raphael line element with groupIndex
	     * @param {number} groupIndex  group index
	     * @returns {object} line raphael object
	     */
	
	
	    RaphaelLineTypeBase.prototype.getLine = function getLine(groupIndex) {
	        return this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];
	    };
	
	    /**
	     * Update line stroke width.
	     * @param {string} changeType over or out
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._updateAreaOpacity = function _updateAreaOpacity(changeType) {
	        if (this.groupAreas) {
	            this.groupAreas.forEach(function (otherArea) {
	                otherArea.area.attr({
	                    'fill-opacity': changeType === CHART_HOVER_STATUS_OVER ? DE_EMPHASIS_OPACITY : 1
	                });
	            });
	        }
	    };
	
	    /**
	     * Update line stroke width.
	     * @param {object} line raphael object
	     * @param {number} strokeWidth stroke width
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._updateLineStrokeWidth = function _updateLineStrokeWidth(line, strokeWidth) {
	        var changeAttr = {
	            'stroke-width': strokeWidth
	        };
	        if (line.attrs) {
	            changeAttr.stroke = line.attrs.stroke;
	        }
	        line.attr(changeAttr);
	    };
	
	    /**
	     * Show animation.
	     * @param {{groupIndex: number, index:number}} data show info
	     */
	
	
	    RaphaelLineTypeBase.prototype.showAnimation = function showAnimation(data) {
	        var groupIndex = data.index;
	        var groupDot = this.groupDots[groupIndex];
	        var item = this._findDotItem(groupDot, data.groupIndex);
	
	        var line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];
	        var strokeWidth = void 0,
	            startLine = void 0;
	
	        if (!item) {
	            return;
	        }
	
	        if (this.chartType === 'area') {
	            var _line = line;
	            startLine = _line.startLine;
	            line = _line.line;
	
	            strokeWidth = 5;
	            this._updateAreaOpacity(CHART_HOVER_STATUS_OVER);
	        } else {
	            strokeWidth = this.lineWidth;
	        }
	
	        this._updateLineStrokeOpacity(CHART_HOVER_STATUS_OVER, line);
	        this._updateLineStrokeWidth(line, strokeWidth);
	        if (startLine) {
	            this._updateLineStrokeWidth(startLine, strokeWidth);
	        }
	
	        this._showDot(item.endDot, groupIndex);
	
	        if (item.startDot) {
	            this._showDot(item.startDot, groupIndex);
	        }
	    };
	
	    /**
	     * Find dot item
	     * @param {Array.<Object>} groupDot - groupDot info
	     * @param {number} index - dot index
	     * @returns {Object} - raphael object
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._findDotItem = function _findDotItem() {
	        var groupDot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	        var index = arguments[1];
	
	        var isRadialChart = _predicate2['default'].isRadialChart(this.chartType);
	
	        // For radial charts, the position path is one more than the length of the data.
	        if (isRadialChart && groupDot.length === index) {
	            index = 0;
	        }
	
	        return groupDot[index];
	    };
	
	    /**
	     * Get pivot group dots.
	     * @returns {Array.<Array>} dots
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._getPivotGroupDots = function _getPivotGroupDots() {
	        if (!this.pivotGroupDots && this.groupDots) {
	            this.pivotGroupDots = _arrayUtil2['default'].pivot(this.groupDots);
	        }
	
	        return this.pivotGroupDots;
	    };
	
	    /**
	     * Show group dots.
	     * @param {number} index index
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._showGroupDots = function _showGroupDots(index) {
	        var _this3 = this;
	
	        var groupDots = this._getPivotGroupDots();
	
	        if (!groupDots || !groupDots[index]) {
	            return;
	        }
	
	        groupDots[index].forEach(function (item, groupIndex) {
	            if (item.endDot) {
	                _this3._showDot(item.endDot, groupIndex);
	            }
	
	            if (item.startDot) {
	                _this3._showDot(item.startDot, groupIndex);
	            }
	        });
	    };
	
	    /**
	     * Show line for group tooltip.
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }} bound bound
	     * @param {object} layout layout
	     */
	
	
	    RaphaelLineTypeBase.prototype.showGroupTooltipLine = function showGroupTooltipLine(bound, layout) {
	        var left = Math.max(bound.position.left, 11);
	        var linePath = _raphaelRenderUtil2['default'].makeLinePath({
	            left: left,
	            top: layout.position.top + bound.dimension.height
	        }, {
	            left: left,
	            top: layout.position.top
	        });
	
	        if (this.tooltipLine) {
	            this.tooltipLine.attr({
	                path: linePath,
	                stroke: '#999',
	                'stroke-opacity': 1
	            });
	        }
	    };
	
	    /**
	     * Show group animation.
	     * @param {number} index index
	     */
	
	
	    RaphaelLineTypeBase.prototype.showGroupAnimation = function showGroupAnimation(index) {
	        this._showGroupDots(index);
	    };
	
	    /**
	     * Hide dot.
	     * @param {object} dot raphael object
	     * @param {number} groupIndex seriesIndex
	     * @param {?number} opacity opacity
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._hideDot = function _hideDot(dot, groupIndex, opacity) {
	        var prev = this._prevDotAttributes[groupIndex];
	        var outDotStyle = this.outDotStyle;
	
	        // if prev data exists, use prev.r
	        // there is dot disappearing issue, when hideDot
	
	        if (prev && !_tuiCodeSnippet2['default'].isUndefined(opacity)) {
	            outDotStyle = _tuiCodeSnippet2['default'].extend({
	                'r': prev.r,
	                'stroke': prev.stroke,
	                'fill': prev.fill,
	                'stroke-opacity': prev['stroke-opacity'],
	                'stroke-width': prev['stroke-width'],
	                'fill-opacity': prev['fill-opacity']
	            });
	        }
	
	        dot.attr(outDotStyle);
	        if (dot.node) {
	            dot.node.setAttribute('filter', '');
	        }
	
	        this.resetSeriesOrder(groupIndex);
	    };
	
	    /**
	     * Hide animation.
	     * @param {{groupIndex: number, index:number}} data hide info
	     */
	
	
	    RaphaelLineTypeBase.prototype.hideAnimation = function hideAnimation(data) {
	        var index = data.groupIndex; // Line chart has pivot values.
	        var groupIndex = data.index;
	        var groupDot = this.groupDots[groupIndex];
	        var item = this._findDotItem(groupDot, index);
	
	        var line = void 0,
	            strokeWidth = void 0,
	            startLine = void 0;
	        var opacity = this.dotOpacity;
	
	        if (!item) {
	            return;
	        }
	
	        line = this.groupLines ? this.groupLines[groupIndex] : this.groupAreas[groupIndex];
	
	        if (this.chartType === 'area') {
	            strokeWidth = this.lineWidth;
	            var _line2 = line;
	            startLine = _line2.startLine;
	            line = _line2.line;
	
	            this._updateAreaOpacity(CHART_HOVER_STATUS_OUT);
	        } else {
	            strokeWidth = this.lineWidth;
	        }
	
	        if (opacity && !_tuiCodeSnippet2['default'].isNull(this.selectedLegendIndex) && this.selectedLegendIndex !== groupIndex) {
	            opacity = DE_EMPHASIS_OPACITY;
	        }
	
	        this._updateLineStrokeOpacity(CHART_HOVER_STATUS_OUT, line);
	        this._updateLineStrokeWidth(line, strokeWidth);
	
	        if (startLine) {
	            this._updateLineStrokeWidth(startLine, strokeWidth);
	        }
	
	        if (item) {
	            this._hideDot(item.endDot.dot, groupIndex, opacity);
	
	            if (item.startDot) {
	                this._hideDot(item.startDot.dot, groupIndex, opacity);
	            }
	        }
	    };
	
	    /**
	     * Hide group dots.
	     * @param {number} index index
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._hideGroupDots = function _hideGroupDots(index) {
	        var _this4 = this;
	
	        var hasSelectedIndex = !_tuiCodeSnippet2['default'].isNull(this.selectedLegendIndex);
	        var baseOpacity = this.dotOpacity;
	        var groupDots = this._getPivotGroupDots();
	
	        if (!groupDots || !groupDots[index]) {
	            return;
	        }
	
	        groupDots[index].forEach(function (item, groupIndex) {
	            var opacity = baseOpacity;
	
	            if (opacity && hasSelectedIndex && _this4.selectedLegendIndex !== groupIndex) {
	                opacity = DE_EMPHASIS_OPACITY;
	            }
	
	            if (item.endDot) {
	                _this4._hideDot(item.endDot.dot, groupIndex, opacity);
	            }
	
	            if (item.startDot) {
	                _this4._hideDot(item.startDot.dot, groupIndex, opacity);
	            }
	        });
	    };
	
	    /**
	     * Hide line for group tooltip.
	     */
	
	
	    RaphaelLineTypeBase.prototype.hideGroupTooltipLine = function hideGroupTooltipLine() {
	        this.tooltipLine.attr({
	            'stroke-opacity': 0
	        });
	    };
	
	    /**
	     * Hide group animation.
	     * @param {number} index index
	     */
	
	
	    RaphaelLineTypeBase.prototype.hideGroupAnimation = function hideGroupAnimation(index) {
	        this._hideGroupDots(index);
	    };
	
	    /**
	     * Move dot.
	     * @param {object} dot - raphael object
	     * @param {{left: number, top: number}} position - position
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._moveDot = function _moveDot(dot, position) {
	        var dotAttrs = {
	            cx: position.left,
	            cy: position.top
	        };
	
	        if (this.dotOpacity) {
	            dotAttrs = _tuiCodeSnippet2['default'].extend({ 'fill-opacity': this.dotOpacity }, dotAttrs, this.borderStyle);
	        }
	
	        dot.attr(dotAttrs);
	    };
	
	    /**
	     * Animate.
	     * @param {function} onFinish callback
	     * @param {Array.<object>} seriesSet series set
	     */
	
	
	    RaphaelLineTypeBase.prototype.animate = function animate(onFinish, seriesSet) {
	        var paper = this.paper,
	            dimension = this.dimension,
	            position = this.position;
	
	        var clipRectId = this._getClipRectId();
	        var remakePosition = this._makeClipRectPosition(position);
	        var clipRect = this.clipRect;
	
	
	        if (!IS_LTE_IE8 && dimension) {
	            if (!clipRect) {
	                clipRect = createClipPathRectWithLayout(paper, remakePosition, dimension, clipRectId);
	                this.clipRect = clipRect;
	            } else {
	                this._makeClipRectPosition(position);
	                clipRect.attr({
	                    width: 0,
	                    height: dimension.height,
	                    x: remakePosition.left,
	                    y: remakePosition.top
	                });
	            }
	
	            seriesSet.forEach(function (seriesElement) {
	                seriesElement.node.setAttribute('clip-path', 'url(#' + clipRectId + ')');
	            });
	
	            clipRect.animate({
	                width: dimension.width
	            }, ANIMATION_DURATION, '>', onFinish);
	        }
	    };
	
	    /**
	     * Make selection dot.
	     * @param {object} position clip rect position
	     *   @param {number} left clip rect left position
	     *   @param {number} top clip rect top position
	     * @returns {{top: number, left: number}} remake clip rect position
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._makeClipRectPosition = function _makeClipRectPosition(position) {
	        return {
	            left: position.left - _const2['default'].SERIES_EXPAND_SIZE,
	            top: position.top - _const2['default'].SERIES_EXPAND_SIZE
	        };
	    };
	
	    /**
	     * Make selection dot.
	     * @param {object} paper raphael paper
	     * @returns {object} selection dot
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._makeSelectionDot = function _makeSelectionDot(paper) {
	        var selectionDot = paper.circle(0, 0, SELECTION_DOT_RADIUS);
	
	        selectionDot.attr({
	            'fill': '#ffffff',
	            'fill-opacity': 0,
	            'stroke-opacity': 0,
	            'stroke-width': 2
	        });
	
	        return selectionDot;
	    };
	
	    /**
	     * Select series.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     */
	
	
	    RaphaelLineTypeBase.prototype.selectSeries = function selectSeries(indexes) {
	        var item = this.groupDots[indexes.index][indexes.groupIndex];
	        var position = this.groupPositions[indexes.index][indexes.groupIndex];
	
	        this.selectedItem = item;
	        this.selectionDot.attr({
	            cx: position.left,
	            cy: position.top,
	            'fill-opacity': 0.5,
	            'stroke-opacity': 1,
	            stroke: this.selectionColor || item.endDot.color
	        });
	
	        if (this.selectionStartDot) {
	            this.selectionStartDot.attr({
	                cx: position.left,
	                cy: position.startTop,
	                'fill-opacity': 0.5,
	                'stroke-opacity': 1,
	                stroke: this.selectionColor || item.startDot.color
	            });
	        }
	    };
	
	    /**
	     * Unselect series.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     */
	
	
	    RaphaelLineTypeBase.prototype.unselectSeries = function unselectSeries(indexes) {
	        var item = this.groupDots[indexes.index][indexes.groupIndex];
	
	        if (this.selectedItem === item) {
	            this.selectionDot.attr({
	                'fill-opacity': 0,
	                'stroke-opacity': 0
	            });
	        }
	
	        if (this.selectionStartDot) {
	            this.selectionStartDot.attr({
	                'fill-opacity': 0,
	                'stroke-opacity': 0
	            });
	        }
	    };
	
	    /**
	     * Set width or height of paper.
	     * @param {number} width - width
	     * @param {number} height - height
	     */
	
	
	    RaphaelLineTypeBase.prototype.setSize = function setSize(width, height) {
	        width = width || this.dimension.width;
	        height = height || this.dimension.height;
	        this.paper.setSize(width, height);
	    };
	
	    /**
	     * Animate by position.
	     * @param {object} raphaelObj - raphael object
	     * @param {{left: number, top: number}} position - position
	     * @param {number} tickSize tick size
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._animateByPosition = function _animateByPosition(raphaelObj, position, tickSize) {
	        var attr = {
	            cx: position.left,
	            cy: position.top
	        };
	
	        if (_tuiCodeSnippet2['default'].isExisty(tickSize)) {
	            attr.transform = 't-' + tickSize + ',0';
	        }
	
	        raphaelObj.animate(attr, MOVING_ANIMATION_DURATION);
	    };
	
	    /**
	     * Animate by path.
	     * @param {object} raphaelObj - raphael object
	     * @param {Array.<string | number>} paths - paths
	     * @param {number} tickSize tick size
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._animateByPath = function _animateByPath(raphaelObj, paths, tickSize) {
	        var attr = {
	            path: paths.join(' ')
	        };
	
	        if (_tuiCodeSnippet2['default'].isExisty(tickSize)) {
	            attr.transform = 't-' + tickSize + ',0';
	        }
	
	        raphaelObj.animate(attr, MOVING_ANIMATION_DURATION);
	    };
	
	    /**
	     * Remove first dot.
	     * @param {Array.<object>} dots - dots
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._removeFirstDot = function _removeFirstDot(dots) {
	        var firstDot = dots.shift();
	
	        firstDot.endDot.dot.remove();
	
	        if (firstDot.startDot) {
	            firstDot.startDot.dot.remove();
	        }
	    };
	
	    /**
	     * Clear paper.
	     */
	
	
	    RaphaelLineTypeBase.prototype.clear = function clear() {
	        delete this.paper.dots;
	        this.paper.clear();
	    };
	
	    /**
	     * Resize clip rect size
	     * @param {number} width series width
	     * @param {number} height series height
	     */
	
	
	    RaphaelLineTypeBase.prototype.resizeClipRect = function resizeClipRect(width, height) {
	        var clipRect = this.paper.getById(this._getClipRectId() + '_rect');
	
	        clipRect.attr({
	            width: width,
	            height: height
	        });
	    };
	
	    /**
	     * Set clip rect id
	     * @returns {string} id - clip rect id
	     * @private
	     */
	
	
	    RaphaelLineTypeBase.prototype._getClipRectId = function _getClipRectId() {
	        if (!this.clipRectId) {
	            this.clipRectId = _renderUtil2['default'].generateClipRectId();
	        }
	
	        return this.clipRectId;
	    };
	
	    /**
	     * Reset series order after selected to be same to when it is first rendered
	     * @param {number} legendIndex - legend index to reset series order
	     * @ignore
	     * @abstract
	     */
	
	
	    RaphaelLineTypeBase.prototype.resetSeriesOrder = function resetSeriesOrder() {};
	
	    /**
	     * @param {SVGElement | {area: {SVGElement}, line: {SVGElement}, startLine: {SVGElement}}} lineType - line or area graph
	     * @param {Array.<SVGElement>} dots - dot type element
	     * @abstract
	     */
	
	
	    RaphaelLineTypeBase.prototype.moveSeriesToFront = function moveSeriesToFront() {};
	
	    return RaphaelLineTypeBase;
	}();
	
	/**
	 * Create clip rect with layout
	 * @param {object} paper Raphael paper
	 * @param {object} position position
	 * @param {object} dimension dimension
	 * @param {string} id ID string
	 * @returns {object}
	 * @ignore
	 */
	
	
	function createClipPathRectWithLayout(paper, position, dimension, id) {
	    var clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
	    var rect = paper.rect(position.left, position.top, 0, dimension.height);
	
	    rect.id = id + '_rect';
	    clipPath.id = id;
	
	    clipPath.appendChild(rect.node);
	    paper.defs.appendChild(clipPath);
	
	    return rect;
	}
	
	exports['default'] = RaphaelLineTypeBase;

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * predicate.
	 * @module predicate
	 * @private */
	/**
	 * @fileoverview Predicate.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	var predicate = {
	    /**
	     * Whether bar chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isBarChart: function isBarChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_BAR;
	    },
	
	
	    /**
	     * Whether column chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isColumnChart: function isColumnChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_COLUMN;
	    },
	
	
	    /**
	     * Whether bar type chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isBarTypeChart: function isBarTypeChart(chartType) {
	        return predicate.isBarChart(chartType) || predicate.isColumnChart(chartType);
	    },
	
	
	    /**
	     * Whether column type chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @param {Array.<string>} seriesTypes - type of series
	     * @returns {boolean}
	     */
	    isColumnTypeChart: function isColumnTypeChart(chartType, seriesTypes) {
	        return predicate.isHeatmapChart(chartType) || predicate.isColumnChart(chartType) || predicate.isBoxplotChart(chartType) || predicate.isLineColumnComboChart(chartType, seriesTypes);
	    },
	
	
	    /**
	     * Whether boxplot chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isBoxplotChart: function isBoxplotChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_BOXPLOT;
	    },
	
	
	    /**
	     * Whether bullet chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isBulletChart: function isBulletChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_BULLET;
	    },
	
	
	    /**
	     * Whether radial type chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isRadialChart: function isRadialChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_RADIAL;
	    },
	
	
	    /**
	     * Whether diverging chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @param {boolean} diverging - whether has diverging or not
	     * @returns {*|boolean}
	     */
	    isDivergingChart: function isDivergingChart(chartType, diverging) {
	        return this.isBarTypeChart(chartType) && diverging;
	    },
	
	
	    /**
	     * Whether normal stack chart or not.
	     * @param {string} chartType - type of chart
	     * @param {string} stackType - type of stack
	     * @returns {boolean}
	     * @private
	     */
	    isNormalStackChart: function isNormalStackChart(chartType, stackType) {
	        var isAllowedStackOption = predicate.isAllowedStackOption(chartType);
	        var isNormalStack = predicate.isNormalStack(stackType);
	
	        return isAllowedStackOption && isNormalStack;
	    },
	
	
	    /**
	     * Whether percent stack chart or not.
	     * @param {string} chartType - type of chart
	     * @param {string} stackType - type of stack
	     * @returns {boolean}
	     * @private
	     */
	    isPercentStackChart: function isPercentStackChart(chartType, stackType) {
	        var isAllowedStackOption = predicate.isAllowedStackOption(chartType);
	        var isPercentStack = predicate.isPercentStack(stackType);
	
	        return isAllowedStackOption && isPercentStack;
	    },
	
	
	    /**
	     * Whether combo chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isComboChart: function isComboChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_COMBO;
	    },
	
	
	    /**
	     * Whether line and column combo chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @param {Array.<string>} subChartTypes - types of chart
	     * @returns {boolean}
	     */
	    isLineColumnComboChart: function isLineColumnComboChart(chartType, subChartTypes) {
	        var isLineOrColumn = _arrayUtil2['default'].all(subChartTypes || [], function (subChartType) {
	            return predicate.isLineChart(subChartType) || predicate.isColumnChart(subChartType);
	        });
	
	        return predicate.isComboChart(chartType) && isLineOrColumn;
	    },
	
	
	    /**
	     * Whether pie and donut combo chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @param {Array.<string>} subChartTypes - types of chart
	     * @returns {boolean}
	     */
	    isPieDonutComboChart: function isPieDonutComboChart(chartType, subChartTypes) {
	        var isAllPieType = _arrayUtil2['default'].all(subChartTypes, function (subChartType) {
	            return predicate.isPieChart(subChartType);
	        });
	
	        return predicate.isComboChart(chartType) && isAllPieType;
	    },
	
	
	    /**
	     * Whether line chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isLineChart: function isLineChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_LINE;
	    },
	
	
	    /**
	     * Whether area chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isAreaChart: function isAreaChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_AREA;
	    },
	
	
	    /**
	     * Whether line and area combo chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @param {Array.<string>} subChartTypes - types of chart
	     * @returns {boolean}
	     */
	    isLineAreaComboChart: function isLineAreaComboChart(chartType, subChartTypes) {
	        var isAllLineType = _arrayUtil2['default'].all(subChartTypes || [], function (subChartType) {
	            return predicate.isLineChart(subChartType) || predicate.isAreaChart(subChartType);
	        });
	
	        return predicate.isComboChart(chartType) && isAllLineType;
	    },
	
	
	    /**
	     * Whether line and area combo chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @param {Array.<string>} subChartTypes - types of chart
	     * @returns {boolean}
	     */
	    hasLineChart: function hasLineChart(chartType, subChartTypes) {
	        var hasLineType = _arrayUtil2['default'].any(subChartTypes || [], function (subChartType) {
	            return predicate.isLineChart(subChartType);
	        });
	
	        return predicate.isComboChart(chartType) && hasLineType;
	    },
	
	
	    /**
	     * Whether line and scatter combo chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @param {Array.<string>} subChartTypes - types of chart
	     * @returns {boolean}
	     */
	    isLineScatterComboChart: function isLineScatterComboChart(chartType, subChartTypes) {
	        var isAllLineType = _arrayUtil2['default'].all(subChartTypes || [], function (subChartType) {
	            return predicate.isLineChart(subChartType) || predicate.isScatterChart(subChartType);
	        });
	
	        return predicate.isComboChart(chartType) && isAllLineType;
	    },
	
	
	    /**
	     * Whether line type chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @param {Array.<string>} [subChartTypes] - types of chart
	     * @returns {boolean}
	     */
	    isLineTypeChart: function isLineTypeChart(chartType, subChartTypes) {
	        return predicate.isLineChart(chartType) || predicate.isAreaChart(chartType) || predicate.isLineAreaComboChart(chartType, subChartTypes);
	    },
	
	
	    /**
	     * Whether bubble chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isBubbleChart: function isBubbleChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_BUBBLE;
	    },
	
	
	    /**
	     * Whether scatter chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	    isScatterChart: function isScatterChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_SCATTER;
	    },
	
	
	    /**
	     * Whether heatmap chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	    isHeatmapChart: function isHeatmapChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_HEATMAP;
	    },
	
	
	    /**
	     * Whether treemap chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	    isTreemapChart: function isTreemapChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_TREEMAP;
	    },
	
	
	    /**
	     * Whether box type chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	    isBoxTypeChart: function isBoxTypeChart(chartType) {
	        return predicate.isHeatmapChart(chartType) || predicate.isTreemapChart(chartType);
	    },
	
	
	    /**
	     * Whether map type chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	    isMapTypeChart: function isMapTypeChart(chartType) {
	        return this.isMapChart(chartType) || this.isHeatmapChart(chartType) || this.isTreemapChart(chartType);
	    },
	
	
	    /**
	     * Whether pie chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	    isPieChart: function isPieChart(chartType) {
	        // change to indexOf for handling alias
	        return chartType && chartType.indexOf(_const2['default'].CHART_TYPE_PIE) !== -1;
	    },
	
	
	    /**
	     * Whether map chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isMapChart: function isMapChart(chartType) {
	        return chartType === _const2['default'].CHART_TYPE_MAP;
	    },
	
	
	    /**
	     * Whether coordinate type chart or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	    isCoordinateTypeChart: function isCoordinateTypeChart(chartType) {
	        return predicate.isBubbleChart(chartType) || predicate.isScatterChart(chartType);
	    },
	
	
	    /**
	     * Whether allow rendering for minus point in area of series.
	     * @memberOf module:predicate
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	    allowMinusPointRender: function allowMinusPointRender(chartType) {
	        return predicate.isLineTypeChart(chartType) || predicate.isCoordinateTypeChart(chartType) || predicate.isBoxTypeChart(chartType) || predicate.isBulletChart(chartType);
	    },
	
	
	    /**
	     * Whether chart to detect mouse events on series or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isChartToDetectMouseEventOnSeries: function isChartToDetectMouseEventOnSeries(chartType) {
	        return predicate.isPieChart(chartType) || predicate.isMapChart(chartType) || predicate.isCoordinateTypeChart(chartType);
	    },
	
	
	    /**
	     * Whether align of label is outer or not.
	     * @memberOf module:predicate
	     * @param {string} align - align of legend
	     * @returns {boolean}
	     */
	    isLabelAlignOuter: function isLabelAlignOuter(align) {
	        return align === _const2['default'].LABEL_ALIGN_OUTER;
	    },
	
	
	    /**
	     * Whether show label or not.
	     * @param {{showLabel: ?boolean, showLegend: ?boolean}} options - options
	     * @returns {boolean}
	     */
	    isShowLabel: function isShowLabel(options) {
	        return options.showLabel || options.showLegend;
	    },
	
	
	    /**
	     * Whether show outer label or not.
	     * @param {{showLabel: ?boolean, showLegend: ?boolean, labelAlign: string}} options - options
	     * @returns {*|boolean}
	     */
	    isShowOuterLabel: function isShowOuterLabel(options) {
	        return predicate.isShowLabel(options) && predicate.isLabelAlignOuter(options.labelAlign);
	    },
	
	
	    /**
	     * Whether align of legend is left or not.
	     * @memberOf module:predicate
	     * @param {string} align - align of legend
	     * @returns {boolean}
	     */
	    isLegendAlignLeft: function isLegendAlignLeft(align) {
	        return align === _const2['default'].LEGEND_ALIGN_LEFT;
	    },
	
	
	    /**
	     * Whether align of legend is top or not.
	     * @memberOf module:predicate
	     * @param {string} align - align of legend
	     * @returns {boolean}
	     */
	    isLegendAlignTop: function isLegendAlignTop(align) {
	        return align === _const2['default'].LEGEND_ALIGN_TOP;
	    },
	
	
	    /**
	     * Whether align of legend is bottom or not.
	     * @memberOf module:predicate
	     * @param {string} align - align of legend
	     * @returns {boolean}
	     */
	    isLegendAlignBottom: function isLegendAlignBottom(align) {
	        return align === _const2['default'].LEGEND_ALIGN_BOTTOM;
	    },
	
	
	    /**
	     * Whether horizontal legend or not.
	     * @memberOf module:predicate
	     * @param {string} align - align option for legend
	     * @returns {boolean}
	     */
	    isHorizontalLegend: function isHorizontalLegend(align) {
	        return predicate.isLegendAlignTop(align) || predicate.isLegendAlignBottom(align);
	    },
	
	
	    /**
	     * Whether vertical legend or not.
	     * @memberOf module:predicate
	     * @param {string} align - align option for legend
	     * @returns {boolean}
	     */
	    isVerticalLegend: function isVerticalLegend(align) {
	        return !predicate.isHorizontalLegend(align);
	    },
	
	
	    /**
	     * Whether allowed stackType option or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - type of chart
	     * @returns {boolean}
	     */
	    isAllowedStackOption: function isAllowedStackOption(chartType) {
	        return predicate.isBarChart(chartType) || predicate.isColumnChart(chartType) || predicate.isAreaChart(chartType);
	    },
	
	
	    /**
	     * Whether normal stack type or not.
	     * @memberOf module:predicate
	     * @param {boolean} stackType - stackType option
	     * @returns {boolean}
	     */
	    isNormalStack: function isNormalStack(stackType) {
	        return stackType === _const2['default'].NORMAL_STACK_TYPE;
	    },
	
	
	    /**
	     * Whether percent stack type or not.
	     * @memberOf module:predicate
	     * @param {boolean} stackType - stackType option
	     * @returns {boolean}
	     */
	    isPercentStack: function isPercentStack(stackType) {
	        return stackType === _const2['default'].PERCENT_STACK_TYPE;
	    },
	
	
	    /**
	     * Whether valid stackType option or not.
	     * @memberOf module:predicate
	     * @param {boolean} stackType - stackType option
	     * @returns {boolean}
	     */
	    isValidStackOption: function isValidStackOption(stackType) {
	        return stackType && (predicate.isNormalStack(stackType) || predicate.isPercentStack(stackType));
	    },
	
	
	    /**
	     * Whether allow range data or not.
	     * @memberOf module:predicate
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	    isAllowRangeData: function isAllowRangeData(chartType) {
	        return predicate.isBarTypeChart(chartType) || predicate.isAreaChart(chartType);
	    },
	
	
	    /**
	     * Whether align of yAxis is center or not.
	     * @memberOf module:predicate
	     * @param {boolean} hasRightYAxis - whether has right yAxis.
	     * @param {string} alignOption - align option of yAxis.
	     * @returns {boolean} whether - align center or not.
	     */
	    isYAxisAlignCenter: function isYAxisAlignCenter(hasRightYAxis, alignOption) {
	        return !hasRightYAxis && alignOption === _const2['default'].YAXIS_ALIGN_CENTER;
	    },
	
	
	    /**
	     * Whether minus limit or not.
	     * @memberOf module:predicate
	     * @param {{min: number, max: number}} limit - limit
	     * @returns {boolean}
	     */
	    isMinusLimit: function isMinusLimit(limit) {
	        return limit.min <= 0 && limit.max <= 0;
	    },
	
	
	    /**
	     * Whether auto tick interval or not.
	     * @param {string} [tickInterval] - tick interval option
	     * @returns {boolean}
	     */
	    isAutoTickInterval: function isAutoTickInterval(tickInterval) {
	        return tickInterval === _const2['default'].TICK_INTERVAL_AUTO;
	    },
	
	
	    /**
	     * Whether valid label interval or not.
	     * @param {number} [labelInterval] - label interval option
	     * @param {string} [tickInterval] - tick interval option
	     * @returns {*|boolean}
	     */
	    isValidLabelInterval: function isValidLabelInterval(labelInterval, tickInterval) {
	        return labelInterval && labelInterval > 1 && !tickInterval;
	    },
	
	
	    /**
	     * Whether datetime type or not.
	     * @param {string} type - type
	     * @returns {boolean}
	     */
	    isDatetimeType: function isDatetimeType(type) {
	        return type === _const2['default'].AXIS_TYPE_DATETIME;
	    },
	
	
	    /**
	     * @param {string} chartType - type of chart
	     * @returns {boolean} - whether it support ChartBase#showTooltip API
	     */
	    isSupportPublicShowTooptipAPI: function isSupportPublicShowTooptipAPI(chartType) {
	        return this.isBarChart(chartType) || this.isColumnChart(chartType) || this.isLineChart(chartType) || this.isAreaChart(chartType) || this.isBoxplotChart(chartType);
	    },
	
	
	    /**
	     * @param {string} chartType - type of chart
	     * @returns {boolean} - whether it support ChartBase#hideTooltip API
	     */
	    isSupportPublicHideTooptipAPI: function isSupportPublicHideTooptipAPI(chartType) {
	        return this.isBarChart(chartType) || this.isColumnChart(chartType) || this.isLineChart(chartType) || this.isAreaChart(chartType) || this.isBoxplotChart(chartType);
	    }
	};
	
	exports['default'] = predicate;

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _raphaelLineTypeBase = __webpack_require__(341);
	
	var _raphaelLineTypeBase2 = _interopRequireDefault(_raphaelLineTypeBase);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _consoleUtil = __webpack_require__(344);
	
	var _consoleUtil2 = _interopRequireDefault(_consoleUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Raphael area chart renderer.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var GUIDE_AREACHART_AREAOPACITY_TYPE = _const2['default'].GUIDE_AREACHART_AREAOPACITY_TYPE,
	    CLASS_NAME_SVG_AUTOSHAPE = _const2['default'].CLASS_NAME_SVG_AUTOSHAPE;
	
	var EMPHASIS_OPACITY = 1;
	var DE_EMPHASIS_OPACITY = 0.3;
	
	var RaphaelAreaChart = function (_RaphaelLineBase) {
	    _inherits(RaphaelAreaChart, _RaphaelLineBase);
	
	    /**
	     * RaphaelAreaChart is graph renderer for area chart.
	     * @constructs RaphaelAreaChart
	     * @private
	     * @private
	     * @extends RaphaelLineTypeBase
	     */
	    function RaphaelAreaChart() {
	        _classCallCheck(this, RaphaelAreaChart);
	
	        /**
	         * selected legend index
	         * @type {?number}
	         */
	        var _this = _possibleConstructorReturn(this, _RaphaelLineBase.call(this));
	
	        _this.selectedLegendIndex = null;
	
	        /**
	         * type of chart
	         * @type {string}
	         */
	        _this.chartType = 'area';
	
	        /**
	         * Line width
	         * @type {number}
	         */
	        _this.lineWidth = 0;
	        return _this;
	    }
	
	    /**
	     * Render function of area chart.
	     * @param {object} paper - raphael paper
	     * @param {{groupPositions: Array.<Array>, dimension: object, theme: object, options: object}} data render data
	     * @returns {object}
	     */
	
	
	    RaphaelAreaChart.prototype.render = function render(paper, data) {
	        var dimension = data.dimension,
	            groupPositions = data.groupPositions,
	            _data$theme = data.theme,
	            theme = _data$theme === undefined ? {} : _data$theme,
	            position = data.position,
	            zeroTop = data.zeroTop,
	            hasRangeData = data.hasRangeData,
	            options = data.options;
	        var _theme$dot = theme.dot,
	            dotTheme = _theme$dot === undefined ? {} : _theme$dot,
	            colors = theme.colors;
	        var spline = options.spline,
	            allowSelect = options.allowSelect,
	            connectNulls = options.connectNulls,
	            pointWidth = options.pointWidth,
	            showDot = options.showDot,
	            areaOpacityOptions = options.areaOpacity;
	
	        var areaOpacity = this._isAreaOpacityNumber(areaOpacityOptions) ? areaOpacityOptions : 1;
	        var dotOpacity = showDot ? 1 : 0;
	        var borderStyle = this.makeBorderStyle(dotTheme.strokeColor, dotOpacity, dotTheme.strokeWidth);
	        var outDotStyle = this.makeOutDotStyle(dotOpacity, borderStyle);
	        var lineWidth = this.lineWidth = _tuiCodeSnippet2['default'].isNumber(pointWidth) ? pointWidth : this.lineWidth;
	
	        this.paper = paper;
	        this.theme = theme;
	        this.isSpline = spline;
	        this.dimension = dimension;
	        this.position = position;
	        this.zeroTop = zeroTop;
	        this.hasRangeData = hasRangeData;
	
	        paper.setStart();
	
	        this.groupPaths = this._getAreaChartPath(groupPositions, null, connectNulls);
	        this.groupAreas = this._renderAreas(paper, this.groupPaths, colors, lineWidth, areaOpacity);
	
	        this.tooltipLine = this._renderTooltipLine(paper, dimension.height);
	        this.groupDots = this._renderDots(paper, groupPositions, colors, dotOpacity);
	
	        if (allowSelect) {
	            this.selectionDot = this._makeSelectionDot(paper);
	            this.selectionColor = theme.selectionColor;
	
	            if (this.hasRangeData) {
	                this.selectionStartDot = this._makeSelectionDot(paper);
	            }
	        }
	
	        this.outDotStyle = outDotStyle;
	        this.groupPositions = groupPositions;
	        this.dotOpacity = dotOpacity;
	        this.pivotGroupDots = null;
	
	        var seriesSet = paper.setFinish();
	        this._moveSeriesToFrontAll();
	        this.tooltipLine.toFront();
	
	        return seriesSet;
	    };
	
	    /**
	     * Rearrange all series sequences.
	     * @private
	     */
	
	
	    RaphaelAreaChart.prototype._moveSeriesToFrontAll = function _moveSeriesToFrontAll() {
	        var len = this.groupPaths ? this.groupPaths.length : 0;
	        for (var i = 0; i < len; i += 1) {
	            this.moveSeriesToFront(this.groupAreas[i], this.groupDots[i]);
	        }
	    };
	
	    /**
	     * Get path for area chart.
	     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions - positions
	     * @param {boolean} [hasExtraPath] - whether has extra path or not
	     * @param {boolean} [connectNulls] - boolean value connect nulls or not
	     * @returns {*}
	     * @private
	     */
	
	
	    RaphaelAreaChart.prototype._getAreaChartPath = function _getAreaChartPath(groupPositions, hasExtraPath, connectNulls) {
	        if (this.isSpline) {
	            return this._makeSplineAreaChartPath(groupPositions, hasExtraPath);
	        }
	
	        return this._makeAreaChartPath(groupPositions, hasExtraPath, connectNulls);
	    };
	
	    /**
	     * Render area graphs.
	     * @param {object} paper paper
	     * @param {Array.<object>} groupPaths group paths
	     * @param {Array.<string>} colors colors
	     * @param {number} lineWidth line width
	     * @param {number} opacity opacity
	     * @returns {Array} raphael objects
	     * @private
	     */
	
	
	    RaphaelAreaChart.prototype._renderAreas = function _renderAreas(paper, groupPaths, colors, lineWidth, opacity) {
	        colors = colors.slice(0, groupPaths.length);
	        colors.reverse();
	        groupPaths.reverse();
	
	        var groupAreas = groupPaths.map(function (path, groupIndex) {
	            var polygons = {};
	            var areaColor = colors[groupIndex] || 'transparent';
	            var lineColor = areaColor;
	            var area = _raphaelRenderUtil2['default'].renderArea(paper, path.area.join(' '), {
	                fill: areaColor,
	                opacity: opacity,
	                stroke: areaColor
	            });
	            var line = _raphaelRenderUtil2['default'].renderLine(paper, path.line.join(' '), lineColor, lineWidth);
	
	            area.node.setAttribute('class', CLASS_NAME_SVG_AUTOSHAPE);
	            line.node.setAttribute('class', CLASS_NAME_SVG_AUTOSHAPE);
	
	            polygons.area = area;
	            polygons.line = line;
	
	            if (path.startLine) {
	                polygons.startLine = _raphaelRenderUtil2['default'].renderLine(paper, path.startLine.join(' '), lineColor, 0);
	            }
	
	            return polygons;
	        });
	
	        return groupAreas.reverse();
	    };
	
	    /**
	     * Make height.
	     * @param {number} top top
	     * @param {number} startTop start top
	     * @returns {number} height
	     * @private
	     */
	
	
	    RaphaelAreaChart.prototype._makeHeight = function _makeHeight(top, startTop) {
	        return Math.abs(top - startTop);
	    };
	
	    /**
	     * Make areas path.
	     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
	     * @param {boolean} [hasExtraPath] - whether has extra path or not
	     * @returns {Array.<string | number>} path
	     * @private
	     */
	
	
	    RaphaelAreaChart.prototype._makeAreasPath = function _makeAreasPath(positions, hasExtraPath) {
	        var _ref3;
	
	        var paths = [];
	        var positionLength = positions.length;
	        var path = [];
	        var latterPath = [];
	        var formerPath = [];
	        var prevNull = false;
	
	        Object.entries(positions).forEach(function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2),
	                index = _ref2[0],
	                position = _ref2[1];
	
	            var moveOrLine = void 0;
	            if (position) {
	                if (prevNull) {
	                    moveOrLine = 'M';
	                    prevNull = false;
	                } else {
	                    moveOrLine = 'L';
	                }
	
	                formerPath.push([moveOrLine, position.left, position.top]);
	                latterPath.unshift(['L', position.left, position.startTop]);
	            } else {
	                prevNull = true;
	                latterPath.push(['z']);
	            }
	
	            if (!position || parseInt(index, 10) === positionLength - 1) {
	                paths.push(formerPath.concat(latterPath));
	                formerPath = [];
	                latterPath = [];
	            }
	        });
	
	        paths.forEach(function (partialPath) {
	            path = path.concat(partialPath);
	        });
	
	        if (hasExtraPath !== false) {
	            var targetIndex = positions.length - 1;
	            path.splice(targetIndex + 1, 0, path[targetIndex], path[targetIndex + 1]);
	        }
	
	        path = (_ref3 = []).concat.apply(_ref3, _toConsumableArray(path));
	        path[0] = 'M';
	
	        return path;
	    };
	
	    /**
	     * Make path for area chart.
	     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
	     * @param {boolean} [hasExtraPath] - whether has extra path or not
	     * @param {boolean} [connectNulls] - boolean value connect nulls or not
	     * @returns {Array.<{area: Array.<string | number>, line: Array.<string | number>}>} path
	     * @private
	     */
	
	
	    RaphaelAreaChart.prototype._makeAreaChartPath = function _makeAreaChartPath(groupPositions, hasExtraPath, connectNulls) {
	        var _this2 = this;
	
	        return groupPositions.map(function (positions) {
	            var paths = {
	                area: _this2._makeAreasPath(positions, hasExtraPath),
	                line: _this2._makeLinesPath(positions, null, connectNulls)
	            };
	
	            if (_this2.hasRangeData) {
	                paths.startLine = _this2._makeLinesPath(positions, 'startTop');
	            }
	
	            return paths;
	        });
	    };
	
	    /**
	     * Make spline path for area chart.
	     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
	     * @param {boolean} [hasExtraPath] - whether has extra path or not
	     * @returns {Array.<{area: Array.<string | number>, line: Array.<string | number>}>} path
	     * @private
	     */
	
	
	    RaphaelAreaChart.prototype._makeSplineAreaChartPath = function _makeSplineAreaChartPath(groupPositions, hasExtraPath) {
	        var _this3 = this;
	
	        return groupPositions.map(function (positions) {
	            var reversePosition = positions.concat().reverse().map(function (position) {
	                return {
	                    left: position.left,
	                    top: position.startTop
	                };
	            });
	
	            var linesPath = _this3._makeSplineLinesPath(positions);
	            var reverseLinesPath = _this3._makeSplineLinesPath(reversePosition, {
	                isReverseDirection: true,
	                isBeConnected: true
	            });
	
	            var areaPath = JSON.parse(JSON.stringify(linesPath));
	            var reverseAreaPath = JSON.parse(JSON.stringify(reverseLinesPath));
	
	            if (hasExtraPath !== false) {
	                var lastPosition = positions[positions.length - 1];
	                var lastReversePosition = reversePosition[reversePosition.length - 1];
	
	                areaPath.push(['K', lastPosition.left, lastPosition.top]);
	                areaPath.push(['L', lastPosition.left, lastPosition.startTop]);
	
	                reverseAreaPath.push(['K', lastReversePosition.left, lastReversePosition.top]);
	                reverseAreaPath.push(['L', lastReversePosition.left, lastReversePosition.top]);
	            }
	
	            return {
	                area: areaPath.concat(reverseAreaPath),
	                line: linesPath
	            };
	        });
	    };
	
	    /**
	     * Resize graph of area chart.
	     * @param {object} params parameters
	     *      @param {{width: number, height:number}} params.dimension dimension
	     *      @param {Array.<Array.<{left:number, top:number}>>} params.groupPositions group positions
	     */
	
	
	    RaphaelAreaChart.prototype.resize = function resize(_ref4) {
	        var _this4 = this;
	
	        var dimension = _ref4.dimension,
	            groupPositions = _ref4.groupPositions,
	            zeroTop = _ref4.zeroTop;
	
	        this.resizeClipRect(dimension.width, dimension.height);
	
	        this.zeroTop = zeroTop;
	        this.groupPositions = groupPositions;
	        this.groupPaths = this._getAreaChartPath(groupPositions);
	        this.paper.setSize(dimension.width, dimension.height);
	        this.tooltipLine.attr({ top: dimension.height });
	
	        this.groupPaths.forEach(function (path, groupIndex) {
	            var area = _this4.groupAreas[groupIndex];
	            area.area.attr({ path: path.area.join(' ') });
	            area.line.attr({ path: path.line.join(' ') });
	
	            if (area.startLine) {
	                area.startLine.attr({ path: path.startLine.join(' ') });
	            }
	
	            _this4.groupDots[groupIndex].forEach(function (item, index) {
	                var position = groupPositions[groupIndex][index];
	
	                if (item.endDot) {
	                    _this4._moveDot(item.endDot.dot, position);
	                }
	                if (item.startDot) {
	                    var startPositon = Object.assign({}, position);
	                    startPositon.top = startPositon.startTop;
	                    _this4._moveDot(item.startDot.dot, startPositon);
	                }
	            });
	        });
	    };
	
	    /**
	     * Select legend.
	     * @param {?number} legendIndex legend index
	     */
	
	
	    RaphaelAreaChart.prototype.selectLegend = function selectLegend(legendIndex) {
	        var _this5 = this;
	
	        var noneSelected = _tuiCodeSnippet2['default'].isNull(legendIndex);
	
	        if (this.selectedLegendIndex && this.selectedLegendIndex !== -1) {
	            this.resetSeriesOrder(this.selectedLegendIndex);
	        }
	
	        this.selectedLegendIndex = legendIndex;
	
	        this.groupAreas.forEach(function (area, groupIndex) {
	            var isSelectedLegend = legendIndex === groupIndex;
	            var opacity = noneSelected || isSelectedLegend ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	            var groupDots = _this5.groupDots[groupIndex];
	
	            area.area.attr({ 'fill-opacity': opacity });
	            area.line.attr({ 'stroke-opacity': opacity });
	
	            if (area.startLine) {
	                area.startLine.attr({ 'stroke-opacity': opacity });
	            }
	
	            if (isSelectedLegend) {
	                _this5.moveSeriesToFront(area, groupDots);
	            }
	        });
	    };
	
	    /**
	     * Reset series order after selected to be same to when it is first rendered
	     * @param {number} legendIndex - legend index to reset series order
	     * @ignore
	     */
	
	
	    RaphaelAreaChart.prototype.resetSeriesOrder = function resetSeriesOrder(legendIndex) {
	        var frontSeries = legendIndex + 1 < this.groupAreas.length ? this.groupAreas[legendIndex + 1] : null;
	
	        if (frontSeries) {
	            var frontArea = frontSeries.area;
	            this.groupAreas[legendIndex].area.insertBefore(frontArea);
	            this.groupAreas[legendIndex].line.insertBefore(frontArea);
	            this.groupDots[legendIndex].forEach(function (item) {
	                if (item && item.endDot) {
	                    item.endDot.dot.insertBefore(frontArea);
	                }
	            });
	        }
	    };
	
	    /**
	     * @param {{area: {SVGElement}, line: {SVGElement}, startLine: {SVGElement}}} areaSurface - line or plane to represent area chart
	     * @param {Array.<SVGElement>} dots - dot type element
	     * @ignore
	     * @override
	     */
	
	
	    RaphaelAreaChart.prototype.moveSeriesToFront = function moveSeriesToFront(areaSurface, dots) {
	        areaSurface.line.toFront();
	        areaSurface.area.toFront();
	
	        if (areaSurface.startLine) {
	            areaSurface.startLine.toFront();
	        }
	
	        dots.forEach(function (item) {
	            item.endDot.dot.toFront();
	            if (item.startDot) {
	                item.startDot.dot.toFront();
	            }
	        });
	    };
	
	    /**
	     * Animate for adding data.
	     * @param {object} data - data for graph rendering
	     * @param {number} tickSize - tick size
	     * @param {Array.<Array.<object>>} groupPositions - group positions
	     * @param {boolean} [shiftingOption] - shifting option
	     * @param {number} zeroTop - position top value for zero point
	     */
	
	
	    RaphaelAreaChart.prototype.animateForAddingData = function animateForAddingData(data, tickSize, groupPositions, shiftingOption, zeroTop) {
	        var _this6 = this;
	
	        var groupPaths = this._getAreaChartPath(groupPositions, false);
	        var additionalIndex = 0;
	
	        if (!groupPositions.length) {
	            return;
	        }
	
	        if (shiftingOption) {
	            additionalIndex = 1;
	        }
	
	        this.zeroTop = zeroTop;
	
	        this.groupAreas.forEach(function (area, groupIndex) {
	            var dots = _this6.groupDots[groupIndex];
	            var groupPosition = groupPositions[groupIndex];
	            var pathMap = groupPaths[groupIndex];
	
	            if (shiftingOption) {
	                _this6._removeFirstDot(dots);
	            }
	
	            dots.forEach(function (item, index) {
	                var position = groupPosition[index + additionalIndex];
	                _this6._animateByPosition(item.endDot.dot, position, tickSize);
	
	                if (item.startDot) {
	                    _this6._animateByPosition(item.startDot.dot, {
	                        left: position.left,
	                        top: position.startTop
	                    }, tickSize);
	                }
	            });
	
	            _this6._animateByPath(area.area, pathMap.area, tickSize);
	            _this6._animateByPath(area.line, pathMap.line, tickSize);
	
	            if (area.startLine) {
	                _this6._animateByPath(area.startLine, pathMap.startLine, tickSize);
	            }
	        });
	    };
	
	    RaphaelAreaChart.prototype.renderSeriesLabel = function renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme) {
	        var attributes = {
	            'font-size': labelTheme.fontSize,
	            'font-family': labelTheme.fontFamily,
	            'font-weight': labelTheme.fontWeight,
	            fill: labelTheme.color,
	            'text-anchor': 'middle',
	            opacity: 0
	        };
	        var set = paper.set();
	
	        groupLabels.forEach(function (categoryLabel, categoryIndex) {
	            categoryLabel.forEach(function (label, seriesIndex) {
	                var position = groupPositions[categoryIndex][seriesIndex];
	                var endLabel = _raphaelRenderUtil2['default'].renderText(paper, position.end, label.end, attributes);
	
	                set.push(endLabel);
	
	                endLabel.node.style.userSelect = 'none';
	                endLabel.node.style.cursor = 'default';
	                endLabel.node.setAttribute('filter', 'url(#glow)');
	
	                if (position.start) {
	                    var startLabel = _raphaelRenderUtil2['default'].renderText(paper, position.start, label.start, attributes);
	
	                    startLabel.node.style.userSelect = 'none';
	                    startLabel.node.style.cursor = 'default';
	                    startLabel.node.setAttribute('filter', 'url(#glow)');
	
	                    set.push(startLabel);
	                }
	            });
	        });
	
	        return set;
	    };
	
	    /**
	     * Test areaOpacity is a number, and return the result.
	     * It is used to determine whether to set a default value, 0.5.
	     * If it is not a number, areaOpacity will be changed to the default value, 0.5.
	     * @param {*} areaOpacity - value of property `options.areaOpacity`
	     * @returns {boolean} - whether areaOpacity is a number.
	     * @private
	     */
	
	
	    RaphaelAreaChart.prototype._isAreaOpacityNumber = function _isAreaOpacityNumber(areaOpacity) {
	        var isNumber = _tuiCodeSnippet2['default'].isNumber(areaOpacity);
	
	        if (isNumber) {
	            if (areaOpacity < 0 || areaOpacity > 1) {
	                _consoleUtil2['default'].print(GUIDE_AREACHART_AREAOPACITY_TYPE, 'warn');
	            }
	        } else if (!_tuiCodeSnippet2['default'].isUndefined(areaOpacity)) {
	            _consoleUtil2['default'].print(GUIDE_AREACHART_AREAOPACITY_TYPE, 'error');
	        }
	
	        return isNumber;
	    };
	
	    return RaphaelAreaChart;
	}(_raphaelLineTypeBase2['default']);
	
	exports['default'] = RaphaelAreaChart;

/***/ }),
/* 344 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	/**
	 * @fileoverview util for console
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	exports['default'] = {
	    /**
	     * check if window.console exists
	     * @param {string} message - message
	     * @param {string} status - print function of window.console
	     */
	    print: function print(message) {
	        var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'log';
	
	        if (window.console) {
	            window.console[status](message);
	        }
	    }
	};

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _raphael = __webpack_require__(330);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview RaphaelPieCharts is graph renderer for pie chart.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var DEGREE_180 = 180;
	var DEGREE_360 = 360;
	var MIN_DEGREE = 0.01;
	var RAD = Math.PI / DEGREE_180;
	var LOADING_ANIMATION_DURATION = 700;
	var EMPHASIS_OPACITY = 1;
	var DE_EMPHASIS_OPACITY = 0.3;
	var DEFAULT_LUMINANT_VALUE = 0.2;
	var OVERLAY_ID = 'overlay';
	var TOOLTIP_OFFSET_VALUE = 20;
	
	/**
	 * @classdesc RaphaelPieCharts is graph renderer for pie chart.
	 * @class RaphaelPieChart
	 * @private
	 */
	
	var RaphaelPieChart = function () {
	    function RaphaelPieChart() {
	        _classCallCheck(this, RaphaelPieChart);
	    }
	
	    /**
	     * Render function of pie chart.
	     * @param {object} paper Raphael paper
	     * @param {{
	     *      sectorData: Array.<object>,
	     *      circleBound: {cx: number, cy: number, r: number},
	     *      dimension: object, theme: object, options: object
	     * }} data render data
	     * @param {object} callbacks callbacks
	     *      @param {function} callbacks.showTooltip show tooltip function
	     *      @param {function} callbacks.hideTooltip hide tooltip function
	     * @returns {object} paper raphael paper
	     */
	    RaphaelPieChart.prototype.render = function render(paper, data, callbacks) {
	        var pieSeriesSet = paper.set();
	
	        /**
	         * raphael object
	         * @type {object}
	         */
	        this.paper = paper;
	
	        /**
	         * ratio for hole
	         * @type {number}
	         */
	        // this.holeRatio = data.options.radiusRange[0];
	
	        /**
	         * base background
	         * @type {string}
	         */
	        var _data$options$radiusR = _slicedToArray(data.options.radiusRange, 1);
	
	        this.holeRatio = _data$options$radiusR[0];
	        this.chartBackground = data.chartBackground;
	
	        /**
	         * type of chart
	         * @type {string}
	         */
	        this.chartType = data.chartType;
	
	        /**
	         * functions for tooltip control
	         * @type {{showTooltip: Function, hideTooltip: Function}}
	         */
	        this.callbacks = callbacks;
	
	        /**
	         * color for selection
	         * @type {string}
	         */
	        this.selectionColor = data.theme.selectionColor;
	
	        /**
	         * bound for circle
	         * @type {{cx: number, cy: number, r: number}}
	         */
	        this.circleBound = data.circleBound;
	
	        /**
	         * sector attr's name for draw graph
	         * @type {string}
	         */
	        this.sectorName = 'sector_' + this.chartType;
	
	        this._setSectorAttr();
	
	        this.sectorInfos = this._renderPie(data.sectorData, data.theme.colors, data.additionalIndex, pieSeriesSet);
	
	        this.overlay = this._renderOverlay();
	
	        this.labelInfos = {
	            value: [],
	            legend: []
	        };
	
	        /**
	         * previous mouse position
	         * @type {{left: number, top: number}}
	         */
	        this.prevPosition = null;
	
	        /**
	         * previous hover sector
	         * @type {object}
	         */
	        this.prevHoverSector = null;
	
	        return pieSeriesSet;
	    };
	
	    /**
	     * Clear paper.
	     */
	
	
	    RaphaelPieChart.prototype.clear = function clear() {
	        this.paper.clear();
	    };
	
	    /**
	     * Make sector path.
	     * @param {number} cx center x
	     * @param {number} cy center y
	     * @param {number} r radius
	     * @param {number} startAngle start angle
	     * @param {number} endAngle end angel
	     * @returns {{path: Array}} sector path
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._makeSectorPath = function _makeSectorPath(cx, cy, r, startAngle, endAngle) {
	        var startRadian = startAngle * RAD;
	        var endRadian = endAngle * RAD;
	        var x1 = cx + r * Math.sin(startRadian); // x point of start radian
	        var y1 = cy - r * Math.cos(startRadian); // y posint of start radian
	        var x2 = cx + r * Math.sin(endRadian); // x point of end radian
	        var y2 = cy - r * Math.cos(endRadian); // y point of end radian
	        var largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0;
	        var path = ['M', cx, cy, 'L', x1, y1, 'A', r, r, 0, largeArcFlag, 1, x2, y2, 'Z'];
	
	        // see details about path
	        // http://www.w3schools.com/svg/svg_path.asp
	        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d
	        return { path: path };
	    };
	
	    /**
	     * Make sector path for donut chart.
	     * @param {number} cx - center x
	     * @param {number} cy - center y
	     * @param {number} r - radius
	     * @param {number} startAngle - start angle
	     * @param {number} endAngle - end angel
	     * @param {number} [holeRadius] - hole radius
	     * @returns {{path: Array}} sector path
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._makeDonutSectorPath = function _makeDonutSectorPath(cx, cy, r, startAngle, endAngle, holeRadius) {
	        /* eslint max-params: [2, 6]*/
	        var startRadian = startAngle * RAD;
	        var endRadian = endAngle * RAD;
	        var r2 = holeRadius || r * this.holeRatio; // radius of donut hole
	        var x1 = cx + r * Math.sin(startRadian);
	        var y1 = cy - r * Math.cos(startRadian);
	        var x2 = cx + r2 * Math.sin(startRadian);
	        var y2 = cy - r2 * Math.cos(startRadian);
	        var x3 = cx + r * Math.sin(endRadian);
	        var y3 = cy - r * Math.cos(endRadian);
	        var x4 = cx + r2 * Math.sin(endRadian);
	        var y4 = cy - r2 * Math.cos(endRadian);
	        var largeArcFlag = endAngle - startAngle > DEGREE_180 ? 1 : 0;
	        var path = ['M', x1, y1, 'A', r, r, 0, largeArcFlag, 1, x3, y3, 'L', x4, y4, 'A', r2, r2, 0, largeArcFlag, 0, x2, y2, 'Z'];
	
	        return { path: path };
	    };
	
	    /**
	     * Set sector attribute for raphael paper.
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._setSectorAttr = function _setSectorAttr() {
	        var makeSectorPath = void 0;
	
	        if (this.paper.customAttributes[this.sectorName]) {
	            return;
	        }
	
	        if (this.holeRatio) {
	            makeSectorPath = this._makeDonutSectorPath;
	        } else {
	            makeSectorPath = this._makeSectorPath;
	        }
	
	        this.paper.customAttributes[this.sectorName] = makeSectorPath.bind(this);
	    };
	
	    /**
	     * Render overlay.
	     * @returns {object} raphael object
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._renderOverlay = function _renderOverlay() {
	        var params = {
	            paper: this.paper,
	            circleBound: {
	                cx: 0,
	                cy: 0,
	                r: 0
	            },
	            angles: {
	                startAngle: 0,
	                endAngle: 0
	            },
	            attrs: {
	                fill: 'none',
	                opacity: 0,
	                stroke: this.chartBackground.color,
	                'stroke-width': 1
	            }
	        };
	        var inner = this._renderSector(params);
	
	        inner.node.setAttribute('class', 'auto-shape-rendering');
	
	        inner.data('id', OVERLAY_ID);
	        inner.data('chartType', this.chartType);
	
	        return inner;
	    };
	
	    /**
	     * Render sector
	     * @param {object} params parameters
	     *      @param {object} params.paper raphael paper
	     *      @param {{cx: number, cy: number, r:number}} params.circleBound circle bounds
	     *      @param {number} params.startAngle start angle
	     *      @param {number} params.endAngle end angle
	     *      @param {{object}} params.attrs attributes
	     * @returns {object} raphael object
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._renderSector = function _renderSector(params) {
	        var circleBound = params.circleBound,
	            angles = params.angles,
	            attrs = params.attrs;
	
	
	        attrs[this.sectorName] = [circleBound.cx, circleBound.cy, circleBound.r, angles.startAngle, angles.endAngle];
	
	        return params.paper.path().attr(attrs);
	    };
	
	    /**
	     * Render pie graph.
	     * @param {Array.<object>} sectorData - sectorData
	     * @param {Array.<string>} colors - sector colors
	     * @param {number} additionalIndex - additional index for accumulate past pie series's data indexes on pieDonutCombo
	     * @param {Array.<object>} pieSeriesSet - pie series set
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._renderPie = function _renderPie(sectorData, colors, additionalIndex, pieSeriesSet) {
	        var _this = this;
	
	        var circleBound = this.circleBound,
	            chartBackground = this.chartBackground;
	
	        var sectorInfos = [];
	
	        sectorData.forEach(function (sectorDatum, index) {
	            var ratio = sectorDatum.ratio;
	
	            var color = colors[index];
	            var sector = _this._renderSector({
	                paper: _this.paper,
	                circleBound: circleBound,
	                angles: sectorDatum.angles.start,
	                attrs: {
	                    fill: chartBackground.color,
	                    stroke: chartBackground.color,
	                    'stroke-width': 0
	                }
	            });
	
	            sector.node.setAttribute('class', 'auto-shape-rendering');
	
	            sector.data('index', index);
	            sector.data('legendIndex', index + additionalIndex);
	            sector.data('chartType', _this.chartType);
	
	            sectorInfos.push({
	                sector: sector,
	                color: color,
	                angles: sectorDatum.angles.end,
	                ratio: ratio
	            });
	
	            pieSeriesSet.push(sector);
	        });
	
	        return sectorInfos;
	    };
	
	    /**
	     * Show overlay.
	     * @param {number} index - index
	     * @param {number} legendIndex - legend index
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._showOverlay = function _showOverlay(index, legendIndex) {
	        var overlay = this.overlay;
	
	        var sectorInfo = this.sectorInfos[index];
	        var sa = sectorInfo.angles.startAngle;
	        var ea = sectorInfo.angles.endAngle;
	        var cb = this.circleBound;
	        var innerAttrs = {
	            fill: '#fff',
	            opacity: 1,
	            'stroke-width': 7,
	            'stroke-color': '#fff',
	            'stroke-miterlimit': 15
	        };
	
	        innerAttrs[this.sectorName] = [cb.cx, cb.cy, cb.r, sa, ea, cb.r * this.holeRatio];
	        overlay.attr(innerAttrs);
	        overlay.data('index', index);
	        overlay.data('legendIndex', legendIndex);
	
	        overlay.node.setAttribute('filter', 'url(#shadow)');
	
	        this._indexingOverlapElement([overlay, sectorInfo.sector, this.labelInfos.legend[index], this.labelInfos.value[index]]);
	    };
	
	    /**
	     * Element indexing For overlay.
	     * @param {Array} elements - indexing elements
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._indexingOverlapElement = function _indexingOverlapElement(elements) {
	        elements.forEach(function (element) {
	            if (element) {
	                element.toFront();
	            }
	        });
	    };
	
	    /**
	     * Hide overlay.
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._hideOverlay = function _hideOverlay() {
	        var overlay = this.overlay;
	
	        var attrs = {
	            fill: 'none',
	            opacity: 0
	        };
	
	        overlay.attr(attrs);
	
	        this._indexingOverlapElement(this.labelInfos.legend);
	        this._indexingOverlapElement(this.labelInfos.value);
	    };
	
	    /**
	     * Animate.
	     * @param {function} callback callback
	     */
	
	
	    RaphaelPieChart.prototype.animate = function animate(callback) {
	        var sectorName = this.sectorName,
	            circleBound = this.circleBound;
	
	        var sectorArgs = [circleBound.cx, circleBound.cy, circleBound.r];
	        var delayTime = 0;
	
	        this.sectorInfos.forEach(function (sectorInfo) {
	            var angles = sectorInfo.angles;
	
	            var attrMap = {
	                fill: sectorInfo.color
	            };
	            var animationTime = LOADING_ANIMATION_DURATION * sectorInfo.ratio;
	
	            if (angles.startAngle === 0 && angles.endAngle === DEGREE_360) {
	                angles.endAngle = DEGREE_360 - MIN_DEGREE;
	            }
	            attrMap[sectorName] = sectorArgs.concat([angles.startAngle, angles.endAngle]);
	
	            var anim = _raphael2['default'].animation(attrMap, animationTime, '>');
	            sectorInfo.sector.animate(anim.delay(delayTime));
	            delayTime += animationTime;
	        });
	
	        if (callback) {
	            setTimeout(callback, delayTime);
	        }
	    };
	
	    /**
	     * Resize graph of pie chart.
	     * @param {object} params parameters
	     *      @param {{width: number, height:number}} params.dimension dimension
	     *      @param {{cx:number, cy:number, r: number}} params.circleBound circle bound
	     */
	
	
	    RaphaelPieChart.prototype.resize = function resize(params) {
	        var dimension = params.dimension,
	            circleBound = params.circleBound;
	
	        this.circleBound = circleBound;
	        this.paper.setSize(dimension.width, dimension.height);
	    };
	
	    RaphaelPieChart.prototype.findSectorInfo = function findSectorInfo(position) {
	        var sector = this.paper && this.paper.getElementByPoint(position.left, position.top);
	        var info = null;
	
	        if (sector) {
	            info = {
	                legendIndex: _tuiCodeSnippet2['default'].isExisty(sector.data('legendIndex')) ? sector.data('legendIndex') : -1,
	                index: _tuiCodeSnippet2['default'].isExisty(sector.data('index')) ? sector.data('index') : -1,
	                chartType: sector.data('chartType')
	            };
	        }
	
	        return info;
	    };
	
	    /**
	     * Whether changed or not.
	     * @param {{left: number, top: number}} prevPosition previous position
	     * @param {{left: number, top: number}} position position
	     * @returns {boolean} result boolean
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._isChangedPosition = function _isChangedPosition(prevPosition, position) {
	        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
	    };
	
	    /**
	     * Show tooltip.
	     * @param {object} sector - raphael object
	     * @param {{left: number, top: number}} position - mouse position
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._showTooltip = function _showTooltip(sector, position) {
	        var args = [{}, 0, sector.data('index'), {
	            left: position.left - TOOLTIP_OFFSET_VALUE,
	            top: position.top - TOOLTIP_OFFSET_VALUE
	        }];
	
	        this.callbacks.showTooltip.apply(null, args);
	    };
	
	    /**
	     * Whether valid sector or not.
	     * @param {object} sector - raphael object
	     * @returns {boolean}
	     * @private
	     */
	
	
	    RaphaelPieChart.prototype._isValidSector = function _isValidSector(sector) {
	        return sector && sector.data('chartType') === this.chartType;
	    };
	
	    /**
	     * Move mouse on series.
	     * @param {{left: number, top: number}} position mouse position
	     */
	
	
	    RaphaelPieChart.prototype.moveMouseOnSeries = function moveMouseOnSeries(position) {
	        var sector = this.paper && this.paper.getElementByPoint(position.left, position.top);
	
	        if (this._isValidSector(sector)) {
	            if (this.prevHoverSector !== sector) {
	                this._showOverlay(sector.data('index'), sector.data('legendIndex'));
	                this.prevHoverSector = sector;
	            }
	
	            if (this._isChangedPosition(this.prevPosition, position)) {
	                this._showTooltip(sector, position);
	            }
	        } else if (this.prevHoverSector) {
	            this._hideOverlay();
	            this.callbacks.hideTooltip();
	            this.prevHoverSector = null;
	        }
	
	        this.prevPosition = position;
	    };
	
	    /**
	     * Select series.
	     * @param {{index: number}} indexes - index map
	     */
	
	
	    RaphaelPieChart.prototype.selectSeries = function selectSeries(indexes) {
	        var sectorInfo = this.sectorInfos[indexes.index];
	
	        if (!sectorInfo) {
	            return;
	        }
	
	        var objColor = _raphael2['default'].color(sectorInfo.color);
	        var luminanceColor = _raphaelRenderUtil2['default'].makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANT_VALUE);
	        var color = this.selectionColor || luminanceColor;
	
	        sectorInfo.sector.attr({
	            fill: color
	        });
	    };
	
	    /**
	     * Unelect series.
	     * @param {{index: number}} indexes - index map
	     */
	
	
	    RaphaelPieChart.prototype.unselectSeries = function unselectSeries(indexes) {
	        var sectorInfo = this.sectorInfos[indexes.index];
	
	        if (!sectorInfo) {
	            return;
	        }
	
	        sectorInfo.sector.attr({
	            fill: sectorInfo.color
	        });
	    };
	
	    /**
	     * Select legend.
	     * @param {?number} legendIndex legend index
	     */
	
	
	    RaphaelPieChart.prototype.selectLegend = function selectLegend(legendIndex) {
	        var isNull = _tuiCodeSnippet2['default'].isNull(legendIndex);
	        this.sectorInfos.forEach(function (sectorInfo, index) {
	            var opacity = isNull || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	
	            sectorInfo.sector.attr({
	                'fill-opacity': opacity
	            });
	        });
	    };
	
	    /**
	     * Get rendered label width
	     * @param {string} text - text content
	     * @param {object} theme - label theme
	     * @returns {number}
	     */
	
	
	    RaphaelPieChart.prototype.getRenderedLabelWidth = function getRenderedLabelWidth(text, theme) {
	        return _raphaelRenderUtil2['default'].getRenderedTextSize(text, theme.fontSize, theme.fontFamily).width;
	    };
	
	    /**
	     * Get rendered label height
	     * @param {string} text - text content
	     * @param {object} theme - label theme
	     * @returns {number}
	     */
	
	
	    RaphaelPieChart.prototype.getRenderedLabelHeight = function getRenderedLabelHeight(text, theme) {
	        return _raphaelRenderUtil2['default'].getRenderedTextSize(text, theme.fontSize, theme.fontFamily).height;
	    };
	
	    /**
	     * Render labels and return label set
	     * @param {object} options label render options
	     *      @param {dataType} dataType dataType (legend or value)
	     *      @param {object} paper Raphael paper
	     *      @param {Array.<object>} labelSet lableset
	     *      @param {object} positions position left, top
	     *      @param {Array.<string>} labels series labels
	     *      @param {object} theme label theme
	     *      @param {Array} colors series theme colors
	     */
	
	
	    RaphaelPieChart.prototype.renderLabels = function renderLabels(options) {
	        var _this2 = this;
	
	        var theme = options.theme,
	            labelFilter = options.labelFilter,
	            dataType = options.dataType,
	            ratioValues = options.ratioValues,
	            seriesNames = options.seriesNames;
	
	        var attributes = {
	            'font-size': theme.fontSize,
	            'font-family': options.fontFamily ? options.fontFamily : options.theme.fontFamily,
	            'font-weight': theme.fontWeight,
	            'text-anchor': 'middle',
	            fill: theme.color || '#fff',
	            opacity: 0
	        };
	
	        options.positions.forEach(function (position, index) {
	            var ratio = ratioValues[index];
	            var isFiltered = labelFilter && !labelFilter({
	                value: options.labels[index],
	                labelType: dataType,
	                seriesName: seriesNames[index],
	                ratio: ratio
	            });
	            var label = void 0;
	
	            if (isFiltered) {
	                return;
	            }
	
	            if (options.colors) {
	                attributes.fill = options.colors[index];
	            }
	
	            if (position) {
	                label = _raphaelRenderUtil2['default'].renderText(options.paper, position, options.labels[index], attributes);
	                label.node.style.userSelect = 'none';
	                label.node.style.cursor = 'default';
	                label.node.setAttribute('class', 'auto-shape-rendering');
	            }
	
	            _this2.labelInfos[dataType].push(label);
	            options.labelSet.push(label);
	        }, this);
	
	        if (!this.labelSet) {
	            this.labelSet = options.labelSet;
	        }
	    };
	
	    return RaphaelPieChart;
	}();
	
	exports['default'] = RaphaelPieChart;

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _raphaelLineTypeBase = __webpack_require__(341);
	
	var _raphaelLineTypeBase2 = _interopRequireDefault(_raphaelLineTypeBase);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Raphael radial line series renderer.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var EMPHASIS_OPACITY = 1;
	var DE_EMPHASIS_OPACITY = 0.3;
	var DEFAULT_LINE_WIDTH = 6;
	
	var RaphaelRadialLineSeries = function (_RaphaelLineTypeBase) {
	    _inherits(RaphaelRadialLineSeries, _RaphaelLineTypeBase);
	
	    /**
	     * RaphaelLineCharts is graph renderer for line chart.
	     * @constructs RaphaelRadialLineSeries
	     * @extends RaphaelLineTypeBase
	     * @ignore
	     */
	    function RaphaelRadialLineSeries() {
	        _classCallCheck(this, RaphaelRadialLineSeries);
	
	        /**
	         * selected legend index
	         * @type {?number}
	         */
	        var _this = _possibleConstructorReturn(this, _RaphaelLineTypeBase.call(this));
	
	        _this.selectedLegendIndex = null;
	
	        /**
	         * type of chart
	         * @type {string}
	         */
	        _this.chartType = 'radial';
	
	        /**
	         * Line width
	         * @type {number}
	         */
	        _this.lineWidth = DEFAULT_LINE_WIDTH;
	        return _this;
	    }
	
	    /**
	     * Render function of line chart.
	     * @param {object} paper - raphael paper
	     * @param {{groupPositions: Array.<Array>, dimension: object, theme: object, options: object}} data render data
	     * @returns {object} paper raphael paper
	     */
	
	
	    RaphaelRadialLineSeries.prototype.render = function render(paper, data) {
	        var dimension = data.dimension,
	            groupPositions = data.groupPositions,
	            theme = data.theme;
	        var colors = theme.colors;
	        var _data$options = data.options,
	            pointWidth = _data$options.pointWidth,
	            showDot = _data$options.showDot,
	            showArea = _data$options.showArea;
	
	        var dotOpacity = showDot ? 1 : 0;
	
	        var groupPaths = this._getLinesPath(groupPositions);
	        var borderStyle = this.makeBorderStyle(theme.strokeColor, dotOpacity, theme.strokeWidth);
	        var outDotStyle = this.makeOutDotStyle(dotOpacity, borderStyle);
	        var radialSeriesSet = paper.set();
	        var lineWidth = this.lineWidth = pointWidth ? pointWidth : this.lineWidth;
	        var dotPositions = groupPositions.map(function (positions) {
	            positions.pop();
	
	            return positions;
	        });
	
	        this.paper = paper;
	        this.theme = theme;
	        this.dimension = dimension;
	        this.position = data.position;
	
	        if (showArea) {
	            this.groupAreas = this._renderArea(paper, groupPaths, colors, radialSeriesSet);
	        }
	
	        this.groupLines = this._renderLines(paper, groupPaths, colors, lineWidth, radialSeriesSet);
	        this.groupDots = this._renderDots(paper, dotPositions, colors, dotOpacity, radialSeriesSet);
	
	        if (data.options.allowSelect) {
	            this.selectionDot = this._makeSelectionDot(paper);
	            this.selectionColor = theme.selectionColor;
	        }
	
	        this.colors = colors;
	        this.borderStyle = borderStyle;
	        this.outDotStyle = outDotStyle;
	        this.groupPositions = groupPositions;
	        this.groupPaths = groupPaths;
	        this.dotOpacity = dotOpacity;
	        this.showArea = showArea;
	
	        return radialSeriesSet;
	    };
	
	    /**
	     * Get lines path.
	     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
	     * @returns {Array.<Array.<string>>} path
	     * @private
	     */
	
	
	    RaphaelRadialLineSeries.prototype._getLinesPath = function _getLinesPath(groupPositions) {
	        var _this2 = this;
	
	        return groupPositions.map(function (positions) {
	            return _this2._makeLinesPath(positions);
	        });
	    };
	
	    /**
	     * Render lines.
	     * @param {object} paper raphael paper
	     * @param {Array.<Array.<string>>} groupPaths paths
	     * @param {string[]} colors line colors
	     * @param {?number} strokeWidth stroke width
	     * @param {Array.<object>} radialSeriesSet radial line series set
	     * @returns {Array.<Array.<object>>} lines
	     * @private
	     */
	
	
	    RaphaelRadialLineSeries.prototype._renderLines = function _renderLines(paper, groupPaths, colors, strokeWidth, radialSeriesSet) {
	        return groupPaths.map(function (path, groupIndex) {
	            var color = colors[groupIndex] || 'transparent';
	            var line = _raphaelRenderUtil2['default'].renderLine(paper, path.join(' '), color, strokeWidth);
	
	            radialSeriesSet.push(line);
	
	            return line;
	        });
	    };
	
	    /**
	     * Render area.
	     * @param {object} paper raphael paper
	     * @param {Array.<Array.<string>>} groupPaths paths
	     * @param {string[]} colors line colors
	     * @param {Array.<object>} radialSeriesSet radial line series set
	     * @returns {Array.<Array.<object>>} lines
	     * @private
	     */
	
	
	    RaphaelRadialLineSeries.prototype._renderArea = function _renderArea(paper, groupPaths, colors, radialSeriesSet) {
	        var _this3 = this;
	
	        return groupPaths.map(function (path, groupIndex) {
	            var color = colors[groupIndex] || 'transparent';
	            var area = _raphaelRenderUtil2['default'].renderArea(paper, path, {
	                fill: color,
	                opacity: 0.4,
	                'stroke-width': _this3.lineWidth,
	                stroke: color
	            });
	
	            radialSeriesSet.push(area);
	
	            return area;
	        }, this);
	    };
	
	    /**
	     * Resize graph of line chart.
	     * /todo copied at raphaelLineCharts#resize, should remove duplication
	     * tooltipLine code was deleted, as group tooltip not works on radial chart/
	     * @param {object} params parameters
	     *      @param {{width: number, height:number}} params.dimension dimension
	     *      @param {Array.<Array.<{left:number, top:number}>>} params.groupPositions group positions
	     */
	
	
	    RaphaelRadialLineSeries.prototype.resize = function resize(params) {
	        var _this4 = this;
	
	        var dimension = params.dimension,
	            groupPositions = params.groupPositions;
	
	
	        this.groupPositions = groupPositions;
	        this.groupPaths = this._getLinesPath(groupPositions);
	        this.paper.setSize(dimension.width, dimension.height);
	
	        this.groupPaths.forEach(function (path, groupIndex) {
	            _this4.groupLines[groupIndex].attr({ path: path.join(' ') });
	            if (_this4.showArea) {
	                _this4.groupAreas[groupIndex].attr({ path: path.join(' ') });
	            }
	            _this4.groupDots[groupIndex].forEach(function (item, index) {
	                _this4._moveDot(item.endDot.dot, groupPositions[groupIndex][index]);
	            });
	        });
	    };
	
	    /**
	     * Select legend.
	     * /todo copied at raphaelLineCharts, should remove duplication
	     * @param {?number} legendIndex legend index
	     */
	
	
	    RaphaelRadialLineSeries.prototype.selectLegend = function selectLegend(legendIndex) {
	        var noneSelected = _tuiCodeSnippet2['default'].isNull(legendIndex);
	
	        this.selectedLegendIndex = legendIndex;
	
	        this.groupLines.forEach(function (line, groupIndex) {
	            var opacity = noneSelected || legendIndex === groupIndex ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	
	            line.attr({ 'stroke-opacity': opacity });
	        });
	    };
	
	    return RaphaelRadialLineSeries;
	}(_raphaelLineTypeBase2['default']);
	
	exports['default'] = RaphaelRadialLineSeries;

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _raphael = __webpack_require__(330);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Raphael bubble chart renderer.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var ANIMATION_DURATION = 700;
	var CIRCLE_OPACITY = 0.8;
	var STROKE_OPACITY = 1;
	var EMPHASIS_OPACITY = 0.8;
	var DE_EMPHASIS_OPACITY = 0.3;
	var DEFAULT_LUMINANC = 0.2;
	var OVERLAY_BORDER_WIDTH = 2;
	var TOOLTIP_OFFSET_VALUE = 20;
	
	/**
	 * bound for circle
	 * @typedef {{left: number, top: number, radius: number}} bound
	 * @private
	 */
	
	/**
	 * Information for rendered circle
	 * @typedef {{circle: object, color: string, bound: bound}} circleInfo
	 * @private
	 */
	
	/**
	 * @classdesc RaphaelBubbleChart is graph renderer for bubble chart.
	 * @class RaphaelBubbleChart
	 * @private
	 */
	
	var RaphaelBubbleChart = function () {
	    function RaphaelBubbleChart() {
	        _classCallCheck(this, RaphaelBubbleChart);
	    }
	
	    /**
	     * Render function of bubble chart
	     * @param {object} paper - Raphael paper
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      seriesDataModel: SeriesDataModel,
	     *      groupBounds: Array.<Array.<bound>>,
	     *      theme: object
	     * }} data - data for rendering
	     * @param {{showTooltip: function, hideTooltip: function}} callbacks - callbacks for toggle of tooltip.
	     * @returns {object}
	     */
	    RaphaelBubbleChart.prototype.render = function render(paper, data, callbacks) {
	        var circleSet = paper.set();
	
	        this.paper = paper;
	
	        /**
	         * theme
	         * @type {object}
	         */
	        this.theme = data.theme;
	
	        /**
	         * seriesDataModel
	         * @type {SeriesDataModel}
	         */
	        this.seriesDataModel = data.seriesDataModel;
	
	        /**
	         * group bounds
	         * @type {Array.<Array.<bound>>}
	         */
	        this.groupBounds = data.groupBounds;
	
	        /**
	         * callbacks for toggle of tooltip.
	         * @type {{showTooltip: Function, hideTooltip: Function}}
	         */
	        this.callbacks = callbacks;
	
	        /**
	         * overlay is circle object of raphael, that using for mouseover.
	         * @type {object}
	         */
	        this.overlay = this._renderOverlay();
	
	        /**
	         * two-dimensional array by circleInfo
	         * @type {Array.<Array.<circleInfo>>}
	         */
	        this.groupCircleInfos = this._renderCircles(circleSet);
	
	        /**
	         * previous selected circle
	         * @type {?object}
	         */
	        this.prevCircle = null;
	
	        /**
	         * previous over circle
	         * @type {?object}
	         */
	        this.prevOverCircle = null;
	
	        /**
	         * animation timeout id
	         * @type {?number}
	         */
	        this.animationTimeoutId = null;
	
	        /**
	         * selected legend
	         * @type {?number}
	         */
	        this.selectedLegend = null;
	
	        if (this.paper.raphael.svg) {
	            this.appendShadowFilterToDefs();
	        }
	
	        return circleSet;
	    };
	
	    /**
	     * Render overlay.
	     * @returns {object}
	     * @private
	     */
	
	
	    RaphaelBubbleChart.prototype._renderOverlay = function _renderOverlay() {
	        var position = {
	            left: 0,
	            top: 0
	        };
	        var attribute = {
	            fill: 'none',
	            stroke: '#fff',
	            'stroke-opacity': STROKE_OPACITY,
	            'stroke-width': 2
	        };
	        var circle = _raphaelRenderUtil2['default'].renderCircle(this.paper, position, 0, attribute);
	
	        return circle;
	    };
	
	    /**
	     * Render circles.
	     * @param {object} circleSet - circle set
	     * @returns {Array.<Array.<circleInfo>>}
	     * @private
	     */
	
	
	    RaphaelBubbleChart.prototype._renderCircles = function _renderCircles(circleSet) {
	        var _this = this;
	
	        var colors = this.theme.colors;
	
	
	        return this.groupBounds.map(function (bounds, groupIndex) {
	            return bounds.map(function (bound, index) {
	                var circleInfo = null;
	
	                if (bound) {
	                    var color = colors[index];
	                    var circle = _raphaelRenderUtil2['default'].renderCircle(_this.paper, bound, 0, {
	                        fill: color,
	                        opacity: 0,
	                        stroke: 'none'
	                    });
	
	                    circleSet.push(circle);
	
	                    circle.data('groupIndex', groupIndex);
	                    circle.data('index', index);
	
	                    circleInfo = {
	                        circle: circle,
	                        color: color,
	                        bound: bound
	                    };
	                }
	
	                return circleInfo;
	            });
	        });
	    };
	
	    /**
	     * Animate circle
	     * @param {object} circle - raphael object
	     * @param {number} radius - radius of circle
	     * @private
	     */
	
	
	    RaphaelBubbleChart.prototype._animateCircle = function _animateCircle(circle, radius) {
	        circle.animate({
	            r: radius,
	            opacity: CIRCLE_OPACITY
	        }, ANIMATION_DURATION, '>');
	    };
	
	    /**
	     * Animate.
	     */
	
	
	    RaphaelBubbleChart.prototype.animate = function animate() {
	        var _this2 = this;
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupCircleInfos, function (circleInfo) {
	            if (!circleInfo) {
	                return;
	            }
	            _this2._animateCircle(circleInfo.circle, circleInfo.bound.radius);
	        });
	    };
	
	    /**
	     * Update circle bound
	     * @param {object} circle - raphael object
	     * @param {{left: number, top: number}} bound - bound
	     * @private
	     */
	
	
	    RaphaelBubbleChart.prototype._updatePosition = function _updatePosition(circle, bound) {
	        circle.attr({
	            cx: bound.left,
	            cy: bound.top,
	            r: bound.radius
	        });
	    };
	
	    /**
	     * Resize graph of bubble type chart.
	     * @param {object} params parameters
	     *      @param {{width: number, height:number}} params.dimension - dimension
	     *      @param {Array.<Array.<bound>>} params.groupBounds - group bounds
	     */
	
	
	    RaphaelBubbleChart.prototype.resize = function resize(params) {
	        var _this3 = this;
	
	        var dimension = params.dimension,
	            groupBounds = params.groupBounds;
	
	
	        this.groupBounds = groupBounds;
	        this.paper.setSize(dimension.width, dimension.height);
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupCircleInfos, function (circleInfo, groupIndex, index) {
	            var bound = groupBounds[groupIndex][index];
	            if (circleInfo) {
	                circleInfo.bound = bound;
	                _this3._updatePosition(circleInfo.circle, bound);
	            }
	        });
	    };
	
	    /**
	     * Find data indexes of rendered circle by position.
	     * @param {{left: number, top: number}} position - mouse position
	     * @returns {{index: number, groupIndex: number}}
	     */
	
	
	    RaphaelBubbleChart.prototype.findIndexes = function findIndexes(position) {
	        var circle = this.paper.getElementByPoint(position.left, position.top);
	        var foundIndexes = null;
	
	        if (circle) {
	            foundIndexes = {
	                index: circle.data('index'),
	                groupIndex: circle.data('groupIndex')
	            };
	        }
	
	        return foundIndexes;
	    };
	
	    RaphaelBubbleChart.prototype.appendShadowFilterToDefs = function appendShadowFilterToDefs() {
	        var filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
	        var feOffset = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
	        var feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
	        var feBlend = document.createElementNS('http://www.w3.org/2000/svg', 'feBlend');
	
	        filter.setAttributeNS(null, 'id', 'shadow');
	        filter.setAttributeNS(null, 'x', '-50%');
	        filter.setAttributeNS(null, 'y', '-50%');
	        filter.setAttributeNS(null, 'width', '180%');
	        filter.setAttributeNS(null, 'height', '180%');
	        feOffset.setAttributeNS(null, 'result', 'offOut');
	        feOffset.setAttributeNS(null, 'in', 'SourceAlpha');
	        feOffset.setAttributeNS(null, 'dx', '0');
	        feOffset.setAttributeNS(null, 'dy', '0');
	        feGaussianBlur.setAttributeNS(null, 'result', 'blurOut');
	        feGaussianBlur.setAttributeNS(null, 'in', 'offOut');
	        feGaussianBlur.setAttributeNS(null, 'stdDeviation', '2');
	        feBlend.setAttributeNS(null, 'in', 'SourceGraphic');
	        feBlend.setAttributeNS(null, 'in2', 'blurOut');
	        feBlend.setAttributeNS(null, 'mode', 'normal');
	        filter.appendChild(feOffset);
	        filter.appendChild(feGaussianBlur);
	        filter.appendChild(feBlend);
	        this.paper.defs.appendChild(filter);
	    };
	
	    /**
	     * Whether changed or not.
	     * @param {{left: number, top: number}} prevPosition - previous position
	     * @param {{left: number, top: number}} position - position
	     * @returns {boolean} result boolean
	     * @private
	     */
	
	
	    RaphaelBubbleChart.prototype._isChangedPosition = function _isChangedPosition(prevPosition, position) {
	        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
	    };
	
	    /**
	     * Show overlay with animation.
	     * @param {object} indexes - indexes
	     *      @param {number} indexes.groupIndex - index of circles group
	     *      @param {number} indexes.index - index of circles
	     */
	
	
	    RaphaelBubbleChart.prototype.showAnimation = function showAnimation(indexes) {
	        var circleInfo = this.groupCircleInfos[indexes.groupIndex][indexes.index];
	        var bound = circleInfo.bound;
	
	        this.circle = circleInfo.circle;
	
	        this.overlay.attr({
	            fill: circleInfo.color,
	            cx: bound.left,
	            cy: bound.top,
	            r: bound.radius + OVERLAY_BORDER_WIDTH,
	            stroke: '#fff',
	            opacity: 1
	        });
	
	        this.circle.attr({
	            opacity: 1
	        });
	
	        this.overlay.node.setAttribute('filter', 'url(#shadow)');
	        this.overlay.toFront();
	        this.circle.toFront();
	    };
	
	    /**
	     * Hide overlay with animation.
	     * @param {object} indexes - indexes
	     *      @param {number} indexes.groupIndex - index of circles group
	     *      @param {number} indexes.index - index of circles
	     */
	
	
	    RaphaelBubbleChart.prototype.hideAnimation = function hideAnimation(indexes) {
	        var changeOpacity = DE_EMPHASIS_OPACITY;
	        this.overlay.attr({
	            cx: 0,
	            cy: 0,
	            r: 0,
	            opacity: 0
	        });
	
	        if (_tuiCodeSnippet2['default'].isNull(this.selectedLegend) || indexes.index === this.selectedLegend) {
	            changeOpacity = EMPHASIS_OPACITY;
	        }
	
	        this.circle.attr({
	            opacity: changeOpacity
	        });
	    };
	
	    /**
	     * Find circle.
	     * @param {{left: number, top: number}} position - position
	     * @returns {?object}
	     * @private
	     */
	
	
	    RaphaelBubbleChart.prototype._findCircle = function _findCircle(position) {
	        var circles = [];
	        var paper = this.paper;
	
	        var foundCircle = void 0;
	
	        while (_tuiCodeSnippet2['default'].isUndefined(foundCircle)) {
	            var circle = paper.getElementByPoint(position.left, position.top);
	
	            if (circle) {
	                if (circle.attrs.opacity > DE_EMPHASIS_OPACITY) {
	                    foundCircle = circle;
	                } else {
	                    circles.push(circle);
	                    circle.hide();
	                }
	            } else {
	                foundCircle = null;
	            }
	        }
	
	        if (!foundCircle) {
	            foundCircle = circles[0];
	        }
	
	        circles.forEach(function (_circle) {
	            _circle.show();
	        });
	
	        return foundCircle;
	    };
	
	    /**
	     * Move mouse on series.
	     * @param {{left: number, top: number}} position - mouse position
	     */
	
	
	    RaphaelBubbleChart.prototype.moveMouseOnSeries = function moveMouseOnSeries(position) {
	        var circle = this._findCircle(position);
	
	        if (circle && _tuiCodeSnippet2['default'].isExisty(circle.data('groupIndex'))) {
	            var groupIndex = circle.data('groupIndex');
	            var index = circle.data('index');
	            var args = [{}, groupIndex, index, {
	                left: position.left - TOOLTIP_OFFSET_VALUE,
	                top: position.top - TOOLTIP_OFFSET_VALUE
	            }];
	
	            if (this._isChangedPosition(this.prevPosition, position)) {
	                this.callbacks.showTooltip.apply(null, args);
	                this.prevOverCircle = circle;
	            }
	        } else if (this.prevOverCircle) {
	            this.callbacks.hideTooltip();
	            this.prevOverCircle = null;
	        }
	        this.prevPosition = position;
	    };
	
	    /**
	     * Select series.
	     * @param {{index: number, groupIndex: number}} indexes - index map
	     */
	
	
	    RaphaelBubbleChart.prototype.selectSeries = function selectSeries(indexes) {
	        var groupIndex = indexes.groupIndex,
	            index = indexes.index;
	
	        var circleInfo = this.groupCircleInfos[groupIndex][index];
	        var objColor = _raphael2['default'].color(circleInfo.color);
	        var themeColor = this.theme.selectionColor;
	        var color = themeColor || _raphaelRenderUtil2['default'].makeChangedLuminanceColor(objColor.hex, DEFAULT_LUMINANC);
	
	        circleInfo.circle.attr({
	            fill: color
	        });
	    };
	
	    /**
	     * Unselect series.
	     * @param {{index: number, groupIndex: number}} indexes - index map
	     */
	
	
	    RaphaelBubbleChart.prototype.unselectSeries = function unselectSeries(indexes) {
	        var groupIndex = indexes.groupIndex,
	            index = indexes.index;
	
	        var circleInfo = this.groupCircleInfos[groupIndex][index];
	
	        circleInfo.circle.attr({
	            fill: circleInfo.color
	        });
	    };
	
	    /**
	     * Select legend.
	     * @param {?number} legendIndex - index of legend
	     */
	
	
	    RaphaelBubbleChart.prototype.selectLegend = function selectLegend(legendIndex) {
	        var noneSelected = _tuiCodeSnippet2['default'].isNull(legendIndex);
	
	        this.selectedLegend = legendIndex;
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.groupCircleInfos, function (circleInfo, groupIndex, index) {
	            if (!circleInfo) {
	                return;
	            }
	
	            var opacity = noneSelected || legendIndex === index ? EMPHASIS_OPACITY : DE_EMPHASIS_OPACITY;
	
	            circleInfo.circle.attr({ opacity: opacity });
	        });
	    };
	
	    return RaphaelBubbleChart;
	}();
	
	exports['default'] = RaphaelBubbleChart;

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview RaphaelBoxTypeChart is graph renderer for box type chart(heatmap chart, treemap chart).
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var ANIMATION_DURATION = 100;
	var MIN_BORDER_WIDTH = 0;
	var MAX_BORDER_WIDTH = 4;
	
	/**
	 * @classdesc RaphaelBoxTypeChart is graph renderer for box type chart(heatmap chart, treemap chart).
	 * @class RaphaelBarChart
	 * @private
	 */
	
	var RaphaelBoxTypeChart = function () {
	    function RaphaelBoxTypeChart() {
	        _classCallCheck(this, RaphaelBoxTypeChart);
	    }
	
	    /**
	     * Render function of bar chart
	     * @param {object} paper Raphael paper
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      colorSpectrum: object,
	     *      seriesDataModel: SeriesDataModel,
	     *      groupBounds: (Array.<Array.<object>>|object.<string, object>),
	     *      theme: object
	     * }} seriesData - data for graph rendering
	     * @returns {object}
	     */
	    RaphaelBoxTypeChart.prototype.render = function render(paper, seriesData) {
	        var seriesSet = paper.set();
	
	        this.paper = paper;
	
	        this.chartType = seriesData.chartType;
	
	        /**
	         * theme
	         * @type {*|{}}
	         */
	        this.theme = seriesData.theme || {};
	
	        /**
	         * color spectrum
	         * @type {Object}
	         */
	        this.colorSpectrum = seriesData.colorSpectrum;
	
	        /**
	         * chart background
	         */
	        this.chartBackground = seriesData.chartBackground;
	
	        /**
	         * zoomable option
	         */
	        this.zoomable = seriesData.zoomable;
	
	        /**
	         * options useColorValue
	         */
	        this.useColorValue = seriesData.options.useColorValue;
	
	        /**
	         * border color for rendering box
	         * @type {string}
	         */
	        this.borderColor = this.theme.borderColor || 'none';
	
	        /**
	         * border width for rendering box
	         */
	        this.borderWidth = this.theme.borderWidth;
	
	        /**
	         * group bounds
	         * @type {Array.<Array.<object>>|object.<string, object>}
	         */
	        this.groupBounds = seriesData.groupBounds;
	
	        /**
	         * bound map
	         * @type {object.<string, {left: number, top: number, width: number, height: number}>}
	         */
	        this.boundMap = seriesData.boundMap;
	
	        this._bindGetBoundFunction();
	        this._bindGetColorFunction();
	
	        this.seriesDataModel = seriesData.seriesDataModel;
	
	        /**
	         * boxes set
	         * @type {Array.<Array.<{rect: Object, color: string}>>}
	         */
	        this.boxesSet = this._renderBoxes(seriesData.seriesDataModel, seriesData.startDepth, !!seriesData.isPivot, seriesSet);
	        this.rectOverlay = this._renderRectOverlay();
	
	        return seriesSet;
	    };
	
	    /**
	     * Render overlay.
	     * @returns {object} raphael object
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._renderRectOverlay = function _renderRectOverlay() {
	        var bound = {
	            width: 1,
	            height: 1,
	            left: 0,
	            top: 0
	        };
	        var attributes = {
	            'fill-opacity': 0
	        };
	
	        var rectOverlay = _raphaelRenderUtil2['default'].renderRect(this.paper, bound, Object.assign({
	            'stroke-width': 0
	        }, attributes));
	
	        rectOverlay.node.setAttribute('filter', 'url(#shadow)');
	
	        return rectOverlay;
	    };
	
	    /**
	     * Bind _getBound private function.
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._bindGetBoundFunction = function _bindGetBoundFunction() {
	        if (this.boundMap) {
	            this._getBound = this._getBoundFromBoundMap;
	        } else {
	            this._getBound = this._getBoundFromGroupBounds;
	        }
	    };
	
	    /**
	     * Bind _bindGetColorFunction private function.
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._bindGetColorFunction = function _bindGetColorFunction() {
	        if (this.colorSpectrum) {
	            this._getColor = this._getColorFromSpectrum;
	        } else {
	            this._getColor = this._getColorFromColors;
	        }
	    };
	
	    /**
	     * Get bound from groupBounds by indexes(groupIndex, index) of seriesItem.
	     * @param {SeriesItem} seriesItem - seriesItem
	     * @returns {{width: number, height: number, left: number, top: number}}
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._getBoundFromGroupBounds = function _getBoundFromGroupBounds(seriesItem) {
	        return this.groupBounds[seriesItem.groupIndex][seriesItem.index].end;
	    };
	
	    /**
	     * Get bound from boundMap by id of seriesItem.
	     * @param {SeriesItem} seriesItem - seriesItem
	     * @returns {{width: number, height: number, left: number, top: number}}
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._getBoundFromBoundMap = function _getBoundFromBoundMap(seriesItem) {
	        return this.boundMap[seriesItem.id];
	    };
	
	    /**
	     * Get color from colorSpectrum by ratio of seriesItem.
	     * @param {SeriesItem} seriesItem - seriesItem
	     * @param {number} startDepth - start depth
	     * @returns {string}
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._getColorFromSpectrum = function _getColorFromSpectrum(seriesItem, startDepth) {
	        var color = void 0;
	
	        if (!seriesItem.hasChild || seriesItem.depth !== startDepth) {
	            color = this.colorSpectrum.getColor(seriesItem.colorRatio || seriesItem.ratio) || this.chartBackground;
	        } else {
	            color = 'none';
	        }
	
	        return color;
	    };
	
	    /**
	     * Get color from colors theme by group property of seriesItem.
	     * @param {SeriesItem} seriesItem - seriesItem
	     * @param {number} startDepth - start depth
	     * @returns {string}
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._getColorFromColors = function _getColorFromColors(seriesItem, startDepth) {
	        return seriesItem.depth === startDepth ? this.theme.colors[seriesItem.group] : '#000';
	    };
	
	    /**
	     * Render rect.
	     * @param {{width: number, height: number, left: number, top: number}} bound - bound
	     * @param {string} color - color
	     * @param {number} strokeWidth - stroke width
	     * @param {number} [fillOpacity] - fill opacity
	     * @returns {object}
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._renderRect = function _renderRect(bound, color, strokeWidth, fillOpacity) {
	        return _raphaelRenderUtil2['default'].renderRect(this.paper, bound, {
	            fill: color,
	            stroke: this.borderColor,
	            'stroke-width': strokeWidth,
	            'fill-opacity': fillOpacity
	        });
	    };
	
	    /**
	     * Get stroke width.
	     * @param {boolean} isFirstDepth - whether it is same to first depth or not
	     * @returns {number}
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._getStrokeWidth = function _getStrokeWidth(isFirstDepth) {
	        var strokeWidth = void 0;
	
	        if (this.borderWidth) {
	            strokeWidth = this.borderWidth;
	        } else if (isFirstDepth) {
	            strokeWidth = MAX_BORDER_WIDTH;
	        } else {
	            strokeWidth = MIN_BORDER_WIDTH;
	        }
	
	        return strokeWidth;
	    };
	
	    /**
	     * Render boxes.
	     * @param {SeriesDataModel} seriesDataModel - seriesDataModel
	     * @param {number} startDepth - start depth
	     * @param {boolean} isPivot - whether pivot or not
	     * @param {Array.<object>} seriesSet - seriesSet
	     * @returns {Array.<Array.<{rect: object, color: string}>>}
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._renderBoxes = function _renderBoxes(seriesDataModel, startDepth, isPivot, seriesSet) {
	        var _this = this;
	
	        var isTreemap = _predicate2['default'].isTreemapChart(this.chartType);
	
	        return seriesDataModel.map(function (seriesGroup, groupIndex) {
	            if (isTreemap && !_this.colorSpectrum && seriesGroup.getSeriesItemCount()) {
	                var firstItem = seriesGroup.getSeriesItem(0);
	                _this._setTreeFillOpacity({
	                    id: firstItem.parent
	                }, startDepth);
	            }
	
	            return seriesGroup.map(function (seriesItem, index) {
	                var result = null;
	                var depth = seriesItem.depth;
	
	                var strokeWidth = _this.colorSpectrum ? 0 : _this._getStrokeWidth(depth === startDepth);
	                var fillOpacity = _this.colorSpectrum ? 1 : seriesItem.fillOpacity;
	
	                seriesItem.groupIndex = groupIndex;
	                seriesItem.index = index;
	                var bound = _this._getBound(seriesItem);
	
	                if (bound) {
	                    var color = _this._getColor(seriesItem, startDepth);
	                    result = {
	                        rect: _this._renderRect(bound, color, strokeWidth, fillOpacity),
	                        seriesItem: seriesItem,
	                        color: color
	                    };
	
	                    if (seriesSet) {
	                        seriesSet.push(result.rect);
	                    }
	                }
	
	                return result;
	            });
	        }, isPivot);
	    };
	
	    /**
	     * @param {{id: number, fillOpacity: number}} parentInfo - parent info
	     * @param {number} startDepth - start depth
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._setTreeFillOpacity = function _setTreeFillOpacity(parentInfo, startDepth) {
	        var _this2 = this;
	
	        var children = this.seriesDataModel.findSeriesItemsByParent(parentInfo.id);
	
	        children.forEach(function (datum, index) {
	            var depth = datum.depth;
	
	
	            if (depth === startDepth) {
	                datum.fillOpacity = 1;
	            } else if (depth === startDepth + 1) {
	                datum.fillOpacity = 0.05 * index;
	            } else if (depth < startDepth) {
	                datum.fillOpacity = 0;
	            } else {
	                datum.fillOpacity = parentInfo.fillOpacity + 0.05 * index;
	            }
	
	            if (datum.hasChild) {
	                _this2._setTreeFillOpacity({
	                    id: datum.id,
	                    fillOpacity: datum.fillOpacity
	                }, startDepth);
	            }
	        });
	    };
	
	    /**
	     * Animate changing color of box.
	     * @param {object} rect - raphael object
	     * @param {string} [color] - fill color
	     * @param {number} [opacity] - fill opacity
	     * @param {number} [strokeColor] - stroke color
	     * @param {number} [strokeWidth] - stroke width
	     * @private
	     */
	
	
	    RaphaelBoxTypeChart.prototype._animateChangingColor = function _animateChangingColor(rect, color, opacity, strokeColor, strokeWidth) {
	        var properties = {
	            'fill-opacity': _tuiCodeSnippet2['default'].isExisty(opacity) ? opacity : 1,
	            stroke: strokeColor,
	            'stroke-width': strokeWidth
	        };
	
	        if (color) {
	            properties.fill = color;
	        }
	
	        rect.animate(properties, ANIMATION_DURATION, '>');
	    };
	
	    /**
	     * Show animation.
	     * @param {{groupIndex: number, index:number}} indexes - index info
	     */
	
	
	    RaphaelBoxTypeChart.prototype.showAnimation = function showAnimation(indexes) {
	        var box = this.boxesSet[indexes.groupIndex][indexes.index];
	
	        if (!box) {
	            return;
	        }
	
	        var rect = box.rect.node;
	        var color = box.color;
	
	
	        if (this.chartType === 'treemap' && !this.zoomable && !this.useColorValue) {
	            color = this.theme.colors[indexes.index];
	        }
	
	        this.rectOverlay.attr({
	            x: rect.getAttribute('x'),
	            y: rect.getAttribute('y'),
	            width: rect.getAttribute('width'),
	            height: rect.getAttribute('height'),
	            fill: color,
	            'fill-opacity': 1,
	            stroke: '#ffffff',
	            'stroke-width': 4,
	            'stroke-opacity': 1
	        });
	
	        this.rectOverlay.toFront();
	
	        if (this.labelSet) {
	            this.labelSet.toFront();
	        }
	    };
	
	    /**
	     * Hide animation.
	     * @param {{groupIndex: number, index:number}} indexes - index info
	     */
	
	
	    RaphaelBoxTypeChart.prototype.hideAnimation = function hideAnimation(indexes) {
	        var box = this.boxesSet[indexes.groupIndex][indexes.index];
	
	        if (!box) {
	            return;
	        }
	
	        this.rectOverlay.attr({
	            width: 1,
	            height: 1,
	            x: 0,
	            y: 0,
	            'fill-opacity': 0,
	            'stroke-opacity': 0
	        });
	    };
	
	    /**
	     * Resize.
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      groupBounds: (Array.<Array.<object>>|object.<string, object>)
	     * }} seriesData - data for graph rendering
	     */
	
	
	    RaphaelBoxTypeChart.prototype.resize = function resize(seriesData) {
	        var _this3 = this;
	
	        var dimension = seriesData.dimension;
	
	
	        this.boundMap = seriesData.boundMap;
	        this.groupBounds = seriesData.groupBounds;
	        this.paper.setSize(dimension.width, dimension.height);
	
	        _raphaelRenderUtil2['default'].forEach2dArray(this.boxesSet, function (box, groupIndex, index) {
	            if (!box) {
	                return;
	            }
	
	            var bound = _this3._getBound(box.seriesItem, groupIndex, index);
	
	            if (bound) {
	                _raphaelRenderUtil2['default'].updateRectBound(box.rect, bound);
	            }
	        });
	    };
	
	    RaphaelBoxTypeChart.prototype.renderSeriesLabel = function renderSeriesLabel(paper, positionSet, labels, labelTheme) {
	        var labelSet = paper.set();
	        var attributes = {
	            'font-size': labelTheme.fontSize,
	            'font-family': labelTheme.fontFamily,
	            'font-weight': labelTheme.fontWeight,
	            fill: '#ffffff',
	            opacity: 0
	        };
	
	        labels.forEach(function (categoryLabel, categoryIndex) {
	            categoryLabel.forEach(function (label, seriesIndex) {
	                var seriesLabel = _raphaelRenderUtil2['default'].renderText(paper, positionSet[categoryIndex][seriesIndex].end, label, attributes);
	
	                seriesLabel.node.style.userSelect = 'none';
	                seriesLabel.node.style.cursor = 'default';
	
	                labelSet.push(seriesLabel);
	            });
	        });
	
	        this.labelSet = labelSet;
	
	        return labelSet;
	    };
	
	    RaphaelBoxTypeChart.prototype.renderSeriesLabelForTreemap = function renderSeriesLabelForTreemap(paper, positions, labels, labelTheme) {
	        var labelSet = paper.set();
	        var attributes = {
	            'font-size': labelTheme.fontSize,
	            'font-family': labelTheme.fontFamily,
	            'font-weight': labelTheme.fontWeight,
	            fill: labelTheme.color,
	            opacity: 0
	        };
	
	        labels.forEach(function (label, index) {
	            if (positions[index]) {
	                var seriesLabel = _raphaelRenderUtil2['default'].renderText(paper, positions[index], label, attributes);
	
	                seriesLabel.node.style.userSelect = 'none';
	                seriesLabel.node.style.cursor = 'default';
	
	                labelSet.push(seriesLabel);
	            }
	        });
	
	        this.labelSet = labelSet;
	
	        return labelSet;
	    };
	
	    return RaphaelBoxTypeChart;
	}();
	
	exports['default'] = RaphaelBoxTypeChart;

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _templateObject = _taggedTemplateLiteral(['\n                  s', ',', ',0,0\n                  t', ',', '\n                '], ['\n                  s', ',', ',0,0\n                  t', ',', '\n                ']),
	    _templateObject2 = _taggedTemplateLiteral(['\n                s', ',', ',0,0\n                t', ',', '\n            '], ['\n                s', ',', ',0,0\n                t', ',', '\n            ']);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview RaphaelPieCharts is graph renderer for map chart.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var browser = _tuiCodeSnippet2['default'].browser;
	
	var IS_LTE_IE8 = browser.msie && browser.version <= 8;
	var STROKE_COLOR = 'gray';
	var ANIMATION_DURATION = 100;
	var G_ID = 'tui-chart-series-group';
	var FILL_COLOR_OF_NO_DATA = '#eee';
	
	/**
	 * @classdesc RaphaelMapCharts is graph renderer for map chart.
	 * @class RaphaelMapChart
	 * @private
	 */
	
	var RaphaelMapChart = function () {
	    function RaphaelMapChart() {
	        _classCallCheck(this, RaphaelMapChart);
	    }
	
	    /**
	     * Render function of map chart.
	     * @param {object} paper paper object
	     * @param {object} data data
	     *      @param {{width: number, height: number}} data.dimension series dimension
	     *      @param {Array.<{code: string, path: string}>} data.map mapData
	     *      @param {ColorSpectrum} data.colorSpectrum color model
	     */
	    RaphaelMapChart.prototype.render = function render(paper, data) {
	        var mapDimension = data.mapModel.getMapDimension();
	
	        this.ratio = this._getDimensionRatio(data.layout.dimension, mapDimension);
	        this.dimension = data.layout.dimension;
	        this.position = data.layout.position;
	        this.paper = paper;
	        this.sectorSet = paper.set();
	        this.sectors = this._renderMap(data, this.ratio);
	
	        if (!IS_LTE_IE8) {
	            this.g = createGElement(paper, this.sectorSet, G_ID);
	        }
	
	        this.overColor = data.theme.overColor;
	    };
	
	    /**
	     * Get dimension ratio
	     * @param {object} dimension dimension
	     * @param {object} mapDimension map dimension
	     * @returns {number}
	     * @private
	     */
	
	
	    RaphaelMapChart.prototype._getDimensionRatio = function _getDimensionRatio(dimension, mapDimension) {
	        return Math.min(dimension.height / mapDimension.height, dimension.width / mapDimension.width);
	    };
	
	    /**
	     * Render map graph.
	     * @param {object} data data
	     *      @param {{width: number, height: number}} data.dimension series dimension
	     *      @param {Array.<{code: string, path: string}>} data.map mapData
	     *      @param {ColorSpectrum} data.colorSpectrum color model
	     * @param {number} dimensionRatio dimension ratio of rendering by map
	     * @returns {Array.<{sector: object, color: string, data: object}>} rendered map information
	     * @private
	     */
	
	
	    RaphaelMapChart.prototype._renderMap = function _renderMap(data, dimensionRatio) {
	        var sectorSet = this.sectorSet,
	            paper = this.paper;
	        var position = data.layout.position;
	        var colorSpectrum = data.colorSpectrum;
	
	
	        return data.mapModel.getMapData().map(function (datum, index) {
	            var ratio = datum.ratio,
	                path = datum.path;
	
	            var color = ratio ? colorSpectrum.getColor(ratio) : FILL_COLOR_OF_NO_DATA;
	            var sector = _raphaelRenderUtil2['default'].renderArea(paper, path, {
	                fill: color,
	                opacity: 1,
	                stroke: STROKE_COLOR,
	                'stroke-width': 0.2,
	                'stroke-opacity': 1,
	                transform: _renderUtil2['default'].oneLineTrim(_templateObject, dimensionRatio, dimensionRatio, position.left / dimensionRatio, position.top / dimensionRatio)
	            });
	
	            sector.data('index', index);
	
	            sectorSet.push(sector);
	
	            return {
	                sector: sector,
	                color: color,
	                ratio: ratio
	            };
	        });
	    };
	
	    /**
	     * Find sector index.
	     * @param {{left: number, top: number}} position position
	     * @returns {?number} found index
	     */
	
	
	    RaphaelMapChart.prototype.findSectorIndex = function findSectorIndex(position) {
	        var sector = this.paper.getElementByPoint(position.left, position.top);
	        var foundIndex = sector && sector.data('index');
	        var data = !_tuiCodeSnippet2['default'].isUndefined(foundIndex) && this.sectors[foundIndex];
	
	        return data && !_tuiCodeSnippet2['default'].isUndefined(data.ratio) ? foundIndex : null;
	    };
	
	    /**
	     * Change color.
	     * @param {number} index index
	     */
	
	
	    RaphaelMapChart.prototype.changeColor = function changeColor(index) {
	        var sector = this.sectors[index];
	        var attributes = {
	            stroke: '#ffffff',
	            'stroke-width': 4
	        };
	
	        if (this.overColor) {
	            attributes.fill = this.overColor;
	        }
	
	        sector.sector.animate(attributes, ANIMATION_DURATION, '>');
	        sector.sector.node.setAttribute('filter', 'url(#shadow)');
	        sector.sector.toFront();
	    };
	
	    /**
	     * Restore color.
	     * @param {number} index index
	     */
	
	
	    RaphaelMapChart.prototype.restoreColor = function restoreColor(index) {
	        var sector = this.sectors[index];
	
	        sector.sector.animate({
	            fill: sector.color,
	            stroke: STROKE_COLOR,
	            'stroke-width': 0.2
	        }, ANIMATION_DURATION, '>');
	        sector.sector.node.setAttribute('filter', 'none');
	    };
	
	    /**
	     * Scale map sector paths
	     * @param {number} changedRatio changed ratio of map
	     * @param {object} position position
	     * @param {number} mapRatio mapdimension ratio by dimansion
	     * @param {object} limitPosition limit position
	     * @param {object} mapDimension map dimension
	     */
	
	
	    RaphaelMapChart.prototype.scaleMapPaths = function scaleMapPaths(changedRatio, position, mapRatio, limitPosition, mapDimension) {
	        var transformList = this.g.transform.baseVal;
	        var zoom = this.paper.canvas.createSVGTransform();
	        var matrix = this.paper.canvas.createSVGMatrix();
	        var raphaelMatrix = this.paper.raphael.matrix();
	        var transformMatrix = transformList.numberOfItems ? transformList.getItem(0).matrix : {
	            a: 1,
	            b: 0,
	            c: 0,
	            d: 1,
	            e: 0,
	            f: 0
	        };
	        var maxRight = mapDimension.width - this.dimension.width;
	        var maxTop = mapDimension.height - this.dimension.height;
	        var previousTranslateX = transformMatrix.e / transformMatrix.a;
	        var previousTranslateY = transformMatrix.f / transformMatrix.d;
	        var currentLimitRight = -maxRight / transformMatrix.a;
	        var currentLimitTop = -maxTop / transformMatrix.d;
	
	        raphaelMatrix.scale(changedRatio, changedRatio, position.left * mapRatio - previousTranslateX * changedRatio, position.top * mapRatio - previousTranslateY * changedRatio);
	        var transformX = raphaelMatrix.e / raphaelMatrix.a + previousTranslateX;
	        var transformY = raphaelMatrix.f / raphaelMatrix.d + previousTranslateY;
	
	        if (transformX >= 0) {
	            raphaelMatrix.e = -previousTranslateX * raphaelMatrix.a;
	        } else if (transformX < currentLimitRight) {
	            raphaelMatrix.e = currentLimitRight - previousTranslateX;
	        }
	
	        if (transformY >= 0) {
	            raphaelMatrix.f = -previousTranslateY * raphaelMatrix.a;
	        } else if (transformY < currentLimitTop) {
	            raphaelMatrix.f = currentLimitTop - previousTranslateY;
	        }
	
	        matrix.a = raphaelMatrix.a;
	        matrix.b = raphaelMatrix.b;
	        matrix.c = raphaelMatrix.c;
	        matrix.d = raphaelMatrix.d;
	        matrix.e = raphaelMatrix.e;
	        matrix.f = raphaelMatrix.f;
	
	        zoom.setMatrix(matrix);
	        transformList.appendItem(zoom);
	        transformList.initialize(transformList.consolidate());
	    };
	
	    /**
	     * Scale map sector paths
	     * @param {object} distances drag distance for moving
	     * @param {object} mapDimension map dimension
	     */
	
	
	    RaphaelMapChart.prototype.moveMapPaths = function moveMapPaths(distances, mapDimension) {
	        var matrix = this.paper.canvas.createSVGMatrix();
	        var raphaelMatrix = this.paper.raphael.matrix();
	        var transformList = this.g.transform.baseVal;
	        var translate = this.paper.canvas.createSVGTransform();
	        var maxRight = mapDimension.width - this.dimension.width;
	        var maxTop = mapDimension.height - this.dimension.height;
	        var transformMatrix = transformList.numberOfItems ? transformList.getItem(0).matrix : {
	            a: 1,
	            b: 0,
	            c: 0,
	            d: 1,
	            e: 0,
	            f: 0
	        };
	
	        raphaelMatrix.translate(distances.x, distances.y);
	        this._translateXForRaphaelMatrix({
	            raphaelMatrix: raphaelMatrix,
	            transformMatrix: transformMatrix,
	            maxRight: maxRight
	        });
	        this._translateYForRaphaelMatrix({
	            raphaelMatrix: raphaelMatrix,
	            transformMatrix: transformMatrix,
	            maxTop: maxTop
	        });
	
	        matrix.a = raphaelMatrix.a;
	        matrix.b = raphaelMatrix.b;
	        matrix.c = raphaelMatrix.c;
	        matrix.d = raphaelMatrix.d;
	        matrix.e = raphaelMatrix.e;
	        matrix.f = raphaelMatrix.f;
	
	        translate.setMatrix(matrix);
	        transformList.appendItem(translate);
	        transformList.initialize(transformList.consolidate());
	    };
	
	    RaphaelMapChart.prototype._translateXForRaphaelMatrix = function _translateXForRaphaelMatrix(_ref) {
	        var raphaelMatrix = _ref.raphaelMatrix,
	            transformMatrix = _ref.transformMatrix,
	            maxRight = _ref.maxRight;
	
	        var currentTranslateX = raphaelMatrix.e / raphaelMatrix.a;
	        var translateX = currentTranslateX + transformMatrix.e / transformMatrix.a;
	
	        if (translateX >= 0 && currentTranslateX > 0) {
	            raphaelMatrix.e = 0;
	        } else if (translateX < 0 && translateX < -maxRight / transformMatrix.a && currentTranslateX < 0) {
	            raphaelMatrix.e = 0;
	        }
	    };
	
	    RaphaelMapChart.prototype._translateYForRaphaelMatrix = function _translateYForRaphaelMatrix(_ref2) {
	        var raphaelMatrix = _ref2.raphaelMatrix,
	            transformMatrix = _ref2.transformMatrix,
	            maxTop = _ref2.maxTop;
	
	        var currentTranslateY = raphaelMatrix.f / raphaelMatrix.d;
	        var translateY = currentTranslateY + transformMatrix.f / transformMatrix.d;
	
	        if (translateY >= 0 && currentTranslateY > 0) {
	            raphaelMatrix.f = 0;
	        } else if (translateY < 0 && translateY < -maxTop / transformMatrix.d && currentTranslateY < 0) {
	            raphaelMatrix.f = 0;
	        }
	    };
	
	    /**
	     * Render series labels
	     * @param {object} paper Raphael paper
	     * @param {Array.<object>} labelData label data
	     * @param {object} labelTheme label theme
	     * @returns {Array.<object>}
	     */
	
	
	    RaphaelMapChart.prototype.renderSeriesLabels = function renderSeriesLabels(paper, labelData, labelTheme) {
	        var attributes = {
	            'font-size': labelTheme.fontSize,
	            'font-family': labelTheme.fontFamily,
	            'font-weight': labelTheme.fontWeight,
	            fill: labelTheme.color,
	            'text-anchor': 'middle',
	            opacity: 0,
	            transform: _renderUtil2['default'].oneLineTrim(_templateObject2, this.ratio, this.ratio, this.position.left / this.ratio, this.position.top / this.ratio)
	        };
	        var set = paper.set();
	
	        labelData.forEach(function (labelDatum) {
	            var position = labelDatum.position;
	
	            var label = _raphaelRenderUtil2['default'].renderText(paper, position, labelDatum.name || labelDatum.code, attributes);
	
	            set.push(label);
	
	            label.node.style.userSelect = 'none';
	            label.node.style.cursor = 'default';
	            label.node.setAttribute('filter', 'url(#glow)');
	
	            if (!IS_LTE_IE8) {
	                self.g.appendChild(label.node);
	            }
	        });
	
	        return set;
	    };
	
	    return RaphaelMapChart;
	}();
	
	/**
	 * Create and append sector set
	 * @param {object} paper Raphael paper
	 * @param {Array.<object>} sectorSet sectorSet
	 * @param {string} id ID string
	 * @returns {object}
	 * @ignore
	 */
	
	
	function createGElement(paper, sectorSet, id) {
	    var g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
	    g.id = id;
	
	    sectorSet.forEach(function (sector) {
	        _domHandler2['default'].append(g, sector.node);
	    });
	
	    paper.canvas.appendChild(g);
	
	    return g;
	}
	
	exports['default'] = RaphaelMapChart;

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _templateObject = _taggedTemplateLiteral(['\n            M', '\n            ,', '\n            l', '\n            ,', '\n            l', '\n            ,-', '\n        '], ['\n            M', '\n            ,', '\n            l', '\n            ,', '\n            l', '\n            ,-', '\n        ']);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Raphael title renderer.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var UNSELECTED_LEGEND_LABEL_OPACITY = 0.5;
	var PAGINATION_POSITION_HEIGHT = 8;
	var PAGINATION_POSITION_WIDTH = 10;
	var PAGINATION_POSITION_HALP_WIDTH = PAGINATION_POSITION_WIDTH / 2;
	var PAGINATION_POSITION_PADDING = 3;
	
	/**
	 * Get sum of icon and left padding width
	 * @returns {number} - icon and left padding width
	 * @ignore
	 */
	function getIconWidth() {
	    return _const2['default'].LEGEND_ICON_WIDTH + _const2['default'].LEGEND_LABEL_LEFT_PADDING;
	}
	
	// const RaphaelLegendComponent = snippet.defineClass(/** @lends RaphaelLegendComponent.prototype */ {
	
	var RaphaelLegendComponent = function () {
	    /** @lends RaphaelLegendComponent.prototype */
	    function RaphaelLegendComponent() {
	        _classCallCheck(this, RaphaelLegendComponent);
	
	        /**
	         * @type {number}
	         * @private
	         */
	        this._checkBoxWidth = 0;
	        /**
	         * @type {number}
	         * @private
	         */
	        this._checkBoxHeight = 0;
	        /**
	         * @type {number}
	         * @private
	         */
	        this._legendItemHeight = 0;
	        /**
	         * @type {number}
	         * @private
	         */
	        this._currentPageCount = 1;
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._showCheckbox = true;
	    }
	
	    /**
	     * @param {Array.<object>} legendData Array of legend item data
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._renderLegendItems = function _renderLegendItems(legendData) {
	        var _this = this;
	
	        var labelPaddingLeft = _const2['default'].LEGEND_LABEL_LEFT_PADDING;
	        var position = Object.assign({}, this.basePosition);
	
	        legendData.forEach(function (legendDatum, index) {
	            var iconType = legendDatum.iconType,
	                legendIndex = legendDatum.index,
	                isUnselected = legendDatum.isUnselected,
	                labelHeight = legendDatum.labelHeight,
	                checkboxData = legendDatum.checkbox;
	
	            var legendColor = legendDatum.colorByPoint ? '#aaa' : legendDatum.theme.color;
	            var predicatedLegendWidth = position.left + _this._calculateSingleLegendWidth(legendIndex, iconType);
	            var isNeedBreakLine = predicatedLegendWidth >= _this.paper.width;
	
	            if (_this.isHorizontal && isNeedBreakLine) {
	                position.top += _this._legendItemHeight + _const2['default'].LABEL_PADDING_TOP;
	                position.left = _this.basePosition.left;
	            }
	
	            if (_this._showCheckbox) {
	                _this._renderCheckbox(position, {
	                    isChecked: checkboxData.checked,
	                    legendIndex: legendIndex,
	                    legendSet: _this.legendSet
	                });
	
	                position.left += _this._checkBoxWidth + labelPaddingLeft;
	            }
	
	            _this._renderIcon(position, {
	                legendColor: legendColor,
	                iconType: iconType,
	                labelHeight: labelHeight,
	                isUnselected: isUnselected,
	                legendIndex: legendIndex,
	                legendSet: _this.legendSet
	            });
	
	            position.left += _const2['default'].LEGEND_ICON_WIDTH + labelPaddingLeft;
	
	            _this._renderLabel(position, {
	                labelText: legendDatum.label,
	                labelHeight: labelHeight,
	                isUnselected: isUnselected,
	                legendIndex: legendIndex,
	                legendSet: _this.legendSet
	            });
	
	            if (_this.isHorizontal) {
	                position.left += _this.labelWidths[index] + _const2['default'].LEGEND_H_LABEL_RIGHT_PADDING;
	            } else {
	                position.left = _this.basePosition.left;
	                position.top += _this._legendItemHeight + _const2['default'].LINE_MARGIN_TOP;
	            }
	        });
	    };
	
	    /**
	     * @param {Array.<object>} legendData Array of legend item data
	     * @param {number} sliceIndex slice index of
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._getLegendData = function _getLegendData(legendData, sliceIndex) {
	        var positionTop = this.basePosition.top;
	        var totalHeight = this.dimension.height;
	        var chartHeight = this.paper.height;
	        var resultLegendData = legendData;
	
	        if (!this.isHorizontal && totalHeight + positionTop * 2 > chartHeight) {
	            this._legendItemHeight = Math.max(legendData[0].labelHeight, _const2['default'].LEGEND_CHECKBOX_SIZE);
	            var pageHeight = chartHeight - positionTop * 2;
	            var singleItemHeight = this._legendItemHeight + _const2['default'].LINE_MARGIN_TOP;
	            var visibleItemCount = Math.floor(pageHeight / singleItemHeight);
	
	            resultLegendData = legendData.slice((sliceIndex - 1) * visibleItemCount, sliceIndex * visibleItemCount);
	        }
	
	        return resultLegendData;
	    };
	
	    /**
	     * Render legend
	     * @param {object} data rendering data
	     *     @param {HTMLElement} data.container legend container
	     *     @param {Array.<object>} data.legendData rendering legendData
	     *     @param {boolean} data.isHorizontal boolean value of horizontal or not
	     *     @param {{height:number, width:number}} data.dimension legend dimension
	     *     @param {object} data.labelTheme legend label theme object
	     *     @param {number} data.labelWidths label widths
	     *     @param {object} data.eventBus event bus
	     * @returns {object} paper
	     */
	
	
	    RaphaelLegendComponent.prototype.render = function render(data) {
	        this.eventBus = data.eventBus;
	        this.paper = data.paper;
	        this.dimension = data.dimension;
	        this.legendSet = this.paper.set();
	        this.labelWidths = data.labelWidths;
	        this.labelTheme = data.labelTheme;
	        this.basePosition = data.position;
	        this.isHorizontal = data.isHorizontal;
	        this.originalLegendData = data.legendData;
	
	        if (this.originalLegendData.length) {
	            this._showCheckbox = _tuiCodeSnippet2['default'].isExisty(data.legendData[0].checkbox);
	            this._setComponentDimensionsBaseOnLabelHeight(data.legendData[0].labelHeight);
	
	            var legendData = this._getLegendData(data.legendData, this._currentPageCount);
	
	            this._renderLegendItems(legendData);
	
	            if (!this.isHorizontal && legendData && legendData.length < data.legendData.length) {
	                var legendHeight = this.paper.height - this.basePosition.top * 2;
	
	                this.availablePageCount = Math.ceil(data.dimension.height / legendHeight);
	
	                this._renderPaginationArea(this.basePosition, {
	                    width: data.dimension.width,
	                    height: legendHeight
	                });
	            }
	        }
	
	        return this.legendSet;
	    };
	
	    /**
	     * @param {string} direction direction string of paginate 'next' or 'previous'
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._paginateLegendAreaTo = function _paginateLegendAreaTo(direction) {
	        var pageNumber = this._currentPageCount;
	
	        this._removeLegendItems();
	
	        if (direction === 'next') {
	            pageNumber += 1;
	        } else {
	            pageNumber -= 1;
	        }
	
	        this._renderLegendItems(this._getLegendData(this.originalLegendData, pageNumber));
	    };
	
	    RaphaelLegendComponent.prototype._removeLegendItems = function _removeLegendItems() {
	        this.legendSet.forEach(function (legendItem) {
	            var events = legendItem.events || [];
	            events.forEach(function (event) {
	                event.unbind();
	            });
	            legendItem.remove();
	        });
	    };
	
	    /**
	     * @param {{top: number, left: number}} position legend area position
	     * @param {{height: number, width: number}} dimension legend area dimension
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._renderPaginationArea = function _renderPaginationArea(position, dimension) {
	        var _this2 = this;
	
	        var LEGEND_PAGINATION_BUTTON_WIDTH = _const2['default'].LEGEND_PAGINATION_BUTTON_WIDTH,
	            LEGEND_PAGINATION_BUTTON_PADDING_RIGHT = _const2['default'].LEGEND_PAGINATION_BUTTON_PADDING_RIGHT,
	            LEGEND_AREA_V_PADDING = _const2['default'].LEGEND_AREA_V_PADDING,
	            LEGEND_AREA_H_PADDING = _const2['default'].LEGEND_AREA_H_PADDING;
	
	        var controllerPositionTop = position.top + dimension.height - LEGEND_AREA_V_PADDING;
	        var controllerPositionLeft = position.left - LEGEND_AREA_H_PADDING;
	        var leftButtonPositionLeft = controllerPositionLeft + LEGEND_AREA_H_PADDING;
	        var rightButtonPositionLeft = _calculator2['default'].sum([leftButtonPositionLeft, LEGEND_PAGINATION_BUTTON_PADDING_RIGHT, LEGEND_PAGINATION_BUTTON_WIDTH]);
	        var lowerArrowPath = ['M', rightButtonPositionLeft + 5, ',', controllerPositionTop + PAGINATION_POSITION_PADDING + 4, 'L', rightButtonPositionLeft + PAGINATION_POSITION_HALP_WIDTH + 5, ',', controllerPositionTop + PAGINATION_POSITION_HEIGHT + 4, 'L', rightButtonPositionLeft + PAGINATION_POSITION_WIDTH + 5, ',', controllerPositionTop + PAGINATION_POSITION_PADDING + 4].join('');
	        var upperArrowPath = ['M', leftButtonPositionLeft + 5, ',', controllerPositionTop + PAGINATION_POSITION_HEIGHT + 4, 'L', leftButtonPositionLeft + PAGINATION_POSITION_HALP_WIDTH + 5, ',', controllerPositionTop + PAGINATION_POSITION_PADDING + 4, 'L', leftButtonPositionLeft + PAGINATION_POSITION_WIDTH + 5, ',', controllerPositionTop + PAGINATION_POSITION_HEIGHT + 4].join('');
	
	        var prevRect = this._renderPaginationRect({
	            top: controllerPositionTop,
	            left: leftButtonPositionLeft
	        });
	        var prevArrow = _raphaelRenderUtil2['default'].renderLine(this.paper, upperArrowPath, '#555', 2);
	
	        var nextRect = this._renderPaginationRect({
	            top: controllerPositionTop,
	            left: rightButtonPositionLeft
	        });
	        var nextArrow = _raphaelRenderUtil2['default'].renderLine(this.paper, lowerArrowPath, '#555', 2);
	        var prevButtonSet = this.paper.set();
	        var nextButtonSet = this.paper.set();
	
	        prevRect.className = 'tui-chart-icon';
	        prevButtonSet.push(prevRect);
	        prevButtonSet.push(prevArrow);
	
	        nextRect.className = 'tui-chart-icon';
	        nextButtonSet.push(nextRect);
	        nextButtonSet.push(nextArrow);
	
	        prevButtonSet.click(function () {
	            if (_this2._currentPageCount > 1) {
	                _this2._paginateLegendAreaTo('previous');
	                _this2._currentPageCount -= 1;
	            }
	        });
	
	        nextButtonSet.click(function () {
	            if (_this2._currentPageCount < _this2.availablePageCount) {
	                _this2._paginateLegendAreaTo('next');
	                _this2._currentPageCount += 1;
	            }
	        });
	    };
	
	    /**
	     * @param {object} position - position top, left
	     * @returns {SVGElement} - svg element
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._renderPaginationRect = function _renderPaginationRect(position) {
	        var BUTTON_SIZE = _const2['default'].LEGEND_PAGINATION_BUTTON_WIDTH;
	        var bound = {
	            left: position.left,
	            top: position.top,
	            width: BUTTON_SIZE,
	            height: BUTTON_SIZE
	        };
	        var rect = _raphaelRenderUtil2['default'].renderRect(this.paper, bound, {
	            fill: '#f4f4f4',
	            rx: '1px',
	            ry: '1px',
	            stroke: 'none'
	        });
	
	        return rect;
	    };
	
	    /**
	     * Make labels width.
	     * @param {Array.<{chartType: ?string, label: string}>} legendData legend data
	     * @param {object} theme theme object
	     * @param {number} maxWidth user option legend max width size
	     * @returns {Array.<number>} label widths
	     */
	
	
	    RaphaelLegendComponent.prototype.makeLabelWidths = function makeLabelWidths(legendData, theme, maxWidth) {
	        return _tuiCodeSnippet2['default'].map(legendData, function (item) {
	            var labelWidth = _raphaelRenderUtil2['default'].getRenderedTextSize(item.label, theme.fontSize, theme.fontFamily).width;
	            if (maxWidth && labelWidth > maxWidth) {
	                labelWidth = maxWidth;
	            }
	
	            return labelWidth + _const2['default'].LEGEND_LABEL_LEFT_PADDING;
	        });
	    };
	
	    /**
	     * Get rendered label height
	     * @param {string} labelText label text
	     * @param {object} theme theme object
	     * @returns {number}
	     */
	
	
	    RaphaelLegendComponent.prototype.getRenderedLabelHeight = function getRenderedLabelHeight(labelText, theme) {
	        return _raphaelRenderUtil2['default'].getRenderedTextSize(labelText, theme.fontSize, theme.fontFamily).height;
	    };
	
	    /**
	     * Render label text and attach event
	     * @param {object} position left, top
	     * @param {object} data rendering data
	     *     @param {string} data.labelText label text
	     *     @param {number} data.labelHeight label height
	     *     @param {boolean} data.isUnselected boolean value for selected or not
	     *     @param {number} data.legendIndex legend index
	     *     @param {Array.<object>} data.legendSet legend set
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._renderLabel = function _renderLabel(position, data) {
	        var eventBus = this.eventBus,
	            labelTheme = this.labelTheme;
	
	        var pos = {
	            left: position.left,
	            top: position.top + this._legendItemHeight / 2
	        };
	        var attributes = {
	            fill: labelTheme.color,
	            'font-size': labelTheme.fontSize,
	            'font-family': labelTheme.fontFamily,
	            'font-weight': labelTheme.fontWeight,
	            opacity: data.isUnselected ? UNSELECTED_LEGEND_LABEL_OPACITY : 1,
	            'text-anchor': 'start'
	        };
	        var label = _raphaelRenderUtil2['default'].renderText(this.paper, pos, data.labelText, attributes);
	
	        label.data('index', data.legendIndex);
	
	        label.node.style.userSelect = 'none';
	        label.node.style.cursor = 'pointer';
	
	        data.legendSet.push(label);
	
	        label.click(function () {
	            eventBus.fire('labelClicked', data.legendIndex);
	        });
	    };
	
	    /**
	     * Render checkbox
	     * @param {object} position left, top
	     * @param {object} data rendering data
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._renderCheckbox = function _renderCheckbox(position, data) {
	        var _this3 = this;
	
	        var left = position.left;
	
	        var top = position.top + (this._legendItemHeight - this._checkBoxHeight) / 2;
	        var checkboxPathSize = this._checkBoxWidth / 3;
	        var checkboxPathHalpSize = this._checkBoxWidth / 5.7;
	        var vPathString = _renderUtil2['default'].oneLineTrim(_templateObject, this._checkBoxWidth * 0.25 + left, this._checkBoxHeight * 0.5 + top, checkboxPathHalpSize, checkboxPathHalpSize, checkboxPathSize, checkboxPathSize);
	
	        var checkboxSet = this.paper.set();
	        var checkboxElement = this.paper.rect(left, top, this._checkBoxWidth, this._checkBoxHeight, 0).attr({
	            fill: '#fff',
	            stroke: '#aaa',
	            'stroke-width': 1
	        });
	        checkboxElement.node.setAttribute('class', 'auto-shape-rendering');
	
	        checkboxSet.push(checkboxElement);
	
	        if (data.isChecked) {
	            var checkElement = this.paper.path(vPathString).attr({
	                'stroke': '#555',
	                'stroke-width': 2
	            });
	            checkElement.node.setAttribute('class', 'auto-shape-rendering');
	            checkboxSet.push(checkElement);
	        }
	
	        checkboxSet.data('index', data.legendIndex);
	        checkboxSet.click(function () {
	            _this3.eventBus.fire('checkboxClicked', data.legendIndex);
	        });
	
	        checkboxSet.forEach(function (checkbox) {
	            data.legendSet.push(checkbox);
	        });
	    };
	
	    /**
	     * Render legend icon and attach event
	     * @param {object} position left, top
	     * @param {object} data rendering data
	     *     @param {string} data.labelText label text
	     *     @param {number} data.labelHeight label height
	     *     @param {string} data.legendColor legend color hex
	     *     @param {boolean} data.isUnselected boolean value for selected or not
	     *     @param {number} data.legendIndex legend index
	     *     @param {Array.<object>} data.legendSet legend set
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._renderIcon = function _renderIcon(position, data) {
	        var _this4 = this;
	
	        var icon = void 0;
	        this.paper.setStart();
	
	        if ((data.iconType === 'line' || data.iconType === 'radial') && this.paper.canvas.transform) {
	            icon = this.paper.path(_const2['default'].LEGEND_LINE_ICON_PATH);
	
	            icon.attr({
	                'stroke': data.legendColor,
	                'stroke-width': 2,
	                'stroke-opacity': data.isUnselected ? UNSELECTED_LEGEND_LABEL_OPACITY : 1
	            });
	            icon.translate(position.left, position.top);
	        } else {
	            icon = _raphaelRenderUtil2['default'].renderRect(this.paper, {
	                left: position.left,
	                top: position.top + (_const2['default'].LEGEND_CHECKBOX_SIZE - _const2['default'].LEGEND_ICON_HEIGHT) / 2,
	                width: _const2['default'].LEGEND_ICON_WIDTH,
	                height: _const2['default'].LEGEND_ICON_HEIGHT
	            }, {
	                'stroke-width': 0,
	                fill: data.legendColor,
	                opacity: data.isUnselected ? UNSELECTED_LEGEND_LABEL_OPACITY : 1
	            });
	        }
	
	        icon.data('icon', data.iconType);
	        icon.data('index', data.legendIndex);
	        icon.click(function () {
	            _this4.eventBus.fire('labelClicked', data.legendIndex);
	        });
	
	        data.legendSet.push(icon);
	    };
	
	    RaphaelLegendComponent.prototype.selectLegend = function selectLegend(index, legendSet) {
	        legendSet.forEach(function (element) {
	            var indexData = element.data('index');
	            var attributeName = element.data('icon') === 'line' ? 'stroke-opacity' : 'opacity';
	
	            if (_tuiCodeSnippet2['default'].isNull(indexData) || _tuiCodeSnippet2['default'].isUndefined(indexData)) {
	                element.attr(attributeName, 1);
	            } else if (!_tuiCodeSnippet2['default'].isUndefined(indexData)) {
	                if (_tuiCodeSnippet2['default'].isNumber(index) && indexData !== index) {
	                    element.attr(attributeName, UNSELECTED_LEGEND_LABEL_OPACITY);
	                } else {
	                    element.attr(attributeName, 1);
	                }
	            }
	        });
	    };
	
	    /**
	     * get checkbox area's width depends on checkbox visibility
	     * @returns {number} - checkbox region's width
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._getCheckboxWidth = function _getCheckboxWidth() {
	        return this._showCheckbox ? this._checkBoxWidth + _const2['default'].LEGEND_LABEL_LEFT_PADDING : 0;
	    };
	
	    /**
	     * Get width of a label when parameter is given.
	     * Otherwise, returns maximum width of labels
	     * @param {number} [index] - legend index
	     * @returns {number} - maximum label width  label width
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._getLabelWidth = function _getLabelWidth(index) {
	        var labelWidth = void 0;
	        if (index) {
	            labelWidth = this.labelWidths[index] || 0;
	        } else {
	            labelWidth = _arrayUtil2['default'].max(this.labelWidths);
	        }
	
	        return labelWidth;
	    };
	
	    /**
	     * calulate a whole legend width before start rendering
	     * @returns {number} - calculate label
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._calculateLegendWidth = function _calculateLegendWidth() {
	        return this._calculateSingleLegendWidth();
	    };
	
	    /**
	     * calculate a single legend width of index `legendIndex`
	     * @param {number} legendIndex - index of legend label
	     * @returns {number} - calculate single legend width
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._calculateSingleLegendWidth = function _calculateSingleLegendWidth(legendIndex) {
	        return _const2['default'].LEGEND_AREA_H_PADDING + this._getCheckboxWidth() + getIconWidth() + this._getLabelWidth(legendIndex) + _const2['default'].LEGEND_AREA_H_PADDING;
	    };
	
	    /**
	     * set component dimension by comparaing label height and icon height
	     * @param {number} labelHeight - label height
	     * @private
	     */
	
	
	    RaphaelLegendComponent.prototype._setComponentDimensionsBaseOnLabelHeight = function _setComponentDimensionsBaseOnLabelHeight(labelHeight) {
	        this._legendItemHeight = Math.max(labelHeight, _const2['default'].LEGEND_CHECKBOX_SIZE);
	        this._checkBoxWidth = this._checkBoxHeight = _const2['default'].LEGEND_CHECKBOX_SIZE;
	    };
	
	    return RaphaelLegendComponent;
	}();
	
	exports['default'] = RaphaelLegendComponent;

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * @fileoverview calculator.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	var PERCENT_DIVISOR = 100;
	
	/**
	 * Calculator.
	 * @module calculator
	 * @private */
	var calculator = {
	    /**
	     * Calculate limit from chart min, max data.
	     *  - http://peltiertech.com/how-excel-calculates-automatic-chart-axis-limits/
	     * @memberOf module:calculator
	     * @param {number} min min minimum value of user data
	     * @param {number} max max maximum value of user data
	     * @returns {{min: number, max: number}} limit axis limit
	     */
	    calculateLimit: function calculateLimit(min, max) {
	        var limit = {};
	        var saveMin = 0;
	
	        if (min < 0) {
	            saveMin = min;
	            max -= min;
	            min = 0;
	        }
	
	        var iodValue = (max - min) / 20;
	
	        limit.max = max + iodValue + saveMin;
	
	        if (max / 6 > min) {
	            limit.min = saveMin;
	        } else {
	            limit.min = min - iodValue + saveMin;
	        }
	
	        return limit;
	    },
	
	
	    /**
	     * Make tick positions of pixel type.
	     * @memberOf module:calculator
	     * @param {number} size area width or height
	     * @param {number} count tick count
	     * @param {?number} additionalPosition additional position
	     * @param {?number} remainLastBlockIntervalPosition remainLastBlockInterval position
	     * @returns {Array.<number>} positions
	     */
	    makeTickPixelPositions: function makeTickPixelPositions(size, count, additionalPosition, remainLastBlockIntervalPosition) {
	        var positions = [];
	
	        additionalPosition = additionalPosition || 0;
	
	        if (count > 0) {
	            positions = _tuiCodeSnippet2['default'].range(0, count).map(function (index) {
	                var ratio = index === 0 ? 0 : index / (count - 1);
	
	                return ratio * size + additionalPosition;
	            });
	            positions[positions.length - 1] -= 1;
	        }
	
	        if (remainLastBlockIntervalPosition) {
	            positions.push(remainLastBlockIntervalPosition);
	        }
	
	        return positions;
	    },
	
	
	    /**
	     * Make labels from limit.
	     * @memberOf module:calculator
	     * @param {{min: number, max: number}} limit axis limit
	     * @param {number} step step between max and min
	     * @returns {string[]} labels
	     * @private
	     */
	    makeLabelsFromLimit: function makeLabelsFromLimit(limit, step) {
	        var multipleNum = calculator.findMultipleNum(step);
	        var min = Math.round(limit.min * multipleNum);
	        var max = Math.round(limit.max * multipleNum);
	        var labels = _tuiCodeSnippet2['default'].range(min, max + 1, step * multipleNum);
	
	        return labels.map(function (label) {
	            return label / multipleNum;
	        });
	    },
	
	
	    /**
	     * Calculate step from limit.
	     * @memberOf module:calculator
	     * @param {{min: number, max: number}} limit axis limit
	     * @param {number} count value count
	     * @returns {number} step
	     */
	    calculateStepFromLimit: function calculateStepFromLimit(limit, count) {
	        return calculator.divide(calculator.subtract(limit.max, limit.min), count - 1);
	    },
	
	
	    /**
	     * Sum plus values.
	     * @param {Array.<number>} values values
	     * @returns {number} sum
	     */
	    sumPlusValues: function sumPlusValues(values) {
	        var plusValues = _tuiCodeSnippet2['default'].filter(values, function (value) {
	            return value > 0;
	        });
	
	        return calculator.sum(plusValues);
	    },
	
	
	    /**
	     * Sum minus values.
	     * @param {Array.<number>} values values
	     * @returns {number} sum
	     */
	    sumMinusValues: function sumMinusValues(values) {
	        var minusValues = _tuiCodeSnippet2['default'].filter(values, function (value) {
	            return value < 0;
	        });
	
	        return calculator.sum(minusValues);
	    },
	
	
	    /**
	     * Make percentage value.
	     * @param {number} value - value
	     * @param {number} totalValue - total value
	     * @returns {number}
	     */
	    makePercentageValue: function makePercentageValue(value, totalValue) {
	        return value / totalValue * PERCENT_DIVISOR;
	    },
	
	
	    /**
	     * Calculate ratio for making bound.
	     * @param {number} value - value
	     * @param {number} divNumber - number for division
	     * @param {number} subNumber - number for subtraction
	     * @param {number} baseRatio - base ratio
	     * @returns {number}
	     */
	    calculateRatio: function calculateRatio(value, divNumber, subNumber, baseRatio) {
	        return divNumber ? (value - subNumber) / divNumber * baseRatio : 0;
	    }
	};
	
	/**
	 * Get length after decimal point.
	 * @memberOf module:calculator
	 * @param {string | number} value target value
	 * @returns {number} result length
	 */
	var getDecimalLength = function getDecimalLength(value) {
	    var valueArr = String(value).split('.');
	
	    return valueArr.length === 2 ? valueArr[1].length : 0;
	};
	
	/**
	 * Find multiple num.
	 * @memberOf module:calculator
	 * @param {...Array} target values
	 * @returns {number} multiple num
	 */
	var findMultipleNum = function findMultipleNum() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	    }
	
	    var underPointLens = args.map(function (value) {
	        return calculator.getDecimalLength(value);
	    });
	    var underPointLen = _arrayUtil2['default'].max(underPointLens);
	
	    return Math.pow(10, underPointLen);
	};
	
	/**
	 * Modulo operation for floating point operation.
	 * @memberOf module:calculator
	 * @param {number} target target values
	 * @param {number} modNum mod num
	 * @returns {number} result mod
	 */
	var mod = function mod(target, modNum) {
	    var multipleNum = calculator.findMultipleNum(modNum);
	    var result = void 0;
	
	    if (multipleNum === 1) {
	        result = target % modNum;
	    } else {
	        result = target * multipleNum % (modNum * multipleNum) / multipleNum;
	    }
	
	    return result;
	};
	
	/**
	 * 'add' is function for add operation to floating point.
	 * @memberOf module:calculator
	 * @param {number} a target a
	 * @param {number} b target b
	 * @returns {number}
	 */
	var add = function add(a, b) {
	    var multipleNum = calculator.findMultipleNum(a, b);
	
	    return (a * multipleNum + b * multipleNum) / multipleNum;
	};
	
	/**
	 * 'subtract' is function for subtract operation to floating point.
	 * @memberOf module:calculator
	 * @param {number} a target a
	 * @param {number} b target b
	 * @returns {number}
	 */
	var subtract = function subtract(a, b) {
	    var multipleNum = calculator.findMultipleNum(a, b);
	
	    return (a * multipleNum - b * multipleNum) / multipleNum;
	};
	
	/**
	 * 'multiply' is function for multiply operation to floating point.
	 * @param {number} a target a
	 * @param {number} b target b
	 * @returns {number}
	 */
	var multiply = function multiply(a, b) {
	    var multipleNum = calculator.findMultipleNum(a, b);
	
	    return a * multipleNum * (b * multipleNum) / (multipleNum * multipleNum);
	};
	
	/**
	 * 'divide' is function for divide operation to floating point.
	 * @memberOf module:calculator
	 * @param {number} a target a
	 * @param {number} b target b
	 * @returns {number}
	 */
	var divide = function divide(a, b) {
	    var multipleNum = calculator.findMultipleNum(a, b);
	
	    return a * multipleNum / (b * multipleNum);
	};
	
	/**
	 * Sum.
	 * @memberOf module:calculator
	 * @param {Array.<number>} values target values
	 * @returns {number} result value
	 */
	var sum = function sum(values) {
	    var copyArr = values.slice();
	    copyArr.unshift(0);
	
	    return copyArr.reduce(function (base, value) {
	        return calculator.add(parseFloat(base), parseFloat(value));
	    });
	};
	
	/**
	 * Obtain the number of divisors.
	 * @memberOf module:calculator
	 * @param {Array.<number>} value target value
	 * @returns {number} result value
	 */
	var divisors = function divisors(value) {
	    var result = [];
	    for (var a = 2, b; a * a <= value; a += 1) {
	        if (value % a === 0) {
	            b = value / a;
	            result.push(a);
	            if (b !== a) {
	                result.push(b);
	            }
	        }
	    }
	    result.sort(function (prev, next) {
	        return prev - next;
	    });
	
	    return result;
	};
	
	calculator.getDecimalLength = getDecimalLength;
	calculator.findMultipleNum = findMultipleNum;
	calculator.mod = mod;
	calculator.add = add;
	calculator.subtract = subtract;
	calculator.multiply = multiply;
	calculator.divide = divide;
	calculator.divisors = divisors;
	calculator.sum = sum;
	
	exports['default'] = calculator;

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview RaphaelMapLegend is graph renderer for map chart legend.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var DEGREE_HORIZONTAL_BAR = 360;
	var DEGREE_VERTICAL_BAR = 270;
	var WEDGE_BASE_HALF = 2.5; // half of wedge triagle base
	
	/**
	 * @classdesc RaphaelMapLegend is graph renderer for map chart legend.
	 * @class RaphaelMapLegend
	 * @private
	 */
	
	var RaphaelMapLegend = function () {
	    function RaphaelMapLegend() {
	        _classCallCheck(this, RaphaelMapLegend);
	
	        /**
	         * Vertical base path
	         * @type {Array}
	         */
	        this.verticalRightBasePath = ['M', -4, 0, 'L', -8, 2.5, 'L', -8, 12.5, 'L', -28, 12.5, 'L', -28, -12.5, 'L', -8, -12.5, 'L', -8, -2.5];
	        this.verticalLeftBasePath = ['M', 10, 0, 'L', 14, 2.5, 'L', 14, 12.5, 'L', 34, 12.5, 'L', 34, -12.5, 'L', 14, -12.5, 'L', 14, -2.5];
	
	        /**
	         * Horizontal base path
	         * @type {Array}
	         */
	        this.horizontalTopBasePath = ['M', 0, 10, 'L', 2.5, 14, 'L', 12.5, 14, 'L', 12.5, 34, 'L', -12.5, 34, 'L', -12.5, 14, 'L', -2.5, 14];
	        this.horizontalBottomBasePath = ['M', 0, -4, 'L', 2.5, -8, 'L', 12.5, -8, 'L', 12.5, -28, 'L', -12.5, -28, 'L', -12.5, -8, 'L', -2.5, -8];
	    }
	
	    /**
	     * Render function of map chart legend.
	     * @param {object} param - param to render spectrum legend
	     *  @param {object} param.paper raphael paper
	     *  @param {object} param.layout legend layout
	     *  @param {ColorSpectrum} param.colorSpectrum map chart color model
	     *  @param {boolean} param.isHorizontal whether horizontal legend or not
	     *  @param {Array.<object>} param.legendSet legend set
	     */
	
	
	    RaphaelMapLegend.prototype.render = function render(param) {
	        var layout = param.layout,
	            align = param.align,
	            legendSet = param.legendSet,
	            theme = param.theme,
	            labels = param.labels;
	
	        var isHorizontal = _predicate2['default'].isHorizontalLegend(align);
	
	        var _labels = _slicedToArray(labels, 1),
	            minLabel = _labels[0];
	
	        var maxLabel = labels[labels.length - 1];
	        var maxLabelWidth = _renderUtil2['default'].getRenderedLabelsMaxWidth([minLabel, maxLabel]);
	        var labelHeight = _renderUtil2['default'].getRenderedLabelHeight(minLabel, theme);
	        var isBoxTypeChart = _predicate2['default'].isBoxTypeChart(this.chartType);
	        var position = layout.position;
	
	
	        this.layout = layout;
	        this.isHorizontal = isHorizontal;
	        this.isLeftLegend = _predicate2['default'].isLegendAlignLeft(align);
	        this.isTopLegend = _predicate2['default'].isLegendAlignTop(align);
	        this.theme = theme;
	        this.paper = param.paper;
	        this.legendSet = param.legendSet;
	        this.colorSpectrum = param.colorSpectrum;
	
	        if (_predicate2['default'].isLegendAlignTop(align)) {
	            position.top += _const2['default'].MAP_LEGEND_AREA_PADDING_WIDE + labelHeight + _const2['default'].MAP_LEGEND_LABEL_PADDING * 2;
	        } else if (_predicate2['default'].isLegendAlignBottom(align)) {
	            position.top += this._calculateHorizontalLegendTooltipHeight(labels, theme) + _const2['default'].MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE;
	
	            if (isBoxTypeChart) {
	                position.top -= _const2['default'].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING;
	            } else {
	                position.top += _const2['default'].MAP_LEGEND_AREA_PADDING_WIDE;
	            }
	        } else if (_predicate2['default'].isLegendAlignLeft(align)) {
	            position.left += maxLabelWidth + _const2['default'].MAP_LEGEND_LABEL_PADDING;
	        } else {
	            position.left = layout.position.right - maxLabelWidth - _const2['default'].MAP_LEGEND_LABEL_PADDING - _const2['default'].MAP_LEGEND_GRAPH_SIZE;
	        }
	
	        var gradientBar = this._renderGradientBar(this.paper, layout, this.colorSpectrum, isHorizontal);
	
	        legendSet.push(gradientBar);
	
	        this.wedge = this._renderWedge(this.paper, position);
	        this.wedgeText = this._renderWedgeText(this.paper, position, theme);
	        legendSet.push(this.wedge);
	
	        this.gradientBar = gradientBar;
	    };
	
	    /**
	     * Render tick label
	     * @param {object} paper Raphael paper
	     * @param {object} baseData base data for render ticks
	     * @param {Array.<string>} labels labels
	     * @param {string} align legend align option
	     * @param {Array.<object>} legendSet legend set
	     */
	
	
	    RaphaelMapLegend.prototype.renderTickLabels = function renderTickLabels(paper, baseData, labels, align, legendSet) {
	        var _this = this;
	
	        var theme = this.theme;
	
	        var attribute = {
	            'font-size': theme.fontSize,
	            'font-family': theme.fontFamily,
	            'font-weight': theme.fontWeight,
	            fill: '#000'
	        };
	
	        var _labels2 = _slicedToArray(labels, 1),
	            minLabel = _labels2[0];
	
	        var maxLabel = labels[labels.length - 1];
	        var maxLabelWidth = _renderUtil2['default'].getRenderedLabelsMaxWidth([minLabel, maxLabel]);
	        var labelHeight = _renderUtil2['default'].getRenderedLabelHeight(minLabel, theme);
	
	        labels.forEach(function (label, labelIndex) {
	            var offsetValue = baseData.step * labelIndex;
	            var pos = Object.assign({}, baseData.position);
	
	            if (_predicate2['default'].isHorizontalLegend(align)) {
	                pos.left += offsetValue;
	                if (_this.isTopLegend) {
	                    pos.top -= labelHeight / 2;
	                } else {
	                    pos.top += labelHeight / 2;
	                }
	            } else {
	                pos.top += offsetValue;
	                if (_this.isLeftLegend) {
	                    attribute['text-anchor'] = 'end';
	                    pos.left = _const2['default'].CHART_PADDING + maxLabelWidth;
	                } else {
	                    attribute['text-anchor'] = 'start';
	                }
	            }
	
	            legendSet.push(_raphaelRenderUtil2['default'].renderText(paper, pos, label, attribute));
	        }, this);
	    };
	
	    /**
	     * Render gradient bar.
	     * @param {object} paper raphael object
	     * @param {object} layout legend layout
	     * @param {ColorSpectrum} colorSpectrum map chart color model
	     * @param {boolean} isHorizontal whether horizontal legend or not
	     * @returns {object}
	     * @private
	     */
	
	
	    RaphaelMapLegend.prototype._renderGradientBar = function _renderGradientBar(paper, layout, colorSpectrum, isHorizontal) {
	        var width = void 0,
	            height = void 0,
	            degree = void 0;
	
	        if (isHorizontal) {
	            width = layout.dimension.width;
	
	            height = _const2['default'].MAP_LEGEND_GRAPH_SIZE;
	            degree = DEGREE_HORIZONTAL_BAR;
	            this._makeWedghPath = this._makeHorizontalWedgePath;
	        } else {
	            width = _const2['default'].MAP_LEGEND_GRAPH_SIZE;
	            height = layout.dimension.height;
	
	            degree = DEGREE_VERTICAL_BAR;
	            this._makeWedghPath = this._makeVerticalWedgePath;
	        }
	
	        var bound = {
	            left: layout.position.left,
	            top: layout.position.top,
	            width: width,
	            height: height
	        };
	
	        return _raphaelRenderUtil2['default'].renderRect(paper, bound, {
	            fill: degree + '-' + colorSpectrum.start + '-' + colorSpectrum.end,
	            stroke: 'none'
	        });
	    };
	
	    /**
	     * Render wedge text
	     * @param {object} paper - raphael paper
	     * @param {object} position - position
	     * @param {object} theme - legend label theme
	     * @returns {SVGTextElement} - wedge text
	     * @private
	     */
	
	
	    RaphaelMapLegend.prototype._renderWedgeText = function _renderWedgeText(paper, position, theme) {
	        if (this.isLeftLegend) {
	            position.left += _const2['default'].MAP_LEGEND_WEDGE_SIZE + _const2['default'].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING;
	        }
	
	        return _raphaelRenderUtil2['default'].renderText(paper, position, '', {
	            'font-size': theme.fontSize,
	            'font-family': theme.fontFamily,
	            'font-weight': theme.fontWeight,
	            fill: theme.color
	        });
	    };
	
	    /**
	     * Render wedge.
	     * @param {object} paper raphael object
	     * @param {{top: number, left: number}} position base position of legend
	     * @returns {object} raphael object
	     * @private
	     */
	
	
	    RaphaelMapLegend.prototype._renderWedge = function _renderWedge(paper, position) {
	        return paper.path(this.verticalBasePath).attr({
	            fill: 'gray',
	            stroke: 'white',
	            'stroke-opacity': 0.2,
	            opacity: 0,
	            transform: 't' + position.left + ',' + position.top
	        });
	    };
	
	    /**
	     * Make vertical wedge path.
	     * @param {number} top top
	     * @param {object} labelDimension label width and height
	     * @returns {Array} path
	     * @private
	     */
	
	
	    RaphaelMapLegend.prototype._makeVerticalWedgePath = function _makeVerticalWedgePath(top, labelDimension) {
	        var isLeftLegend = this.isLeftLegend;
	
	        var path = this.verticalBasePath = isLeftLegend ? this.verticalLeftBasePath : this.verticalRightBasePath;
	        var PADDING_H = _const2['default'].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING,
	            PADDING_V = _const2['default'].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING;
	        var labelWidth = labelDimension.width,
	            labelHeight = labelDimension.height;
	
	
	        path[2] = top;
	        path[5] = top + WEDGE_BASE_HALF;
	        path[8] = path[11] = top + labelHeight / 2 + PADDING_V;
	        path[14] = path[17] = top - labelHeight / 2 - PADDING_V;
	        path[20] = top - WEDGE_BASE_HALF;
	
	        if (isLeftLegend) {
	            path[10] = path[13] = path[4] + labelWidth + PADDING_H * 2;
	        } else {
	            path[10] = path[13] = path[4] - labelWidth - PADDING_H * 2;
	        }
	
	        return path;
	    };
	
	    /**
	     * Make horizontal wedge path.
	     * @param {number} left left
	     * @param {object} labelDimension label width and height
	     * @returns {Array} path
	     * @private
	     */
	
	
	    RaphaelMapLegend.prototype._makeHorizontalWedgePath = function _makeHorizontalWedgePath(left, labelDimension) {
	        var path = this.horiziontalBaseBath = this.isTopLegend ? this.horizontalTopBasePath : this.horizontalBottomBasePath;
	        var PADDING_H = _const2['default'].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING,
	            PADDING_V = _const2['default'].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING;
	        var labelWidth = labelDimension.width,
	            labelHeight = labelDimension.height;
	
	
	        path[1] = left;
	        path[4] = left + WEDGE_BASE_HALF;
	        path[7] = path[10] = left + labelWidth / 2 + PADDING_H;
	        path[13] = path[16] = left - labelWidth / 2 - PADDING_H;
	        path[19] = left - WEDGE_BASE_HALF;
	
	        if (this.isTopLegend) {
	            path[11] = path[14] = path[5] + labelHeight + PADDING_V * 2;
	        } else {
	            path[11] = path[14] = path[5] - labelHeight - PADDING_V * 2;
	        }
	
	        return path;
	    };
	
	    /**
	     * Show wedge.
	     * @param {number} ratio value ratio beyond spectrum legend
	     * @param {string} label data value
	     */
	
	
	    RaphaelMapLegend.prototype.showWedge = function showWedge(ratio, label) {
	        var labelTheme = this.theme;
	        var labelSize = _raphaelRenderUtil2['default'].getRenderedTextSize(label, labelTheme.fontSize, labelTheme.fontFamily);
	        var legendSize = this.isHorizontal ? this.layout.dimension.width : this.layout.dimension.height;
	        var path = this._makeWedghPath(legendSize * ratio, labelSize);
	
	        this.wedge.attr({
	            path: path,
	            opacity: 1,
	            fill: this.colorSpectrum.getColor(ratio)
	        });
	
	        var wedgeBBox = this.wedge.getBBox();
	
	        var wedgeTextTop = _calculator2['default'].sum([wedgeBBox.y, _const2['default'].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING, labelSize.height / 2]);
	
	        var wedgeTextLeft = _calculator2['default'].sum([wedgeBBox.x, _const2['default'].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING, labelSize.width / 2]);
	
	        if (this.isLeftLegend) {
	            wedgeTextLeft += _const2['default'].MAP_LEGEND_WEDGE_SIZE;
	        }
	
	        if (this.isTopLegend) {
	            wedgeTextTop += _const2['default'].MAP_LEGEND_WEDGE_SIZE;
	        }
	
	        this.wedgeText.attr({
	            x: wedgeTextLeft,
	            y: wedgeTextTop,
	            text: label,
	            opacity: 1
	        });
	
	        this.wedge.toFront();
	        this.wedgeText.toFront();
	    };
	
	    /**
	     * Hide wedge
	     */
	
	
	    RaphaelMapLegend.prototype.hideWedge = function hideWedge() {
	        this.wedge.attr({
	            opacity: 0
	        });
	
	        this.wedgeText.attr({
	            opacity: 0
	        });
	    };
	
	    /**
	     * Remove location URL from fill attribute
	     * @private
	     */
	
	
	    RaphaelMapLegend.prototype.removeLocationURLFromFillAttribute = function removeLocationURLFromFillAttribute() {
	        var gradientBar = this.gradientBar;
	
	        var fillURL = gradientBar.node.getAttribute('fill');
	        var locationUrlRegExp = /url\('?([^#]+)#[^#]+'?\)/;
	
	        var _locationUrlRegExp$ex = locationUrlRegExp.exec(fillURL);
	
	        var _locationUrlRegExp$ex2 = _slicedToArray(_locationUrlRegExp$ex, 2);
	
	        this.locationURL = _locationUrlRegExp$ex2[1];
	
	
	        gradientBar.node.setAttribute('fill', fillURL.replace(this.locationURL, ''));
	    };
	
	    /**
	     * Restore location URL to fill attribute
	     * @private
	     */
	
	
	    RaphaelMapLegend.prototype.restoreLocationURLToFillAttribute = function restoreLocationURLToFillAttribute() {
	        var gradientBar = this.gradientBar;
	
	        var fillURL = gradientBar.node.getAttribute('fill');
	
	        gradientBar.node.setAttribute('fill', fillURL.replace('#', this.locationURL + '#'));
	    };
	
	    /**
	     * Calculate tooltip area height of horizontal legend
	     * @param {Array.<string>} labels - labels
	     * @param {object} theme - legend label theme
	     * @returns {number} - tooltip height
	     * @private
	     */
	
	
	    RaphaelMapLegend.prototype._calculateHorizontalLegendTooltipHeight = function _calculateHorizontalLegendTooltipHeight(labels, theme) {
	        var label = labels.length ? labels[labels.length - 1] : '';
	        var labelHeight = _renderUtil2['default'].getRenderedLabelHeight(label, theme);
	
	        return _calculator2['default'].sum([_const2['default'].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING * 2, labelHeight, _const2['default'].MAP_LEGEND_WEDGE_SIZE]);
	    };
	
	    /**
	     * Calculate tooltip area width of vertical legend
	     * @param {Array.<string>} labels - labels
	     * @param {object} theme - legend label theme
	     * @returns {number} - tooltip width
	     * @private
	     */
	
	
	    RaphaelMapLegend.prototype._calculateVerticalLegendTooltipWidth = function _calculateVerticalLegendTooltipWidth(labels, theme) {
	        var label = labels.length ? labels[labels.length - 1] : '';
	        var labelWidth = _renderUtil2['default'].getRenderedLabelWidth(label, theme);
	
	        return _calculator2['default'].sum([_const2['default'].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING * 2, labelWidth, _const2['default'].MAP_LEGEND_WEDGE_SIZE]);
	    };
	
	    return RaphaelMapLegend;
	}();
	
	exports['default'] = RaphaelMapLegend;

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview RaphaelCircleLegend is graph renderer for circleLegend.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	/**
	 * @classdesc RaphaelCircleLegend is graph renderer for circleLegend.
	 * @class RaphaelCircleLegend
	 * @private
	 */
	var RaphaelCircleLegend = function () {
	    function RaphaelCircleLegend() {
	        _classCallCheck(this, RaphaelCircleLegend);
	    }
	
	    /**
	     * Render circle and label.
	     * @param {object} paper paper object
	     * @param {{width: number, height: number}} layout - layout of circle legend area
	     * @param {number} maxRadius - pixel type maximum radius
	     * @param {Array.<number>} radiusRatios - radius ratios
	     * @param {Array.<string>} labels - circle legend labels
	     * @returns {Array.<object>}
	     * @private
	     */
	    RaphaelCircleLegend.prototype.render = function render(paper, layout, maxRadius, radiusRatios, labels) {
	        var left = layout.position.left + layout.dimension.width / 2;
	        var circleLegendSet = paper.set();
	
	        radiusRatios.forEach(function (ratio, index) {
	            var radius = maxRadius * ratio;
	            var top = layout.position.top + layout.dimension.height - radius;
	            var circle = _raphaelRenderUtil2['default'].renderCircle(paper, {
	                left: left,
	                top: top
	            }, radius, {
	                fill: 'none',
	                opacity: 1,
	                stroke: '#888',
	                'stroke-width': 1
	            });
	
	            circleLegendSet.push(circle);
	
	            circleLegendSet.push(_raphaelRenderUtil2['default'].renderText(paper, {
	                left: left,
	                top: top - radius - 5
	            }, labels[index]));
	        });
	
	        return circleLegendSet;
	    };
	
	    return RaphaelCircleLegend;
	}();
	
	exports['default'] = RaphaelCircleLegend;

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Raphael title renderer.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var RaphaelTitleComponent = function () {
	    function RaphaelTitleComponent() {
	        _classCallCheck(this, RaphaelTitleComponent);
	    }
	
	    /**
	     * Render title
	     * @param {object} renderInfo infos for render
	     *   @param {object} renderInfo.paper - paper
	     *   @param {string} renderInfo.titleText - title text
	     *   @param {{x: number, y: number}} renderInfo.offset - title offset x, y
	     *   @param {object} renderInfo.theme - theme object
	     *   @param {string} [renderInfo.align] - title align option
	     *   @param {number} renderInfo.chartTitleAreaWidth chart title area width
	     * @returns {Array.<object>} title set
	     */
	    RaphaelTitleComponent.prototype.render = function render(renderInfo) {
	        var paper = renderInfo.paper,
	            titleText = renderInfo.titleText,
	            offset = renderInfo.offset,
	            theme = renderInfo.theme,
	            _renderInfo$align = renderInfo.align,
	            align = _renderInfo$align === undefined ? _const2['default'].TITLE_ALIGN_LEFT : _renderInfo$align,
	            chartTitleAreaWidth = renderInfo.chartTitleAreaWidth;
	        var fontSize = theme.fontSize,
	            fontFamily = theme.fontFamily;
	
	        var titleSize = _raphaelRenderUtil2['default'].getRenderedTextSize(titleText, fontSize, fontFamily);
	        var titleSet = paper.set();
	        var pos = this.getTitlePosition(titleSize, align, chartTitleAreaWidth, offset);
	        var textAnchorAlign = {
	            left: 'start',
	            right: 'end',
	            center: 'middle'
	        };
	
	        titleSet.push(_raphaelRenderUtil2['default'].renderText(paper, pos, titleText, {
	            'font-family': theme.fontFamily,
	            'font-size': theme.fontSize,
	            'font-weight': theme.fontWeight,
	            fill: theme.color,
	            'text-anchor': textAnchorAlign[align]
	        }));
	
	        return titleSet;
	    };
	
	    /**
	     * calculate position of title
	     * @param {{width: number, height: number}} titleSize - size of title
	     * @param {string} [align] - title align option
	     * @param {number} chartWidth chart width
	     * @param {{x: number, y: number}} offset - title offset x, y
	     * @returns {{top: number, left: number}} position of title
	     */
	
	
	    RaphaelTitleComponent.prototype.getTitlePosition = function getTitlePosition(titleSize, align, chartWidth, offset) {
	        var left = void 0;
	
	        if (align === _const2['default'].TITLE_ALIGN_CENTER) {
	            left = chartWidth / 2;
	        } else if (align === _const2['default'].TITLE_ALIGN_RIGHT) {
	            left = chartWidth;
	        } else {
	            left = _const2['default'].CHART_PADDING;
	        }
	
	        var pos = {
	            left: left,
	            top: _const2['default'].CHART_PADDING + titleSize.height / 2 // for renderText's baseline
	        };
	
	        if (offset) {
	            if (offset.x) {
	                pos.left += offset.x;
	            } else if (offset.y) {
	                pos.top += offset.y;
	            }
	        }
	
	        return pos;
	    };
	
	    /**
	     * Resize title component
	     * @param {number} chartWidth chart width
	     * @param {Array.<object>} titleSet title set
	     */
	
	
	    RaphaelTitleComponent.prototype.resize = function resize(chartWidth, titleSet) {
	        titleSet.attr({
	            left: _const2['default'].CHART_PADDING
	        });
	    };
	
	    return RaphaelTitleComponent;
	}();
	
	exports['default'] = RaphaelTitleComponent;

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Raphael title renderer.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var Y_AXIS_TITLE_PADDING = _const2['default'].Y_AXIS_TITLE_PADDING,
	    AXIS_BACKGROUND_RIGHT_PADDING = _const2['default'].AXIS_BACKGROUND_RIGHT_PADDING;
	
	var RaphaelAxisComponent = function () {
	    function RaphaelAxisComponent() {
	        _classCallCheck(this, RaphaelAxisComponent);
	
	        this.ticks = [];
	    }
	
	    /**
	     * Render background with plot background color
	     * @param {object} paper Raphael paper
	     * @param {object} position axis position
	     * @param {object} dimension axis dimension
	     * @param {object} theme chart theme
	     * @returns {Element} - raphael <rect> element
	     * @private
	     */
	
	
	    RaphaelAxisComponent.prototype.renderBackground = function renderBackground(paper, position, dimension, theme) {
	        var background = theme && theme.background || {};
	        var _background$color = background.color,
	            color = _background$color === undefined ? '#fff' : _background$color,
	            _background$opacity = background.opacity,
	            opacity = _background$opacity === undefined ? 1 : _background$opacity;
	
	
	        return _raphaelRenderUtil2['default'].renderRect(paper, {
	            left: 0,
	            top: position.top,
	            width: dimension.width + position.left - AXIS_BACKGROUND_RIGHT_PADDING,
	            height: dimension.height
	        }, {
	            fill: color,
	            opacity: opacity,
	            'stroke-width': 0
	        });
	    };
	
	    /**
	     * Render title
	     * @param {object} paper raphael paper
	     * @param {object} data rendering data
	     * @param {string} data.text text content
	     * @param {object} data.theme theme object
	     * @param {object} data.rotationInfo object
	     * @param {object} data.layout dimension and position
	     */
	
	
	    RaphaelAxisComponent.prototype.renderTitle = function renderTitle(paper, data) {
	        var theme = data.theme,
	            rotationInfo = data.rotationInfo;
	        var fontFamily = theme.fontFamily,
	            fontSize = theme.fontSize,
	            fontWeight = theme.fontWeight,
	            color = theme.color;
	
	        var textAnchor = this.getRenderTitleAnchor(rotationInfo);
	        var attributes = {
	            'dominant-baseline': 'auto',
	            'font-family': fontFamily,
	            'font-size': fontSize,
	            'font-weight': fontWeight,
	            fill: color,
	            transform: 'none',
	            'text-anchor': textAnchor
	        };
	        var position = this.calculatePosition(paper, data);
	        var title = _raphaelRenderUtil2['default'].renderText(paper, position, data.text, attributes);
	
	        title.node.style.userSelect = 'none';
	        title.node.style.cursor = 'default';
	
	        data.set.push(title);
	    };
	
	    /**
	     * Get title anchor
	     * @param {object} rotationInfo - isCenter, isVertical, isPositionRight
	     * @returns {string} textAnchor - middle or end or start
	     */
	
	
	    RaphaelAxisComponent.prototype.getRenderTitleAnchor = function getRenderTitleAnchor(rotationInfo) {
	        var textAnchor = 'middle';
	        if (rotationInfo.isPositionRight) {
	            textAnchor = 'end';
	        } else if (rotationInfo.isVertical && !rotationInfo.isCenter) {
	            textAnchor = 'start';
	        }
	
	        return textAnchor;
	    };
	
	    /**
	     * Render Axis label
	     * @param {object} data data for render label
	     *       @param {{
	     *           left: number,
	     *           top: number
	     *       }} data.positionTopAndLeft left, top positions
	     *       @param {string} data.labelText label text
	     *       @param {number} data.labelSize label size
	     *       @param {object} data.paper raphael paper
	     *       @param {boolean} data.isVertical boolean value of axis is vertical
	     *       @param {boolean} data.isPositionRight boolean value of axis is right yAxis
	     *       @param {object} data.theme theme of label
	     */
	
	
	    RaphaelAxisComponent.prototype.renderLabel = function renderLabel(data) {
	        var positionTopAndLeft = data.positionTopAndLeft,
	            labelText = data.labelText,
	            paper = data.paper,
	            theme = data.theme,
	            isVertical = data.isVertical,
	            isCenter = data.isCenter;
	
	        var attributes = {
	            'dominant-baseline': 'central',
	            'font-family': theme.fontFamily,
	            'font-size': theme.fontSize,
	            'font-weight': theme.fontWeight,
	            fill: theme.color
	        };
	
	        if (data.isPositionRight) {
	            attributes['text-anchor'] = 'end';
	        } else if (isVertical && !isCenter) {
	            attributes['text-anchor'] = 'start';
	        } else {
	            attributes['text-anchor'] = 'middle';
	        }
	
	        var textObj = _raphaelRenderUtil2['default'].renderText(paper, positionTopAndLeft, labelText, attributes);
	
	        textObj.node.style.userSelect = 'none';
	        textObj.node.style.cursor = 'default';
	
	        data.set.push(textObj);
	        this.ticks.push(textObj);
	    };
	
	    /**
	     * Render rotated Axis label
	     * @param {object} data data for render rotated label
	     *       @param {{
	     *           left: number,
	     *           top: number
	     *       }} data.positionTopAndLeft left, top positions
	     *       @param {string} data.labelText label text
	     *       @param {object} data.paper raphael paper
	     *       @param {boolean} data.isVertical boolean value of axis is vertical
	     *       @param {object} data.theme theme of label
	     *       @param {number} data.degree rotation degree
	     */
	
	
	    RaphaelAxisComponent.prototype.renderRotatedLabel = function renderRotatedLabel(data) {
	        var positionTopAndLeft = data.positionTopAndLeft,
	            labelText = data.labelText,
	            paper = data.paper,
	            theme = data.theme;
	
	        var textObj = _raphaelRenderUtil2['default'].renderText(paper, positionTopAndLeft, labelText, {
	            'dominant-baseline': 'central',
	            'font-family': theme.fontFamily,
	            'font-size': theme.fontSize,
	            'font-weight': theme.fontWeight,
	            fill: theme.color,
	            'text-anchor': 'end',
	            transform: 'r' + -data.degree + ',' + positionTopAndLeft.left + ',' + positionTopAndLeft.top
	        });
	
	        textObj.node.style.userSelect = 'none';
	        textObj.node.style.cursor = 'arrow';
	
	        data.set.push(textObj);
	        this.ticks.push(textObj);
	    };
	
	    /**
	     * Render ticks on given paper
	     * @param {object} data data for rendering ticks
	     */
	
	
	    RaphaelAxisComponent.prototype.renderTicks = function renderTicks(data) {
	        var _this = this;
	
	        var paper = data.paper,
	            positions = data.positions,
	            additionalSize = data.additionalSize,
	            isVertical = data.isVertical,
	            isCenter = data.isCenter,
	            isDivided = data.isDivided,
	            isPositionRight = data.isPositionRight,
	            tickColor = data.tickColor,
	            layout = data.layout;
	
	
	        var rightEdgeOfAxis = layout.position.left + layout.dimension.width;
	        var baseTop = layout.position.top;
	        var baseLeft = layout.position.left;
	        var centerAxisWidth = isDivided ? data.otherSideDimension.width : 0;
	        var isContainDivensionArea = function isContainDivensionArea(position) {
	            var compareType = isVertical ? 'height' : 'width';
	
	            return position > layout.dimension[compareType] + centerAxisWidth;
	        };
	        var tick = void 0;
	
	        positions.forEach(function (position) {
	            var pathString = 'M';
	
	            position += additionalSize;
	
	            if (isContainDivensionArea(position)) {
	                return;
	            }
	
	            if (isVertical) {
	                if (isCenter) {
	                    pathString += baseLeft + ',' + (baseTop + position);
	                    pathString += 'H' + (baseLeft + 5);
	
	                    pathString += 'M' + rightEdgeOfAxis + ',' + (baseTop + position);
	                    pathString += 'H' + (rightEdgeOfAxis - 5);
	                } else if (isPositionRight) {
	                    pathString += baseLeft + ',' + (baseTop + position);
	                    pathString += 'H' + (baseLeft + 5);
	                } else {
	                    pathString += rightEdgeOfAxis + ',' + (baseTop + position);
	                    pathString += 'H' + (rightEdgeOfAxis - 5);
	                }
	            } else {
	                pathString += baseLeft + position + ',' + baseTop;
	                pathString += 'V' + (baseTop + 5);
	            }
	
	            if (!isNaN(position)) {
	                tick = paper.path(pathString).attr({
	                    stroke: tickColor,
	                    opacity: 0.5
	                });
	                data.set.push(tick);
	                _this.ticks.push(tick);
	            }
	        });
	    };
	
	    /**
	     * Render tick line  on given paper
	     * @param {number} data data for render tick line
	     * @param {number} data.areaSize area size width or height
	     * @param {object} data.paper raphael paper
	     * @param {boolean} data.isVertical boolean value of vertical axis or not
	     */
	
	
	    RaphaelAxisComponent.prototype.renderStandardLine = function renderStandardLine(data) {
	        var lineSize = data.areaSize,
	            _data$layout = data.layout,
	            position = _data$layout.position,
	            dimension = _data$layout.dimension,
	            paper = data.paper,
	            isVertical = data.isVertical;
	
	        var baseLeft = position.left;
	        var minAbs = Math.abs(data.axisLimit.min);
	        var maxAbs = Math.abs(data.axisLimit.max);
	        var standardRatio = 1 - maxAbs / (minAbs + maxAbs);
	        var pathString = 'M';
	        var baseTop = position.top;
	        var rightEdgeOfAxis = baseLeft + dimension.width;
	
	        if (isVertical) {
	            var lineStartYCoord = baseTop;
	            rightEdgeOfAxis += data.seriesDimension.width * standardRatio;
	            pathString += rightEdgeOfAxis + ',' + lineStartYCoord;
	            var lineEndYCoord = baseTop + lineSize;
	            pathString += 'V' + lineEndYCoord;
	        } else {
	            pathString += baseLeft;
	            baseTop -= data.seriesDimension.height * standardRatio;
	            pathString += ',' + baseTop + 'H';
	            var lineEndXCoord = baseLeft + lineSize;
	            pathString += lineEndXCoord;
	        }
	
	        data.set.push(paper.path(pathString).attr({
	            'stroke-width': 1,
	            opacity: 0.5
	        }));
	    };
	
	    /**
	     * Render tick line  on given paper
	     * @param {number} data data for render tick line
	     * @param {number} data.areaSize area size width or height
	     * @param {object} data.paper raphael paper
	     * @param {boolean} data.isNotDividedXAxis boolean value for XAxis divided or not
	     * @param {number} data.additionalSize additional size for position and line length
	     * @param {number} data.additionalWidth additional width of tick line paper
	     * @param {number} data.additionalHeight additional height of tick line paper
	     * @param {boolean} data.isPositionRight boolean value of right yAxis or not
	     * @param {boolean} data.isCenter boolean value of center yAxis or not
	     * @param {boolean} data.isVertical boolean value of vertical axis or not
	     */
	
	
	    RaphaelAxisComponent.prototype.renderTickLine = function renderTickLine(data) {
	        var areaSize = data.areaSize,
	            paper = data.paper,
	            _data$layout2 = data.layout,
	            _data$layout2$positio = _data$layout2.position,
	            baseTop = _data$layout2$positio.top,
	            baseLeft = _data$layout2$positio.left,
	            dimension = _data$layout2.dimension,
	            isNegativeStandard = data.isNegativeStandard,
	            isNotDividedXAxis = data.isNotDividedXAxis,
	            additionalSize = data.additionalSize,
	            isPositionRight = data.isPositionRight,
	            isCenter = data.isCenter,
	            isVertical = data.isVertical,
	            tickColor = data.tickColor,
	            seriesDimension = data.seriesDimension;
	
	        var lineSize = areaSize;
	        var verticalTickLineEndYCoord = dimension.height + baseTop;
	        var rightEdgeOfAxis = baseLeft + dimension.width;
	        var pathString = 'M';
	        var lineStartYCoord = void 0,
	            lineEndYCoord = void 0;
	
	        if (isPositionRight) {
	            pathString += baseLeft + ',' + baseTop;
	            pathString += 'V' + verticalTickLineEndYCoord;
	        } else if (isVertical) {
	            lineStartYCoord = baseTop;
	            if (isNegativeStandard) {
	                rightEdgeOfAxis += seriesDimension.width / 2;
	            }
	            pathString += rightEdgeOfAxis + ',' + lineStartYCoord;
	
	            if (isCenter) {
	                pathString += 'V' + verticalTickLineEndYCoord;
	                pathString += 'M' + baseLeft + ',' + lineStartYCoord;
	                pathString += 'V' + verticalTickLineEndYCoord;
	            } else {
	                lineEndYCoord = baseTop + lineSize;
	                pathString += 'V' + lineEndYCoord;
	            }
	        } else {
	            pathString = this._makeNormalTickPath(pathString, {
	                isNotDividedXAxis: isNotDividedXAxis,
	                baseTop: baseTop,
	                baseLeft: baseLeft,
	                additionalSize: additionalSize,
	                isNegativeStandard: isNegativeStandard,
	                seriesDimension: seriesDimension,
	                lineSize: lineSize
	            });
	        }
	
	        data.set.push(paper.path(pathString).attr({
	            'stroke-width': 1,
	            stroke: tickColor,
	            opacity: 0.5
	        }));
	    };
	
	    /**
	     * Render tick line  on given paper
	     * @param {string} pathString render path string
	     * @param {object} pathInfo render path infos
	     *   @param {boolean} pathInfo.isNotDividedXAxis boolean value for XAxis divided or not
	     *   @param {number} pathInfo.baseTop baseTop
	     *   @param {number} pathInfo.baseLeft baseLeft
	     *   @param {number} pathInfo.additionalSize additional size for position and line length
	     *   @param {boolean} bpathInfo.isNegativeStandard boolean value for XAxis divided or not
	     *   @param {object} pathInfo.seriesDimension seriesDemension
	     *   @param {number} pathInfo.lineSize tick line size
	     *   @returns {string} pathString
	     * @private
	     */
	
	
	    RaphaelAxisComponent.prototype._makeNormalTickPath = function _makeNormalTickPath(pathString, pathInfo) {
	        if (pathInfo.isNotDividedXAxis) {
	            pathString += pathInfo.baseLeft;
	        } else {
	            pathString += pathInfo.baseLeft + pathInfo.additionalSize;
	        }
	
	        if (pathInfo.isNegativeStandard) {
	            pathInfo.baseTop -= pathInfo.seriesDimension.height / 2;
	        }
	
	        pathString += ',' + pathInfo.baseTop + 'H';
	
	        var lineEndXCoord = pathInfo.baseLeft + pathInfo.lineSize;
	
	        if (!pathInfo.isNotDividedXAxis) {
	            lineEndXCoord += pathInfo.additionalSize;
	        }
	
	        pathString += lineEndXCoord;
	
	        return pathString;
	    };
	
	    /**
	     * Animate ticks for adding data
	     * @param {number} tickSize tick size of moving
	     */
	
	
	    RaphaelAxisComponent.prototype.animateForAddingData = function animateForAddingData(tickSize) {
	        this.ticks.forEach(function (tick) {
	            tick.animate({
	                transform: 't-' + tickSize + ',0'
	            }, 300);
	        });
	    };
	
	    /**
	     * Calculate axis title position, and transforma
	     * @param {Raphael.paper} paper - paper
	     * @param {object} data - options for calcultating title position
	     *  @param {object} data.rotationInfo - isCenter, isVertical, isPositionRight
	     *  @param {object} data.text - text
	     *  @param {object} data.theme - theme
	     *  @param {object} data.layout - layout
	     * @returns {object} position - top, left
	     */
	
	
	    RaphaelAxisComponent.prototype.calculatePosition = function calculatePosition(paper, data) {
	        var rotationInfo = data.rotationInfo,
	            text = data.text,
	            theme = data.theme,
	            additionalWidth = data.additionalWidth,
	            otherSideDimension = data.otherSideDimension,
	            areaSize = data.areaSize,
	            tickCount = data.tickCount,
	            layout = data.layout;
	
	        var textHeight = getTextHeight(text, theme);
	        var textWidth = getTextWidth(text, theme);
	        var axisHeight = layout.dimension.height;
	        var axisWidth = layout.dimension.width;
	        var top = layout.position.top;
	
	        var left = layout.position.left + additionalWidth;
	        var adjustLeftPosition = textWidth / 2 - otherSideDimension.width;
	        var position = {
	            top: top + axisHeight - textHeight / 2,
	            left: left + (adjustLeftPosition < 0 ? 0 : adjustLeftPosition)
	        };
	
	        if (rotationInfo.isVertical) {
	            if (rotationInfo.isCenter) {
	                position.top += textHeight / 2;
	                position.left = left + axisWidth / 2;
	            } else if (!rotationInfo.isDiverging) {
	                position.top = top - textHeight / 2 - Y_AXIS_TITLE_PADDING;
	            }
	        } else if (!rotationInfo.isVertical) {
	            if (rotationInfo.isDiverging && rotationInfo.isYAxisCenter) {
	                position.left = left + areaSize / 2;
	            } else if (rotationInfo.isDiverging && !rotationInfo.isYAxisCenter) {
	                position.left = left + axisWidth / 2;
	            } else if (rotationInfo.isColumnType) {
	                position.left = left + axisWidth / (tickCount - 1) / 2;
	            }
	        }
	
	        if (rotationInfo.isPositionRight) {
	            position.left += axisWidth;
	        }
	
	        if (!rotationInfo.isCenter) {
	            addOffset(position, data.offset);
	        }
	
	        return position;
	    };
	
	    return RaphaelAxisComponent;
	}();
	
	/**
	 * Get a text height by theme
	 * @param {string} text - text
	 * @param {object} theme - axis theme
	 * @returns {number} text height
	 * @ignore
	 */
	
	
	function getTextHeight(text, theme) {
	    var titleSize = _raphaelRenderUtil2['default'].getRenderedTextSize(text, theme.fontSize, theme.fontFamily);
	
	    return titleSize.height;
	}
	
	/**
	 * Get a text width by theme
	 * @param {string} text - text
	 * @param {object} theme - axis theme
	 * @returns {number} text width
	 * @ignore
	 */
	function getTextWidth(text, theme) {
	    var titleSize = _raphaelRenderUtil2['default'].getRenderedTextSize(text, theme.fontSize, theme.fontFamily);
	
	    return titleSize.width;
	}
	
	/**
	 * Add offset to position
	 * @param {object} position - top, left
	 * @param {object} offset - x, y
	 * @ignore
	 */
	function addOffset(position, offset) {
	    if (!offset) {
	        return;
	    }
	
	    if (offset.x) {
	        position.left += offset.x;
	    }
	    if (offset.y) {
	        position.top += offset.y;
	    }
	}
	
	exports['default'] = RaphaelAxisComponent;

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview RaphaelRadialPlot is graph renderer for radial plot.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var STEP_TOP_ADJUSTMENT = 8;
	var STEP_LEFT_ADJUSTMENT = 3;
	
	/**
	 * @classdesc RaphaelRadialPlot is graph renderer for radial plot.
	 * @class RaphaelRadialPlot
	 * @private
	 */
	
	var RaphaelRadialPlot = function () {
	    function RaphaelRadialPlot() {
	        _classCallCheck(this, RaphaelRadialPlot);
	    }
	
	    /**
	     * Render function of map chart legend.
	     * @param {object} params parameters
	     * @param {HTMLElement} params.container container
	     * @param {{width: number, height: number}} params.dimension - dimension of circle legend area
	     * @param {Array<Array>} params.plotPositions plot positions
	     * @param {object} params.labelData label data
	     * @returns {object} paper raphael paper
	     */
	    RaphaelRadialPlot.prototype.render = function render(params) {
	        var plotSet = params.paper.set();
	
	        this.paper = params.paper;
	        this.layout = params.layout;
	        this.plotPositions = params.plotPositions;
	        this.theme = params.theme;
	        this.options = params.options;
	        this.labelData = params.labelData;
	
	        this._renderPlot(plotSet);
	        this._renderLabels(plotSet);
	
	        plotSet.toBack();
	        this.paper.pushDownBackgroundToBottom();
	
	        return plotSet;
	    };
	
	    /**
	     * Render plot component
	     * @param {Array.<object>} plotSet plot set
	     * @private
	     */
	
	
	    RaphaelRadialPlot.prototype._renderPlot = function _renderPlot(plotSet) {
	        if (this.options.type === 'circle') {
	            this._renderCirclePlot(plotSet);
	        } else {
	            this._renderSpiderwebPlot(plotSet);
	        }
	
	        this._renderCategoryDots(plotSet);
	    };
	
	    /**
	     * Render spider web plot
	     * @param {Array.<object>} plotSet plot set
	     * @private
	     */
	
	
	    RaphaelRadialPlot.prototype._renderSpiderwebPlot = function _renderSpiderwebPlot(plotSet) {
	        var groupPaths = this._getLinesPath(this.plotPositions);
	
	        this._renderLines(groupPaths, this.theme.lineColor, plotSet);
	    };
	
	    /**
	     * Render circle plot
	     * @param {Array.<object>} plotSet plot set
	     * @private
	     */
	
	
	    RaphaelRadialPlot.prototype._renderCirclePlot = function _renderCirclePlot(plotSet) {
	        var plotPositions = this.plotPositions;
	
	        var _plotPositions = _slicedToArray(plotPositions, 1),
	            _plotPositions$ = _slicedToArray(_plotPositions[0], 1),
	            centerPoint = _plotPositions$[0];
	
	        var strokeColor = this.theme.lineColor;
	
	        for (var i = 1; i < plotPositions.length; i += 1) {
	            var _plotPositions$i = _slicedToArray(plotPositions[i], 1),
	                pos = _plotPositions$i[0];
	
	            var radius = centerPoint.top - pos.top;
	
	            plotSet.push(_raphaelRenderUtil2['default'].renderCircle(this.paper, centerPoint, radius, {
	                stroke: strokeColor,
	                'stroke-opacity': 0.05
	            }));
	        }
	    };
	
	    /**
	     * Render category lines
	     * @param {Array.<object>} plotSet plot set
	     * @private
	     */
	
	
	    RaphaelRadialPlot.prototype._renderCategoryDots = function _renderCategoryDots(plotSet) {
	        var _this = this;
	
	        var bounds = this._makePlotDotBounds(_arrayUtil2['default'].pivot(this.plotPositions));
	        bounds.forEach(function (bound) {
	            var squareDot = _raphaelRenderUtil2['default'].renderRect(_this.paper, bound, {
	                fill: '#000000',
	                'fill-opacity': 0.5,
	                'stroke-width': 0
	            });
	            plotSet.push(squareDot);
	        }, this);
	    };
	
	    RaphaelRadialPlot.prototype._makePlotDotBounds = function _makePlotDotBounds(plotPositions) {
	        var bounds = plotPositions.map(function (positions) {
	            var outMostPlot = positions[positions.length - 1];
	            var bound = {
	                top: outMostPlot.top - 2,
	                left: outMostPlot.left - 2,
	                width: 4,
	                height: 4
	            };
	
	            return bound;
	        });
	        bounds.pop();
	
	        return bounds;
	    };
	
	    /**
	     * Render labels
	     * @param {Array.<object>} plotSet plot set
	     * @private
	     */
	
	
	    RaphaelRadialPlot.prototype._renderLabels = function _renderLabels(plotSet) {
	        var paper = this.paper,
	            theme = this.theme,
	            labelData = this.labelData;
	
	        var attributes = {
	            fill: theme.lineColor,
	            'font-size': theme.label.fontSize,
	            'font-family': theme.label.fontFamily,
	            'text-anchor': 'end',
	            'font-weight': '100',
	            'dominant-baseline': 'middle'
	        };
	
	        labelData.category.forEach(function (item) {
	            var categoryAttributes = Object.assign({}, attributes, {
	                'text-anchor': item.position.anchor,
	                fill: '#333333'
	            });
	            var label = _raphaelRenderUtil2['default'].renderText(paper, item.position, item.text, categoryAttributes);
	
	            label.node.style.userSelect = 'none';
	            label.node.style.cursor = 'default';
	
	            plotSet.push(label);
	        });
	
	        labelData.step.forEach(function (item) {
	            var stepLabel = _raphaelRenderUtil2['default'].renderText(paper, item.position, item.text, attributes);
	
	            item.position.top -= STEP_TOP_ADJUSTMENT;
	            item.position.left -= STEP_LEFT_ADJUSTMENT;
	
	            stepLabel.node.style.userSelect = 'none';
	            stepLabel.node.style.cursor = 'default';
	
	            plotSet.push(stepLabel);
	        });
	    };
	
	    /**
	     * Render lines.
	     * @param {Array.<Array.<string>>} groupPaths paths
	     * @param {string} lineColor line color
	     * @param {Array.<object>} plotSet plot set
	     * @returns {Array.<Array.<object>>} lines
	     * @private
	     */
	
	
	    RaphaelRadialPlot.prototype._renderLines = function _renderLines(groupPaths, lineColor, plotSet) {
	        var paper = this.paper;
	
	
	        return groupPaths.map(function (path) {
	            var line = _raphaelRenderUtil2['default'].renderLine(paper, path.join(' '), lineColor, 1);
	            line.node.setAttribute('stroke-opacity', 0.05);
	
	            plotSet.push(line);
	
	            return line;
	        });
	    };
	
	    /**
	     * Get lines path.
	     * /todo remove duplication, copied from raphaelLineTypeBase
	     * @param {Array.<Array.<{left: number, top: number, startTop: number}>>} groupPositions positions
	     * @returns {Array.<Array.<string>>} path
	     * @private
	     */
	
	
	    RaphaelRadialPlot.prototype._getLinesPath = function _getLinesPath(groupPositions) {
	        var _this2 = this;
	
	        return groupPositions.map(function (positions) {
	            return _this2._makeLinesPath(positions);
	        });
	    };
	
	    /**
	     * Make lines path.
	     * /todo remove duplication, copied from raphaelLineTypeBase
	     * @param {Array.<{left: number, top: number, startTop: number}>} positions positions
	     * @param {?string} [posTopType='top'] position top type
	     * @param {boolean} [connectNulls] - boolean value connect nulls or not
	     * @returns {Array.<string | number>} paths
	     * @private
	     */
	
	
	    RaphaelRadialPlot.prototype._makeLinesPath = function _makeLinesPath(positions, posTopType, connectNulls) {
	        var path = [];
	        var prevMissing = false;
	
	        posTopType = posTopType || 'top';
	
	        positions.forEach(function (position) {
	            var pathCommand = prevMissing && !connectNulls ? 'M' : 'L';
	
	            if (position) {
	                path.push([pathCommand, position.left, position[posTopType]]);
	                if (prevMissing) {
	                    prevMissing = false;
	                }
	            } else {
	                prevMissing = true;
	            }
	        });
	
	        path = Array.prototype.concat.apply([], path);
	        path[0] = 'M';
	
	        return path;
	    };
	
	    return RaphaelRadialPlot;
	}();
	
	exports['default'] = RaphaelRadialPlot;

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _chartFactory = __webpack_require__(358);
	
	var _chartFactory2 = _interopRequireDefault(_chartFactory);
	
	var _pluginFactory = __webpack_require__(360);
	
	var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
	
	var _themeManager = __webpack_require__(361);
	
	var _themeManager2 = _interopRequireDefault(_themeManager);
	
	var _mapManager = __webpack_require__(363);
	
	var _mapManager2 = _interopRequireDefault(_mapManager);
	
	var _objectUtil = __webpack_require__(364);
	
	var _objectUtil2 = _interopRequireDefault(_objectUtil);
	
	var _seriesDataImporter = __webpack_require__(365);
	
	var _seriesDataImporter2 = _interopRequireDefault(_seriesDataImporter);
	
	var _drawingToolPicker = __webpack_require__(366);
	
	var _drawingToolPicker2 = _interopRequireDefault(_drawingToolPicker);
	
	__webpack_require__(367);
	
	__webpack_require__(368);
	
	__webpack_require__(473);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Raw series datum.
	 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
	 * @private
	 */
	
	/**
	 * Raw series data.
	 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
	 * @private
	 */
	
	/**
	 * Raw data.
	 * @typedef {{
	 *      categories: ?Array.<string>,
	 *      series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})
	 * }} rawData
	 * @private
	 */
	
	/**
	 * Create chart.
	 * @param {HTMLElement} container container
	 * @param {({
	 *        series: (object|Array),
	 *        categories: Array
	 *   }|{
	 *        table: ({
	 *          elementId: string
	 *        }|{
	 *          element: HTMLElement
	 *        })
	 *   })} rawData - raw data object or data container table element or table's id
	 * @param {{
	 *   chart: {
	 *     width: number,
	 *     height: number,
	 *     title: string,
	 *     format: string
	 *   },
	 *   yAxis: {
	 *     title: string,
	 *     min: number
	 *   },
	 *   xAxis: {
	 *     title: string,
	 *     min: number
	 *   },
	 *   tooltip: {
	 *     suffix: string,
	 *     template: function
	 *   },
	 *   theme: string
	 * }} options - chart options
	 * @param {string} chartType - chart type
	 * @returns {object} chart instance.
	 * @private
	 * @ignore
	 */
	function _createChart(container) {
	  var rawData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var options = arguments[2];
	  var chartType = arguments[3];
	
	  if (rawData.table) {
	    rawData = _seriesDataImporter2['default'].makeDataWithTable(rawData.table);
	  }
	
	  if (!rawData.series) {
	    rawData.series = [];
	  }
	
	  rawData = _objectUtil2['default'].deepCopy(rawData);
	
	  if (chartType !== 'combo') {
	    var temp = rawData.series;
	    rawData.series = {};
	    rawData.series[chartType] = temp;
	  }
	
	  options = options ? _objectUtil2['default'].deepCopy(options) : {};
	  options.chartType = chartType;
	  options.theme = options.theme || _const2['default'].DEFAULT_THEME_NAME;
	
	  var isColorByPoint = options.series && options.series.colorByPoint;
	  var theme = _themeManager2['default'].get(options.theme, chartType, rawData.series, isColorByPoint);
	  var chart = _chartFactory2['default'].get(options.chartType, rawData, theme, options);
	
	  chart.render(container);
	  chart.animateChart();
	
	  return chart;
	}
	
	/**
	 * Bar chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {Array.<string>} rawData.categories - categories
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object|Array} options.yAxis - options for y axis component
	 *          @param {string | object} options.yAxis.title - title text or title object
	 *              @param {string} options.yAxis.title.text - title text
	 *              @param {number} options.yAxis.title.offsetX - title offset x
	 *              @param {number} options.yAxis.title.offsetY - title offset y
	 *          @param {number} options.yAxis.labelMargin - label margin for y axis
	 *          @param {string} options.yAxis.align - align option for center y axis
	 *          @param {string} options.yAxis.type - type of axis
	 *          @param {string} options.yAxis.dateFormat - date format
	 *          @param {string} options.yAxis.prefix - prefix for yAxis
	 *          @param {string} options.yAxis.suffix - suffix for yAxis
	 *      @param {object} options.xAxis - options for x axis component
	 *          @param {string | object} options.xAxis.title - title text or title object
	 *              @param {string} options.xAxis.title.text - title text
	 *              @param {number} options.xAxis.title.offsetX - title offset x
	 *              @param {number} options.xAxis.title.offsetY - title offset y
	 *          @param {number} options.xAxis.labelMargin - label margin for x axis
	 *          @param {number} options.xAxis.min - minimum value for x axis
	 *          @param {number} options.xAxis.max - maximum value for x axis
	 *          @param {number} options.xAxis.pointOnColumn - Place the label between the ticks.
	 *          @param {string} options.xAxis.prefix - prefix for xAxis
	 *          @param {string} options.xAxis.suffix - suffix for xAxis
	 *      @param {object} options.series - options for series component
	 *          @param {string} options.series.stackType - type of stack
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *          @param {number} options.series.barWidth - bar width
	 *          @param {boolean} options.series.allowSelect - whether allow select or not
	 *          @param {boolean} options.series.diverging - whether diverging or not
	 *          @param {boolean} options.series.colorByPoint - whether category Individual colors
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
	 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {object} options.plot - options for plot component
	 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} bar chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       categories: ['cate1', 'cate2', 'cate3'],
	 *       series: [
	 *         {
	 *           name: 'Legend1',
	 *           data: [20, 30, 50]
	 *         },
	 *         {
	 *           name: 'Legend2',
	 *           data: [40, 40, 60]
	 *         },
	 *         {
	 *           name: 'Legend3',
	 *           data: [60, 50, 10]
	 *         },
	 *         {
	 *           name: 'Legend4',
	 *           data: [80, 10, 70]
	 *         }
	 *       ]
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Bar Chart'
	 *       },
	 *       yAxis: {
	 *         title: 'Y Axis'
	 *       },
	 *       xAxis: {
	 *         title: 'X Axis'
	 *       }
	 *     };
	 * chart.barChart(container, rawData, options);
	 */
	/**
	 * @fileoverview chart.js is entry point of Toast UI Chart.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	function barChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_BAR);
	}
	
	/**
	 * Column chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {Array.<string>} rawData.categories - categories
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object} options.yAxis - options for y axis component
	 *          @param {string | object} options.yAxis.title - title text or title object
	 *              @param {string} options.yAxis.title.text - title text
	 *              @param {number} options.yAxis.title.offsetX - title offset x
	 *              @param {number} options.yAxis.title.offsetY - title offset y
	 *          @param {number} options.yAxis.labelMargin - label margin for y axis
	 *          @param {number} options.yAxis.min - minimum value for y axis
	 *          @param {number} options.yAxis.max - maximum value for y axis
	 *          @param {string} options.yAxis.prefix - prefix for yAxis
	 *          @param {string} options.yAxis.suffix - suffix for yAxis
	 *      @param {object} options.xAxis - options for x axis component
	 *          @param {string | object} options.xAxis.title - title text or title object
	 *              @param {string} options.xAxis.title.text - title text
	 *              @param {number} options.xAxis.title.offsetX - title offset x
	 *              @param {number} options.xAxis.title.offsetY - title offset y
	 *          @param {number} options.xAxis.labelMargin - label margin for x axis
	 *          @param {number} options.xAxis.labelInterval - label interval for x axis
	 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
	 *          @param {string} options.xAxis.type - type of axis
	 *          @param {string} options.xAxis.dateFormat - date format
	 *          @param {string} options.xAxis.prefix - prefix for xAxis
	 *          @param {string} options.xAxis.suffix - suffix for xAxis
	 *      @param {object} options.series - options for series component
	 *          @param {string} options.series.stackType - type of stack
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *          @param {number} options.series.barWidth - bar width
	 *          @param {boolean} options.series.allowSelect - whether allow select or not
	 *          @param {boolean} options.series.diverging - whether diverging or not
	 *          @param {boolean} options.series.colorByPoint - whether category Individual colors
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
	 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {object} options.plot - options for plot component
	 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} column chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       categories: ['cate1', 'cate2', 'cate3'],
	 *       series: [
	 *         {
	 *           name: 'Legend1',
	 *           data: [20, 30, 50]
	 *         },
	 *         {
	 *           name: 'Legend2',
	 *           data: [40, 40, 60]
	 *         },
	 *         {
	 *           name: 'Legend3',
	 *           data: [60, 50, 10]
	 *         },
	 *         {
	 *           name: 'Legend4',
	 *           data: [80, 10, 70]
	 *         }
	 *       ]
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Column Chart'
	 *       },
	 *       yAxis: {
	 *         title: 'Y Axis'
	 *       },
	 *       xAxis: {
	 *         title: 'X Axis'
	 *       }
	 *     };
	 * chart.columnChart(container, rawData, options);
	 */
	function columnChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_COLUMN);
	}
	
	/**
	 * Line chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {?Array.<string>} rawData.categories - categories
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object|Array} options.yAxis - options for y axis component
	 *          @param {string | object} options.yAxis.title - title text or title object
	 *              @param {string} options.yAxis.title.text - title text
	 *              @param {number} options.yAxis.title.offsetX - title offset x
	 *              @param {number} options.yAxis.title.offsetY - title offset y
	 *          @param {number} options.yAxis.labelMargin - label margin for y axis
	 *          @param {number} options.yAxis.min - minimum value for y axis
	 *          @param {number} options.yAxis.max - maximum value for y axis
	 *          @param {string} options.yAxis.prefix - prefix for yAxis
	 *          @param {string} options.yAxis.suffix - suffix for yAxis
	 *      @param {object} options.xAxis - options for x axis component
	 *          @param {string | object} options.xAxis.title - title text or title object
	 *              @param {string} options.xAxis.title.text - title text
	 *              @param {number} options.xAxis.title.offsetX - title offset x
	 *              @param {number} options.xAxis.title.offsetY - title offset y
	 *          @param {number} options.xAxis.labelMargin - label margin for x axis
	 *          @param {number} options.xAxis.labelInterval - label interval for x axis
	 *          @param {string} options.xAxis.tickInterval - tick interval for x axis
	 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
	 *          @param {string} options.xAxis.type - type of axis
	 *          @param {string} options.xAxis.dateFormat - date format
	 *          @param {string} options.xAxis.prefix - prefix for xAxis
	 *          @param {string} options.xAxis.suffix - suffix for xAxis
	 *      @param {object} options.series - options for series component
	 *          @param {boolean} options.series.showDot - whether show dot or not
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *          @param {boolean} options.series.allowSelect - whether allow select or not
	 *          @param {boolean} options.series.spline - whether spline or not
	 *          @param {boolean} options.series.zoomable - whether zoomable or not
	 *          @param {boolean} options.series.shifting - whether shifting or not
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
	 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {object} options.plot - options for plot component
	 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
	 *          @param {Array} options.plot.bands - plot bands
	 *              @param {Array.<string|number|date>} options.plot.bands.range - value range for matching
	 *              @param {string} options.plot.bands.color - band color
	 *              @param {number} options.plot.bands.opacity - band opacity
	 *              @param {boolean} options.plot.mergeOverlappingRanges - whether show overlapping ranges
	 *          @param {Array} options.plot.lines - plot lines
	 *              @param {(string|number|date)} options.plot.lines.value - value for matching
	 *              @param {string} options.plot.lines.color - band color
	 *              @param {number} options.plot.lines.opacity - band opacity
	 *          @param {Array.<{value: (string|number|date), color: ?string, opacity: ?string}>} options.plot.lines
	 *                  - plot lines
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} line chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       categories: ['cate1', 'cate2', 'cate3'],
	 *       series: [
	 *         {
	 *           name: 'Legend1',
	 *           data: [20, 30, 50]
	 *         },
	 *         {
	 *           name: 'Legend2',
	 *           data: [40, 40, 60]
	 *         },
	 *         {
	 *           name: 'Legend3',
	 *           data: [60, 50, 10]
	 *         },
	 *         {
	 *           name: 'Legend4',
	 *           data: [80, 10, 70]
	 *         }
	 *       ]
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Line Chart'
	 *       },
	 *       yAxis: {
	 *         title: 'Y Axis'
	 *       },
	 *       xAxis: {
	 *         title: 'X Axis'
	 *       },
	 *       series: {
	 *         showDot: true
	 *       }
	 *     };
	 * chart.lineChart(container, rawData, options);
	 */
	function lineChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_LINE);
	}
	
	/**
	 * Area chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {?Array.<string>} rawData.categories - categories
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object} options.yAxis - options for y axis component
	 *          @param {string | object} options.yAxis.title - title text or title object
	 *              @param {string} options.yAxis.title.text - title text
	 *              @param {number} options.yAxis.title.offsetX - title offset x
	 *              @param {number} options.yAxis.title.offsetY - title offset y
	 *          @param {number} options.yAxis.labelMargin - label margin for y axis
	 *          @param {number} options.yAxis.min - minimum value for y axis
	 *          @param {number} options.yAxis.max - maximum value for y axis
	 *          @param {string} options.yAxis.prefix - prefix for yAxis
	 *          @param {string} options.yAxis.suffix - suffix for yAxis
	 *      @param {object} options.xAxis - options for x axis component
	 *          @param {string | object} options.xAxis.title - title text or title object
	 *              @param {string} options.xAxis.title.text - title text
	 *              @param {number} options.xAxis.title.offsetX - title offset x
	 *              @param {number} options.xAxis.title.offsetY - title offset y
	 *          @param {number} options.xAxis.labelMargin - label margin for x axis
	 *          @param {number} options.xAxis.labelInterval - label interval for x axis
	 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
	 *          @param {string} options.xAxis.tickInterval - tick interval for x axis
	 *          @param {string} options.xAxis.type - type of axis
	 *          @param {string} options.xAxis.dateFormat - date format
	 *          @param {number} options.xAxis.pointOnColumn - Place the label between the ticks.
	 *          @param {string} options.xAxis.prefix - prefix for xAxis
	 *          @param {string} options.xAxis.suffix - suffix for xAxis
	 *      @param {object} options.series - options for series component
	 *          @param {boolean} options.series.showDot - whether show dot or not
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *          @param {boolean} options.series.allowSelect - whether allow select or not
	 *          @param {boolean} options.series.spline - whether spline or not
	 *          @param {boolean} options.series.zoomable - whether zoomable or not
	 *          @param {boolean} options.series.shifting - whether shifting or not
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
	 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {object} options.plot - options for plot component
	 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
	 *          @param {Array} options.plot.bands - plot bands
	 *              @param {Array.<string|number|date>} options.plot.bands.range - value range for matching
	 *              @param {string} options.plot.bands.color - band color
	 *              @param {number} options.plot.bands.opacity - band opacity
	 *              @param {boolean} options.plot.mergeOverlappingRanges - whether show overlapping ranges
	 *          @param {Array} options.plot.lines - plot lines
	 *              @param {(string|number|date)} options.plot.lines.value - value for matching
	 *              @param {string} options.plot.lines.color - band color
	 *              @param {number} options.plot.lines.opacity - band opacity
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} area chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       categories: ['cate1', 'cate2', 'cate3'],
	 *       series: [
	 *         {
	 *           name: 'Legend1',
	 *           data: [20, 30, 50]
	 *         },
	 *         {
	 *           name: 'Legend2',
	 *           data: [40, 40, 60]
	 *         },
	 *         {
	 *           name: 'Legend3',
	 *           data: [60, 50, 10]
	 *         },
	 *         {
	 *           name: 'Legend4',
	 *           data: [80, 10, 70]
	 *         }
	 *       ]
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Area Chart'
	 *       },
	 *       yAxis: {
	 *         title: 'Y Axis'
	 *       },
	 *       xAxis: {
	 *         title: 'X Axis'
	 *       }
	 *     };
	 * chart.areaChart(container, rawData, options);
	 */
	function areaChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_AREA);
	}
	
	/**
	 * Bubble chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {Array.<string>} rawData.categories - categories
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object} options.yAxis - options for y axis component
	 *          @param {string | object} options.yAxis.title - title text or title object
	 *              @param {string} options.yAxis.title.text - title text
	 *              @param {number} options.yAxis.title.offsetX - title offset x
	 *              @param {number} options.yAxis.title.offsetY - title offset y
	 *          @param {number} options.yAxis.labelMargin - label margin for y axis
	 *          @param {number} options.yAxis.min - minimum value for y axis
	 *          @param {number} options.yAxis.max - maximum value for y axis
	 *          @param {string} options.yAxis.prefix - prefix for yAxis
	 *          @param {string} options.yAxis.suffix - suffix for yAxis
	 *      @param {object} options.xAxis - options for x axis component
	 *          @param {string | object} options.xAxis.title - title text or title object
	 *              @param {string} options.xAxis.title.text - title text
	 *              @param {number} options.xAxis.title.offsetX - title offset x
	 *              @param {number} options.xAxis.title.offsetY - title offset y
	 *          @param {number} options.xAxis.labelMargin - label margin for x axis
	 *          @param {number} options.xAxis.labelInterval - label interval for x axis
	 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
	 *          @param {number} options.xAxis.min - minimum value for y axis
	 *          @param {number} options.xAxis.max - maximum value for y axis
	 *          @param {string} options.xAxis.prefix - prefix for xAxis
	 *          @param {string} options.xAxis.suffix - suffix for xAxis
	 *      @param {object} options.series - options for series component
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *          @param {boolean} options.series.allowSelect - whether allow select or not
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
	 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {object} options.circleLegend - options for circleLegend
	 *          @param {boolean} options.circleLegend.visible - whether visible or not (default: true)
	 *      @param {object} options.plot - options for plot component
	 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} bubble chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       series: [
	 *         {
	 *           name: 'Legend1',
	 *           data: [{
	 *              x: 10,
	 *              y: 20,
	 *              r: 15,
	 *              label: 'Lable1'
	 *           }, {
	 *              x: 20,
	 *              y: 40,
	 *              r: 10,
	 *              label: 'Lable2'
	 *           }]
	 *         },
	 *         {
	 *           name: 'Legend2',
	 *           data: [{
	 *              x: 40,
	 *              y: 10,
	 *              r: 5,
	 *              label: 'Lable3'
	 *           }, {
	 *              x: 30,
	 *              y: 40,
	 *              r: 8,
	 *              label: 'Lable4'
	 *           }]
	 *         }
	 *       ]
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Bubble Chart'
	 *       },
	 *       yAxis: {
	 *         title: 'Y Axis'
	 *       },
	 *       xAxis: {
	 *         title: 'X Axis'
	 *       }
	 *     };
	 * chart.bubbleChart(container, rawData, options);
	 */
	function bubbleChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_BUBBLE);
	}
	
	/**
	 * Scatter chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {Array.<string>} rawData.categories - categories
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object} options.yAxis - options for y axis component
	 *          @param {string | object} options.yAxis.title - title text or title object
	 *              @param {string} options.yAxis.title.text - title text
	 *              @param {number} options.yAxis.title.offsetX - title offset x
	 *              @param {number} options.yAxis.title.offsetY - title offset y
	 *          @param {number} options.yAxis.labelMargin - label margin for y axis
	 *          @param {number} options.yAxis.min - minimum value for y axis
	 *          @param {number} options.yAxis.max - maximum value for y axis
	 *      @param {object} options.xAxis - options for x axis component
	 *          @param {string | object} options.xAxis.title - title text or title object
	 *              @param {string} options.xAxis.title.text - title text
	 *              @param {number} options.xAxis.title.offsetX - title offset x
	 *              @param {number} options.xAxis.title.offsetY - title offset y
	 *          @param {number} options.xAxis.labelMargin - label margin for x axis
	 *          @param {number} options.xAxis.min - minimum value for y axis
	 *          @param {number} options.xAxis.max - maximum value for y axis
	 *      @param {object} options.series - options for series component
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *          @param {boolean} options.series.allowSelect - whether allow select or not
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
	 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {object} options.plot - options for plot component
	 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} scatter chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       series: [
	 *         {
	 *           name: 'Legend1',
	 *           data: [{
	 *              x: 10,
	 *              y: 20
	 *           }, {
	 *              x: 20,
	 *              y: 40
	 *           }]
	 *         },
	 *         {
	 *           name: 'Legend2',
	 *           data: [{
	 *              x: 40,
	 *              y: 10
	 *           }, {
	 *              x: 30,
	 *              y: 40
	 *           }]
	 *         }
	 *       ]
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Scatter Chart'
	 *       },
	 *       yAxis: {
	 *         title: 'Y Axis'
	 *       },
	 *       xAxis: {
	 *         title: 'X Axis'
	 *       }
	 *     };
	 * chart.scatterChart(container, rawData, options);
	 */
	function scatterChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_SCATTER);
	}
	
	/**
	 * Heatmap chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {{x: Array.<string | number>, y: Array.<string | number>}} rawData.categories - categories
	 *      @param {Array.<Array.<number>>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object} options.yAxis - options for y axis component
	 *          @param {string | object} options.yAxis.title - title text or title object
	 *              @param {string} options.yAxis.title.text - title text
	 *              @param {number} options.yAxis.title.offsetX - title offset x
	 *              @param {number} options.yAxis.title.offsetY - title offset y
	 *          @param {number} options.yAxis.labelMargin - label margin for y axis
	 *          @param {string} options.yAxis.prefix - prefix for yAxis
	 *          @param {string} options.yAxis.suffix - suffix for yAxis
	 *      @param {object} options.xAxis - options for x axis component
	 *          @param {string | object} options.xAxis.title - title text or title object
	 *              @param {string} options.xAxis.title.text - title text
	 *              @param {number} options.xAxis.title.offsetX - title offset x
	 *              @param {number} options.xAxis.title.offsetY - title offset y
	 *          @param {number} options.xAxis.labelMargin - label margin for x axis
	 *          @param {string} options.xAxis.prefix - prefix for xAxis
	 *          @param {string} options.xAxis.suffix - suffix for xAxis
	 *      @param {object} options.series - options for series component
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} heatmap chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       categories: {
	 *           x: [10, 20, 30, 40, 50],
	 *           y: [1, 2, 3, 4, 5, 6]
	 *       },
	 *       series: [
	 *           [10, 20, 30, 40, 50],
	 *           [1, 4, 6, 7, 8],
	 *           [20, 4, 5, 70, 8],
	 *           [100, 40, 30, 80, 30],
	 *           [20, 10, 60, 90, 20],
	 *           [50, 40, 30, 20, 10]
	 *       ]
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Heatmap Chart'
	 *       },
	 *       yAxis: {
	 *         title: 'Y Axis'
	 *       },
	 *       xAxis: {
	 *         title: 'X Axis'
	 *       }
	 *     };
	 * chart.heatmapChart(container, rawData, options);
	 */
	function heatmapChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_HEATMAP);
	}
	
	/**
	 * Treemap chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {Array.<Array.<object>>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object} options.series - options for series component
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *          @param {boolean} options.series.useColorValue - whether use colorValue or not
	 *          @param {boolean} options.series.zoomable - whether zoomable or not
	 *          @param {boolean} options.series.useLeafLabel - whether use leaf label or not
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} treemap chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       series: [
	 *          {
	 *              label: 'label1',
	 *              value: 6
	 *          },
	 *          {
	 *              label: 'label2',
	 *              value: 6
	 *          },
	 *          {
	 *              label: 'label3',
	 *              value: 4
	 *          },
	 *          {
	 *              label: 'label4',
	 *              value: 3
	 *          },
	 *          {
	 *              label: 'label5',
	 *              value: 2
	 *          },
	 *          {
	 *              label: 'label6',
	 *              value: 2
	 *          },
	 *          {
	 *              label: 'label7',
	 *              value: 1
	 *          }
	 *     ],
	 *     options = {
	 *       chart: {
	 *         title: 'Treemap Chart'
	 *       }
	 *     };
	 * chart.treemapChart(container, rawData, options);
	 */
	function treemapChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_TREEMAP);
	}
	
	/**
	 * Combo chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {Array.<string>} rawData.categories - categories
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object|Array} options.yAxis - options for y axis component
	 *          @param {string | object} options.yAxis.title - title text or title object
	 *              @param {string} options.yAxis.title.text - title text
	 *              @param {number} options.yAxis.title.offsetX - title offset x
	 *              @param {number} options.yAxis.title.offsetY - title offset y
	 *          @param {number} options.yAxis.labelMargin - label margin for y axis
	 *          @param {number} options.yAxis.min - minimum value for y axis
	 *          @param {number} options.yAxis.max - maximum value for y axis
	 *          @param {string} options.yAxis.prefix - prefix for yAxis
	 *          @param {string} options.yAxis.suffix - suffix for yAxis
	 *          @param {string} options.yAxis.chartType - chart type for combo chart
	 *      @param {object} options.xAxis - options for x axis component
	 *          @param {string | object} options.xAxis.title - title text or title object
	 *              @param {string} options.xAxis.title.text - title text
	 *              @param {number} options.xAxis.title.offsetX - title offset x
	 *              @param {number} options.xAxis.title.offsetY - title offset y
	 *          @param {number} options.xAxis.labelMargin - label margin for x axis
	 *          @param {number} options.xAxis.labelInterval - label interval for x axis
	 *          @param {boolean} options.xAxis.rotateLabel - whether rotate label or not (default: true)
	 *          @param {string} options.xAxis.prefix - prefix for xAxis
	 *          @param {string} options.xAxis.suffix - suffix for xAxis
	 *      @param {object} options.series - options for series component
	 *          @param {?object} options.series.column - options for column series component
	 *              @param {string} options.series.column.stackType - type of stack
	 *              @param {boolean} options.series.column.showLabel - whether show label or not
	 *              @param {number} options.series.column.barWidth - bar width
	 *          @param {?object} options.series.line - options for line series component
	 *              @param {boolean} options.series.line.showDot - whether show dot or not
	 *              @param {boolean} options.series.line.showLabel - whether show label or not
	 *              @param {boolean} options.series.line.spline - whether spline or not
	 *          @param {?object} options.series.area - options for line series component
	 *              @param {boolean} options.series.area.showDot - whether show dot or not
	 *              @param {boolean} options.series.area.showLabel - whether show label or not
	 *              @param {boolean} options.series.area.spline - whether spline or not
	 *          @param {?object} options.series.pie - options for pie series component
	 *              @param {boolean} options.series.pie.showLabel - whether show label or not
	 *              @param {number} options.series.pie.radiusRatio - ratio of radius for pie graph
	 *              @param {number} options.series.pie.startAngle - start angle
	 *              @param {number} options.series.pie.endAngle - end angle
	 *          @param {boolean} options.series.showDot - whether show dot or not
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *          @param {boolean} options.series.allowSelect - whether allow select or not
	 *          @param {boolean} options.series.spline - whether spline or not
	 *          @param {boolean} options.series.zoomable - whether zoomable or not
	 *          @param {boolean} options.series.shifting - whether shifting or not
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {object} options.tooltip.column - options for column tooltip
	 *              @param {string} options.tooltip.column.suffix - suffix for tooltip
	 *              @param {function} [options.tooltip.column.template] template of tooltip
	 *              @param {string} options.tooltip.column.align - align option for tooltip
	 *              @param {number} options.tooltip.column.offsetX - tooltip offset x
	 *              @param {number} options.tooltip.column.offsetY - tooltip offset y
	 *          @param {boolean} options.tooltip.grouped - whether group tooltip or not
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left)
	 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {object} options.plot - options for plot component
	 *          @param {boolean} options.plot.showLine - whether show line or not (default: true)
	 *          @param {Array} options.plot.bands - plot bands for line & area combo chart
	 *              @param {Array.<string|number|date>} options.plot.bands.range - value range for matching
	 *              @param {string} options.plot.bands.color - band color
	 *              @param {number} options.plot.bands.opacity - band opacity
	 *              @param {boolean} options.plot.mergeOverlappingRanges - whether show overlapping ranges
	 *          @param {Array} options.plot.lines - plot lines
	 *              @param {(string|number|date)} options.plot.lines.value - value for matching
	 *              @param {string} options.plot.lines.color - band color
	 *              @param {number} options.plot.lines.opacity - band opacity
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} combo chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       categories: ['cate1', 'cate2', 'cate3'],
	 *       series: {
	 *         column: [
	 *           {
	 *             name: 'Legend1',
	 *             data: [20, 30, 50]]
	 *           },
	 *           {
	 *             name: 'Legend2',
	 *             data: [40, 40, 60]
	 *           },
	 *           {
	 *             name: 'Legend3',
	 *             data: [60, 50, 10]
	 *           },
	 *           {
	 *             name: 'Legend4',
	 *             data: [80, 10, 70]
	 *           }
	 *         },
	 *         line: [
	 *           {
	 *             name: 'Legend5',
	 *             data: [1, 2, 3]
	 *           }
	 *         ]
	 *       }
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Combo Chart'
	 *       },
	 *       yAxis:[
	 *         {
	 *           title: 'Y Axis',
	 *           chartType: 'line'
	 *         },
	 *         {
	 *           title: 'Y Right Axis'
	 *         }
	 *       ],
	 *       xAxis: {
	 *         title: 'X Axis'
	 *       },
	 *       series: {
	 *         showDot: true
	 *       }
	 *     };
	 * chart.comboChart(container, rawData, options);
	 */
	function comboChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_COMBO);
	}
	
	/**
	 * Pie chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object} options.series - options for series component
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *          @param {boolean} options.series.showLegend - whether show legend label or not
	 *          @param {function} options.series.labelFilter - filter for series label display
	 *          @param {number} options.series.radiusRatio - ratio of radius for pie graph
	 *          @param {boolean} options.series.allowSelect - whether allow select or not
	 *          @param {boolean} options.series.startAngle - start angle
	 *          @param {boolean} options.series.endAngle - end angle
	 *          @param {string} options.series.labelAlign - label align
	 *          @param {Array<string>} options.series.radiusRange: radius range
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left|center|outer)
	 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} pie chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       series: [
	 *         {
	 *           name: 'Legend1',
	 *           data: 20
	 *         },
	 *         {
	 *           name: 'Legend2',
	 *           data: 40
	 *         },
	 *         {
	 *           name: 'Legend3',
	 *           data: 60
	 *         },
	 *         {
	 *           name: 'Legend4',
	 *           data: 80
	 *         }
	 *       ]
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Pie Chart'
	 *       }
	 *     };
	 * chart.pieChart(container, rawData, options);
	 */
	function pieChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_PIE);
	}
	
	/**
	 * Map chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData chart data
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object} options.series - options for series component
	 *          @param {boolean} options.series.showLabel - whether show label or not
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {object} options.tooltip.offset - tooltip offset
	 *              @param {number} options.tooltip.offset.x - offset x
	 *              @param {number} options.tooltip.offset.y - offset y
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left|center|outer)
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.map map type
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} map chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 *     rawData = {
	 *       series: [
	 *         {
	 *           code: 'KR',
	 *           data: 100,
	 *           labelCoordinate: {
	 *             x: 0.6,
	 *             y: 0.7
	 *           }
	 *         },
	 *         {
	 *           code: 'JP',
	 *           data: 50
	 *         }
	 *       ]
	 *     },
	 *     options = {
	 *       chart: {
	 *         title: 'Map Chart'
	 *       },
	 *       map: 'world'
	 *     };
	 * chart.mapChart(container, rawData, options);
	 */
	function mapChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_MAP);
	}
	
	/**
	 * radial chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData - raw data
	 *      @param {Array.<Array>} rawData.series - series data
	 * @param {object} options - chart options
	 *      @param {object} options.chart - base options for chart
	 *          @param {number} options.chart.width - chart width
	 *          @param {number} options.chart.height - chart height
	 *          @param {string | object} options.chart.title - title text or title object
	 *              @param {string} options.chart.title.text - title text
	 *              @param {string} options.chart.title.align - align option for chart title (left|center|right)
	 *              @param {number} options.chart.title.offsetX - title offset x
	 *              @param {number} options.chart.title.offsetY - title offset y
	 *          @param {string | function} options.chart.format - formatter for value
	 *      @param {object} options.series - options for series component
	 *          @param {boolean} options.series.showDot - show dot or not (default: false)
	 *          @param {boolean} options.series.showArea - show area or not (default: false)
	 *      @param {object} options.plot - options for plot component
	 *          @param {boolean} options.plot.type - "spiderweb" or "circle" (default: "spiderweb")
	 *      @param {object|Array} options.yAxis - options for y axis component
	 *          @param {number} options.yAxis.min - minimum value for y axis
	 *          @param {number} options.yAxis.max - maximum value for y axis
	 *      @param {object} options.tooltip - options for tooltip component
	 *          @param {string} options.tooltip.suffix - suffix for tooltip
	 *          @param {function} [options.tooltip.template] - template for tooltip
	 *          @param {string} options.tooltip.align - align option for tooltip
	 *          @param {number} options.tooltip.offsetX - tooltip offset x
	 *          @param {number} options.tooltip.offsetY - tooltip offset y
	 *      @param {object} options.legend - options for legend component
	 *          @param {string} options.legend.align - align option for legend (top|bottom|left|center|outer)
	 *          @param {boolean} options.legend.showCheckbox - whether show checkbox or not (default: true)
	 *          @param {boolean} options.legend.visible - whether visible or not (default: true)
	 *          @param {number} options.legend.maxWidth - legend name display max width
	 *      @param {string} options.theme - theme name
	 *      @param {string} options.libType - type of graph library
	 *      @param {object} options.chartExportMenu - options for exporting
	 *          @param {string} options.chartExportMenu.filename - export file name
	 *          @param {string} options.chartExportMenu.visible - whether visible or not (default: true)
	 *      @param {boolean} options.usageStatistics - send hostname to google analytics
	 * @returns {object} radial chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('chart-area'),
	 *     rawData = {
	 *         categories: ["June", "July", "Aug", "Sep", "Oct", "Nov"],
	 *         series: [
	 *             {
	 *                 name: 'Budget',
	 *                 data: [5000, 3000, 5000, 7000, 6000, 4000]
	 *             },
	 *             {
	 *                 name: 'Income',
	 *                 data: [8000, 8000, 7000, 2000, 5000, 3000]
	 *             },
	 *             {
	 *                 name: 'Expenses',
	 *                 data: [4000, 4000, 6000, 3000, 4000, 5000]
	 *             },
	 *             {
	 *                 name: 'Debt',
	 *                 data: [6000, 3000, 3000, 1000, 2000, 4000]
	 *             }
	 *         ]
	 *     },
	 *     options = {
	 *         chart: {
	 *             width: 600,
	 *             height: 400
	 *         },
	 *         series: {
	 *             showDot: true,
	 *             showArea: true
	 *         },
	 *         plot: {
	 *             type: 'circle'
	 *         },
	 *         yAxis: {
	 *             min: 0,
	 *             max: 9000
	 *         }
	 *     };
	 * chart.radialChart(container, rawData, options);
	 *
	 */
	function radialChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_RADIAL);
	}
	
	/**
	 * Boxplot chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData chart data
	 * @param {object} options - chart options
	 * @returns {object} box plot chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('container-id'),
	 * var rawData = {
	 *  categories: ['Budget', 'Income', 'Expenses', 'Debt'],
	 *  series: [{
	 *      name: '2015',
	 *      data: [
	 *          [1000, 2500, 3714, 5500, 7000],
	 *          [1000, 2250, 3142, 4750, 6000]
	 *      ],
	 *      outliers: [
	 *          [0, 14000]
	 *      ]
	 *  }, {
	 *      name: '2016',
	 *      data: [
	 *          [2000, 4500, 6714, 11500, 13000],
	 *          [7000, 9250, 10142, 11750, 12000]
	 *      ],
	 *      outliers: [
	 *          [1, 14000]
	 *      ]
	 *  }];
	 * };
	 * var options = {
	 *      chart: {
	 *          width: 600,
	 *          height: 400
	 *      },
	 *      series: {
	 *          showDot: true,
	 *          showArea: true
	 *      },
	 *      plot: {
	 *          type: 'circle'
	 *      },
	 *      yAxis: {
	 *          min: 0,
	 *          max: 9000
	 *      }
	 *  };
	 * chart.boxplotChart(container, rawData, options);
	 */
	function boxplotChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_BOXPLOT);
	}
	
	/**
	 * Bullet chart creator.
	 * @memberof module:chart
	 * @memberof tui.chart
	 * @param {HTMLElement} container - chart container
	 * @param {rawData} rawData chart data
	 * @param {object} options - chart options
	 * @returns {object} bullet chart
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var container = document.getElementById('chart-area');
	 * var data = {
	 *   categories: ['July', 'August'],
	 *   series: [{
	 *       name: 'Budget',
	 *       data: 25,
	 *      markers: [28, 2, 15],
	 *       ranges: [[-1, 10], [10, 20], [20, 30]]
	 *   },{
	 *       name: 'Hello',
	 *       data: 11,
	 *       markers: [20],
	 *       ranges: [[0, 8], [8, 15]]
	 *   }]
	 * };
	 * var options = {
	 *    chart: {
	 *       width: 700,
	 *       height: 300,
	 *       title: 'Monthly Revenue'
	 *   },
	 *   series: {
	 *       showLabel: true,
	 *       vertical: false
	 *   }
	 * };
	 * chart.bulletChart(container, data, options);
	 */
	function bulletChart(container, rawData, options) {
	  return _createChart(container, rawData, options, _const2['default'].CHART_TYPE_BULLET);
	}
	
	/**
	 * Register theme.
	 * @memberof tui.chart
	 * @param {string} themeName - theme name
	 * @param {object} theme - application chart theme
	 *      @param {object} theme.chart - chart theme
	 *          @param {string} theme.chart.fontFamily - font family for chart
	 *          @param {string} theme.chart.background - background for chart
	 *      @param {object} theme.title - chart title theme
	 *          @param {number} theme.title.fontSize - font size
	 *          @param {string} theme.title.fontFamily - font family
	 *          @param {string} theme.title.fontWeight - font weight
	 *          @param {string} theme.title.color - font color
	 *          @param {string} theme.title.background - background
	 *      @param {object} theme.yAxis - y axis theme
	 *          @param {object} theme.yAxis.title - theme for y axis title
	 *              @param {number} theme.yAxis.title.fontSize - font size
	 *              @param {string} theme.yAxis.title.fontFamily - font family
	 *              @param {string} theme.yAxis.title.fontWeight - font weight
	 *              @param {string} theme.yAxis.title.color - font color
	 *          @param {object} theme.yAxis.label - theme for y axis label
	 *              @param {number} theme.yAxis.label.fontSize - font size
	 *              @param {string} theme.yAxis.label.fontFamily - font family
	 *              @param {string} theme.yAxis.label.fontWeight - font weight
	 *              @param {string} theme.yAxis.label.color - font color
	 *          @param {string} theme.yAxis.tickColor - color for y axis tick
	 *      @param {object} theme.xAxis - theme for x axis
	 *          @param {object} theme.xAxis.title - theme for x axis title
	 *              @param {number} theme.xAxis.title.fontSize - font size
	 *              @param {string} theme.xAxis.title.fontFamily - font family
	 *              @param {string} theme.xAxis.title.fontWeight - font weight
	 *              @param {string} theme.xAxis.title.color - font color
	 *          @param {object} theme.xAxis.label - theme for x axis label
	 *              @param {number} theme.xAxis.label.fontSize - font size
	 *              @param {string} theme.xAxis.label.fontFamily - font family
	 *              @param {string} theme.xAxis.label.fontWeight - font weight
	 *              @param {string} theme.xAxis.label.color - font color
	 *          @param {string} theme.xAxis.tickColor - color for x axis tick
	 *      @param {object} theme.plot - theme for plot
	 *          @param {string} theme.plot.lineColor - line color
	 *          @param {string} theme.plot.background - background
	 *      @param {object} theme.series theme for series
	 *          @param {Array.<string>} theme.series.colors - colors
	 *          @param {string} theme.series.borderColor - border color
	 *          @param {string} theme.series.selectionColor - selection color
	 *          @param {string} theme.series.startColor - start color
	 *          @param {string} theme.series.endColor - end color
	 *          @param {string} theme.series.overColor - over color
	 *      @param {object} theme.legend - theme for legend
	 *          @param {object} theme.legend.label - theme for legend label
	 *              @param {number} theme.legend.label.fontSize - font size
	 *              @param {string} theme.legend.label.fontFamily - font family
	 *              @param {string} theme.legend.label.fontWeight - font family
	 *              @param {string} theme.legend.label.color - font color
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var theme = {
	 *   yAxis: {
	 *     tickColor: '#ccbd9a',
	 *       title: {
	 *         color: '#333333'
	 *       },
	 *       label: {
	 *         color: '#6f491d'
	 *       }
	 *     },
	 *     xAxis: {
	 *       tickColor: '#ccbd9a',
	 *       title: {
	 *         color: '#333333'
	 *       },
	 *       label: {
	 *         color: '#6f491d'
	 *       }
	 *     },
	 *     plot: {
	 *       lineColor: '#e5dbc4',
	 *       background: '#f6f1e5'
	 *     },
	 *     series: {
	 *       colors: ['#40abb4', '#e78a31', '#c1c452', '#795224', '#f5f5f5'],
	 *       borderColor: '#8e6535',
	 *       selectionColor: '#cccccc',
	 *       startColor: '#efefef',
	 *       endColor: 'blue',
	 *       overColor: 'yellow'
	 *     },
	 *     legend: {
	 *       label: {
	 *         color: '#6f491d'
	 *       }
	 *     }
	 *   };
	 * chart.registerTheme('newTheme', theme);
	 */
	function registerTheme(themeName, theme) {
	  _themeManager2['default'].register(themeName, theme);
	}
	
	/**
	 * Register map.
	 * @memberof tui.chart
	 * @param {string} mapName map name
	 * @param {Array.<{code: string, name: string, path: string}>} data map data
	 * @api
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var data = [
	 *   {
	 *     code: 'KR',
	 *     name: 'South Korea',
	 *     path: 'M835.13,346.53L837.55,350.71...',
	 *     labelCoordinate: {
	 *       x: 0.6,
	 *       y: 0.7
	 *     }
	 *   },
	 *   //...
	 * ];
	 * chart.registerMap('newMap', data);
	 */
	function registerMap(mapName, data) {
	  _mapManager2['default'].register(mapName, data);
	}
	
	/**
	 * Register graph plugin.
	 * @memberof tui.chart
	 * @param {string} libType type of graph library
	 * @param {object} plugin plugin to control library
	 * @param {function} getPaperCallback callback function for getting paper
	 * @example
	 * var chart = tui.chart; // or require('tui-chart');
	 * var pluginRaphael = {
	 *   bar: function() {} // Render class
	 * };
	 * tui.chart.registerPlugin('raphael', pluginRaphael);
	 */
	function registerPlugin(libType, plugin, getPaperCallback) {
	  _pluginFactory2['default'].register(libType, plugin);
	  _drawingToolPicker2['default'].addRendererType(libType, getPaperCallback);
	}
	
	module.exports = {
	  barChart: barChart,
	  columnChart: columnChart,
	  lineChart: lineChart,
	  areaChart: areaChart,
	  bubbleChart: bubbleChart,
	  scatterChart: scatterChart,
	  heatmapChart: heatmapChart,
	  treemapChart: treemapChart,
	  comboChart: comboChart,
	  pieChart: pieChart,
	  mapChart: mapChart,
	  radialChart: radialChart,
	  boxplotChart: boxplotChart,
	  bulletChart: bulletChart,
	  registerTheme: registerTheme,
	  registerMap: registerMap,
	  registerPlugin: registerPlugin
	};

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var charts = {}; /**
	                  * @fileoverview  Chart factory play role register chart.
	                  *                Also, you can get chart from this factory.
	                  * @author NHN.
	                  *         FE Development Lab <dl_javascript@nhn.com>
	                  */
	
	exports['default'] = {
	    /**
	     * Find key for getting chart.
	     * @param {string} chartType - type of chart
	     * @param {{seriesAlias: ?object, series: object.<string, Array>}} rawData - raw data
	     * @returns {string}
	     * @private
	     */
	    _findKey: function _findKey(chartType, rawData) {
	        var key = null;
	        if (_predicate2['default'].isComboChart(chartType)) {
	            var chartTypeMap = _rawDataHandler2['default'].getChartTypeMap(rawData);
	
	            if (chartTypeMap[_const2['default'].CHART_TYPE_COLUMN] && chartTypeMap[_const2['default'].CHART_TYPE_LINE]) {
	                key = _const2['default'].CHART_TYPE_COLUMN_LINE_COMBO;
	            } else if (chartTypeMap[_const2['default'].CHART_TYPE_LINE] && chartTypeMap[_const2['default'].CHART_TYPE_SCATTER]) {
	                key = _const2['default'].CHART_TYPE_LINE_SCATTER_COMBO;
	            } else if (chartTypeMap[_const2['default'].CHART_TYPE_AREA] && chartTypeMap[_const2['default'].CHART_TYPE_LINE]) {
	                key = _const2['default'].CHART_TYPE_LINE_AREA_COMBO;
	            } else if (chartTypeMap[_const2['default'].CHART_TYPE_PIE]) {
	                key = _const2['default'].CHART_TYPE_PIE_DONUT_COMBO;
	            }
	        } else {
	            key = chartType;
	        }
	
	        return key;
	    },
	
	
	    /**
	     * Get chart instance.
	     * @param {string} chartType chart type
	     * @param {object} rawData chart data
	     * @param {object} theme chart options
	     * @param {object} options chart options
	     * @returns {object} chart instance;
	     */
	    get: function get(chartType, rawData, theme, options) {
	        var key = this._findKey(chartType, rawData);
	        var Chart = charts[key];
	
	        if (!Chart) {
	            throw new Error('Not exist ' + chartType + ' chart.');
	        }
	
	        return new Chart(rawData, theme, options);
	    },
	
	
	    /**
	     * Register chart.
	     * @param {string} chartType char type
	     * @param {class} ChartClass chart class
	     */
	    register: function register(chartType, ChartClass) {
	        charts[chartType] = ChartClass;
	    }
	};

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @fileoverview Raw data handler.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
	
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Raw data Handler.
	 * @module rawDataHandler
	 * @private */
	exports['default'] = {
	    /**
	     * Pick stacks.
	     * @param {Array.<{stack: string}>} seriesData - raw series data
	     * @param {boolean} [divergingOption] - diverging option
	     * @returns {Array.<string>} stacks
	     */
	    pickStacks: function pickStacks(seriesData, divergingOption) {
	        var stacks = seriesData.map(function (seriesDatum) {
	            return seriesDatum.stack;
	        });
	
	        var uniqStacks = _arrayUtil2['default'].unique(stacks);
	
	        if (divergingOption) {
	            uniqStacks = uniqStacks.slice(0, 2);
	        }
	
	        var filteredStack = uniqStacks.filter(function (stack) {
	            return !!stack;
	        });
	
	        if (filteredStack.length < uniqStacks.length) {
	            filteredStack.push(_const2['default'].DEFAULT_STACK);
	        }
	
	        return filteredStack;
	    },
	
	
	    /**
	     * Sort series data from stacks.
	     * @param {Array.<{stack: ?string}>} seriesData series data
	     * @param {Array.<string>} stacks stacks
	     * @returns {Array}
	     * @private
	     */
	    _sortSeriesData: function _sortSeriesData(seriesData, stacks) {
	        var newSeriesData = [];
	
	        if (!stacks) {
	            stacks = this.pickStacks(seriesData);
	        }
	
	        stacks.forEach(function (stack) {
	            var filtered = seriesData.filter(function (datum) {
	                return (datum.stack || _const2['default'].DEFAULT_STACK) === stack;
	            });
	            newSeriesData = newSeriesData.concat(filtered);
	        });
	
	        return newSeriesData;
	    },
	
	
	    /**
	     * Remove stack of series data.
	     * @param {Array.<{stack: ?string}>} seriesData series data
	     */
	    removeSeriesStack: function removeSeriesStack(seriesData) {
	        Object.values(seriesData).forEach(function (datum) {
	            delete datum.stack;
	        });
	    },
	
	
	    /**
	     * Find char type from chart name.
	     * @param {object.<string, string>} seriesAlias - alias map
	     * @param {string} seriesType - series name
	     * @returns {*}
	     */
	    findChartType: function findChartType(seriesAlias, seriesType) {
	        var chartType = void 0;
	
	        if (seriesAlias) {
	            chartType = seriesAlias[seriesType];
	        }
	
	        return chartType || seriesType;
	    },
	
	
	    /**
	     * Get chart type map.
	     * @param {{series: (Array | object)}} rawData - raw data
	     * @returns {object.<string, string>}
	     */
	    getChartTypeMap: function getChartTypeMap(rawData) {
	        var _this = this;
	
	        var chartTypeMap = {};
	
	        if (_tuiCodeSnippet2['default'].isObject(rawData.series)) {
	            _tuiCodeSnippet2['default'].forEach(rawData.series, function (data, seriesType) {
	                chartTypeMap[_this.findChartType(rawData.seriesAlias, seriesType)] = true;
	            });
	        }
	
	        return chartTypeMap;
	    },
	
	
	    /**
	     * Create minus values.
	     * @param {Array.<number>} data number data
	     * @returns {Array} minus values
	     * @private
	     */
	    _createMinusValues: function _createMinusValues(data) {
	        return data.map(function (value) {
	            return value < 0 ? 0 : -value;
	        });
	    },
	
	
	    /**
	     * Create plus values.
	     * @param {Array.<number>} data number data
	     * @returns {Array} plus values
	     * @private
	     */
	    _createPlusValues: function _createPlusValues(data) {
	        return data.map(function (value) {
	            return value < 0 ? 0 : value;
	        });
	    },
	
	
	    /**
	     * Make normal diverging raw series data.
	     * @param {{data: Array.<number>}} rawSeriesData raw series data
	     * @returns {{data: Array.<number>}} changed raw series data
	     * @private
	     */
	    _makeNormalDivergingRawSeriesData: function _makeNormalDivergingRawSeriesData(rawSeriesData) {
	        rawSeriesData.length = Math.min(rawSeriesData.length, 2);
	
	        rawSeriesData[0].data = this._createMinusValues(rawSeriesData[0].data);
	
	        if (rawSeriesData[1]) {
	            rawSeriesData[1].data = this._createPlusValues(rawSeriesData[1].data);
	        }
	
	        return rawSeriesData;
	    },
	
	
	    /**
	     * Make raw series data for stacked diverging option.
	     * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
	     * @returns {{data: Array.<number>}} changed raw series data
	     * @private
	     */
	    _makeRawSeriesDataForStackedDiverging: function _makeRawSeriesDataForStackedDiverging(rawSeriesData) {
	        var _this2 = this;
	
	        var stacks = this.pickStacks(rawSeriesData, true);
	        var result = [];
	
	        var _stacks = _slicedToArray(stacks, 2),
	            leftStack = _stacks[0],
	            rightStack = _stacks[1];
	
	        rawSeriesData = this._sortSeriesData(rawSeriesData, stacks);
	
	        rawSeriesData.forEach(function (seriesDatum) {
	            var stack = seriesDatum.stack || _const2['default'].DEFAULT_STACK;
	            if (stack === leftStack) {
	                seriesDatum.data = _this2._createMinusValues(seriesDatum.data);
	                result.push(seriesDatum);
	            } else if (stack === rightStack) {
	                seriesDatum.data = _this2._createPlusValues(seriesDatum.data);
	                result.push(seriesDatum);
	            }
	        });
	
	        return result;
	    },
	
	
	    /**
	     * Make raw series data for diverging.
	     * @param {{data: Array.<number>, stack: string}} rawSeriesData raw series data
	     * @param {?string} stackTypeOption stackType option
	     * @returns {{data: Array.<number>}} changed raw series data
	     * @private
	     */
	    _makeRawSeriesDataForDiverging: function _makeRawSeriesDataForDiverging(rawSeriesData, stackTypeOption) {
	        if (_predicate2['default'].isValidStackOption(stackTypeOption)) {
	            rawSeriesData = this._makeRawSeriesDataForStackedDiverging(rawSeriesData);
	        } else {
	            rawSeriesData = this._makeNormalDivergingRawSeriesData(rawSeriesData);
	        }
	
	        return rawSeriesData;
	    },
	
	
	    /**
	     * Update raw series data by options.
	     * @param {object} rawData - raw data
	     * @param {{stackType: ?string, diverging: ?boolean}} seriesOptions - series options
	     */
	    updateRawSeriesDataByOptions: function updateRawSeriesDataByOptions(rawData) {
	        var _this3 = this;
	
	        var seriesOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	        if (_predicate2['default'].isValidStackOption(seriesOptions.stackType)) {
	            Object.keys(rawData.series).forEach(function (seriesType) {
	                rawData.series[seriesType] = _this3._sortSeriesData(rawData.series[seriesType]);
	            });
	        }
	
	        if (seriesOptions.diverging) {
	            Object.entries(rawData.series).forEach(function (_ref) {
	                var _ref2 = _slicedToArray(_ref, 2),
	                    seriesType = _ref2[0],
	                    seriesDatum = _ref2[1];
	
	                rawData.series[seriesType] = _this3._makeRawSeriesDataForDiverging(seriesDatum, seriesOptions.stackType);
	            });
	        }
	    },
	
	
	    /**
	     * Append outlier value to boxplot series data end
	     * @param {object} rawData - raw data
	     */
	    appendOutliersToSeriesData: function appendOutliersToSeriesData(rawData) {
	        var boxplot = rawData.series.boxplot;
	
	        boxplot.forEach(function (seriesItem) {
	            var outliers = seriesItem.outliers;
	
	            if (outliers && outliers.length) {
	                outliers.forEach(function (outlier) {
	                    seriesItem.data[outlier[0]].push(outlier[1]);
	                });
	            }
	        });
	    },
	
	
	    /**
	     * Filter raw data belong to checked legend.
	     * @param {object} rawData raw data
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @returns {object} rawData
	     */
	    filterCheckedRawData: function filterCheckedRawData(rawData, checkedLegends) {
	        var cloneData = JSON.parse(JSON.stringify(rawData));
	
	        if (checkedLegends) {
	            Object.entries(cloneData.series).forEach(function (_ref3) {
	                var _ref4 = _slicedToArray(_ref3, 2),
	                    chartType = _ref4[0],
	                    serieses = _ref4[1];
	
	                if (!checkedLegends[chartType]) {
	                    cloneData.series[chartType] = [];
	                } else if (checkedLegends[chartType].length) {
	                    cloneData.series[chartType] = serieses.filter(function (series, index) {
	                        return checkedLegends[chartType][index];
	                    });
	                }
	            });
	        }
	
	        if (cloneData.series.bullet) {
	            var filteredCategories = [];
	            checkedLegends.bullet.forEach(function (isChecked, index) {
	                if (isChecked) {
	                    filteredCategories.push(rawData.categories[index]);
	                }
	            });
	            cloneData.categories = filteredCategories;
	        }
	
	        return cloneData;
	    },
	
	
	    /**
	     * Modify rawData to fit chart format
	     * @param {object} rawData - raw data
	     * @private
	     */
	    _makeRawSeriesDataForBulletChart: function _makeRawSeriesDataForBulletChart(rawData) {
	        var _rawData$series$bulle = rawData.series.bullet,
	            bullet = _rawData$series$bulle === undefined ? [] : _rawData$series$bulle;
	
	
	        rawData.categories = rawData.categories || [];
	        rawData.categories = bullet.map(function (seriesData) {
	            return seriesData.name || '';
	        });
	    }
	};

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var plugins = {}; /**
	                   * @fileoverview  Plugin factory play role register rendering plugin.
	                   *                Also, you can get plugin from this factory.
	                   * @author NHN.
	                   *         FE Development Lab <dl_javascript@nhn.com>
	                   */
	exports['default'] = {
	    /**
	        * Get graph renderer.
	        * @param {string} libType type of graph library
	        * @param {string} chartType chart type
	        * @returns {object} renderer instance
	        */
	    get: function get(libType, chartType) {
	        var plugin = plugins[libType || _const2['default'].DEFAULT_PLUGIN];
	
	        if (!plugin) {
	            throw new Error('Not exist ' + libType + ' plugin.');
	        }
	
	        var Renderer = plugin[chartType];
	        if (!Renderer) {
	            throw new Error('Not exist ' + chartType + ' chart renderer.');
	        }
	
	        var renderer = new Renderer();
	
	        return renderer;
	    },
	
	    /**
	        * Plugin register.
	        * @param {string} libType type of graph library
	        * @param {object} plugin plugin to control library
	        */
	    register: function register(libType, plugin) {
	        plugins[libType] = plugin;
	    }
	};

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @Fileoverview  Theme manager.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _defaultTheme = __webpack_require__(362);
	
	var _defaultTheme2 = _interopRequireDefault(_defaultTheme);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var themes = {};
	
	exports['default'] = {
	    /**
	     * Theme register.
	     * @param {string} themeName theme name
	     * @param {object} theme theme
	     */
	    register: function register(themeName, theme) {
	        theme = JSON.parse(JSON.stringify(theme));
	        themes[themeName] = theme;
	    },
	
	
	    /**
	     * Pick series types from raw series data.
	     * @param {string} chartType - chart type
	     * @param {object} rawSeriesData - raw series data
	     * @returns {Array}
	     * @private
	     */
	    _pickSeriesNames: function _pickSeriesNames(chartType, rawSeriesData) {
	        var seriesTypes = [];
	        if (_predicate2['default'].isComboChart(chartType)) {
	            Object.keys(rawSeriesData).forEach(function (seriesType) {
	                seriesTypes.push(seriesType);
	            });
	        } else {
	            seriesTypes.push(chartType);
	        }
	
	        return seriesTypes;
	    },
	
	
	    /**
	     * Overwrite theme
	     * @param {object} fromTheme - from theme
	     * @param {object} toTheme - to theme
	     * @private
	     */
	    _overwriteTheme: function _overwriteTheme(fromTheme, toTheme) {
	        var _this = this;
	
	        Object.entries(toTheme).forEach(function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2),
	                key = _ref2[0],
	                item = _ref2[1];
	
	            var fromItem = fromTheme[key];
	            if (!fromItem && fromItem !== 0) {
	                return;
	            }
	
	            if (_tuiCodeSnippet2['default'].isArray(fromItem)) {
	                toTheme[key] = fromItem.slice();
	            } else if (_tuiCodeSnippet2['default'].isObject(fromItem)) {
	                _this._overwriteTheme(fromItem, item);
	            } else {
	                toTheme[key] = fromItem;
	            }
	        });
	    },
	
	
	    /**
	     * Pick valid theme properties.
	     * @param {object} theme - theme
	     * @param {string} componentType - component type (series or yAxis)
	     * @returns {object}
	     * @private
	     */
	    _pickValidTheme: function _pickValidTheme(theme, componentType) {
	        var validTheme = {};
	
	        _const2['default'].THEME_PROPS_MAP[componentType].forEach(function (propName) {
	            if (_tuiCodeSnippet2['default'].isExisty(theme[propName])) {
	                validTheme[propName] = theme[propName];
	            }
	        });
	
	        return validTheme;
	    },
	
	
	    /**
	     * Create component theme with series name
	     * @param {Array.<string>} seriesTypes - series types
	     * @param {object} fromTheme - from theme
	     * @param {object} toTheme - to theme
	     * @param {string} componentType - component type
	     * @returns {object}
	     * @private
	     */
	    _createComponentThemeWithSeriesName: function _createComponentThemeWithSeriesName(seriesTypes, fromTheme, toTheme, componentType) {
	        var _this2 = this;
	
	        var newTheme = {};
	
	        fromTheme = fromTheme || {};
	
	        seriesTypes.forEach(function (seriesType) {
	            var theme = fromTheme[seriesType] || _this2._pickValidTheme(fromTheme, componentType);
	
	            if (_tuiCodeSnippet2['default'].keys(theme).length) {
	                newTheme[seriesType] = JSON.parse(JSON.stringify(_defaultTheme2['default'][componentType]));
	                _this2._overwriteTheme(theme, newTheme[seriesType]);
	            } else {
	                newTheme[seriesType] = JSON.parse(JSON.stringify(toTheme));
	            }
	        });
	
	        return newTheme;
	    },
	
	
	    /**
	     * Make each series's color
	     * @param {Array.<string>} themeColors Theme colors to use
	     * @param {number} seriesCount Series count
	     * @param {number} startColorIndex Start color index
	     * @returns {Array.<string>} colors
	     */
	    _makeEachSeriesColors: function _makeEachSeriesColors(themeColors, seriesCount, startColorIndex) {
	        var colors = [];
	        var themeColorsLen = themeColors.length;
	        var colorIndex = startColorIndex || 0;
	
	        for (var i = 0; i < seriesCount; i += 1) {
	            colors.push(themeColors[colorIndex]);
	
	            colorIndex += 1;
	
	            if (colorIndex >= themeColorsLen) {
	                colorIndex = 0;
	            }
	        }
	
	        return colors;
	    },
	
	
	    /**
	     * Set series colors theme.
	     * @param {Array.<string>} seriesTypes - series type
	     * @param {object} seriesThemes - series theme map
	     * @param {object} rawSeriesThemes - raw series theme map
	     * @param {object} rawSeriesData - raw series data
	     * @param {boolean} isColorByPoint - check colorByPoint option
	     * @private
	     */
	    _setSeriesColors: function _setSeriesColors(seriesTypes, seriesThemes, rawSeriesThemes, rawSeriesData, isColorByPoint) {
	        var _this3 = this;
	
	        var seriesColors = void 0,
	            seriesCount = void 0,
	            hasOwnColors = void 0;
	        var colorIndex = 0;
	
	        rawSeriesThemes = rawSeriesThemes || {}; // to simplify if/else statement
	
	        seriesTypes.forEach(function (seriesType) {
	            if (rawSeriesThemes[seriesType]) {
	                seriesColors = rawSeriesThemes[seriesType].colors;
	                hasOwnColors = true;
	            } else {
	                seriesColors = rawSeriesThemes.colors || _defaultTheme2['default'].series.colors;
	                hasOwnColors = false;
	            }
	
	            seriesCount = _this3._getSeriesThemeColorCount(rawSeriesData[seriesType], isColorByPoint);
	
	            seriesThemes[seriesType].colors = _this3._makeEachSeriesColors(seriesColors, seriesCount, !hasOwnColors && colorIndex);
	
	            // To distinct between series that use default theme, we make the colors different
	            if (!hasOwnColors) {
	                colorIndex = (seriesCount + colorIndex) % seriesColors.length;
	            }
	        });
	    },
	
	
	    /**
	     * Get number of series theme color from seriesData
	     * @param {object} rawSeriesDatum - raw series data contains series information
	     * @param {boolean} isColorByPoint - check colorByPoint option
	     * @returns {number} number of series theme color
	     * @private
	     */
	    _getSeriesThemeColorCount: function _getSeriesThemeColorCount(rawSeriesDatum, isColorByPoint) {
	        var seriesCount = 0;
	
	        if (rawSeriesDatum && rawSeriesDatum.length) {
	            var existFirstSeriesDataLength = rawSeriesDatum[0] && rawSeriesDatum[0].data && rawSeriesDatum[0].data.length;
	
	            if (isColorByPoint && existFirstSeriesDataLength) {
	                seriesCount = Math.max(rawSeriesDatum.length, rawSeriesDatum[0].data.length);
	            } else {
	                seriesCount = rawSeriesDatum.length;
	            }
	        }
	
	        return seriesCount;
	    },
	    _initTheme: function _initTheme(themeName, rawTheme, seriesTypes, rawSeriesData, isColorByPoint) {
	        var theme = void 0;
	
	        if (themeName !== _const2['default'].DEFAULT_THEME_NAME) {
	            // customized theme that overrides default theme
	            theme = JSON.parse(JSON.stringify(_defaultTheme2['default']));
	            this._overwriteTheme(rawTheme, theme);
	        } else {
	            // default theme
	            theme = JSON.parse(JSON.stringify(rawTheme));
	        }
	
	        // make each component theme have theme by series name. theme.yAxis.theme -> theme.yAxis.line.theme
	        theme.yAxis = this._createComponentThemeWithSeriesName(seriesTypes, rawTheme.yAxis, theme.yAxis, 'yAxis');
	        theme.series = this._createComponentThemeWithSeriesName(seriesTypes, rawTheme.series, theme.series, 'series');
	
	        this._setSeriesColors(seriesTypes, theme.series, rawTheme.series, rawSeriesData, isColorByPoint);
	
	        return theme;
	    },
	
	
	    /**
	     * Create target themes for font inherit.
	     * @param {object} theme - theme
	     * @returns {Array.<object>}
	     * @private
	     */
	    _createTargetThemesForFontInherit: function _createTargetThemesForFontInherit(theme) {
	        var items = [theme.title, theme.xAxis.title, theme.xAxis.label, theme.legend.label, theme.plot.label];
	
	        _tuiCodeSnippet2['default'].forEach(theme.yAxis, function (_theme) {
	            items.push(_theme.title, _theme.label);
	        });
	
	        _tuiCodeSnippet2['default'].forEach(theme.series, function (_theme) {
	            items.push(_theme.label);
	        });
	
	        return items;
	    },
	
	
	    /**
	     * Inherit theme font.
	     * @param {object} theme theme
	     * @private
	     */
	    _inheritThemeFont: function _inheritThemeFont(theme) {
	        var targetThemes = this._createTargetThemesForFontInherit(theme);
	        var baseFont = theme.chart.fontFamily;
	
	        targetThemes.forEach(function (item) {
	            if (!item.fontFamily) {
	                item.fontFamily = baseFont;
	            }
	        });
	    },
	
	
	    /**
	     * Copy color theme to otherTheme from seriesTheme.
	     * @param {object} seriesTheme - series theme
	     * @param {object} otherTheme - other theme
	     * @param {object} seriesType - series name
	     * @private
	     */
	    _copySeriesColorTheme: function _copySeriesColorTheme(seriesTheme, otherTheme, seriesType) {
	        otherTheme[seriesType] = {
	            colors: seriesTheme.colors,
	            borderColor: seriesTheme.borderColor,
	            selectionColor: seriesTheme.selectionColor
	        };
	    },
	
	
	    /**
	     * Copy series color theme to other components.
	     * @param {object} theme theme
	     * @private
	     * @ignore
	     */
	    _copySeriesColorThemeToOther: function _copySeriesColorThemeToOther(theme) {
	        var _this4 = this;
	
	        _tuiCodeSnippet2['default'].forEach(theme.series, function (seriesTheme, seriesType) {
	            _this4._copySeriesColorTheme(seriesTheme, theme.legend, seriesType);
	            _this4._copySeriesColorTheme(seriesTheme, theme.tooltip, seriesType);
	        });
	    },
	
	
	    /**
	     * Get theme.
	     * @param {string} themeName - theme name
	     * @param {string} chartType - chart type
	     * @param {object} rawSeriesData - raw series data
	     * @param {boolean} isColorByPoint - check colorByPoint option
	     * @returns {object}
	     */
	    get: function get(themeName, chartType, rawSeriesData, isColorByPoint) {
	        var rawTheme = themes[themeName];
	
	        if (!rawTheme) {
	            throw new Error('Not exist ' + themeName + ' theme.');
	        }
	
	        var seriesTypes = this._pickSeriesNames(chartType, rawSeriesData);
	
	        var theme = this._initTheme(themeName, rawTheme, seriesTypes, rawSeriesData, isColorByPoint);
	
	        this._inheritThemeFont(theme, seriesTypes);
	        this._copySeriesColorThemeToOther(theme);
	
	        return theme;
	    }
	};

/***/ }),
/* 362 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var DEFAULT_COLOR = '#000000';
	var DEFAULT_BACKGROUND = '#ffffff';
	var DEFAULT_FONTWEIGHT = 'lighter';
	var DEFAULT_FONTFAMILY = 'Arial';
	var EMPTY = '';
	var DEFAULT_AXIS = {
	    tickColor: DEFAULT_COLOR,
	    title: {
	        fontSize: 11,
	        fontFamily: DEFAULT_FONTFAMILY,
	        color: '#bbbbbb',
	        fontWeight: 'bold'
	    },
	    label: {
	        fontSize: 11,
	        fontFamily: DEFAULT_FONTFAMILY,
	        color: '#333',
	        fontWeight: 'normal'
	    }
	};
	
	exports['default'] = {
	    chart: {
	        background: {
	            color: DEFAULT_BACKGROUND,
	            opacity: 1
	        },
	        fontFamily: DEFAULT_FONTFAMILY
	    },
	    title: {
	        fontSize: 18,
	        fontFamily: DEFAULT_FONTFAMILY,
	        color: DEFAULT_COLOR,
	        fontWeight: DEFAULT_FONTWEIGHT
	    },
	    yAxis: DEFAULT_AXIS,
	    xAxis: DEFAULT_AXIS,
	    plot: {
	        lineColor: '#000000',
	        background: '#ffffff',
	        label: {
	            fontSize: 11,
	            fontFamily: DEFAULT_FONTFAMILY,
	            color: '#888'
	        }
	    },
	    series: {
	        label: {
	            fontSize: 11,
	            fontFamily: DEFAULT_FONTFAMILY,
	            color: DEFAULT_COLOR,
	            fontWeight: DEFAULT_FONTWEIGHT
	        },
	        colors: ['#00a9ff', '#ffb840', '#ff5a46', '#00bd9f', '#785fff', '#f28b8c', '#989486', '#516f7d', '#29dbe3', '#dddddd'],
	        borderColor: EMPTY,
	        borderWidth: EMPTY,
	        selectionColor: EMPTY,
	        startColor: '#FFE98A',
	        endColor: '#D74177',
	        overColor: EMPTY,
	        dot: {
	            fillColor: EMPTY,
	            fillOpacity: 1,
	            strokeColor: EMPTY,
	            strokeOpacity: EMPTY,
	            strokeWidth: 0,
	            radius: 6,
	            hover: {
	                fillColor: EMPTY,
	                fillOpacity: 1,
	                strokeColor: '#fff',
	                strokeOpacity: 1,
	                strokeWidth: 4,
	                radius: 6
	            }
	        },
	        ranges: []
	    },
	    legend: {
	        label: {
	            fontSize: 11,
	            fontFamily: DEFAULT_FONTFAMILY,
	            color: '#333',
	            fontWeight: DEFAULT_FONTWEIGHT
	        }
	    },
	    tooltip: {},
	    chartExportMenu: {
	        backgroundColor: '#fff',
	        borderRadius: 0,
	        borderWidth: 1,
	        color: '#000'
	    }
	};

/***/ }),
/* 363 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	/**
	 * @fileoverview  Map Manager.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	var maps = {};
	
	exports["default"] = {
	    /**
	     * Get map data.
	     * @param {string} mapName map name
	     * @returns {Array} map data
	     */
	    get: function get(mapName) {
	        var data = maps[mapName];
	
	        if (!data) {
	            throw new Error("Not exist " + mapName + " map.");
	        }
	
	        return data;
	    },
	
	
	    /**
	     * Register Map.
	     * @param {string} mapName map name
	     * @param {Array} data map data
	     */
	    register: function register(mapName, data) {
	        maps[mapName] = data;
	    }
	};

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @fileoverview util for object
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
	
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Deep copy.
	 * @memberOf module:objectUtil
	 * @param {object|Array|*} origin - original data
	 * @returns {*}
	 */
	var deepCopy = function deepCopy(origin) {
	    var clone = void 0;
	
	    if (_tuiCodeSnippet2['default'].isArray(origin)) {
	        clone = [];
	        origin.forEach(function (value, index) {
	            clone[index] = deepCopy(value);
	        });
	    } else if (_tuiCodeSnippet2['default'].isFunction(origin) || _tuiCodeSnippet2['default'].isDate(origin)) {
	        clone = origin;
	    } else if (_tuiCodeSnippet2['default'].isObject(origin)) {
	        clone = {};
	
	        Object.entries(origin).forEach(function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2),
	                key = _ref2[0],
	                value = _ref2[1];
	
	            clone[key] = deepCopy(value);
	        });
	    } else {
	        clone = origin;
	    }
	
	    return clone;
	};
	
	/**
	 * util for object
	 * @module objectUtil
	 * @private */
	exports['default'] = {
	    deepCopy: deepCopy
	};

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Get series data from 2D array
	 * @param {Array.<Array>} table2DArray - extracted 2DArray from table element
	 * @returns {{
	 *     series: Array.<object>,
	 *     categories: Array.<string>
	 *         }}
	 * @private
	 */
	/**
	 * @fileOverview Series data importer
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	function getChartDataFrom2DArray(table2DArray) {
	    var chartData = void 0;
	
	    if (table2DArray.length > 0) {
	        chartData = {};
	        chartData.categories = [];
	        chartData.series = [];
	        chartData.categories = table2DArray.shift().slice(1);
	
	        table2DArray.forEach(function (tr) {
	            var seriesDatum = {
	                name: tr[0],
	                data: tr.slice(1)
	            };
	            chartData.series.push(seriesDatum);
	        });
	    }
	
	    return chartData;
	}
	
	/**
	 * Get pivoted second dimension array from table to use element.innerText
	 * @param {HTMLElement} tableElement - table element for extract chart's raw data
	 * @returns {Array.<Array>}
	 * @private
	 */
	function get2DArray(tableElement) {
	    var resultArray = [];
	
	    if (tableElement) {
	        var secondDimensionArray = [];
	        var trs = _tuiCodeSnippet2['default'].toArray(tableElement.getElementsByTagName('TR'));
	
	        _tuiCodeSnippet2['default'].forEach(trs, function (tr, index) {
	            var tagName = index === 0 ? 'TH' : 'TD';
	            var cells = _tuiCodeSnippet2['default'].toArray(tr.getElementsByTagName(tagName));
	            var rows = _tuiCodeSnippet2['default'].pluck(cells, 'innerText');
	
	            secondDimensionArray.push(rows);
	        });
	
	        if (secondDimensionArray[0].length < secondDimensionArray[1].length) {
	            secondDimensionArray[0].unshift('');
	        }
	
	        resultArray = _arrayUtil2['default'].pivot(secondDimensionArray);
	    }
	
	    return resultArray;
	}
	
	/**
	 * Make chart data with table element
	 * @param {({
	 *     elementId:string
	 * }|{
	 *     element:HTMLElement
	 * })} table - object for table data import
	 * @returns {rawData}
	 * @ignore
	 * @api
	 */
	function makeDataWithTable(table) {
	    var element = void 0;
	
	    if (table.element && table.element.tagName === 'TABLE') {
	        element = table.element;
	    } else if (table.elementId) {
	        element = document.getElementById(table.elementId);
	    }
	
	    var chartData = getChartDataFrom2DArray(get2DArray(element));
	
	    return chartData;
	}
	
	exports['default'] = {
	    makeDataWithTable: makeDataWithTable
	};

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * Get raphael paper
	 * @param {HTMLElement} container container element
	 * @param {{width:number, height:number}} dimension dimension
	 * @returns {object}
	 * @private
	 */
	
	/**
	 * Renderers
	 * @type {object}
	 * @ignore
	 */
	var renderers = {
	    DOM: function DOM(container) {
	        var paper = _domHandler2['default'].create('DIV');
	        _domHandler2['default'].append(container, paper);
	
	        return paper;
	    }
	};
	
	var DrawingToolPicker = function () {
	    function DrawingToolPicker() {
	        _classCallCheck(this, DrawingToolPicker);
	    }
	
	    /**
	     * DrawingToolPicker initializer
	     * @param {{width:number, height:number}} dimension dimension
	     * @ignore
	     */
	    DrawingToolPicker.prototype.initDimension = function initDimension(dimension) {
	        this.dimension = dimension;
	    };
	
	    /**
	     * Get drawing tool paper
	     * @param {HTMLElement} container container element
	     * @param {string} rendererType component renderer type
	     * @returns {HTMLElement|object}
	     * @ignore
	     */
	
	
	    DrawingToolPicker.prototype.getPaper = function getPaper(container, rendererType) {
	        var paper = this[rendererType + 'Paper'];
	        var isNeedCreateNewPaper = _tuiCodeSnippet2['default'].isExisty(container) && paper && _domHandler2['default'].findParentByClass(paper.canvas, 'tui-chart') !== container;
	
	        if (!paper || isNeedCreateNewPaper) {
	            paper = renderers[rendererType].call(this, container, this.dimension);
	
	            if (rendererType !== 'DOM') {
	                this[rendererType + 'Paper'] = paper;
	            }
	        }
	
	        return paper;
	    };
	
	    /**
	     * Add renderer type
	     * @param {string} componentType component renderer type
	     * @param {function} callback callback function for get renderer's paper
	     */
	
	
	    DrawingToolPicker.addRendererType = function addRendererType(componentType, callback) {
	        renderers[componentType] = callback;
	    };
	
	    return DrawingToolPicker;
	}();
	
	exports['default'] = DrawingToolPicker;

/***/ }),
/* 367 */
/***/ (function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON
	// Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
	if (!window.JSON) {
	    window.JSON = {
	        parse: function parse(sJSON) {
	            return eval('(' + sJSON + ')');
	        },
	        stringify: function () {
	            var toString = Object.prototype.toString;
	            var isArray = Array.isArray || function (a) {
	                return toString.call(a) === '[object Array]';
	            };
	            var escMap = { '"': '\\"', '\\': '\\\\', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t' };
	            var escFunc = function escFunc(m) {
	                return escMap[m] || '\\u' + (m.charCodeAt(0) + 0x10000).toString(16).substr(1);
	            };
	            var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g;
	            return function stringify(value) {
	                if (value == null) {
	                    return 'null';
	                } else if (typeof value === 'number') {
	                    return isFinite(value) ? value.toString() : 'null';
	                } else if (typeof value === 'boolean') {
	                    return value.toString();
	                } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	                    if (typeof value.toJSON === 'function') {
	                        return stringify(value.toJSON());
	                    } else if (isArray(value)) {
	                        var res = '[';
	                        for (var i = 0; i < value.length; i++) {
	                            res += (i ? ', ' : '') + stringify(value[i]);
	                        }return res + ']';
	                    } else if (toString.call(value) === '[object Object]') {
	                        var tmp = [];
	                        for (var k in value) {
	                            if (value.hasOwnProperty(k)) tmp.push(stringify(k) + ': ' + stringify(value[k]));
	                        }
	                        return '{' + tmp.join(', ') + '}';
	                    }
	                }
	                return '"' + value.toString().replace(escRE, escFunc) + '"';
	            };
	        }()
	    };
	}
	
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
	// Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
	if (typeof Object.create != 'function') {
	    Object.create = function (undefined) {
	        var Temp = function Temp() {};
	        return function (prototype, propertiesObject) {
	            if (prototype !== Object(prototype) && prototype !== null) {
	                throw TypeError('Argument must be an object, or null');
	            }
	            Temp.prototype = prototype || {};
	            if (propertiesObject !== undefined) {
	                Object.defineProperties(Temp.prototype, propertiesObject);
	            }
	            var result = new Temp();
	            Temp.prototype = null;
	            // to imitate the case of Object.create(null)
	            if (prototype === null) {
	                result.__proto__ = null;
	            }
	            return result;
	        };
	    }();
	}
	
	// https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
	// Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
	if (!Array.isArray) {
	    Array.isArray = function (arg) {
	        return Object.prototype.toString.call(arg) === '[object Array]';
	    };
	}
	
	// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
	// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
	// MIT license
	
	(function () {
	    var lastTime = 0;
	    var vendors = ['ms', 'moz', 'webkit', 'o'];
	    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
	        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
	        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	    }
	
	    if (!window.requestAnimationFrame) {
	        window.requestAnimationFrame = function (callback) {
	            var currTime = new Date().getTime();
	            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	            var id = window.setTimeout(function () {
	                callback(currTime + timeToCall);
	            }, timeToCall);
	            lastTime = currTime + timeToCall;
	            return id;
	        };
	    }
	
	    if (!window.cancelAnimationFrame) {
	        window.cancelAnimationFrame = function (id) {
	            clearTimeout(id);
	        };
	    }
	})();

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _chartFactory = __webpack_require__(358);
	
	var _chartFactory2 = _interopRequireDefault(_chartFactory);
	
	var _barChart = __webpack_require__(369);
	
	var _barChart2 = _interopRequireDefault(_barChart);
	
	var _columnChart = __webpack_require__(451);
	
	var _columnChart2 = _interopRequireDefault(_columnChart);
	
	var _lineChart = __webpack_require__(452);
	
	var _lineChart2 = _interopRequireDefault(_lineChart);
	
	var _areaChart = __webpack_require__(454);
	
	var _areaChart2 = _interopRequireDefault(_areaChart);
	
	var _columnLineComboChart = __webpack_require__(455);
	
	var _columnLineComboChart2 = _interopRequireDefault(_columnLineComboChart);
	
	var _lineScatterComboChart = __webpack_require__(457);
	
	var _lineScatterComboChart2 = _interopRequireDefault(_lineScatterComboChart);
	
	var _lineAreaComboChart = __webpack_require__(458);
	
	var _lineAreaComboChart2 = _interopRequireDefault(_lineAreaComboChart);
	
	var _pieDonutComboChart = __webpack_require__(459);
	
	var _pieDonutComboChart2 = _interopRequireDefault(_pieDonutComboChart);
	
	var _pieChart = __webpack_require__(460);
	
	var _pieChart2 = _interopRequireDefault(_pieChart);
	
	var _bubbleChart = __webpack_require__(461);
	
	var _bubbleChart2 = _interopRequireDefault(_bubbleChart);
	
	var _scatterChart = __webpack_require__(462);
	
	var _scatterChart2 = _interopRequireDefault(_scatterChart);
	
	var _heatmapChart = __webpack_require__(463);
	
	var _heatmapChart2 = _interopRequireDefault(_heatmapChart);
	
	var _treemapChart = __webpack_require__(466);
	
	var _treemapChart2 = _interopRequireDefault(_treemapChart);
	
	var _mapChart = __webpack_require__(467);
	
	var _mapChart2 = _interopRequireDefault(_mapChart);
	
	var _radialChart = __webpack_require__(470);
	
	var _radialChart2 = _interopRequireDefault(_radialChart);
	
	var _boxplotChart = __webpack_require__(471);
	
	var _boxplotChart2 = _interopRequireDefault(_boxplotChart);
	
	var _bulletChart = __webpack_require__(472);
	
	var _bulletChart2 = _interopRequireDefault(_bulletChart);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_BAR, _barChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_COLUMN, _columnChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_LINE, _lineChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_AREA, _areaChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_COLUMN_LINE_COMBO, _columnLineComboChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_LINE_SCATTER_COMBO, _lineScatterComboChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_LINE_AREA_COMBO, _lineAreaComboChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_PIE_DONUT_COMBO, _pieDonutComboChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_PIE, _pieChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_BUBBLE, _bubbleChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_SCATTER, _scatterChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_HEATMAP, _heatmapChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_TREEMAP, _treemapChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_MAP, _mapChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_RADIAL, _radialChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_BOXPLOT, _boxplotChart2['default']);
	_chartFactory2['default'].register(_const2['default'].CHART_TYPE_BULLET, _bulletChart2['default']);

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Bar chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var BarChart = function (_ChartBase) {
	    _inherits(BarChart, _ChartBase);
	
	    /**
	     * Bar chart.
	     * @constructs BarChart
	     * @extends ChartBase
	     * @mixes axisTypeMixer
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function BarChart(rawData, theme, options) {
	        _classCallCheck(this, BarChart);
	
	        _rawDataHandler2['default'].updateRawSeriesDataByOptions(rawData, options.series);
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true
	        }));
	
	        _this.className = 'tui-bar-chart';
	
	        _this._updateOptionsRelatedDiverging();
	        return _this;
	    }
	
	    /**
	     * Update options related diverging option.
	     * @private
	     */
	
	
	    BarChart.prototype._updateOptionsRelatedDiverging = function _updateOptionsRelatedDiverging() {
	        var options = this.options; // eslint-disable-line
	
	        options.series = options.series || {};
	        if (options.series.diverging) {
	            options.yAxis = options.yAxis || {};
	            options.xAxis = options.xAxis || {};
	            options.plot = options.plot || {};
	
	            options.series.stackType = options.series.stackType || _const2['default'].NORMAL_STACK_TYPE;
	
	            var isCenter = _predicate2['default'].isYAxisAlignCenter(this.hasRightYAxis, options.yAxis.align);
	
	            options.yAxis.isCenter = isCenter;
	            options.xAxis.divided = isCenter;
	            options.series.divided = isCenter;
	            options.plot.divided = isCenter;
	        }
	    };
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    BarChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('barSeries', 'barSeries');
	
	        this.componentManager.register('yAxis', 'axis');
	        this.componentManager.register('xAxis', 'axis');
	
	        if (this.hasRightYAxis) {
	            this.componentManager.register('rightYAxis', 'axis');
	        }
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{xAxis: boolean}}
	     * @override
	     */
	
	
	    BarChart.prototype.getScaleOption = function getScaleOption() {
	        return {
	            xAxis: true
	        };
	    };
	
	    /**
	     * On change selected legend.
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @ignore
	     */
	
	
	    BarChart.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
	        var boundParams = void 0;
	
	        if (this.hasRightYAxis) {
	            boundParams = {
	                optionChartTypes: ['bar', 'bar']
	            };
	        }
	        _chartBase2['default'].prototype.onChangeCheckedLegends.call(this, checkedLegends, null, boundParams);
	    };
	
	    /**
	     * Add data ratios.
	     * modified from axisTypeMixer
	     * @override
	     */
	
	
	    BarChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        var _options$series = this.options.series,
	            seriesOption = _options$series === undefined ? {} : _options$series,
	            chartType = this.chartType;
	
	        var _ref = seriesOption[chartType] || seriesOption,
	            stackType = _ref.stackType;
	
	        this.dataProcessor.addDataRatios(limitMap[chartType], stackType, chartType);
	    };
	
	    return BarChart;
	}(_chartBase2['default']);
	
	exports['default'] = BarChart;

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _componentManager = __webpack_require__(371);
	
	var _componentManager2 = _interopRequireDefault(_componentManager);
	
	var _dataProcessor = __webpack_require__(428);
	
	var _dataProcessor2 = _interopRequireDefault(_dataProcessor);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _objectUtil = __webpack_require__(364);
	
	var _objectUtil2 = _interopRequireDefault(_objectUtil);
	
	var _boundsAndScaleBuilder = __webpack_require__(439);
	
	var _boundsAndScaleBuilder2 = _interopRequireDefault(_boundsAndScaleBuilder);
	
	var _themeManager = __webpack_require__(361);
	
	var _themeManager2 = _interopRequireDefault(_themeManager);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview ChartBase
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var GA_TRACKING_ID = 'UA-129983528-1';
	
	/** Class representing a point. */
	
	var ChartBase = function () {
	    /**
	     * Chart base.
	     * @constructs ChartBase
	     * @param {object} params parameters
	     *      @param {object} params.rawData raw data
	     *      @param {object} params.theme chart theme
	     *      @param {object} params.options chart options
	     *      @param {boolean} params.hasAxes whether has axes or not
	     *      @param {boolean} params.isVertical whether vertical or not
	     *      @param {DataProcessor} params.DataProcessor DataProcessor
	     */
	    function ChartBase(params) {
	        _classCallCheck(this, ChartBase);
	
	        /**
	         * theme
	         * @type {object}
	         * @ignore
	         */
	        this.theme = params.theme;
	
	        if (params.seriesTypes) {
	            this.seriesTypes = params.seriesTypes;
	        }
	
	        if (params.chartTypes) {
	            this.chartTypes = params.chartTypes;
	        }
	
	        /**
	         * chart original options
	         * @type {string}
	         * @ignore
	         */
	        this.originalOptions = _objectUtil2['default'].deepCopy(params.options);
	
	        this._initializeOptions(params.options);
	
	        /**
	         * chart type
	         * @type {string}
	         */
	        this.chartType = this.options.chartType;
	
	        /**
	         * whether chart has axes or not
	         * @type {boolean}
	         * @ignore
	         */
	        this.hasAxes = params.hasAxes;
	
	        /**
	         * whether vertical or not
	         * @type {boolean}
	         * @ignore
	         */
	        this.isVertical = !!params.isVertical;
	
	        /**
	         * data processor
	         * @type {DataProcessor}
	         * @ignore
	         */
	        this.dataProcessor = this._createDataProcessor(params);
	
	        /**
	         * event bus for transmitting message
	         * @type {object}
	         * @ignore
	         */
	        this.eventBus = new _tuiCodeSnippet2['default'].CustomEvents();
	
	        /**
	         * previous xAxis data
	         * @type {null|object}
	         * @ignore
	         */
	        this.prevXAxisData = null;
	
	        /**
	         * component manager
	         * @type {ComponentManager}
	         * @ignore
	         */
	        this.componentManager = this._createComponentManager();
	
	        /**
	         * Whether has right y axis or not.
	         * @type {boolean}
	         * @ignore
	         */
	        this.hasRightYAxis = _tuiCodeSnippet2['default'].isArray(this.options.yAxis) && this.options.yAxis.length > 1;
	
	        this.addComponents();
	
	        this._attachToEventBus();
	
	        if (this.options.usageStatistics) {
	            _tuiCodeSnippet2['default'].sendHostname('chart', GA_TRACKING_ID);
	        }
	    }
	
	    /**
	     * get on select series function
	     * @param {{legendIndex: number, index: number}} indexInfo - selected indexes
	     * @param {?boolean} shouldSelect - whether should select or not
	     * @api
	     * @example
	     * chart.selectSeries({legendIndex: 0, index: 0}, true);
	     */
	
	
	    ChartBase.prototype.selectSeries = function selectSeries(_ref) {
	        var index = _ref.legendIndex,
	            groupIndex = _ref.index;
	        var shouldSelect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	        this.componentManager.get('mouseEventDetector').selectSeries({
	            chartType: this.chartType,
	            indexes: {
	                groupIndex: groupIndex,
	                index: index
	            } }, shouldSelect);
	    };
	
	    /**
	     * get on deselect series function
	     * @api
	     * @example
	     * chart.unselectSeries();
	     */
	
	
	    ChartBase.prototype.unselectSeries = function unselectSeries() {
	        this.componentManager.get('mouseEventDetector').unselectSeries();
	    };
	
	    /**
	     * Attach to event bus.
	     * @private
	     */
	
	
	    ChartBase.prototype._attachToEventBus = function _attachToEventBus() {
	        this.eventBus.on('changeCheckedLegends', this.onChangeCheckedLegends, this);
	
	        if (this.onZoom) {
	            this.eventBus.on({
	                zoom: this.onZoom,
	                resetZoom: this.onResetZoom
	            }, this);
	        }
	    };
	
	    /**
	     * Set offset property
	     * @param {{offset: object}} options - options
	     * @param {string} fromProperty - from property name
	     * @param {string} toProperty - to property name
	     * @private
	     */
	
	
	    ChartBase.prototype._setOffsetProperty = function _setOffsetProperty(options, fromProperty, toProperty) {
	        if (!_tuiCodeSnippet2['default'].isExisty(options[fromProperty])) {
	            return;
	        }
	
	        options.offset = options.offset || {};
	        options.offset[toProperty] = options[fromProperty];
	        delete options[fromProperty];
	    };
	
	    /**
	     * Initialize offset.
	     * @param {{offsetX: ?number, offsetY: ?number}} options - offset options
	     * @private
	     */
	
	
	    ChartBase.prototype._initializeOffset = function _initializeOffset(options) {
	        if (!options) {
	            return;
	        }
	
	        this._setOffsetProperty(options, 'offsetX', 'x');
	        this._setOffsetProperty(options, 'offsetY', 'y');
	    };
	
	    /**
	     * Initialize title options.
	     * @param {
	     *      Array.<{title: (string | {text: string, offsetX: number, offsetY: number})}> |
	     *      {title: (string | {text: string, offsetX: number, offsetY: number})}
	     * } targetOptions - target options
	     * @private
	     */
	
	
	    ChartBase.prototype._initializeTitleOptions = function _initializeTitleOptions(targetOptions) {
	        var _this = this;
	
	        if (!targetOptions) {
	            return;
	        }
	
	        var optionsSet = _tuiCodeSnippet2['default'].isArray(targetOptions) ? targetOptions : [targetOptions];
	        optionsSet.forEach(function (options) {
	            var title = options.title;
	
	
	            if (_tuiCodeSnippet2['default'].isString(title)) {
	                options.title = {
	                    text: title
	                };
	            }
	
	            _this._initializeOffset(options.title);
	        });
	    };
	
	    /**
	     * Initialize tooltip options.
	     * @param {{grouped: ?boolean, offsetX: ?number, offsetY: ?number}} options - tooltip options
	     * @private
	     */
	
	
	    ChartBase.prototype._initializeTooltipOptions = function _initializeTooltipOptions(options) {
	        options.grouped = !!options.grouped;
	        this._initializeOffset(options);
	
	        delete options.position;
	    };
	
	    /**
	     * Initialize options.
	     * @param {object} options - options for chart
	     * @private
	     */
	
	
	    ChartBase.prototype._initializeOptions = function _initializeOptions(options) {
	        var originalOptions = _objectUtil2['default'].deepCopy(options);
	        var defaultOption = {
	            chartTypes: this.charTypes,
	            xAxis: {},
	            series: {},
	            tooltip: {},
	            usageStatistics: true,
	            chartExportMenu: Object.assign({
	                visible: true
	            }, originalOptions.chartExportMenu),
	            legend: Object.assign({
	                visible: true
	            }, originalOptions.legend)
	        };
	        delete originalOptions.chartExportMenu;
	        delete originalOptions.legend;
	
	        Object.assign(options, defaultOption, originalOptions);
	
	        this._initializeTitleOptions(options.chart);
	        this._initializeTitleOptions(options.xAxis);
	        this._initializeTitleOptions(options.yAxis);
	        this._initializeTooltipOptions(options.tooltip);
	
	        this.options = options;
	    };
	
	    /**
	     * Create dataProcessor for processing raw data.
	     * @param {object} params parameters
	     *      @param {object} params.rawData - raw data
	     *      @param {DataProcessor} params.DataProcessor - DataProcessor class
	     *      @param {{chart: object, chartType: string}} params.options - chart options
	     *      @param {Array} params.seriesTypes series - chart types for rendering series
	     * @returns {object} data processor
	     * @private
	     */
	
	
	    ChartBase.prototype._createDataProcessor = function _createDataProcessor(params) {
	        var DataProcessor = params.DataProcessor || _dataProcessor2['default'];
	        var dataProcessor = new DataProcessor(params.rawData, this.chartType, params.options, this.seriesTypes);
	
	        return dataProcessor;
	    };
	
	    /**
	     * Create ComponentManager.
	     * @returns {ComponentManager}
	     * @private
	     */
	
	
	    ChartBase.prototype._createComponentManager = function _createComponentManager() {
	        return new _componentManager2['default']({
	            options: this.options,
	            theme: this.theme,
	            dataProcessor: this.dataProcessor,
	            hasAxes: this.hasAxes,
	            eventBus: this.eventBus,
	            isVertical: this.isVertical,
	            seriesTypes: this.seriesTypes || [this.chartType]
	        });
	    };
	
	    /**
	     * Add components.
	     * @abstract
	     * @ignore
	     */
	
	
	    ChartBase.prototype.addComponents = function addComponents() {};
	
	    /**
	     * Get scale option.
	     * @abstract
	     * @ignore
	     */
	
	
	    ChartBase.prototype.getScaleOption = function getScaleOption() {};
	
	    /**
	     * Build bounds and scale data.
	     * @param {object} prevXAxisData - previous xAxis data
	     * @param {boolean} addingDataMode - whether adding data mode or not
	     * @returns {{
	     *      layoutBounds: {
	     *          dimensionMap: {
	     *              xAxis: {width: number, height: number},
	     *              yAxis: {width: number, height: number},
	     *              rightYAxis: {width: number, height: number},
	     *              series: {width: number, height: number},
	     *              extendedSeries: {width: number, height: number},
	     *              mouseEventDetector: {width: number, height: number},
	     *              legend: {width: number, height: number},
	     *              tooltip: {width: number, height: number}
	     *          },
	     *          positionMap: {
	     *              xAxis: {left: number, top: number},
	     *              yAxis: {left: number, top: number},
	     *              rightYAxis: {left: number, top: number},
	     *              series: {left: number, top: number},
	     *              extendedSeries: {left: number, top: number},
	     *              mouseEventDetector: {left: number, top: number},
	     *              legend: {left: number, top: number},
	     *              tooltip: {left: number, top: number}
	     *          }
	     *      },
	     *      limitMap: {
	     *          xAxis: {min: number, max: number},
	     *          yAxis: {min: number, max: number}
	     *      },
	     *      axisDataMap: {
	     *          xAxis: object,
	     *          yAxis: object,
	     *          yRightAxis: object
	     *      },
	     *      maxRadius: ?number
	     * }}
	     * @private
	     */
	
	
	    ChartBase.prototype._buildBoundsAndScaleData = function _buildBoundsAndScaleData(prevXAxisData, addingDataMode) {
	        return _boundsAndScaleBuilder2['default'].build(this.dataProcessor, this.componentManager, {
	            chartType: this.chartType,
	            seriesTypes: this.seriesTypes,
	            options: this.options,
	            theme: this.theme,
	            hasAxes: this.hasAxes,
	            scaleOption: this.getScaleOption(),
	            isVertical: this.isVertical,
	            hasRightYAxis: this.hasRightYAxis,
	            addedDataCount: this._dynamicDataHelper ? this._dynamicDataHelper.addedDataCount : null,
	            prevXAxisData: prevXAxisData,
	            addingDataMode: addingDataMode
	        });
	    };
	
	    /**
	     * Add data ratios.
	     * @abstract
	     * @ignore
	     */
	
	
	    ChartBase.prototype.addDataRatios = function addDataRatios() {};
	
	    /**
	     * Make chart ready for render, it should be invoked before render, rerender, resize and zoom.
	     * @param {?boolean} addingDataMode - whether adding data mode or not
	     * @returns {object} Bounds and scale data
	     * @ignore
	     */
	
	
	    ChartBase.prototype.readyForRender = function readyForRender(addingDataMode) {
	        var boundsAndScale = this._buildBoundsAndScaleData(this.prevXAxisData, addingDataMode);
	
	        if (boundsAndScale.axisDataMap.xAxis) {
	            this.prevXAxisData = boundsAndScale.axisDataMap.xAxis;
	        }
	
	        this.addDataRatios(boundsAndScale.limitMap);
	
	        return boundsAndScale;
	    };
	
	    /**
	     * Render chart.
	     * @param {HTMLElement} wrapper chart wrapper element
	     * @ignore
	     */
	
	
	    ChartBase.prototype.render = function render(wrapper) {
	        var container = _domHandler2['default'].create('DIV', 'tui-chart ' + this.className);
	        var componentManager = this.componentManager,
	            dataProcessor = this.dataProcessor;
	
	        var seriesVisibilityMap = dataProcessor.getLegendVisibility();
	        var rawData = _rawDataHandler2['default'].filterCheckedRawData(dataProcessor.rawData, seriesVisibilityMap);
	        var raphaelPaper = componentManager.drawingToolPicker.getPaper(container, _const2['default'].COMPONENT_TYPE_RAPHAEL);
	
	        this.dataProcessor.initData(rawData);
	
	        raphaelPaper.changeChartBackgroundColor(this.theme.chart.background.color);
	        raphaelPaper.changeChartBackgroundOpacity(this.theme.chart.background.opacity);
	        _renderUtil2['default'].renderFontFamily(container, this.theme.chart.fontFamily);
	
	        _domHandler2['default'].append(wrapper, container);
	
	        var boundsAndScale = this.readyForRender();
	
	        _renderUtil2['default'].renderDimension(container, boundsAndScale.dimensionMap.chart);
	        componentManager.render('render', boundsAndScale, {
	            checkedLegends: seriesVisibilityMap
	        }, container);
	        this.chartContainer = container;
	        this.paper = raphaelPaper;
	    };
	
	    /**
	     * protectedRerender
	     * @param {{line: Array.<boolean>, column: Array.<boolean>}} checkedLegends checked legends
	     * @param {?object} rawData rawData
	     * @ignore
	     */
	
	
	    ChartBase.prototype.protectedRerender = function protectedRerender(checkedLegends, rawData) {
	        var dataProcessor = this.dataProcessor;
	
	
	        if (!rawData) {
	            rawData = _rawDataHandler2['default'].filterCheckedRawData(dataProcessor.getCurrentData(), checkedLegends);
	        }
	
	        this.dataProcessor.initData(rawData);
	
	        var boundsAndScale = this.readyForRender();
	
	        this.componentManager.render('rerender', boundsAndScale, { checkedLegends: checkedLegends }, this.chartContainer);
	    };
	
	    /**
	     * rerender
	     * @param {{column: Array.<string>, line: Array.<string>}} checkedLegends data that whether series has checked or not
	     * @param {object} rawData rawData
	     * @api
	     * @deprecated
	     */
	
	
	    ChartBase.prototype.rerender = function rerender(checkedLegends, rawData) {
	        checkedLegends = checkedLegends || this.getCheckedLegend();
	        rawData = rawData || this.dataProcessor.getOriginalRawData();
	
	        var seriesData = rawData.series;
	
	        rawData.series = Object.keys(seriesData).reduce(function (result, item) {
	            var series = seriesData[item];
	            var checkedInfo = checkedLegends[item];
	
	            result[item] = series.map(function (seriesItem, index) {
	                seriesItem.visible = checkedInfo[index];
	
	                return seriesItem;
	            });
	
	            return result;
	        }, {});
	
	        this.setData(rawData);
	    };
	
	    /**
	     * setData
	     * @param {object} rawData rawData
	     * @api
	     */
	
	
	    ChartBase.prototype.setData = function setData() {
	        var rawData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	        var data = this._initializeRawData(rawData);
	        var dataProcessor = this.dataProcessor;
	        var _options = this.options,
	            chartType = _options.chartType,
	            themeOptions = _options.theme;
	
	
	        dataProcessor.initData(data, true);
	
	        var theme = _themeManager2['default'].get(themeOptions, chartType, data.series);
	
	        this.theme = theme;
	        this.componentManager.presetBeforeRerender();
	        this.componentManager.presetForChangeData(theme);
	        this.protectedRerender(dataProcessor.getLegendVisibility());
	    };
	
	    /**
	     * Get checked indexes.
	     * @returns {{column: ?Array.<string>, line: ?Array.<string>}} object data that whether series has checked or not
	     * @api
	     */
	
	
	    ChartBase.prototype.getCheckedLegend = function getCheckedLegend() {
	        var componentManager = this.componentManager,
	            dataProcessor = this.dataProcessor;
	
	        var hasLegendComponent = componentManager.has('legend');
	
	        return hasLegendComponent ? componentManager.get('legend').getCheckedIndexes() : dataProcessor.getLegendVisibility();
	    };
	
	    /**
	     * initialize rawData
	     * @param {object} rawData rawData
	     * @returns {object} - remaked rawData
	     * @private
	     */
	
	
	    ChartBase.prototype._initializeRawData = function _initializeRawData(rawData) {
	        var data = _objectUtil2['default'].deepCopy(rawData);
	        var _originalOptions = this.originalOptions,
	            chartType = _originalOptions.chartType,
	            seriesOption = _originalOptions.series;
	
	
	        if (chartType !== 'combo' && _tuiCodeSnippet2['default'].isArray(data.series)) {
	            var clonedSeries = data.series;
	            data.series = {};
	            data.series[chartType] = clonedSeries;
	        }
	
	        _rawDataHandler2['default'].updateRawSeriesDataByOptions(data, seriesOption);
	
	        if (chartType === 'boxplot') {
	            _rawDataHandler2['default'].appendOutliersToSeriesData(data);
	        }
	
	        return data;
	    };
	
	    /**
	     * On change checked legend.
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @param {?object} rawData rawData
	     * @param {?object} boundsParams addition params for calculating bounds
	     * @ignore
	     */
	
	
	    ChartBase.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends, rawData, boundsParams) {
	        this.protectedRerender(checkedLegends, rawData, boundsParams);
	    };
	
	    /**
	     * Animate chart.
	     * @ignore
	     */
	
	
	    ChartBase.prototype.animateChart = function animateChart() {
	        this.componentManager.execute('animateComponent');
	    };
	
	    /**
	     * Register of user event.
	     * @param {string} eventName event name
	     * @param {function} func event callback
	     * @api
	     */
	
	
	    ChartBase.prototype.on = function on(eventName, func) {
	        /**
	         * Select legend event
	         * @event ChartBase#selectLegend
	         * @param {object} info selected legend info
	         *   @param {string} legend legend name
	         *   @param {string} chartType chart type
	         *   @param {number} index selected legend index
	         * @api
	         * @example
	         * chart.on('selectLegend', function(info) {
	         *     console.log(info);
	         * });
	         */
	
	        /**
	         * Select series event
	         * @event ChartBase#selectSeries
	         * @param {object} info selected series info
	         *   @param {string} legend legend name
	         *   @param {string} chartType chart type
	         *   @param {number} legendIndex selected legend index
	         *   @param {number} index selected category index
	         * @api
	         * @example
	         * chart.on('selectSeries', function(info) {
	         *     console.log(info);
	         * });
	         */
	
	        /**
	         * unselect series event
	         * @event ChartBase#unselectSeries
	         * @param {object} info unselected series info
	         *   @param {string} legend legend name
	         *   @param {string} chartType chart type
	         *   @param {number} legendIndex selected legend index
	         *   @param {number} index selected category index
	         * @api
	         * @example
	         * chart.on('unselectSeries', function(info) {
	         *     console.log(info);
	         * });
	         */
	
	        /**
	         * before show tooltip event
	         * @event ChartBase#beforeShowTooltip
	         * @param {object} info target series info
	         *   @param {string} legend legend name
	         *   @param {string} chartType chart type
	         *   @param {number} legendIndex target legend index
	         *   @param {number} index target category index
	         * @api
	         * @example
	         * chart.on('beforeShowTooltip', function(info) {
	         * });
	         */
	
	        /**
	         * after show tooltip event
	         * @event ChartBase#afterShowTooltip
	         * @param {object} info target series info
	         *   @param {string} legend legend name
	         *   @param {string} chartType chart type
	         *   @param {number} legendIndex target legend index
	         *   @param {number} index target category index
	         *   @param {HTMLElement} element tooltip element
	         *   @param {object} position tooltip position
	         *     @param {number} left tooltip left position
	         *     @param {number} top tooltip left position
	         * @api
	         * @example
	         * chart.on('afterShowTooltip', function(info) {
	         *    console.log(info);
	         * });
	         */
	
	        /**
	         * before hide tooltip event
	         * @event ChartBase#beforeHideTooltip
	         * @api
	         * @example
	         * chart.on('beforeHideTooltip', function() {
	         *     // Create a task at the time of the event.
	         * });
	         */
	
	        /**
	         * change checked legend event
	         * @event ChartBase#changeCheckedLegends
	         * @param {object.<string, array>} info `checked` information that matches the chart type.
	         * @api
	         * @example
	         * chart.on('changeCheckedLegends', function(info) {
	         *    console.log(info);
	         * });
	         */
	
	        /**
	         * Register of user event.
	         * @event MapChart#zoom
	         * @param {string} magnification zoom ratio
	         * @api
	         * @example
	         * chart.on('zoom', function(magnification) {
	         *    console.log(magnification);
	         * });
	         */
	
	        if (_const2['default'].PUBLIC_EVENT_MAP[eventName]) {
	            this.eventBus.on(_const2['default'].PUBLIC_EVENT_PREFIX + eventName, func);
	        }
	    };
	
	    /**
	     * Remove user event.
	     * @param {string} eventName event name
	     * @param {function} func event callback
	     * @ignore
	     */
	
	
	    ChartBase.prototype.off = function off(eventName, func) {
	        if (_const2['default'].PUBLIC_EVENT_MAP[eventName]) {
	            this.eventBus.off(_const2['default'].PUBLIC_EVENT_PREFIX + eventName, func);
	        }
	    };
	
	    /**
	     * Update dimension of chart.
	     * @param {{width: number, height: number}} dimension dimension
	     * @returns {boolean} whether updated or not
	     * @private
	     */
	
	
	    ChartBase.prototype._updateChartDimension = function _updateChartDimension(dimension) {
	        var updated = false;
	        var options = this.options;
	
	
	        options.chart = options.chart || {};
	
	        if (dimension.width && dimension.width > 0 && options.chart.width !== dimension.width) {
	            options.chart.width = dimension.width;
	            updated = true;
	        }
	
	        if (dimension.height && dimension.height > 0 && options.chart.height !== dimension.height) {
	            options.chart.height = dimension.height;
	            updated = true;
	        }
	
	        return updated;
	    };
	
	    /**
	     * Public API for resizable.
	     * @param {object} dimension dimension
	     *      @param {number} dimension.width width
	     *      @param {number} dimension.height height
	     * @api
	     */
	
	
	    ChartBase.prototype.resize = function resize(dimension) {
	        var dataProcessor = this.dataProcessor;
	
	        var seriesVisibilityMap = dataProcessor.getLegendVisibility();
	
	        if (!dimension) {
	            return;
	        }
	
	        var updated = this._updateChartDimension(dimension);
	
	        if (!updated) {
	            return;
	        }
	
	        var boundsAndScale = this.readyForRender();
	        var chartDimension = boundsAndScale.dimensionMap.chart;
	
	        _renderUtil2['default'].renderDimension(this.chartContainer, chartDimension);
	        this.paper.resizeBackground(chartDimension.width, chartDimension.height);
	        this.paper.setSize(chartDimension.width, chartDimension.height);
	
	        this.componentManager.render('resize', boundsAndScale, {
	            checkedLegends: seriesVisibilityMap
	        });
	    };
	
	    /**
	     * Set tooltip align option.
	     * @param {string} align align (left|center|right, top|middle|bottom)
	     * @api
	     */
	
	
	    ChartBase.prototype.setTooltipAlign = function setTooltipAlign(align) {
	        this.componentManager.get('tooltip').setAlign(align);
	    };
	
	    /**
	     * Set tooltip offset option.
	     * @param {object} offset - tooltip offset
	     *      @param {number} offset.x - offset x
	     *      @param {number} offset.y - offset y
	     * @api
	     */
	
	
	    ChartBase.prototype.setTooltipOffset = function setTooltipOffset(offset) {
	        this.componentManager.get('tooltip').setOffset(offset);
	    };
	
	    /**
	     * Set position option.
	     * @param {object} position moving position
	     *      @param {number} position.left left
	     *      @param {number} position.top top
	     * @api
	     * @deprecated
	     */
	
	
	    ChartBase.prototype.setTooltipPosition = function setTooltipPosition(position) {
	        this.componentManager.get('tooltip').setPosition(position);
	    };
	
	    /**
	     * Reset tooltip align option.
	     * @api
	     */
	
	
	    ChartBase.prototype.resetTooltipAlign = function resetTooltipAlign() {
	        this.componentManager.get('tooltip').resetAlign();
	    };
	
	    /**
	     * Reset tooltip position.
	     * @api
	     */
	
	
	    ChartBase.prototype.resetTooltipOffset = function resetTooltipOffset() {
	        this.componentManager.get('tooltip').resetOffset();
	    };
	
	    /**
	     * Reset tooltip position.
	     * @api
	     * @deprecated
	     */
	
	
	    ChartBase.prototype.resetTooltipPosition = function resetTooltipPosition() {
	        this.resetTooltipOffset();
	    };
	
	    /**
	     * Show series label.
	     * @api
	     */
	
	
	    ChartBase.prototype.showSeriesLabel = function showSeriesLabel() {
	        var seriesSet = this.componentManager.where({ componentType: 'series' });
	
	        seriesSet.forEach(function (series) {
	            series.showLabel();
	        });
	    };
	
	    /**
	     * Hide series label.
	     * @api
	     */
	
	
	    ChartBase.prototype.hideSeriesLabel = function hideSeriesLabel() {
	        var seriesSet = this.componentManager.where({ componentType: 'series' });
	
	        seriesSet.forEach(function (series) {
	            series.hideLabel();
	        });
	    };
	
	    /**
	     * Add data.
	     * @abstract
	     */
	
	
	    ChartBase.prototype.addData = function addData() {};
	
	    /**
	     * Add plot line.
	     * @abstract
	     */
	
	
	    ChartBase.prototype.addPlotLine = function addPlotLine() {};
	
	    /**
	     * Add plot band.
	     * @abstract
	     */
	
	
	    ChartBase.prototype.addPlotBand = function addPlotBand() {};
	
	    /**
	     * Remove plot line.
	     * @abstract
	     */
	
	
	    ChartBase.prototype.removePlotLine = function removePlotLine() {};
	
	    /**
	     * Remove plot band.
	     * @abstract
	     */
	
	
	    ChartBase.prototype.removePlotBand = function removePlotBand() {};
	
	    /**
	     * Get series item bound by indexes
	     * @param {number} index - tooltip data's category index
	     * @param {number} seriesIndex - tooltip data's series index
	     * @param {number} [outlierIndex] - outlier index of tooltip, exists only hovered on boxplot chart's outlier point
	     *
	     * @returns {?object} - series item bound
	     * @private
	     */
	
	
	    ChartBase.prototype._getSeriesData = function _getSeriesData(index, seriesIndex, outlierIndex) {
	        var indexes = {
	            index: index,
	            seriesIndex: seriesIndex,
	            outlierIndex: outlierIndex
	        };
	
	        if (seriesIndex < 0) {
	            return null;
	        }
	
	        return this.componentManager.get('mouseEventDetector').findDataByIndexes(indexes);
	    };
	
	    /**
	     * find series index by legend label
	     * @param {string} chartType - chart tyoe
	     * @param {string} legendLabel - legend label
	     * @returns {number} - if not found return -1, else return found series index
	     * @private
	     */
	
	
	    ChartBase.prototype._findSeriesIndexByLabel = function _findSeriesIndexByLabel(chartType, legendLabel) {
	        var labels = this.dataProcessor.getLegendLabels(chartType);
	        var len = labels ? labels.length : 0;
	        var seriesIndex = -1;
	
	        for (var i = 0; i < len; i += 1) {
	            if (labels[i] === legendLabel) {
	                seriesIndex = i;
	                break;
	            }
	        }
	
	        return seriesIndex;
	    };
	
	    /**
	     * @param {number} index - category index
	     * @param {number} seriesIndex - series index
	     * @returns {object}
	     * @private
	     */
	
	
	    ChartBase.prototype._findDataByIndexes = function _findDataByIndexes(index, seriesIndex) {
	        return this.componentManager.get('mouseEventDetector').findDataByIndexes(index, seriesIndex);
	    };
	
	    /**
	     * show tooltip by index of series item
	     * @param {object} params - data needed for making a tooltip
	     * @ignore
	     */
	
	
	    ChartBase.prototype.showTooltip = function showTooltip(params) {
	        var foundSeriesIndex = void 0,
	            foundData = void 0;
	
	        if (!_predicate2['default'].isSupportPublicShowTooptipAPI(this.chartType)) {
	            return;
	        }
	
	        var isGroupTooltip = this.options.tooltip && this.options.tooltip.grouped;
	        var mouseEventDetector = this.componentManager.get('mouseEventDetector');
	
	        if (isGroupTooltip) {
	            foundData = { indexes: { groupIndex: params.index } };
	        } else {
	            foundSeriesIndex = this._findSeriesIndexByLabel(params.chartType, params.legend);
	            foundData = this._getSeriesData(params.index, foundSeriesIndex, params.outlierIndex);
	        }
	
	        if (foundData) {
	            foundData.silent = true;
	            mouseEventDetector._showTooltip(foundData);
	        } else {
	            this.hideTooltip();
	        }
	    };
	
	    /**
	     * hide tooltip
	     * @ignore
	     */
	
	
	    ChartBase.prototype.hideTooltip = function hideTooltip() {
	        if (!_predicate2['default'].isSupportPublicShowTooptipAPI(this.chartType)) {
	            return;
	        }
	
	        var isGroupTooltip = this.options.tooltip && this.options.tooltip.grouped;
	        var mouseEventDetector = this.componentManager.get('mouseEventDetector');
	
	        if (isGroupTooltip && mouseEventDetector.prevIndex >= 0 || !isGroupTooltip && mouseEventDetector.prevFoundData) {
	            mouseEventDetector._hideTooltip({ silent: true });
	        }
	    };
	
	    return ChartBase;
	}();
	
	exports['default'] = ChartBase;

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _axis = __webpack_require__(372);
	
	var _axis2 = _interopRequireDefault(_axis);
	
	var _plot = __webpack_require__(373);
	
	var _plot2 = _interopRequireDefault(_plot);
	
	var _title = __webpack_require__(374);
	
	var _title2 = _interopRequireDefault(_title);
	
	var _radialPlot = __webpack_require__(375);
	
	var _radialPlot2 = _interopRequireDefault(_radialPlot);
	
	var _chartExportMenu = __webpack_require__(377);
	
	var _chartExportMenu2 = _interopRequireDefault(_chartExportMenu);
	
	var _drawingToolPicker = __webpack_require__(366);
	
	var _drawingToolPicker2 = _interopRequireDefault(_drawingToolPicker);
	
	var _legend = __webpack_require__(383);
	
	var _legend2 = _interopRequireDefault(_legend);
	
	var _spectrumLegend = __webpack_require__(385);
	
	var _spectrumLegend2 = _interopRequireDefault(_spectrumLegend);
	
	var _circleLegend = __webpack_require__(386);
	
	var _circleLegend2 = _interopRequireDefault(_circleLegend);
	
	var _tooltip = __webpack_require__(387);
	
	var _tooltip2 = _interopRequireDefault(_tooltip);
	
	var _groupTooltip = __webpack_require__(393);
	
	var _groupTooltip2 = _interopRequireDefault(_groupTooltip);
	
	var _mapChartTooltip = __webpack_require__(395);
	
	var _mapChartTooltip2 = _interopRequireDefault(_mapChartTooltip);
	
	var _mapChartEventDetector = __webpack_require__(396);
	
	var _mapChartEventDetector2 = _interopRequireDefault(_mapChartEventDetector);
	
	var _mouseEventDetector = __webpack_require__(400);
	
	var _mouseEventDetector2 = _interopRequireDefault(_mouseEventDetector);
	
	var _barChartSeries = __webpack_require__(407);
	
	var _barChartSeries2 = _interopRequireDefault(_barChartSeries);
	
	var _columnChartSeries = __webpack_require__(411);
	
	var _columnChartSeries2 = _interopRequireDefault(_columnChartSeries);
	
	var _lineChartSeries = __webpack_require__(412);
	
	var _lineChartSeries2 = _interopRequireDefault(_lineChartSeries);
	
	var _radialSeries = __webpack_require__(414);
	
	var _radialSeries2 = _interopRequireDefault(_radialSeries);
	
	var _areaChartSeries = __webpack_require__(415);
	
	var _areaChartSeries2 = _interopRequireDefault(_areaChartSeries);
	
	var _bubbleChartSeries = __webpack_require__(416);
	
	var _bubbleChartSeries2 = _interopRequireDefault(_bubbleChartSeries);
	
	var _scatterChartSeries = __webpack_require__(418);
	
	var _scatterChartSeries2 = _interopRequireDefault(_scatterChartSeries);
	
	var _mapChartSeries = __webpack_require__(419);
	
	var _mapChartSeries2 = _interopRequireDefault(_mapChartSeries);
	
	var _pieChartSeries = __webpack_require__(420);
	
	var _pieChartSeries2 = _interopRequireDefault(_pieChartSeries);
	
	var _heatmapChartSeries = __webpack_require__(421);
	
	var _heatmapChartSeries2 = _interopRequireDefault(_heatmapChartSeries);
	
	var _treemapChartSeries = __webpack_require__(422);
	
	var _treemapChartSeries2 = _interopRequireDefault(_treemapChartSeries);
	
	var _boxPlotChartSeries = __webpack_require__(424);
	
	var _boxPlotChartSeries2 = _interopRequireDefault(_boxPlotChartSeries);
	
	var _bulletChartSeries = __webpack_require__(425);
	
	var _bulletChartSeries2 = _interopRequireDefault(_bulletChartSeries);
	
	var _zoom = __webpack_require__(426);
	
	var _zoom2 = _interopRequireDefault(_zoom);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview ComponentManager manages components of chart.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	// legends
	
	
	// tooltips
	
	
	// mouse event detectors
	
	
	// series
	
	
	var COMPONENT_FACTORY_MAP = {
	    axis: _axis2['default'],
	    plot: _plot2['default'],
	    radialPlot: _radialPlot2['default'],
	    legend: _legend2['default'],
	    spectrumLegend: _spectrumLegend2['default'],
	    circleLegend: _circleLegend2['default'],
	    tooltip: _tooltip2['default'],
	    groupTooltip: _groupTooltip2['default'],
	    mapChartTooltip: _mapChartTooltip2['default'],
	    mapChartEventDetector: _mapChartEventDetector2['default'],
	    mouseEventDetector: _mouseEventDetector2['default'],
	    barSeries: _barChartSeries2['default'],
	    columnSeries: _columnChartSeries2['default'],
	    lineSeries: _lineChartSeries2['default'],
	    radialSeries: _radialSeries2['default'],
	    areaSeries: _areaChartSeries2['default'],
	    bubbleSeries: _bubbleChartSeries2['default'],
	    scatterSeries: _scatterChartSeries2['default'],
	    mapSeries: _mapChartSeries2['default'],
	    pieSeries: _pieChartSeries2['default'],
	    heatmapSeries: _heatmapChartSeries2['default'],
	    treemapSeries: _treemapChartSeries2['default'],
	    boxplotSeries: _boxPlotChartSeries2['default'],
	    bulletSeries: _bulletChartSeries2['default'],
	    zoom: _zoom2['default'],
	    chartExportMenu: _chartExportMenu2['default'],
	    title: _title2['default']
	};
	
	var ComponentManager = function () {
	    /**
	     * ComponentManager manages components of chart.
	     * @param {object} params parameters
	     *      @param {object} params.theme - theme
	     *      @param {object} params.options - options
	     *      @param {DataProcessor} params.dataProcessor - data processor
	     *      @param {boolean} params.hasAxes - whether has axes or not
	     * @constructs ComponentManager
	     * @private
	     */
	    function ComponentManager(params) {
	        _classCallCheck(this, ComponentManager);
	
	        var chartOption = params.options.chart;
	        var width = _tuiCodeSnippet2['default'].pick(chartOption, 'width') || _const2['default'].CHART_DEFAULT_WIDTH;
	        var height = _tuiCodeSnippet2['default'].pick(chartOption, 'height') || _const2['default'].CHART_DEFAULT_HEIGHT;
	
	        /**
	         * Components
	         * @type {Array.<object>}
	         */
	        this.components = [];
	
	        /**
	         * componentFactory map.
	         * @type {object}
	         */
	        this.componentMap = {};
	
	        /**
	         * theme
	         * @type {object}
	         */
	        this.theme = params.theme || {};
	
	        /**
	         * options
	         * @type {object}
	         */
	        this.options = params.options || {};
	
	        /**
	         * data processor
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = params.dataProcessor;
	
	        /**
	         * whether chart has axes or not
	         * @type {boolean}
	         */
	        this.hasAxes = params.hasAxes;
	
	        /**
	         * whether chart is vertical or not
	         * @type {boolean}
	         */
	        this.isVertical = params.isVertical;
	
	        /**
	         * event bus for transmitting message
	         * @type {object}
	         */
	        this.eventBus = params.eventBus;
	
	        /**
	         * Drawing tool picker
	         * @type {object}
	         */
	        this.drawingToolPicker = new _drawingToolPicker2['default']();
	
	        this.drawingToolPicker.initDimension({
	            width: width,
	            height: height
	        });
	
	        /**
	         * seriesTypes of chart
	         * @type {Array.<string>}
	         */
	        this.seriesTypes = params.seriesTypes;
	    }
	
	    /**
	     * Make component options.
	     * @param {object} options options
	     * @param {string} optionKey component option key
	     * @param {string} componentName component name
	     * @param {number} index component index
	     * @returns {object} options
	     * @private
	     */
	
	
	    ComponentManager.prototype._makeComponentOptions = function _makeComponentOptions(options, optionKey, componentName, index) {
	        options = options || this.options[optionKey];
	        options = _tuiCodeSnippet2['default'].isArray(options) ? options[index] : options || {};
	
	        return options;
	    };
	
	    /**
	     * Register component.
	     * The component refers to a component of the chart.
	     * The component types are axis, legend, plot, series and mouseEventDetector.
	     * Chart Component Description : https://i-msdn.sec.s-msft.com/dynimg/IC267997.gif
	     * @param {string} name component name
	     * @param {string} classType component factory name
	     * @param {object} [params={}] optional params that for alternative charts
	     * @ignore
	     */
	
	
	    ComponentManager.prototype.register = function register(name, classType) {
	        var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	
	        var index = params.index || 0;
	        var componentFactory = COMPONENT_FACTORY_MAP[classType];
	        var componentType = componentFactory.componentType;
	
	
	        params.name = name;
	        params.chartTheme = this.theme;
	        params.chartOptions = this.options;
	        params.seriesTypes = this.seriesTypes;
	
	        var optionKey = this._getOptionKey(componentType, name);
	
	        params.theme = this._makeTheme(optionKey, name);
	        params.options = this._makeOptions(optionKey, name, index);
	
	        params.dataProcessor = this.dataProcessor;
	        params.hasAxes = this.hasAxes;
	        params.isVertical = this.isVertical;
	        params.eventBus = this.eventBus;
	
	        // alternative scale models for charts that do not use common scale models like maps
	        params.alternativeModel = this.alternativeModel;
	
	        var component = componentFactory(params);
	
	        // component creation can be refused by factory, according to option data
	        if (component) {
	            component.componentName = name;
	            component.componentType = componentType;
	
	            this.components.push(component);
	            this.componentMap[name] = component;
	        }
	    };
	
	    /**
	     * Preset before rerender
	     * This method is eliminating zoom buttons and tooltips, so only works with zoom supported charts.
	     */
	
	
	    ComponentManager.prototype.presetBeforeRerender = function presetBeforeRerender() {
	        if (this.componentMap.mouseEventDetector.zoomable) {
	            this.componentMap.mouseEventDetector.presetBeforeRerender();
	        }
	    };
	
	    /**
	     * Preset components for setData
	     * @param {object} theme theme object
	     * @ignore
	     */
	
	
	    ComponentManager.prototype.presetForChangeData = function presetForChangeData(theme) {
	        var _this = this;
	
	        this.theme = theme;
	        this.components.forEach(function (component) {
	            if (component.presetForChangeData) {
	                var componentType = component.componentType,
	                    componentName = component.componentName;
	
	                var optionKey = _this._getOptionKey(componentType, componentName);
	
	                component.presetForChangeData(_this._makeTheme(optionKey, componentName));
	            }
	        });
	    };
	
	    /**
	     * Make option
	     * @param {string} optionKey Key on which to create the option.
	     * @param {string} name name of component
	     * @param {number} index index of chart for series option
	     * @returns {object} option
	     * @private
	     */
	
	
	    ComponentManager.prototype._makeOptions = function _makeOptions(optionKey, name, index) {
	        var options = this.options[optionKey];
	
	        if (!options && optionKey === 'rightYAxis') {
	            options = this.options.yAxis;
	        }
	
	        if (optionKey === 'series') {
	            this.seriesTypes.forEach(function (seriesType) {
	                if (name.indexOf(seriesType) === 0) {
	                    options = options[seriesType] || options; // For combo chart, options are set for each chart
	
	                    if (_tuiCodeSnippet2['default'].isArray(options)) {
	                        options = options[index] || {};
	                    }
	
	                    return false;
	                }
	
	                return true;
	            });
	        }
	
	        return options;
	    };
	
	    /**
	     * Make option key
	     * @param {string} type type of component
	     * @param {name} name name of component
	     * @returns {string} optionKey Key on which to create the option.
	     * @private
	     */
	
	
	    ComponentManager.prototype._getOptionKey = function _getOptionKey(type, name) {
	        return type === 'axis' ? name : type;
	    };
	
	    /**
	     * Make theme
	     * @param {string} optionKey Key on which to create the option.
	     * @param {string} name name of component
	     * @returns {object} theme
	     * @private
	     */
	
	
	    ComponentManager.prototype._makeTheme = function _makeTheme(optionKey, name) {
	        var theme = this.theme[optionKey];
	
	        if (!theme && optionKey === 'rightYAxis') {
	            theme = this.theme.yAxis;
	        }
	
	        if (optionKey === 'series') {
	            this.seriesTypes.forEach(function (seriesType) {
	                if (name.indexOf(seriesType) === 0) {
	                    theme = theme[seriesType]; // For combo, single chart, themes are set for each chart
	
	                    return false;
	                }
	
	                return true;
	            });
	        }
	
	        return theme;
	    };
	
	    /**
	     * Make data for rendering.
	     * @param {string} name - component name
	     * @param {string} type - component type
	     * @param {object} paper - raphael object
	     * @param {{
	     *      layoutBounds: {
	     *          dimensionMap: object,
	     *          positionMap: object
	     *      },
	     *      limitMap: object,
	     *      axisDataMap: object,
	     *      maxRadius: ?number
	     * }} boundsAndScale - bounds and scale data
	     * @param {?object} additionalData - additional data
	     * @returns {object}
	     * @private
	     */
	
	
	    ComponentManager.prototype._makeDataForRendering = function _makeDataForRendering(name, type, paper, boundsAndScale, additionalData) {
	        var data = Object.assign({ paper: paper }, additionalData);
	
	        if (boundsAndScale) {
	            Object.assign(data, boundsAndScale);
	
	            data.layout = {
	                dimension: data.dimensionMap[name] || data.dimensionMap[type],
	                position: data.positionMap[name] || data.positionMap[type]
	            };
	        }
	
	        return data;
	    };
	
	    /**
	     * Render components.
	     * @param {string} funcName - function name for executing
	     * @param {{
	     *      layoutBounds: {
	     *          dimensionMap: object,
	     *          positionMap: object
	     *      },
	     *      limitMap: object,
	     *      axisDataMap: object,
	     *      maxRadius: ?number
	     * }} boundsAndScale - bounds and scale data
	     * @param {?object} additionalData - additional data
	     * @param {?HTMLElement} container - container
	     */
	
	
	    ComponentManager.prototype.render = function render(funcName, boundsAndScale, additionalData, container) {
	        var _this2 = this;
	
	        var elements = this.components.map(function (component) {
	            var element = null;
	
	            if (component[funcName]) {
	                var name = component.componentName;
	                var type = component.componentType;
	                var paper = _this2.drawingToolPicker.getPaper(container, component.drawingType);
	                var data = _this2._makeDataForRendering(name, type, paper, boundsAndScale, additionalData);
	
	                var result = component[funcName](data);
	
	                if (result && !result.paper) {
	                    element = result;
	                }
	            }
	
	            return element;
	        });
	
	        if (container) {
	            _domHandler2['default'].append(container, elements);
	        }
	    };
	
	    /**
	     * Find components to conditionMap.
	     * @param {object} conditionMap condition map
	     * @returns {Array.<object>} filtered components
	     */
	
	
	    ComponentManager.prototype.where = function where(conditionMap) {
	        return this.components.filter(function (component) {
	            var contained = true;
	
	            Object.entries(conditionMap).forEach(function (_ref) {
	                var _ref2 = _slicedToArray(_ref, 2),
	                    key = _ref2[0],
	                    value = _ref2[1];
	
	                if (component[key] !== value) {
	                    contained = false;
	                }
	
	                return contained;
	            });
	
	            return contained;
	        });
	    };
	
	    /**
	     * Execute components.
	     * @param {string} funcName - function name
	     */
	
	
	    ComponentManager.prototype.execute = function execute(funcName) {
	        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            args[_key - 1] = arguments[_key];
	        }
	
	        this.components.forEach(function (component) {
	            if (component[funcName]) {
	                component[funcName].apply(component, args);
	            }
	        });
	    };
	
	    /**
	     * Get component.
	     * @param {string} name component name
	     * @returns {object} component instance
	     */
	
	
	    ComponentManager.prototype.get = function get(name) {
	        return this.componentMap[name];
	    };
	
	    /**
	     * Whether has component or not.
	     * @param {string} name - comopnent name
	     * @returns {boolean}
	     */
	
	
	    ComponentManager.prototype.has = function has(name) {
	        return !!this.get(name);
	    };
	
	    return ComponentManager;
	}();
	
	exports['default'] = ComponentManager;

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = axisFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _pluginFactory = __webpack_require__(360);
	
	var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                          
	                                                                                                                                                           * @fileoverview  Axis component.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var AXIS_EDGE_RATIO = _const2['default'].AXIS_EDGE_RATIO,
	    X_AXIS_LABEL_PADDING = _const2['default'].X_AXIS_LABEL_PADDING,
	    COMPONENT_TYPE_RAPHAEL = _const2['default'].COMPONENT_TYPE_RAPHAEL;
	
	var Axis = function () {
	    /**
	     * Axis component.
	     * @constructs Axis
	     * @private
	     * @param {object} params parameters
	     *      @param {object} params.bound axis bound
	     *      @param {object} params.theme axis theme
	     *      @param {object} params.options axis options
	     *      @param {object} params.dataProcessor data processor of chart
	     *      @param {object} params.seriesType series type
	     *      @param {boolean} params.isYAxis boolean value for axis is vertical or not
	     */
	    function Axis(params) {
	        _classCallCheck(this, Axis);
	
	        /**
	         * Axis view className
	         * @type {string}
	         */
	        this.className = 'tui-chart-axis-area';
	
	        /**
	         * Data processor
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = params.dataProcessor;
	
	        /**
	         * Options
	         * @type {object}
	         */
	        this.options = params.options || {};
	
	        /**
	         * Axis Theme
	         * Use chart background theme object for render yAxis background on dynamicDataShifting chart
	         * @type {object}
	         */
	        this.theme = _tuiCodeSnippet2['default'].extend({}, params.theme, {
	            background: params.chartTheme.chart.background
	        });
	
	        /**
	         * Whether label type axis or not.
	         * @type {boolean}
	         */
	        this.isLabelAxis = false;
	
	        /**
	         * Whether vertical type or not.
	         * @type {boolean}
	         */
	        this.isYAxis = params.isYAxis;
	
	        /**
	         * Whether data dynamic shifting or not.
	         * @type {boolean}
	         */
	        this.shifting = params.shifting;
	
	        /**
	         * cached axis data
	         * @type {object}
	         */
	        this.data = {};
	
	        /**
	         * layout bounds information for this components
	         * @type {null|{dimension:{width:number, height:number}, position:{left:number, top:number, ?right:number}}}
	         */
	        this.layout = null;
	
	        /**
	         * dimension map for layout of chart
	         * @type {null|object}
	         */
	        this.dimensionMap = null;
	
	        /**
	         * axis data map
	         * @type {null|object}
	         */
	        this.axisDataMap = null;
	
	        /**
	         * Renderer
	         * @type {object}
	         */
	        this.graphRenderer = _pluginFactory2['default'].get(COMPONENT_TYPE_RAPHAEL, 'axis');
	
	        /**
	         * Drawing type
	         * @type {string}
	         */
	        this.drawingType = COMPONENT_TYPE_RAPHAEL;
	
	        /**
	         * Paper additional width
	         * @type {number}
	         */
	        this.paperAdditionalWidth = 0;
	
	        /** * Paper additional height
	         * @type {number}
	         */
	        this.paperAdditionalHeight = 0;
	
	        /**
	         * Raphael Element for axis background
	         * We should caching this for prevent making background multiply
	         * @type {Raphael.Element}
	         */
	        this._elBg = null;
	
	        this.isRightYAxis = params.name === 'rightYAxis';
	    }
	
	    /**
	     * Render vertical axis background
	     * @private
	     */
	
	
	    Axis.prototype._renderBackground = function _renderBackground() {
	        var dimension = Object.assign({}, this.layout.dimension);
	        var position = Object.assign({}, this.layout.position);
	
	        if (this._elBg) {
	            this._elBg.remove();
	        }
	
	        this._elBg = this.graphRenderer.renderBackground(this.paper, position, dimension, this.theme.background);
	    };
	
	    /**
	     * Render child containers like title area, label area and tick area.
	     * @param {number} size xAxis width or yAxis height
	     * @param {number} tickCount tick count
	     * @param {Array.<number|string>} categories categories
	     * @param {number} additionalWidth additional width
	     * @private
	     */
	
	
	    Axis.prototype._renderChildContainers = function _renderChildContainers(size, tickCount, categories) {
	        var additionalWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	
	        var isYAxisLineType = this.isYAxis && this.data.aligned;
	        var axisLimit = this.limitMap[this.dataProcessor.chartType];
	        var isNegativeLimitChart = !this.data.limit && axisLimit && axisLimit.min < 0;
	        var isBarChart = _predicate2['default'].isBarTypeChart(this.dataProcessor.chartType);
	        var seriesOption = this.dataProcessor.getOption('series') || {};
	        var isDivergingOption = seriesOption.diverging;
	
	        if (this.isYAxis && !this.data.isPositionRight && !this.options.isCenter && this.shifting) {
	            this._renderBackground();
	        }
	
	        this._renderTitleArea(size, additionalWidth);
	
	        if (this.options.showLabel !== false) {
	            this._renderLabelArea(size, tickCount, categories, additionalWidth);
	        }
	
	        if (!isYAxisLineType) {
	            this._renderTickArea(size, tickCount, additionalWidth);
	        }
	        if (isNegativeLimitChart && isBarChart && !isDivergingOption) {
	            this._renderNegativeStandardsLine(size, additionalWidth, this.dimensionMap.series, axisLimit);
	        }
	    };
	
	    /**
	     * Render divided xAxis if yAxis rendered in the center.
	     * @param {{width: number, height:number}} dimension axis area width and height
	     * @private
	     */
	
	
	    Axis.prototype._renderDividedAxis = function _renderDividedAxis(_ref) {
	        var width = _ref.width;
	        var _data = this.data,
	            tickCount = _data.tickCount,
	            categories = _data.labels;
	
	        var lSideWidth = Math.round(width / 2);
	        var rSideWidth = width - lSideWidth - 1;
	        var halfTickCount = parseInt(tickCount / 2, 10) + 1;
	        var lCategories = categories.slice(0, halfTickCount);
	        var rCategories = categories.slice(halfTickCount - 1, tickCount);
	        var tickInterval = lSideWidth / halfTickCount;
	        var secondXAxisAdditionalPosition = lSideWidth + this.dimensionMap.yAxis.width - 1;
	
	        this.paperAdditionalWidth = tickInterval;
	
	        this._renderChildContainers(lSideWidth, halfTickCount, lCategories, 0);
	        this._renderChildContainers(rSideWidth + 1, halfTickCount, rCategories, secondXAxisAdditionalPosition);
	    };
	
	    /**
	     * Render single axis if not divided.
	     * @param {{width: number, height: number}} dimension axis area dimension
	     * @private
	     */
	
	
	    Axis.prototype._renderNotDividedAxis = function _renderNotDividedAxis(_ref2) {
	        var width = _ref2.width,
	            height = _ref2.height;
	        var _data2 = this.data,
	            positionRatio = _data2.positionRatio,
	            tickCount = _data2.tickCount,
	            labels = _data2.labels;
	        var isYAxis = this.isYAxis;
	
	        var size = isYAxis ? height : width;
	        var additionalSize = 0;
	
	        if (positionRatio) {
	            additionalSize = size * positionRatio;
	        }
	
	        this._renderChildContainers(size, tickCount, labels, additionalSize);
	    };
	
	    /**
	     * Render axis area.
	     * @private
	     */
	
	
	    Axis.prototype._renderAxisArea = function _renderAxisArea() {
	        var dimension = this.layout.dimension;
	        var isLabelAxis = this.data.isLabelAxis;
	        var _options = this.options,
	            divided = _options.divided,
	            isCenter = _options.isCenter;
	        var width = dimension.width;
	
	
	        this.isLabelAxis = isLabelAxis;
	
	        if (divided) {
	            this.containerWidth = width + this.dimensionMap.yAxis.width;
	            this._renderDividedAxis(dimension);
	            width = this.containerWidth;
	        } else {
	            width += isCenter ? 1 : 0;
	            this._renderNotDividedAxis(dimension);
	        }
	    };
	
	    /**
	     * Set data for rendering.
	     * @param {{
	     *      options: ?object,
	     *      layout: {
	     *          dimension: {width: number, height: number},
	     *          position: {left: number, top: number}
	     *      },
	     *      dimensionMap: object,
	     *      axisDataMap: object
	     * }} data - bounds and scale data
	     * @private
	     */
	
	
	    Axis.prototype._setDataForRendering = function _setDataForRendering(_ref3) {
	        var layout = _ref3.layout,
	            dimensionMap = _ref3.dimensionMap,
	            limitMap = _ref3.limitMap,
	            axisDataMap = _ref3.axisDataMap;
	
	        this.layout = layout;
	        this.dimensionMap = dimensionMap;
	        this.limitMap = limitMap;
	
	        this.data = axisDataMap[this.componentName];
	        this.options = this.data.options;
	    };
	
	    /**
	     * @param {object} data - bounds and scale data
	     */
	
	
	    Axis.prototype.render = function render(data) {
	        var paper = data.paper;
	
	        this.paper = paper;
	        this.axisSet = paper.set();
	
	        this._setDataForRendering(data);
	        this._renderAxisArea();
	    };
	
	    /**
	     * Rerender axis component.
	     * @param {object} data - bounds and scale data
	     */
	
	
	    Axis.prototype.rerender = function rerender(data) {
	        this.axisSet.remove();
	
	        this.render(data);
	    };
	
	    /**
	     * Resize axis component.
	     * @param {object} data - bounds and scale data
	     */
	
	
	    Axis.prototype.resize = function resize(data) {
	        this.rerender(data);
	    };
	
	    /**
	     * Zoom.
	     * @param {object} data - bounds and scale data
	     */
	
	
	    Axis.prototype.zoom = function zoom(data) {
	        this.rerender(data);
	    };
	
	    /**
	     * get other side axis dimension
	     * @returns {object}
	     * @private
	     */
	
	
	    Axis.prototype._getOtherSideDimension = function _getOtherSideDimension() {
	        return this.dimensionMap[this.isYAxis ? 'xAxis' : 'yAxis'];
	    };
	
	    /**
	     * Title area renderer
	     * @param {number} size - area size
	     * @param {number} additionalWidth - right side xAxis position
	     * @private
	     */
	
	
	    Axis.prototype._renderTitleArea = function _renderTitleArea(size, additionalWidth) {
	        var _options$title = this.options.title,
	            title = _options$title === undefined ? {} : _options$title;
	
	        var yAxisOption = this.dataProcessor.getOption('yAxis');
	        var seriesOption = this.dataProcessor.getOption('series') || {};
	
	        if (title.text) {
	            this.graphRenderer.renderTitle(this.paper, {
	                text: title.text,
	                offset: title.offset,
	                theme: this.theme.title,
	                rotationInfo: {
	                    isVertical: this.isYAxis,
	                    isPositionRight: this.data.isPositionRight,
	                    isCenter: this.options.isCenter,
	                    isColumnType: _predicate2['default'].isColumnTypeChart(this.dataProcessor.chartType, this.dataProcessor.seriesTypes),
	                    isDiverging: seriesOption.diverging,
	                    isYAxisCenter: yAxisOption && yAxisOption.align === 'center'
	                },
	                layout: this.layout,
	                areaSize: size,
	                additionalWidth: additionalWidth,
	                otherSideDimension: this._getOtherSideDimension(),
	                tickCount: this.data.tickCount,
	                set: this.axisSet
	            });
	        }
	    };
	
	    /**
	     * Render tick line.
	     * @param {number} areaSize - width or height
	     * @param {boolean} isNotDividedXAxis - whether is not divided x axis or not.
	     * @param {number} additionalSize - additional size
	     * @private
	     */
	
	
	    Axis.prototype._renderTickLine = function _renderTickLine(areaSize, isNotDividedXAxis, additionalSize) {
	        this.graphRenderer.renderTickLine({
	            areaSize: areaSize,
	            additionalSize: additionalSize,
	            additionalWidth: this.paperAdditionalWidth,
	            additionalHeight: this.paperAdditionalHeight,
	            isPositionRight: this.data.isPositionRight,
	            isCenter: this.data.options.isCenter,
	            isNotDividedXAxis: isNotDividedXAxis,
	            isVertical: this.isYAxis,
	            tickColor: this.theme.tickColor,
	            layout: this.layout,
	            paper: this.paper,
	            set: this.axisSet
	        });
	    };
	
	    /**
	     * Render ticks.
	     * @param {number} size - width or height
	     * @param {number} tickCount - tick count
	     * @param {boolean} isNotDividedXAxis - whether is not divided x axis or not.
	     * @param {number} [additionalSize] - additional size
	     * @private
	     */
	
	
	    Axis.prototype._renderTicks = function _renderTicks(size, tickCount, isNotDividedXAxis, additionalSize) {
	        var tickColor = this.theme.tickColor;
	        var _data3 = this.data,
	            remainLastBlockInterval = _data3.remainLastBlockInterval,
	            _data3$sizeRatio = _data3.sizeRatio,
	            sizeRatio = _data3$sizeRatio === undefined ? 1 : _data3$sizeRatio,
	            dataTickCount = _data3.tickCount,
	            isPositionRight = _data3.isPositionRight;
	
	        var remainLastBlockIntervalPosition = remainLastBlockInterval ? size : 0;
	        var isYAxis = this.isYAxis;
	        var _data$options = this.data.options,
	            isCenter = _data$options.isCenter,
	            isDivided = _data$options.divided;
	
	        var positions = _calculator2['default'].makeTickPixelPositions(size * sizeRatio, tickCount, 0, remainLastBlockIntervalPosition);
	        var additionalHeight = this.paperAdditionalHeight + 1;
	        var additionalWidth = this.paperAdditionalWidth;
	        var positionLength = remainLastBlockIntervalPosition ? dataTickCount + 1 : dataTickCount;
	
	        positions.length = positionLength;
	
	        this.graphRenderer.renderTicks({
	            paper: this.paper,
	            layout: this.layout,
	            positions: positions,
	            isVertical: isYAxis,
	            isCenter: isCenter,
	            isDivided: isDivided,
	            additionalSize: additionalSize,
	            additionalWidth: additionalWidth,
	            additionalHeight: additionalHeight,
	            otherSideDimension: this._getOtherSideDimension(),
	            isPositionRight: isPositionRight,
	            tickColor: tickColor,
	            set: this.axisSet
	        });
	    };
	
	    Axis.prototype._renderNegativeStandardsLine = function _renderNegativeStandardsLine(size, additionalSize, seriesDimension, axisLimit) {
	        this.graphRenderer.renderStandardLine({
	            areaSize: size,
	            isVertical: this.isYAxis,
	            layout: this.layout,
	            paper: this.paper,
	            set: this.axisSet,
	            seriesDimension: seriesDimension,
	            axisLimit: axisLimit
	        });
	    };
	
	    /**
	     * Render tick area.
	     * @param {number} size - width or height
	     * @param {number} tickCount - tick count
	     * @param {number} [additionalSize] - additional size (width or height)
	     * @private
	     */
	
	
	    Axis.prototype._renderTickArea = function _renderTickArea(size, tickCount, additionalSize) {
	        var isNotDividedXAxis = !this.isYAxis && !this.options.divided;
	
	        this._renderTickLine(size, isNotDividedXAxis, additionalSize || 0);
	        this._renderTicks(size, tickCount, isNotDividedXAxis, additionalSize || 0);
	    };
	
	    /**
	     * Render label area.
	     * @param {number} size label area size
	     * @param {number} tickCount tick count
	     * @param {Array.<string>} categories categories
	     * @param {number} [additionalSize] additional size (width or height)
	     * @private
	     */
	
	
	    Axis.prototype._renderLabelArea = function _renderLabelArea(size, tickCount, categories, additionalSize) {
	        var _data4 = this.data,
	            _data4$sizeRatio = _data4.sizeRatio,
	            sizeRatio = _data4$sizeRatio === undefined ? 1 : _data4$sizeRatio,
	            remainLastBlockInterval = _data4.remainLastBlockInterval;
	
	        var remainLastBlockIntervalPosition = remainLastBlockInterval ? size : 0;
	        var tickPixelPositions = _calculator2['default'].makeTickPixelPositions(size * sizeRatio, tickCount, 0, remainLastBlockIntervalPosition);
	        var labelDistance = tickPixelPositions[1] - tickPixelPositions[0];
	
	        this._renderLabels(tickPixelPositions, categories, labelDistance, additionalSize || 0);
	    };
	
	    /**
	     * Make html of rotation labels.
	     * @param {Array.<object>} positions label position array
	     * @param {string[]} categories categories
	     * @param {number} labelSize label size
	     * @param {number} additionalSize additional size
	     * @private
	     */
	
	
	    Axis.prototype._renderRotationLabels = function _renderRotationLabels(positions, categories, labelSize, additionalSize) {
	        var _this = this;
	
	        var renderer = this.graphRenderer;
	        var isYAxis = this.isYAxis;
	
	        var theme = this.theme.label;
	        var degree = this.data.degree;
	
	        var halfWidth = labelSize / 2;
	        var edgeAlignWidth = labelSize / AXIS_EDGE_RATIO;
	        var _layout$position = this.layout.position,
	            top = _layout$position.top,
	            left = _layout$position.left;
	
	        var horizontalTop = top + X_AXIS_LABEL_PADDING;
	        var baseLeft = left;
	        var labelMargin = this.options.labelMargin || 0;
	
	        positions.forEach(function (position, index) {
	            var labelPosition = position + (additionalSize || 0);
	            var positionTopAndLeft = {};
	
	            if (isYAxis) {
	                positionTopAndLeft.top = labelPosition + halfWidth;
	                positionTopAndLeft.left = labelSize + labelMargin;
	            } else {
	                positionTopAndLeft.top = horizontalTop + labelMargin;
	                positionTopAndLeft.left = baseLeft + labelPosition + edgeAlignWidth;
	            }
	
	            renderer.renderRotatedLabel({
	                degree: degree,
	                labelText: categories[index],
	                paper: _this.paper,
	                positionTopAndLeft: positionTopAndLeft,
	                set: _this.axisSet,
	                theme: theme
	            });
	        }, this);
	    };
	
	    /**
	     * Make html of normal labels.
	     * @param {Array.<object>} positions label position array
	     * @param {string[]} categories categories
	     * @param {number} labelSize label size
	     * @param {number} additionalSize additional size
	     * @private
	     */
	
	
	    Axis.prototype._renderNormalLabels = function _renderNormalLabels(positions, categories, labelSize, additionalSize) {
	        var _this2 = this;
	
	        var renderer = this.graphRenderer;
	        var isYAxis = this.isYAxis,
	            isCategoryLabel = this.isLabelAxis,
	            dataProcessor = this.dataProcessor,
	            layout = this.layout;
	        var isPositionRight = this.data.isPositionRight;
	
	        var theme = this.theme.label;
	        var _options2 = this.options,
	            _options2$labelMargin = _options2.labelMargin,
	            labelMargin = _options2$labelMargin === undefined ? 0 : _options2$labelMargin,
	            pointOnColumn = _options2.pointOnColumn,
	            isCenter = _options2.isCenter;
	
	        var isLineTypeChart = _predicate2['default'].isLineTypeChart(dataProcessor.chartType, dataProcessor.seriesTypes);
	        var isPointOnColumn = isLineTypeChart && pointOnColumn;
	        var isAutoTickInterval = _predicate2['default'].isAutoTickInterval(this.options.tickInterval);
	
	        positions.forEach(function (position, index) {
	            var labelPosition = position + additionalSize;
	            var halfLabelDistance = labelSize / 2;
	            var isOverLapXAxisLabel = _this2._isOverLapXAxisLabel(categories[index], position, positions[index + 1]);
	            var positionTopAndLeft = {};
	
	            /*
	             * to prevent printing `undefined` text, when category label is not set
	             */
	            if (labelPosition < 0 || !isYAxis && isAutoTickInterval && isOverLapXAxisLabel) {
	                return;
	            }
	
	            if (isYAxis) {
	                positionTopAndLeft = _this2._getYAxisLabelPosition(layout, {
	                    labelPosition: labelPosition,
	                    isCategoryLabel: isCategoryLabel,
	                    halfLabelDistance: halfLabelDistance,
	                    isPositionRight: isPositionRight
	                });
	            } else {
	                positionTopAndLeft = _this2._getXAxisLabelPosition(layout, {
	                    labelMargin: labelMargin,
	                    labelHeight: _renderUtil2['default'].getRenderedLabelsMaxHeight(categories, theme),
	                    labelPosition: labelPosition,
	                    isCategoryLabel: isCategoryLabel,
	                    isLineTypeChart: isLineTypeChart,
	                    isPointOnColumn: isPointOnColumn,
	                    halfLabelDistance: halfLabelDistance
	                });
	            }
	
	            positionTopAndLeft.top = Math.round(positionTopAndLeft.top);
	            positionTopAndLeft.left = Math.round(positionTopAndLeft.left);
	
	            renderer.renderLabel({
	                isPositionRight: isPositionRight,
	                isVertical: isYAxis,
	                isCenter: isCenter,
	                labelSize: labelSize,
	                labelText: categories[index],
	                paper: _this2.paper,
	                positionTopAndLeft: positionTopAndLeft,
	                set: _this2.axisSet,
	                theme: theme
	            });
	        }, this);
	    };
	
	    /**
	     * @param {string} labelText - axis label text
	     * @param {number} position - current left position
	     * @param {number} nextPosition - next  left position
	     * @returns {boolean}
	     */
	
	
	    Axis.prototype._isOverLapXAxisLabel = function _isOverLapXAxisLabel(labelText, position, nextPosition) {
	        var labelWidth = _renderUtil2['default'].getRenderedLabelWidth(labelText);
	        if (!_tuiCodeSnippet2['default'].isUndefined(nextPosition) && nextPosition - position < labelWidth) {
	            return true;
	        }
	
	        return false;
	    };
	
	    /**
	     * @param {object} layout - axis dimension, position
	     * @param {object} params - optional data needed to render axis labels
	     * @returns {object} top, left positon of y axis
	     */
	
	
	    Axis.prototype._getYAxisLabelPosition = function _getYAxisLabelPosition(layout, params) {
	        var labelLeftPosition = void 0;
	        var labelTopPosition = params.labelPosition;
	
	        if (params.isCategoryLabel) {
	            labelTopPosition += params.halfLabelDistance + layout.position.top;
	        } else {
	            labelTopPosition = layout.dimension.height + layout.position.top - labelTopPosition;
	        }
	
	        if (params.isPositionRight) {
	            labelLeftPosition = layout.position.left + layout.dimension.width;
	        } else if (this.options.isCenter) {
	            labelLeftPosition = layout.position.left + layout.dimension.width / 2;
	        } else {
	            labelLeftPosition = layout.position.left;
	        }
	
	        return {
	            top: labelTopPosition,
	            left: labelLeftPosition
	        };
	    };
	
	    /**
	     * @param {object} layout - axis dimension, position
	     * @param {object} params - optional data needed to render axis labels
	     * @returns {object} top, left positon of y axis
	     */
	
	
	    Axis.prototype._getXAxisLabelPosition = function _getXAxisLabelPosition(layout, params) {
	        var labelTopPosition = _calculator2['default'].sum([layout.position.top, X_AXIS_LABEL_PADDING, params.labelMargin, params.labelHeight / 2]);
	        var labelLeftPosition = params.labelPosition + layout.position.left;
	
	        if (params.isCategoryLabel) {
	            if (!params.isLineTypeChart || params.isPointOnColumn) {
	                labelLeftPosition += params.halfLabelDistance;
	            }
	        }
	
	        return {
	            top: labelTopPosition,
	            left: labelLeftPosition
	        };
	    };
	
	    /**
	     * Make labels html.
	     * @param {Array.<object>} positions - positions for labels
	     * @param {Array.<string>} categories - categories
	     * @param {number} labelSize label size
	     * @param {number} additionalSize additional size
	     * @private
	     */
	
	
	    Axis.prototype._renderLabels = function _renderLabels(positions, categories, labelSize, additionalSize) {
	        var _options3 = this.options,
	            rotateLabel = _options3.rotateLabel,
	            prefix = _options3.prefix,
	            suffix = _options3.suffix;
	        var _data5 = this.data,
	            degree = _data5.degree,
	            multilineLabels = _data5.multilineLabels;
	
	        var isRotationlessXAxis = !this.isYAxis && this.isLabelAxis && rotateLabel === false;
	        var hasRotatedXAxisLabel = this.componentName === 'xAxis' && degree;
	        var axisLabels = void 0;
	
	        if (isRotationlessXAxis) {
	            axisLabels = multilineLabels;
	        } else {
	            axisLabels = categories;
	        }
	
	        if (axisLabels.length) {
	            positions.length = axisLabels.length;
	        }
	
	        axisLabels = _renderUtil2['default'].addPrefixSuffix(axisLabels, prefix, suffix);
	
	        if (hasRotatedXAxisLabel) {
	            this._renderRotationLabels(positions, axisLabels, labelSize, additionalSize);
	        } else {
	            this._renderNormalLabels(positions, axisLabels, labelSize, additionalSize);
	        }
	    };
	
	    /**
	     * Animate axis for adding data
	     * @param {object} data rendering data
	     */
	
	
	    Axis.prototype.animateForAddingData = function animateForAddingData(data) {
	        if (!this.isYAxis) {
	            this.graphRenderer.animateForAddingData(data.tickSize);
	        }
	    };
	
	    return Axis;
	}();
	
	/**
	 * Factory for Axis
	 * @param {object} axisParam parameter
	 * @returns {object}
	 * @ignore
	 */
	
	
	function axisFactory(axisParam) {
	    var chartOptions = axisParam.chartOptions,
	        name = axisParam.name,
	        theme = axisParam.theme,
	        seriesTypes = axisParam.seriesTypes;
	    var chartType = chartOptions.chartType,
	        series = chartOptions.series;
	
	
	    axisParam.isYAxis = name === 'yAxis' || name === 'rightYAxis';
	    axisParam.shifting = series.shifting;
	
	    // In combo chart, the theme is divided into series name considering two YAxis(yAxis and rightYAxis)
	    // @todo change theme structure so that access theme by axis type, not considering chart type
	    //     like theme.xAxis, theme.yAxis, theme.rightYAxis
	    if (chartType === 'combo') {
	        if (axisParam.isYAxis) {
	            axisParam.theme = theme[seriesTypes[0]];
	        } else if (name === 'rightYAxis') {
	            axisParam.componentType = 'yAxis';
	            axisParam.theme = theme[seriesTypes[1]];
	            axisParam.index = 1;
	        }
	        // @todo I do not know why the single type chart with yAxis branches once again as the chart name inside it. I feel inconsistent
	    } else if (axisParam.isYAxis) {
	        axisParam.theme = theme[chartType];
	        // single chart, xAxis
	    } else {
	        axisParam.theme = theme;
	    }
	
	    return new Axis(axisParam);
	}
	
	axisFactory.componentType = 'axis';
	axisFactory.Axis = Axis;

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports['default'] = plotFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Plot component.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var Plot = function () {
	    /**
	     * Plot component.
	     * @constructs Plot
	     * @private
	     * @param {object} params parameters
	     *      @param {number} params.vTickCount vertical tick count
	     *      @param {number} params.hTickCount horizontal tick count
	     *      @param {object} params.theme axis theme
	     * @ignore
	     */
	    function Plot(params) {
	        _classCallCheck(this, Plot);
	
	        /**
	         * Plot view className
	         * @type {string}
	         */
	        this.className = 'tui-chart-plot-area';
	
	        /**
	         * Data processor
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = params.dataProcessor;
	
	        /**
	         * Options
	         * @type {object}
	         */
	        this.options = params.options || {};
	        this.options.showLine = _tuiCodeSnippet2['default'].isUndefined(this.options.showLine) ? true : this.options.showLine;
	        this.options.lines = this.options.lines || [];
	        this.options.bands = this.options.bands || [];
	
	        /**
	         * x axis type option
	         * @type {?string}
	         */
	        this.xAxisTypeOption = params.xAxisTypeOption;
	
	        /**
	         * Theme
	         * @type {object}
	         */
	        this.theme = params.theme || {};
	
	        /**
	         * chart type
	         * @type {string}
	         */
	        this.chartType = params.chartType;
	
	        /**
	         * sub charts type
	         * @type {Array.<string>}
	         */
	        this.chartTypes = params.chartTypes;
	
	        /**
	         * layout bounds information for this components
	         * @type {null|{dimension:{width:number, height:number}, position:{left:number, top:number}}}
	         */
	        this.layout = null;
	
	        /**
	         * axis data map
	         * @type {null|object}
	         */
	        this.axisDataMap = null;
	
	        this.drawingType = _const2['default'].COMPONENT_TYPE_RAPHAEL;
	    }
	
	    /**
	     * Preset components for setData
	     * @param {object} theme theme object
	     * @ignore
	     */
	
	
	    Plot.prototype.presetForChangeData = function presetForChangeData() {
	        var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.theme;
	
	        this.theme = theme;
	    };
	
	    /**
	     * Render plot area.
	     * @param {object} paper paper object
	     * @private
	     */
	
	
	    Plot.prototype._renderPlotArea = function _renderPlotArea(paper) {
	        var dimension = this.layout.dimension;
	
	
	        if (_predicate2['default'].isLineTypeChart(this.chartType, this.chartTypes)) {
	            this._renderOptionalLines(paper, dimension);
	        }
	
	        if (this.options.showLine) {
	            this._renderPlotLines(paper, dimension);
	        }
	    };
	
	    /**
	     * Set data for rendering.
	     * @param {{
	     *      layout: {
	     *          dimension: {width: number, height: number},
	     *          position: {left: number, top: number}
	     *      },
	     *      axisDataMap: object
	     * }} data - bounds and scale data
	     * @private
	     */
	
	
	    Plot.prototype._setDataForRendering = function _setDataForRendering(data) {
	        if (data) {
	            this.layout = data.layout;
	            this.dimensionMap = data.dimensionMap;
	            this.axisDataMap = data.axisDataMap;
	            this.paper = data.paper;
	        }
	    };
	
	    /**
	     * Render plot component.
	     * @param {object} data - bounds and scale data
	     */
	
	
	    Plot.prototype.render = function render(data) {
	        var paper = data && data.paper || this.paper;
	        this.plotSet = paper.set();
	        this.additionalPlotSet = paper.set();
	
	        this._setDataForRendering(data);
	        this._renderPlotArea(this.paper);
	
	        this.additionalPlotSet.toBack();
	        this.plotSet.toBack();
	        paper.pushDownBackgroundToBottom();
	    };
	
	    /**
	     * Rerender.
	     * @param {object} data - bounds and scale data
	     */
	
	
	    Plot.prototype.rerender = function rerender(data) {
	        this.additionalPlotSet.remove();
	        this.plotSet.remove();
	        this.render(data);
	    };
	
	    /**
	     * Resize plot component.
	     * @param {object} data - bounds and scale data
	     */
	
	
	    Plot.prototype.resize = function resize(data) {
	        this.rerender(data);
	    };
	
	    /**
	     * Zoom.
	     * @param {object} data - bounds and scale data
	     */
	
	
	    Plot.prototype.zoom = function zoom(data) {
	        this.rerender(data);
	    };
	
	    /**
	     * Make template params for vertical line.
	     * @param {object} additionalParams - additional params
	     * @returns {object}
	     * @private
	     */
	
	
	    Plot.prototype._makeVerticalLineTemplateParams = function _makeVerticalLineTemplateParams(additionalParams) {
	        return _tuiCodeSnippet2['default'].extend({
	            className: 'vertical',
	            positionType: 'left',
	            width: '1px'
	        }, additionalParams);
	    };
	
	    /**
	     * Make template params for horizontal line.
	     * @param {object} additionalParams - additional params
	     * @returns {object}
	     * @private
	     */
	
	
	    Plot.prototype._makeHorizontalLineTemplateParams = function _makeHorizontalLineTemplateParams(additionalParams) {
	        return _tuiCodeSnippet2['default'].extend({
	            className: 'horizontal',
	            positionType: 'bottom',
	            height: '1px'
	        }, additionalParams);
	    };
	
	    /**
	     * Render line
	     * @param {number} offsetPosition - start percentage offsetPosition
	     * @param {object} attributes - line attributes
	     * @returns {object} path
	     * @private
	     */
	
	
	    Plot.prototype._renderLine = function _renderLine(offsetPosition, attributes) {
	        var _layout = this.layout,
	            top = _layout.position.top,
	            height = _layout.dimension.height;
	
	        var pathString = 'M' + offsetPosition + ',' + top + 'V' + (top + height);
	        var path = this.paper.path(pathString);
	
	        path.attr({
	            opacity: attributes.opacity || 1,
	            stroke: attributes.color
	        });
	
	        this.additionalPlotSet.push(path);
	
	        return path;
	    };
	
	    /**
	     * Render band
	     * @param {number} offsetPosition - start percentage offsetPosition
	     * @param {number} plotWidth - plotWidth
	     * @param {object} attributes - band attributes
	     * @returns {object} band
	     * @private
	     */
	
	
	    Plot.prototype._renderBand = function _renderBand(offsetPosition, plotWidth, attributes) {
	        var _layout2 = this.layout,
	            position = _layout2.position,
	            dimension = _layout2.dimension;
	
	        var remainingWidth = dimension.width - offsetPosition + position.left;
	        var bandWidth = plotWidth < 0 ? remainingWidth : plotWidth;
	        var rect = this.paper.rect(offsetPosition, position.top, bandWidth, dimension.height);
	
	        rect.attr({
	            fill: attributes.color,
	            opacity: attributes.opacity || 1,
	            stroke: attributes.color
	        });
	
	        this.additionalPlotSet.push(rect);
	
	        return rect;
	    };
	
	    /**
	     * Create value range for optional line.
	     * @param {{range: ?Array.<number>, value: ?number}} optionalLineData - optional line data
	     * @returns {Array.<number>}
	     * @private
	     */
	
	
	    Plot.prototype._createOptionalLineValueRange = function _createOptionalLineValueRange(optionalLineData) {
	        var range = optionalLineData.range || [optionalLineData.value];
	
	        if (_predicate2['default'].isDatetimeType(this.xAxisTypeOption)) {
	            range = range.map(function (value) {
	                var date = new Date(value);
	
	                return date.getTime() || value;
	            });
	        }
	
	        return range;
	    };
	
	    /**
	     * Create position for optional line, when value axis.
	     * @param {{dataMin: number, distance: number}} xAxisData - x axis data
	     * @param {number} width - width
	     * @param {number} value - value
	     * @returns {number|null}
	     * @private
	     */
	
	
	    Plot.prototype._createOptionalLinePosition = function _createOptionalLinePosition(_ref, width, value) {
	        var dataMin = _ref.dataMin,
	            distance = _ref.distance;
	
	        var ratio = (value - dataMin) / distance;
	        var position = ratio * width;
	
	        if (ratio === 1) {
	            position -= 1;
	        }
	
	        if (position < 0) {
	            position = null;
	        }
	
	        return position;
	    };
	
	    /**
	     * Calculate xAxis labelDistance
	     * @param {number} width - width of xAxis
	     * @param {object} xAxisData - x axis data
	     * @returns {number}
	     * @private
	     */
	
	
	    Plot.prototype._calculateXAxisLabelDistance = function _calculateXAxisLabelDistance(width, xAxisData) {
	        var _xAxisData$sizeRatio = xAxisData.sizeRatio,
	            sizeRatio = _xAxisData$sizeRatio === undefined ? 1 : _xAxisData$sizeRatio,
	            tickCount = xAxisData.tickCount,
	            remainLastBlockInterval = xAxisData.remainLastBlockInterval;
	
	        var remainLastBlockIntervalPosition = remainLastBlockInterval ? width : 0;
	        var tickPixelPositions = _calculator2['default'].makeTickPixelPositions(width * sizeRatio, tickCount, 0, remainLastBlockIntervalPosition);
	
	        return tickPixelPositions[1] - tickPixelPositions[0];
	    };
	
	    /**
	     * Create position for optional line, when label axis.
	     * @param {number} width - width
	     * @param {object} xAxisData - x axis data
	     * @param {number} value - value
	     * @returns {number|null}
	     * @private
	     */
	
	
	    Plot.prototype._createOptionalLinePositionWhenLabelAxis = function _createOptionalLinePositionWhenLabelAxis(width, xAxisData, value) {
	        var dataProcessor = this.dataProcessor;
	
	        var isLineTypeChart = _predicate2['default'].isLineTypeChart(dataProcessor.chartType, dataProcessor.seriesTypes);
	        var isPointOnColumn = isLineTypeChart && xAxisData.options.pointOnColumn;
	        var index = dataProcessor.findCategoryIndex(value);
	        var halfLabelDistance = this._calculateXAxisLabelDistance(width, xAxisData) / 2;
	
	        var position = null;
	        var ratio = void 0;
	
	        if (!_tuiCodeSnippet2['default'].isNull(index)) {
	            var categoryCount = dataProcessor.getCategoryCount();
	            var divCount = isPointOnColumn ? categoryCount : categoryCount - 1;
	
	            ratio = index === 0 ? 0 : index / divCount;
	
	            position = ratio * width;
	            if (isPointOnColumn) {
	                position += halfLabelDistance;
	            }
	        }
	
	        if (ratio === 1) {
	            position -= 1;
	        }
	
	        return position;
	    };
	
	    /**
	     * Create position map for optional line.
	     * @param {{range: ?Array.<number>, value: ?number}} optionalLineData - optional line data
	     * @param {{isLabelAxis: boolean, dataMin: number, distance: number}} xAxisData - x axis data
	     * @param {number} width - width
	     * @returns {{start: number, end: number}}
	     * @private
	     */
	
	
	    Plot.prototype._createOptionalLinePositionMap = function _createOptionalLinePositionMap(optionalLineData, xAxisData, width) {
	        var categories = this.dataProcessor.getCategories();
	        var categoriesLen = categories.length;
	        var xAxisValues = this.dataProcessor.valuesMap.linex;
	
	        var range = this._createOptionalLineValueRange(optionalLineData);
	        var startPosition = void 0,
	            endPosition = void 0;
	
	        if (xAxisData.isLabelAxis) {
	            startPosition = this._createOptionalLinePositionWhenLabelAxis(width, xAxisData, range[0]);
	            endPosition = this._createOptionalLinePositionWhenLabelAxis(width, xAxisData, range[1]);
	        } else {
	            startPosition = this._createOptionalLinePosition(xAxisData, width, range[0]);
	            endPosition = range[1] && this._createOptionalLinePosition(xAxisData, width, range[1]);
	        }
	
	        if (_tuiCodeSnippet2['default'].isNull(startPosition)) {
	            var startValue = categoriesLen ? categories[0] : xAxisValues[0];
	            startPosition = this._isBeforeVisibleValue(range[0], startValue) ? 0 : -1;
	        }
	
	        if (_tuiCodeSnippet2['default'].isNull(endPosition) || endPosition > width) {
	            var endValue = categoriesLen ? categories[categoriesLen - 1] : xAxisValues[xAxisValues.length - 1];
	            endPosition = this._isAfterVisibleValue(range[1], endValue) ? width : -1;
	        }
	
	        return {
	            start: startPosition,
	            end: endPosition
	        };
	    };
	
	    /**
	     * @param {string} value - value of starting point
	     * @param {string} firstValue - first visible value data
	     * @returns {boolean} - whether starting point value is at before first visible data or not
	     * @private
	     */
	
	
	    Plot.prototype._isBeforeVisibleValue = function _isBeforeVisibleValue(value, firstValue) {
	        var dataProcessor = this.dataProcessor;
	
	
	        if (!_tuiCodeSnippet2['default'].isExisty(value)) {
	            return false;
	        }
	
	        if (_predicate2['default'].isDatetimeType(this.xAxisTypeOption)) {
	            return value < firstValue;
	        }
	
	        var valueIndex = dataProcessor.findAbsoluteCategoryIndex(value);
	        var firstValueIndex = dataProcessor.findAbsoluteCategoryIndex(firstValue);
	
	        return valueIndex >= 0 && valueIndex < firstValueIndex;
	    };
	
	    /**
	     * @param {string} value - value of end point
	     * @param {string} lastValue - last visible value data
	     * @returns {boolean} - whether end point value is at after last visible value data or not
	     * @private
	     */
	
	
	    Plot.prototype._isAfterVisibleValue = function _isAfterVisibleValue(value, lastValue) {
	        var dataProcessor = this.dataProcessor;
	
	
	        if (!_tuiCodeSnippet2['default'].isExisty(value)) {
	            return false;
	        }
	
	        if (_predicate2['default'].isDatetimeType(this.xAxisTypeOption)) {
	            return value > lastValue;
	        }
	
	        var valueIndex = dataProcessor.findAbsoluteCategoryIndex(value);
	        var lastValueIndex = dataProcessor.findAbsoluteCategoryIndex(lastValue);
	
	        return valueIndex >= 0 && valueIndex > lastValueIndex;
	    };
	
	    /**
	     * Render optional line.
	     * @param {Array.<number>} xAxisData - positions
	     * @param {number} width - standard width
	     * @param {object} attributes - template parameters
	     * @param {object} optionalLineData - optional line information
	     * @returns {object}
	     * @private
	     */
	
	
	    Plot.prototype._renderOptionalLine = function _renderOptionalLine(xAxisData, width, attributes, optionalLineData) {
	        var positionMap = this._createOptionalLinePositionMap(optionalLineData, xAxisData, width);
	        var line = void 0;
	
	        if (positionMap.start >= 0 && positionMap.start <= width) {
	            attributes.width = 1;
	
	            attributes.color = optionalLineData.color || 'transparent';
	            attributes.opacity = optionalLineData.opacity;
	
	            line = this._renderLine(positionMap.start + this.layout.position.left, attributes);
	        }
	
	        return line;
	    };
	
	    /**
	     * Render optional band.
	     * @param {Array.<number>} xAxisData - positions
	     * @param {number} width - standard width
	     * @param {object} attributes - template parameters
	     * @param {object} optionalLineData - optional line information
	     * @returns {object}
	     * @private
	     */
	
	
	    Plot.prototype._makeOptionalBand = function _makeOptionalBand(xAxisData, width, attributes, optionalLineData) {
	        var _this = this;
	
	        var range = optionalLineData.range;
	
	
	        if (range && range.length) {
	            this._makeRangeTo2DArray(optionalLineData);
	        }
	
	        var positionMaps = optionalLineData.range.map(function (rangeItem) {
	            return _this._createOptionalLinePositionMap({ range: rangeItem }, xAxisData, width);
	        });
	
	        if (optionalLineData.mergeOverlappingRanges) {
	            positionMaps.sort(compareByStartPosition);
	            positionMaps = this._mergeOverlappingPositionMaps(positionMaps);
	        }
	
	        return positionMaps.map(function (positionMap) {
	            var isStartPositionInsidePlotArea = positionMap.start >= 0 && positionMap.start <= width;
	            var band = void 0;
	
	            if (isStartPositionInsidePlotArea && positionMap.end >= 0) {
	                attributes.color = optionalLineData.color || 'transparent';
	                attributes.opacity = optionalLineData.opacity;
	
	                var bandWidth = positionMap.end - positionMap.start;
	                band = _this._renderBand(positionMap.start + _this.layout.position.left, bandWidth, attributes);
	            }
	
	            return band;
	        }, this);
	    };
	
	    /**
	     * Make optional lines html.
	     * @param {Array.<object>} lines - optional lines
	     * @param {{width: number, height: number}} dimension - dimension
	     * @returns {string}
	     * @private
	     */
	
	
	    Plot.prototype._makeOptionalLines = function _makeOptionalLines(lines, _ref2) {
	        var width = _ref2.width,
	            height = _ref2.height;
	
	        var xAxisData = this.axisDataMap.xAxis;
	        var templateParams = this._makeVerticalLineTemplateParams({
	            height: height + 'px'
	        });
	        var makeOptionalLineHtml = this._renderOptionalLine.bind(this, xAxisData, width, templateParams);
	
	        return lines.map(makeOptionalLineHtml);
	    };
	
	    /**
	     * Make optional lines html.
	     * @param {Array.<object>} lines - optional lines
	     * @param {{width: number, height: number}} dimension - dimension
	     * @returns {string}
	     * @private
	     */
	
	
	    Plot.prototype._makeOptionalBands = function _makeOptionalBands(lines, _ref3) {
	        var width = _ref3.width,
	            height = _ref3.height;
	
	        var xAxisData = this.axisDataMap.xAxis;
	        var templateParams = this._makeVerticalLineTemplateParams({
	            height: height + 'px'
	        });
	        var makeOptionalLineHtml = this._makeOptionalBand.bind(this, xAxisData, width, templateParams);
	
	        return lines.map(makeOptionalLineHtml);
	    };
	
	    /**
	     * Render optional lines and bands.
	     * @param {object} paper - paper
	     * @param {{width: number, height: number}} dimension - dimension
	     * @private
	     */
	
	
	    Plot.prototype._renderOptionalLines = function _renderOptionalLines(paper, dimension) {
	        this.optionalBands = this._makeOptionalBands(this.options.bands, dimension);
	        this.optionalLines = this._makeOptionalLines(this.options.lines, dimension);
	    };
	
	    /**
	     * Maker html for vertical lines
	     * @param {{width: number, height: number}} dimension - dimension
	     * @private
	     */
	
	
	    Plot.prototype._renderVerticalLines = function _renderVerticalLines(_ref4) {
	        var _this2 = this;
	
	        var width = _ref4.width;
	
	        var positions = this._makeHorizontalPositions(width);
	        var layout = this.layout,
	            lineColor = this.theme.lineColor;
	        var _layout$position = layout.position,
	            top = _layout$position.top,
	            left = _layout$position.left;
	
	
	        positions.forEach(function (position) {
	            var pathString = 'M' + (position + left) + ',' + top + 'V' + (top + layout.dimension.height);
	            var path = _this2.paper.path(pathString);
	
	            path.attr({
	                stroke: lineColor,
	                'stroke-width': 1,
	                'stroke-opacity': 0.05
	            });
	
	            _this2.plotSet.push(path);
	        });
	    };
	
	    /**
	     * Maker html for horizontal lines.
	     * @param {{width: number, height: number}} dimension - dimension
	     * @private
	     */
	
	
	    Plot.prototype._renderHorizontalLines = function _renderHorizontalLines(_ref5) {
	        var _this3 = this;
	
	        var height = _ref5.height;
	
	        var positions = this._makeVerticalPositions(height);
	        var layout = this.layout,
	            lineColor = this.theme.lineColor;
	        var _layout$position2 = layout.position,
	            left = _layout$position2.left,
	            top = _layout$position2.top;
	
	        var distance = positions.length > 1 ? positions[1] - positions[0] : 0;
	
	        positions.forEach(function (position, index) {
	            var pathString = 'M' + left + ',' + (distance * index + top) + 'H' + (left + layout.dimension.width);
	            var path = _this3.paper.path(pathString);
	
	            path.attr({
	                stroke: lineColor,
	                'stroke-width': 1,
	                'stroke-opacity': 0.05
	            });
	
	            _this3.plotSet.push(path);
	        });
	    };
	
	    /**
	     * Render plot lines.
	     * @param {HTMLElement} container - container element
	     * @param {{width: number, height: number}} dimension plot area dimension
	     * @private
	     */
	
	
	    Plot.prototype._renderPlotLines = function _renderPlotLines(container, dimension) {
	        if (!this.options.hideLine) {
	            this._renderVerticalLines(dimension);
	            this._renderHorizontalLines(dimension);
	        }
	    };
	
	    /**
	     * Make positions for vertical line.
	     * @param {number} height plot height
	     * @returns {Array.<number>} positions
	     * @private
	     */
	
	
	    Plot.prototype._makeVerticalPositions = function _makeVerticalPositions(height) {
	        var axisDataMap = this.axisDataMap;
	
	        var yAxis = axisDataMap.yAxis || axisDataMap.rightYAxis;
	        var positions = _calculator2['default'].makeTickPixelPositions(height, yAxis.validTickCount);
	
	        positions.shift();
	
	        return positions;
	    };
	
	    /**
	     * Make divided positions of plot.
	     * @param {number} width - plot width
	     * @param {number} tickCount - tick count
	     * @returns {Array.<number>}
	     * @private
	     */
	
	
	    Plot.prototype._makeDividedPlotPositions = function _makeDividedPlotPositions(width, tickCount) {
	        var yAxisWidth = this.dimensionMap.yAxis.width;
	
	        tickCount = parseInt(tickCount / 2, 10) + 1;
	        width -= yAxisWidth;
	
	        var leftWidth = Math.round(width / 2);
	        var rightWidth = width - leftWidth;
	        var leftPositions = _calculator2['default'].makeTickPixelPositions(leftWidth, tickCount);
	        var rightPositions = _calculator2['default'].makeTickPixelPositions(rightWidth, tickCount, leftWidth + yAxisWidth);
	
	        leftPositions.pop();
	        rightPositions.shift();
	
	        return leftPositions.concat(rightPositions);
	    };
	
	    /**
	     * Make positions for horizontal line.
	     * @param {number} width plot width
	     * @returns {Array.<number>} positions
	     * @private
	     */
	
	
	    Plot.prototype._makeHorizontalPositions = function _makeHorizontalPositions(width) {
	        var tickCount = this.axisDataMap.xAxis.validTickCount;
	        var positions = void 0;
	
	        if (this.options.divided) {
	            positions = this._makeDividedPlotPositions(width, tickCount);
	        } else {
	            positions = _calculator2['default'].makeTickPixelPositions(width, tickCount);
	            positions.shift();
	        }
	
	        return positions;
	    };
	
	    /**
	     * Add plot line.
	     * @param {{index: number, color: string, id: string}} data - data
	     */
	
	
	    Plot.prototype.addPlotLine = function addPlotLine(data) {
	        this.options.lines.push(data);
	        this.rerender();
	    };
	
	    /**
	     * Add plot band.
	     * @param {{range: Array.<number>, color: string, id: string}} data - data
	     */
	
	
	    Plot.prototype.addPlotBand = function addPlotBand(data) {
	        this.options.bands.push(data);
	        this.rerender();
	    };
	
	    /**
	     * Remove plot line.
	     * @param {string} id - line id
	     */
	
	
	    Plot.prototype.removePlotLine = function removePlotLine(id) {
	        this.options.lines = this.options.lines.filter(function (line) {
	            return line.id !== id;
	        });
	        this.rerender();
	    };
	
	    /**
	     * Remove plot band.
	     * @param {string} id - band id
	     */
	
	
	    Plot.prototype.removePlotBand = function removePlotBand(id) {
	        this.options.bands = this.options.bands.filter(function (band) {
	            return band.id !== id;
	        });
	        this.rerender();
	    };
	
	    /**
	     * Animate for adding data.
	     * @param {{tickSize: number, shifting: boolean}} data - data for animation
	     */
	
	
	    Plot.prototype.animateForAddingData = function animateForAddingData(data) {
	        var _this4 = this;
	
	        var optionLines = this.options.lines;
	        var optionBands = this.options.bands;
	
	        if (!this.dataProcessor.isCoordinateType()) {
	            if (data.shifting) {
	                this._animateItemForAddingData(this.optionalLines, data, function (itemIdx) {
	                    optionLines.splice(itemIdx, 1);
	                });
	
	                this.optionalBands.forEach(function (bandRanges, bandIdx) {
	                    _this4._animateItemForAddingData(bandRanges, data, function (itemIdx) {
	                        optionBands[bandIdx].range.splice(itemIdx, 1);
	                    });
	                });
	            }
	        }
	    };
	
	    /**
	     * Animate Item for adding data.
	     * @private
	     * @param {Array.<object>} optionalItems - svg rect elements for animate
	     * @param {{tickSize: number, shifting: boolean}} data - data for animation
	     * @param {function} removePlotItem - function for optional plot delete
	     */
	
	
	    Plot.prototype._animateItemForAddingData = function _animateItemForAddingData(optionalItems, data, removePlotItem) {
	        var _this5 = this;
	
	        optionalItems.forEach(function (item, lineIdx) {
	            var bbox = item.getBBox();
	
	            if (bbox.x - data.tickSize < _this5.layout.position.left) {
	                item.animate({
	                    transform: 'T-' + data.tickSize + ',0',
	                    opacity: 0
	                }, 300, 'linear', function () {
	                    removePlotItem(lineIdx);
	                    item.remove();
	                });
	            } else {
	                item.animate({
	                    transform: 'T-' + data.tickSize + ',0'
	                }, 300);
	            }
	        });
	    };
	
	    /**
	     * Check if  optionalLineData has range property and range property is 2D array
	     * @param {{range: ?Array.<number>}} optionalLineData - optional line data
	     * @private
	     */
	
	
	    Plot.prototype._makeRangeTo2DArray = function _makeRangeTo2DArray(optionalLineData) {
	        var range = optionalLineData.range;
	
	        var isOneDimensionArray = range && _tuiCodeSnippet2['default'].isArray(range) && (range.length === 0 || !_tuiCodeSnippet2['default'].isArray(range[0]));
	
	        if (isOneDimensionArray) {
	            optionalLineData.range = [range];
	        }
	    };
	
	    /**
	     * check if some areas are overlapped, and then merge overlapping area
	     * @param {Array.<{start: number, end: number}>} positionMaps - original positionMaps
	     * @returns {Array.<{start: number, end: number}>} - inspected positionMaps
	     * @private
	     */
	
	
	    Plot.prototype._mergeOverlappingPositionMaps = function _mergeOverlappingPositionMaps(positionMaps) {
	        var len = positionMaps.length;
	        var processedMap = void 0,
	            previous = void 0;
	
	        if (len) {
	            processedMap = [positionMaps[0]];
	            var _processedMap = processedMap;
	
	            var _processedMap2 = _slicedToArray(_processedMap, 1);
	
	            previous = _processedMap2[0];
	        }
	
	        for (var i = 1; i < len; i += 1) {
	            var current = positionMaps[i];
	
	            if (current.start <= previous.end) {
	                previous.end = Math.max(current.end, previous.end);
	            } else {
	                processedMap.push(current);
	                previous = current;
	            }
	        }
	
	        return processedMap;
	    };
	
	    return Plot;
	}();
	
	/**
	 * Compare positionMap by it's start value
	 * @param {{start: number, end: number}} previous - previouse plot band positionMap
	 * @param {{start: number, end: number}} current - current plot band positionMap
	 * @returns {number} - comparison of whether a is greater than b
	 * @ignore
	 */
	
	
	function compareByStartPosition(previous, current) {
	    return previous.start - current.start;
	}
	
	/**
	 * Factory for Plot
	 * @param {object} param parameter
	 * @returns {object}
	 * @ignore
	 */
	function plotFactory(param) {
	    var seriesTypes = param.seriesTypes,
	        _param$chartOptions = param.chartOptions,
	        chartType = _param$chartOptions.chartType,
	        xAxisType = _param$chartOptions.xAxis.type;
	
	    // same among bar, chart, line, area charts
	
	    param.chartType = chartType;
	    param.chartTypes = seriesTypes;
	    param.xAxisTypeOption = xAxisType;
	
	    return new Plot(param);
	}
	
	plotFactory.componentType = 'plot';
	plotFactory.Plot = Plot;

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = titleFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _pluginFactory = __webpack_require__(360);
	
	var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview  Title component.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var Title = function () {
	  /**
	   * Title component.
	   * @constructs Title
	   * @param {object} params parameters
	   *      @param {object} params.bound title bound
	   *      @param {object} params.theme title theme
	   *      @param {object} params.options title options
	   *      @param {object} params.text title text content
	   * @ignore
	   */
	  function Title(params) {
	    _classCallCheck(this, Title);
	
	    /**
	     * Theme
	     * @type {object}
	     */
	    this.theme = params.theme || {};
	
	    /**
	     * Title text content
	     * @type {string}
	     */
	    this.titleText = params.text;
	
	    /**
	     * Relative offset position
	     * @type {object}
	     */
	    this.offset = params.offset;
	
	    /**
	     * title align option
	     * @type {object}
	     */
	    this.align = params.align;
	
	    /**
	     * Graph renderer
	     * @type {object}
	     */
	    this.graphRenderer = _pluginFactory2['default'].get(_const2['default'].COMPONENT_TYPE_RAPHAEL, 'title');
	
	    /**
	     * Drawing type
	     * @type {string}
	     */
	    this.drawingType = _const2['default'].COMPONENT_TYPE_RAPHAEL;
	  }
	
	  /**
	   * Render title component
	   * @param {object} data data for render title
	   */
	
	
	  Title.prototype.render = function render(data) {
	    this.titleSet = this._renderTitleArea(data);
	  };
	
	  /**
	   * Render title component
	   * @param {object} data data for render title
	   */
	
	
	  Title.prototype.resize = function resize(data) {
	    var dimensionMap = data.dimensionMap;
	
	    var legendWidth = dimensionMap.legend ? dimensionMap.legend.width : 0;
	    var width = dimensionMap.series.width + legendWidth;
	
	    this.graphRenderer.resize(width, this.titleSet);
	  };
	
	  /**
	   * Render title component
	   * @param {object} data data for render title
	   */
	
	
	  Title.prototype.rerender = function rerender(data) {
	    this.titleSet.remove();
	
	    this.render(data);
	  };
	
	  /**
	   * Render title on given paper
	   * @param {object} data data for render title
	   * @returns {object} raphael paper
	   * @private
	   */
	
	
	  Title.prototype._renderTitleArea = function _renderTitleArea(data) {
	    var paper = data.paper,
	        dimensionMap = data.dimensionMap;
	
	    var chartTitleAreaWidth = this._calculateForTitleAreaWidth(dimensionMap);
	
	    return this.graphRenderer.render({
	      paper: paper,
	      titleText: this.titleText,
	      offset: this.offset,
	      theme: this.theme,
	      align: this.align,
	      chartTitleAreaWidth: chartTitleAreaWidth
	    });
	  };
	
	  /**
	   * Calculate title area width
	   * @param {object} dimensionMap dimensionMap
	   *     @param {object} dimensionMap.chartExportMenu dimension of chartExportMenu
	   *     @param {object} dimensionMap.chart chart of chartExportMenu
	   * @returns {number} title area width
	   * @private
	   */
	
	
	  Title.prototype._calculateForTitleAreaWidth = function _calculateForTitleAreaWidth(_ref) {
	    var chartExportMenu = _ref.chartExportMenu,
	        chart = _ref.chart;
	
	    var exportMenuWidth = chartExportMenu ? chartExportMenu.width * 2 : 0;
	
	    return chart.width - exportMenuWidth;
	  };
	
	  return Title;
	}();
	
	/**
	 * Factory for Title
	 * @param {object} param parameter
	 * @returns {object|null}
	 * @ignore
	 */
	
	
	function titleFactory(param) {
	  var options = param.chartOptions.chart || { title: {} };
	  var title = null;
	
	  if (options.title && options.title.text) {
	    param.text = options.title.text;
	    param.offset = options.title.offset;
	    param.align = options.title.align;
	
	    title = new Title(param);
	  }
	
	  return title;
	}
	
	titleFactory.componentType = 'title';
	titleFactory.Title = Title;

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = RadialPlotFactory;
	
	var _geometric = __webpack_require__(376);
	
	var _geometric2 = _interopRequireDefault(_geometric);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _pluginFactory = __webpack_require__(360);
	
	var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Radial plot component.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var COMPONENT_TYPE_RAPHAEL = _const2['default'].COMPONENT_TYPE_RAPHAEL,
	    RADIAL_PLOT_PADDING = _const2['default'].RADIAL_PLOT_PADDING,
	    RADIAL_MARGIN_FOR_CATEGORY = _const2['default'].RADIAL_MARGIN_FOR_CATEGORY,
	    RADIAL_CATEGORY_PADDING = _const2['default'].RADIAL_CATEGORY_PADDING;
	
	var RadialPlot = function () {
	    /**
	     * Plot component.
	     * @constructs Plot
	     * @param {object} params parameters
	     *      @param {number} params.vTickCount vertical tick count
	     *      @param {number} params.hTickCount horizontal tick count
	     *      @param {object} params.theme axis theme
	     * @ignore
	     */
	    function RadialPlot(params) {
	        _classCallCheck(this, RadialPlot);
	
	        /**
	         * plot component className
	         * @type {string}
	         */
	        this.className = 'tui-chart-plot-area';
	
	        /**
	         * Options
	         * @type {object}
	         */
	        this.options = _tuiCodeSnippet2['default'].extend({
	            type: 'spiderweb'
	        }, params.options);
	
	        /**
	         * Theme
	         * @type {object}
	         */
	        this.theme = params.theme || {};
	
	        /**
	         * Graph renderer
	         * @type {object}
	         */
	        this.graphRenderer = _pluginFactory2['default'].get(COMPONENT_TYPE_RAPHAEL, 'radialPlot');
	
	        this.drawingType = COMPONENT_TYPE_RAPHAEL;
	    }
	
	    /**
	     * Render plot area
	     * @param {object} paper paper object
	     * @param {object} layout layout
	     * @param {Array.<Array>} plotPositions plot positions
	     * @param {object} labelData label data
	     * @returns {Array.<object>} plotSet
	     */
	
	
	    RadialPlot.prototype._renderPlotArea = function _renderPlotArea(paper, layout, plotPositions, labelData) {
	        var renderParams = {
	            paper: paper,
	            layout: layout,
	            plotPositions: plotPositions,
	            labelData: labelData,
	            theme: this.theme,
	            options: this.options
	        };
	
	        return this.graphRenderer.render(renderParams);
	    };
	
	    /**
	     * Make plot positions for render
	     * @param {object} axisDataMap axisDataMap
	     * @param {object} layout layout
	     * @returns {Array.<Array>} plot positions
	     */
	
	
	    RadialPlot.prototype._makePositions = function _makePositions(axisDataMap, layout) {
	        var dimension = layout.dimension,
	            _layout$position = layout.position,
	            left = _layout$position.left,
	            top = _layout$position.top;
	        var width = dimension.width,
	            height = dimension.height;
	
	
	        width = width - RADIAL_PLOT_PADDING - RADIAL_MARGIN_FOR_CATEGORY;
	        height = height - RADIAL_PLOT_PADDING - RADIAL_MARGIN_FOR_CATEGORY;
	
	        var centerX = _calculator2['default'].sum([width / 2, RADIAL_PLOT_PADDING / 2, RADIAL_MARGIN_FOR_CATEGORY / 2, left]);
	
	        var centerY = height / 2 - RADIAL_PLOT_PADDING / 2 - RADIAL_MARGIN_FOR_CATEGORY / 2 - top;
	        var stepCount = axisDataMap.yAxis.tickCount;
	        var angleStepCount = axisDataMap.xAxis.labels.length;
	
	        return makeSpiderWebPositions({
	            width: width,
	            height: height,
	            centerX: centerX,
	            centerY: centerY,
	            angleStepCount: angleStepCount,
	            stepCount: stepCount
	        });
	    };
	
	    /**
	     * Make category positions
	     * @param {object} axisDataMap axisDataMap
	     * @param {object} layout layout
	     * @returns {Array.<object>} category positions
	     */
	
	
	    RadialPlot.prototype._makeCategoryPositions = function _makeCategoryPositions(axisDataMap, layout) {
	        var dimension = layout.dimension,
	            _layout$position2 = layout.position,
	            left = _layout$position2.left,
	            top = _layout$position2.top;
	        var width = dimension.width,
	            height = dimension.height;
	
	
	        width = width - RADIAL_PLOT_PADDING - RADIAL_CATEGORY_PADDING;
	        height = height - RADIAL_PLOT_PADDING - RADIAL_CATEGORY_PADDING;
	
	        var centerX = _calculator2['default'].sum([width / 2, RADIAL_PLOT_PADDING / 2, RADIAL_CATEGORY_PADDING / 2, left]);
	        var centerY = height / 2 - RADIAL_PLOT_PADDING / 2 - RADIAL_CATEGORY_PADDING / 2 - top;
	        var angleStepCount = axisDataMap.xAxis.labels.length;
	
	        return makeRadialCategoryPositions({
	            width: width,
	            height: height,
	            centerX: centerX,
	            centerY: centerY,
	            angleStepCount: angleStepCount
	        });
	    };
	
	    /**
	     * Make label data
	     * @param {object} axisDataMap axisDataMap
	     * @param {object} dimension dimension
	     * @param {Array.<Array>} plotPositions plot positions
	     * @returns {object}
	     */
	
	
	    RadialPlot.prototype._makeLabelData = function _makeLabelData(axisDataMap, dimension, plotPositions) {
	        var categories = axisDataMap.xAxis.labels;
	        var stepLabels = axisDataMap.yAxis.labels;
	
	        var categoryPositions = this._makeCategoryPositions(axisDataMap, dimension);
	        var categoryLabelData = [];
	        var stepLabelData = [];
	
	        for (var i = 0; i < categories.length; i += 1) {
	            categoryLabelData.push({
	                text: categories[i],
	                position: categoryPositions[i]
	            });
	        }
	
	        // skip last step label. it could overlapped by category label
	        for (var j = 0; j < stepLabels.length - 1; j += 1) {
	            stepLabelData.push({
	                text: stepLabels[j],
	                position: plotPositions[j][0]
	            });
	        }
	
	        return {
	            category: categoryLabelData,
	            step: stepLabelData
	        };
	    };
	
	    /**
	     * Render plot component.
	     * @param {object} data - bounds and scale data
	     */
	
	
	    RadialPlot.prototype.render = function render(_ref) {
	        var axisDataMap = _ref.axisDataMap,
	            layout = _ref.layout,
	            paper = _ref.paper;
	
	        var plotPositions = this._makePositions(axisDataMap, layout);
	        var labelData = this._makeLabelData(axisDataMap, layout, plotPositions);
	
	        this.plotSet = this._renderPlotArea(paper, layout, plotPositions, labelData);
	    };
	
	    /**
	     * Re render plot component
	     * @param {object} data - bounds and scale data
	     */
	
	
	    RadialPlot.prototype.rerender = function rerender(data) {
	        this.plotSet.remove();
	
	        this.render(data);
	    };
	
	    /**
	     * Resize plot component.
	     * @param {object} data - bounds and scale data
	     */
	
	
	    RadialPlot.prototype.resize = function resize(data) {
	        this.rerender(data);
	    };
	
	    return RadialPlot;
	}();
	
	/**
	 * Make Spider web positions
	 * @param {object} params parameters
	 *     @param {number} params.width width
	 *     @param {number} params.height height
	 *     @param {number} params.centerX center x coordinate
	 *     @param {number} params.centerY cneter y coordinate
	 *     @param {number} params.angleStepCount angle step count
	 *     @param {number} params.stepCount step count
	 * @returns {Array<Array>} positions
	 * @private
	 */
	
	
	function makeSpiderWebPositions(params) {
	    var width = params.width,
	        height = params.height,
	        centerX = params.centerX,
	        centerY = params.centerY,
	        angleStepCount = params.angleStepCount,
	        stepCount = params.stepCount;
	
	    var radius = Math.min(width, height) / 2;
	    var angleStep = 360 / angleStepCount;
	    var points = [];
	    var stepPixel = radius / (stepCount - 1); // As there is not size in step 0, one step is removed
	
	    for (var i = 0; i < stepCount; i += 1) {
	        var stepPoints = [];
	        // point Y of first pixel to rotate
	        var pointY = centerY + stepPixel * i;
	
	        for (var j = 0; j < angleStepCount; j += 1) {
	            var point = _geometric2['default'].rotatePointAroundOrigin(centerX, centerY, centerX, pointY, angleStep * j);
	
	            stepPoints.push({
	                left: point.x,
	                top: height - point.y // convert y to top
	            });
	        }
	
	        stepPoints.push(stepPoints[0]);
	        points[i] = stepPoints;
	    }
	
	    return points;
	}
	
	/**
	 * Make radial category positions
	 * @param {object} params parameters
	 *     @param {number} params.width width
	 *     @param {number} params.height height
	 *     @param {number} params.centerX center x coordinate
	 *     @param {number} params.centerY cneter y coordinate
	 *     @param {number} params.angleStepCount angle step count
	 * @returns {Array<object>} category positions
	 * @private
	 */
	function makeRadialCategoryPositions(params) {
	    var width = params.width,
	        height = params.height,
	        centerX = params.centerX,
	        centerY = params.centerY,
	        angleStepCount = params.angleStepCount;
	
	    var radius = Math.min(height, width) / 2;
	    var angleStep = 360 / angleStepCount;
	    var points = [];
	    var pointY = centerY + radius;
	
	    for (var i = 0; i < angleStepCount; i += 1) {
	        var reversedAngle = 360 - angleStep * i;
	        var point = _geometric2['default'].rotatePointAroundOrigin(centerX, centerY, centerX, pointY, reversedAngle);
	        var anchor = void 0;
	
	        if (reversedAngle > 0 && reversedAngle < 180) {
	            anchor = 'end';
	        } else if (reversedAngle > 180 && reversedAngle < 360) {
	            anchor = 'start';
	        } else {
	            anchor = 'middle';
	        }
	
	        points.push({
	            left: point.x,
	            top: height - point.y, // convert y to top
	            anchor: anchor
	        });
	    }
	
	    return points;
	}
	
	/**
	 * RadialPlotFactory
	 * @param {object} param chart options
	 * @returns {object} radialplot instanse
	 * @ignore
	 */
	function RadialPlotFactory(param) {
	    return new RadialPlot(param);
	}
	
	RadialPlotFactory.componentType = 'plot';
	RadialPlotFactory.RadialPlot = RadialPlot;

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Rotate a point around the origin with an angle.
	 * @param {number} centerX center point x
	 * @param {number} centerY center point y
	 * @param {number} pointX point x to rotate
	 * @param {number} pointY point y to rotate
	 * @param {number} angle angle
	 * @returns {object} x, y
	 * @ignore
	 */
	function rotatePointAroundOrigin(centerX, centerY, pointX, pointY, angle) {
	    var rad = angle * (Math.PI / 180);
	    var newX = (pointX - centerX) * Math.cos(rad) - (pointY - centerY) * Math.sin(rad);
	    var newY = (pointX - centerX) * Math.sin(rad) + (pointY - centerY) * Math.cos(rad);
	
	    newX += centerX;
	    newY += centerY;
	
	    return {
	        x: newX,
	        y: newY
	    };
	}
	/**
	 * Calculate adjacent.
	 * @param {number} degree degree
	 * @param {number} hypotenuse hypotenuse
	 * @returns {number} adjacent
	 * @ignore
	 *
	 *   H : Hypotenuse
	 *   A : Adjacent
	 *   O : Opposite
	 *   D : Degree
	 *
	 *        /|
	 *       / |
	 *    H /  | O
	 *     /   |
	 *    /\ D |
	 *    -----
	 *       A
	 */
	/**
	 * @fileoverview module for geometric operation
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	function calculateAdjacent(degree, hypotenuse) {
	    return Math.cos(degree * _const2['default'].RAD) * hypotenuse;
	}
	
	/**
	 * Calculate opposite.
	 * @param {number} degree degree
	 * @param {number} hypotenuse hypotenuse
	 * @returns {number} opposite
	 * @ignore
	 */
	function calculateOpposite(degree, hypotenuse) {
	    return Math.sin(degree * _const2['default'].RAD) * hypotenuse;
	}
	
	/**
	 * Calculate rotated width.
	 * @param {number} degree - degree
	 * @param {number} width - width
	 * @param {number} height - height
	 * @returns {number}
	 * @ignore
	 */
	function calculateRotatedWidth(degree, width, height) {
	    var centerHalf = calculateAdjacent(degree, width / 2);
	    var sideHalf = calculateAdjacent(_const2['default'].ANGLE_90 - degree, height / 2);
	
	    return (centerHalf + sideHalf) * 2;
	}
	
	/**
	 * Calculate rotated height
	 * @param {number} degree - degree
	 * @param {number} width - width
	 * @param {number} height - height
	 * @returns {number}
	 * @ignore
	 */
	function calculateRotatedHeight(degree, width, height) {
	    var centerHalf = calculateOpposite(degree, width / 2);
	    var sideHalf = calculateOpposite(_const2['default'].ANGLE_90 - degree, height / 2);
	
	    return (centerHalf + sideHalf) * 2;
	}
	
	exports['default'] = {
	    rotatePointAroundOrigin: rotatePointAroundOrigin,
	    calculateAdjacent: calculateAdjacent,
	    calculateRotatedHeight: calculateRotatedHeight,
	    calculateRotatedWidth: calculateRotatedWidth,
	    calculateOpposite: calculateOpposite
	};

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = chartExportMenuFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _chartExporter = __webpack_require__(378);
	
	var _chartExporter2 = _interopRequireDefault(_chartExporter);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _eventListener = __webpack_require__(382);
	
	var _eventListener2 = _interopRequireDefault(_eventListener);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview chartExportMenu component.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var CHART_EXPORT_MENU_ITEMS = ['xls', 'csv', 'png', 'jpeg'];
	var CLASS_NAME_CHART_EXPORT_MENU_OPENED = 'menu-opened';
	var CLASS_NAME_CHART_EXPORT_MENU_BUTTON = _const2['default'].CLASS_NAME_CHART_EXPORT_MENU_BUTTON,
	    CLASS_NAME_CHART_EXPORT_MENU = _const2['default'].CLASS_NAME_CHART_EXPORT_MENU,
	    CLASS_NAME_CHART_EXPORT_MENU_HEAD = _const2['default'].CLASS_NAME_CHART_EXPORT_MENU_HEAD,
	    CLASS_NAME_CHART_EXPORT_MENU_BODY = _const2['default'].CLASS_NAME_CHART_EXPORT_MENU_BODY,
	    CLASS_NAME_CHART_EXPORT_MENU_ITEM = _const2['default'].CLASS_NAME_CHART_EXPORT_MENU_ITEM,
	    COMPONENT_TYPE_DOM = _const2['default'].COMPONENT_TYPE_DOM;
	
	var ChartExportMenu = function () {
	    /**
	     * ChartExportMenu component.
	     * @constructs ChartExportMenu
	     * @private
	     * @param {object} params parameters
	     */
	    function ChartExportMenu(params) {
	        _classCallCheck(this, ChartExportMenu);
	
	        /**
	         * ChartExportMenu view className
	         * @type {string}
	         */
	        this.className = 'tui-chart-chartExportMenu-area';
	
	        /**
	         * Data processor
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = params.dataProcessor;
	
	        /**
	         * chart title
	         * @type {string}
	         */
	        this.chartTitle = params.chartTitle || 'tui-chart';
	
	        /**
	         * export filename
	         * @type {string}
	         */
	        this.exportFilename = params.exportFilename || this.chartTitle;
	
	        /**
	         * chart type
	         * @type {string}
	         */
	        this.chartType = params.chartType;
	
	        /**
	         * layout bounds information for this components
	         * @type {null|{dimension:{width:number, height:number}, position:{right:number, top:number}}}
	         */
	        this.layout = null;
	
	        /**
	         * chartExportMenu container
	         * @type {HTMLElement}
	         */
	        this.chartExportMenuContainer = null;
	
	        /**
	         * chartExportMenu element
	         * @type {HTMLElement}
	         */
	        this.chartExportMenu = null;
	
	        /**
	         * chartExportMenu options
	         */
	        this.options = params.options;
	
	        /**
	         * Event bus
	         * @type {EventBus}
	         */
	        this.eventBus = params.eventBus;
	        this.drawingType = COMPONENT_TYPE_DOM;
	
	        this.theme = params.theme || null;
	    }
	
	    /**
	     * Create chartExportMenuButton
	     * @returns {HTMLElement}
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._createChartExportMenuButton = function _createChartExportMenuButton() {
	        var menuButton = _domHandler2['default'].create('div', CLASS_NAME_CHART_EXPORT_MENU_BUTTON);
	
	        if (this.options.buttonClass) {
	            _domHandler2['default'].addClass(menuButton, this.options.buttonClass);
	        }
	
	        return menuButton;
	    };
	
	    /**
	     * Render chartExportMenu area.
	     * @param {HTMLElement} chartExportMenuContainer chartExportMenu area element
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._renderChartExportMenuArea = function _renderChartExportMenuArea(chartExportMenuContainer) {
	        var menuButton = this._createChartExportMenuButton();
	        var dimension = this.layout.dimension;
	
	
	        chartExportMenuContainer.appendChild(menuButton);
	
	        _renderUtil2['default'].renderDimension(chartExportMenuContainer, dimension);
	        _renderUtil2['default'].renderPosition(chartExportMenuContainer, this.layout.position);
	    };
	
	    /**
	     * Render chartExportMenu area.
	     * @param {HTMLElement} chartExportMenuContainer chartExportMenu area element
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._renderChartExportMenu = function _renderChartExportMenu(chartExportMenuContainer) {
	        var seriesDataModelMap = this.dataProcessor.seriesDataModelMap;
	
	        var isDataDownloadAvailable = this.isDataDownloadAvailable(seriesDataModelMap);
	        var isDownloadSupported = _chartExporter2['default'].isDownloadSupported,
	            isImageExtension = _chartExporter2['default'].isImageExtension,
	            isImageDownloadAvailable = _chartExporter2['default'].isImageDownloadAvailable;
	
	        var menuElement = _domHandler2['default'].create('ul', CLASS_NAME_CHART_EXPORT_MENU);
	        var menuHead = _domHandler2['default'].create('li', CLASS_NAME_CHART_EXPORT_MENU_HEAD);
	        var menuBody = _domHandler2['default'].create('li', CLASS_NAME_CHART_EXPORT_MENU_BODY);
	        var menuStyle = menuElement.style;
	        var _theme = this.theme,
	            borderWidth = _theme.borderWidth,
	            borderRadius = _theme.borderRadius,
	            backgroundColor = _theme.backgroundColor,
	            color = _theme.color;
	
	        var menuItems = [];
	
	        if (isDownloadSupported && (isDataDownloadAvailable || isImageDownloadAvailable)) {
	            menuItems = CHART_EXPORT_MENU_ITEMS.map(function (exportItemType) {
	                var itemElement = void 0;
	
	                if (!isImageExtension(exportItemType) && isDataDownloadAvailable || isImageExtension(exportItemType) && isImageDownloadAvailable) {
	                    itemElement = _domHandler2['default'].create('li', CLASS_NAME_CHART_EXPORT_MENU_ITEM);
	                    itemElement.id = exportItemType;
	                    itemElement.innerHTML = exportItemType;
	                }
	
	                return itemElement;
	            });
	        } else {
	            menuStyle.width = '200px';
	            menuItems[0] = _domHandler2['default'].create('li', CLASS_NAME_CHART_EXPORT_MENU_ITEM);
	            menuItems[0].innerHTML = 'Browser does not support client-side download.';
	        }
	
	        if (this.theme) {
	            if (borderWidth) {
	                menuStyle.borderWidth = borderWidth;
	            }
	
	            if (borderRadius) {
	                menuStyle.borderRadius = borderRadius;
	            }
	
	            if (backgroundColor) {
	                menuStyle.backgroundColor = backgroundColor;
	            }
	
	            if (color) {
	                menuStyle.color = color;
	            }
	        }
	
	        if (this.options.menuClass) {
	            _domHandler2['default'].addClass(menuElement, this.options.menuClass);
	        }
	
	        menuHead.innerHTML = 'Export to';
	
	        _domHandler2['default'].append(menuBody, menuItems);
	        _domHandler2['default'].append(menuElement, menuHead);
	        _domHandler2['default'].append(menuElement, menuBody);
	
	        this.chartExportMenu = menuElement;
	
	        _domHandler2['default'].append(chartExportMenuContainer, menuElement);
	    };
	
	    /**
	     * Set data for rendering.
	     * @param {{
	     *      layout: {
	     *          dimension: {width: number, height: number},
	     *          position: {left: number, top: number}
	     *      },
	     *      axisDataMap: object
	     * }} data - bounds and scale data
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._setDataForRendering = function _setDataForRendering(data) {
	        if (data) {
	            this.layout = data.layout;
	            this.dimensionMap = data.dimensionMap;
	            this.axisDataMap = data.axisDataMap;
	        }
	    };
	
	    /**
	     * Render chartExportMenu component.
	     * @param {object} data - bounds and scale data
	     * @returns {HTMLElement} chartExportMenu element
	     */
	
	
	    ChartExportMenu.prototype.render = function render(data) {
	        var container = null;
	
	        if (_chartExporter2['default'].isDownloadSupported) {
	            container = this.container = data.paper;
	
	            _domHandler2['default'].addClass(container, this.className);
	
	            this._setDataForRendering(data);
	            this._renderChartExportMenuArea(container);
	            this._renderChartExportMenu(container);
	            this.chartExportMenuContainer = container;
	            this._attachEvent();
	        }
	
	        return container;
	    };
	
	    /**
	     * Rerender.
	     */
	
	
	    ChartExportMenu.prototype.rerender = function rerender() {
	        this._hideChartExportMenu();
	    };
	
	    /**
	     * Resize.
	     */
	
	
	    ChartExportMenu.prototype.resize = function resize() {};
	
	    /**
	     * Show chart export menu
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._showChartExportMenu = function _showChartExportMenu() {
	        _domHandler2['default'].addClass(this.chartExportMenuContainer, CLASS_NAME_CHART_EXPORT_MENU_OPENED);
	        this.chartExportMenu.style.display = 'block';
	    };
	
	    /**
	     * Hide chart export menu
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._hideChartExportMenu = function _hideChartExportMenu() {
	        if (this.chartExportMenuContainer) {
	            _domHandler2['default'].removeClass(this.chartExportMenuContainer, CLASS_NAME_CHART_EXPORT_MENU_OPENED);
	            this.chartExportMenu.style.display = 'none';
	        }
	    };
	
	    /**
	     * onclick event handler
	     * @param {MouseEvent} e mouse event
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._onClick = function _onClick(e) {
	        var elTarget = e.target || e.srcElement;
	
	        if (_domHandler2['default'].hasClass(elTarget, CLASS_NAME_CHART_EXPORT_MENU_ITEM)) {
	            if (elTarget.id) {
	                var svgElement = this._getMainSvgElemenmt(this.container.parentNode);
	
	                this.eventBus.fire('beforeImageDownload');
	
	                _chartExporter2['default'].exportChart(this.exportFilename, elTarget.id, this.dataProcessor.rawData, svgElement, this.options);
	
	                this.eventBus.fire('afterImageDownload');
	            }
	
	            this._hideChartExportMenu();
	        } else if (_domHandler2['default'].hasClass(elTarget, CLASS_NAME_CHART_EXPORT_MENU_BUTTON) && this.chartExportMenuContainer === elTarget.parentNode && !_domHandler2['default'].hasClass(this.chartExportMenuContainer, CLASS_NAME_CHART_EXPORT_MENU_OPENED)) {
	            this._showChartExportMenu();
	        } else {
	            this._hideChartExportMenu();
	        }
	    };
	
	    /**
	     * Return chart svg
	     * @param {HTMLElement} mainContainer - chart container element
	     * @returns {HTMLElement} - chart main svg element
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._getMainSvgElemenmt = function _getMainSvgElemenmt(mainContainer) {
	        var svgElements = Array.from(mainContainer.getElementsByTagName('svg'));
	        var svgElement = void 0;
	
	        svgElements.forEach(function (svg) {
	            if (mainContainer === svg.parentNode) {
	                svgElement = svg;
	            }
	        });
	
	        return svgElement;
	    };
	
	    /**
	     * Return boolean value for chart data is able to export
	     * @param {object} seriesDataModels series data model
	     * @returns {boolean}
	     */
	
	
	    ChartExportMenu.prototype.isDataDownloadAvailable = function isDataDownloadAvailable(seriesDataModels) {
	        var result = true;
	
	        if (_predicate2['default'].isTreemapChart(this.chartType)) {
	            result = false;
	        } else {
	            Object.values(seriesDataModels).forEach(function (seriesDataModel) {
	                if (seriesDataModel.isCoordinateType) {
	                    result = false;
	                }
	
	                return false;
	            });
	        }
	
	        return result;
	    };
	
	    /**
	     * Attach browser event.
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._attachEvent = function _attachEvent() {
	        _eventListener2['default'].on(this.chartExportMenuContainer.parentNode, 'click', this._onClick, this);
	    };
	
	    /**
	     * Detach browser event.
	     * @private
	     */
	
	
	    ChartExportMenu.prototype._detachEvent = function _detachEvent() {
	        _eventListener2['default'].off(this.chartExportMenuContainer.parentNode, 'click', this._onClick);
	    };
	
	    return ChartExportMenu;
	}();
	
	/**
	 * Factory for ChartExportMenu
	 * @param {object} params parameter
	 * @returns {object|null}
	 * @ignore
	 */
	
	
	function chartExportMenuFactory(params) {
	    var isVisible = params.options.visible;
	    var _params$chartOptions$ = params.chartOptions.chart,
	        chartOption = _params$chartOptions$ === undefined ? {} : _params$chartOptions$;
	
	    var exportingOption = params.chartOptions.chartExportMenu;
	    var chartExportMenu = null;
	
	    if (chartOption.title) {
	        params.chartTitle = chartOption.title.text;
	    }
	
	    if (exportingOption && exportingOption.filename) {
	        params.exportFilename = exportingOption.filename;
	    }
	
	    if (isVisible) {
	        chartExportMenu = new ChartExportMenu(params);
	    }
	
	    return chartExportMenu;
	}
	
	chartExportMenuFactory.componentType = 'chartExportMenu';

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _dataExporter = __webpack_require__(379);
	
	var _dataExporter2 = _interopRequireDefault(_dataExporter);
	
	var _imageExporter = __webpack_require__(381);
	
	var _imageExporter2 = _interopRequireDefault(_imageExporter);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * @fileOverview Chart exporter
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	var browser = _tuiCodeSnippet2['default'].browser,
	    isExisty = _tuiCodeSnippet2['default'].isExisty,
	    isString = _tuiCodeSnippet2['default'].isString;
	
	
	var isIE10OrIE11 = browser.msie && (browser.version === 10 || browser.version === 11);
	var isImageDownloadAvailable = !isIE10OrIE11 || isIE10OrIE11 && document.createElement('canvas').getContext('2d').drawSvg;
	var isDownloadAttributeSupported = isExisty(document.createElement('a').download);
	var isMsSaveOrOpenBlobSupported = window.Blob && window.navigator.msSaveOrOpenBlob;
	
	/**
	 * Return given extension type is image format
	 * @param {string} extension extension
	 * @returns {boolean}
	 * @ignore
	 */
	function isImageExtension(extension) {
	    return _arrayUtil2['default'].any(_imageExporter2['default'].getExtensions(), function (imageExtension) {
	        return extension === imageExtension;
	    });
	}
	/**
	 * Return given extension type is data format
	 * @param {string} extension extension
	 * @returns {boolean}
	 * @ignore
	 */
	function isDataExtension(extension) {
	    return _arrayUtil2['default'].any(_dataExporter2['default'].getExtensions(), function (dataExtension) {
	        return extension === dataExtension;
	    });
	}
	
	/**
	 * Download chart data with given export type
	 * @param {string} fileName - file name = chart title
	 * @param {string} extension - file extension
	 * @param {object} rawData - chart raw data
	 * @param {HTMLElement} svgElement - svg element
	 * @param {object} [downloadOptions] download option
	 * @ignore
	 */
	function exportChart(fileName, extension, rawData, svgElement, downloadOptions) {
	    var downloadOption = downloadOptions && downloadOptions[extension] ? downloadOptions[extension] : {};
	
	    if (isImageExtension(extension)) {
	        _imageExporter2['default'].downloadImage(fileName, extension, svgElement);
	    } else if (isDataExtension(extension)) {
	        _dataExporter2['default'].downloadData(fileName, extension, rawData, downloadOption);
	    }
	}
	
	exports['default'] = {
	    exportChart: exportChart,
	    isDownloadSupported: isDownloadAttributeSupported || isMsSaveOrOpenBlobSupported,
	    isImageDownloadAvailable: isImageDownloadAvailable,
	    isImageExtension: isImageExtension,
	
	    /**
	     * Add file extension to dataExtension
	     * @param {string} type file extension type
	     * @param {string} extension file extension
	     */
	    addExtension: function addExtension(type, extension) {
	        var isValidExtension = extension && isString(extension);
	        var exporter = void 0;
	        var extensions = void 0;
	
	        if (type === 'data') {
	            exporter = _dataExporter2['default'];
	        } else if (type === 'image') {
	            exporter = _imageExporter2['default'];
	        }
	
	        if (exporter && isValidExtension) {
	            extensions = exporter.getExtensions();
	            extensions.push(extension);
	        }
	    }
	};

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _templateObject = _taggedTemplateLiteral(['<html xmlns:o="urn:schemas-microsoft-com:office:office" \n        xmlns:x="urn:schemas-microsoft-com:office:excel" \n        xmlns="http://www.w3.org/TR/REC-html40">\n        <head>\n            <!--[if gte mso 9]>\n                <xml>\n                    <x:ExcelWorkbook>\n                        <x:ExcelWorksheets>\n                            <x:ExcelWorksheet>\n                                <x:Name>Ark1</x:Name>\n                                <x:WorksheetOptions>\n                                    <x:DisplayGridlines/>\n                                </x:WorksheetOptions>\n                            </x:ExcelWorksheet>\n                        </x:ExcelWorksheets>\n                        </x:ExcelWorkbook>\n                </xml>\n            <![endif]-->\n            <meta name=ProgId content=Excel.Sheet>\n            <meta charset=UTF-8>\n        </head>\n        <body>\n            ', '\n        </body>\n        </html>'], ['<html xmlns:o="urn:schemas-microsoft-com:office:office" \n        xmlns:x="urn:schemas-microsoft-com:office:excel" \n        xmlns="http://www.w3.org/TR/REC-html40">\n        <head>\n            <!--[if gte mso 9]>\n                <xml>\n                    <x:ExcelWorkbook>\n                        <x:ExcelWorksheets>\n                            <x:ExcelWorksheet>\n                                <x:Name>Ark1</x:Name>\n                                <x:WorksheetOptions>\n                                    <x:DisplayGridlines/>\n                                </x:WorksheetOptions>\n                            </x:ExcelWorksheet>\n                        </x:ExcelWorksheets>\n                        </x:ExcelWorkbook>\n                </xml>\n            <![endif]-->\n            <meta name=ProgId content=Excel.Sheet>\n            <meta charset=UTF-8>\n        </head>\n        <body>\n            ', '\n        </body>\n        </html>']);
	
	var _downloader = __webpack_require__(380);
	
	var _downloader2 = _interopRequireDefault(_downloader);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
	                                                                                                                                                                                                     * @fileOverview Chart data exporter
	                                                                                                                                                                                                     * @author NHN.
	                                                                                                                                                                                                     *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                     */
	
	var DATA_URI_HEADERS = {
	    xls: 'data:application/vnd.ms-excel;base64,',
	    csv: 'data:text/csv;charset=utf-8,%EF%BB%BF' /* BOM for utf-8 */
	};
	var DATA_URI_BODY_MAKERS = {
	    xls: _makeXlsBodyWithRawData,
	    csv: _makeCsvBodyWithRawData
	};
	var dataExtensions = [].concat(_toConsumableArray(_const2['default'].DATA_EXTENSIONS));
	
	var dataExporter = {
	    /**
	     * Download chart data
	     * @param {string} fileName file name
	     * @param {string} extension file extension
	     * @param {object} rawData raw data of chart
	     * @param {object} [downloadOption] download option
	     */
	    downloadData: function downloadData(fileName, extension, rawData, downloadOption) {
	        var chartData2DArray = _get2DArrayFromRawData(rawData);
	        var contentType = DATA_URI_HEADERS[extension].replace(/(data:|;base64,|,%EF%BB%BF)/g, '');
	        var content = DATA_URI_BODY_MAKERS[extension](chartData2DArray, downloadOption);
	
	        if (this._isNeedDataEncodeing()) {
	            if (extension !== 'csv') {
	                // base64 encoding for data URI scheme.
	                content = window.btoa(unescape(encodeURIComponent(content)));
	            }
	            content = DATA_URI_HEADERS[extension] + content;
	        }
	
	        _downloader2['default'].execDownload(fileName, extension, content, contentType);
	    },
	
	
	    /**
	     * Whether need encode type or not
	     * @returns {boolean}
	     * @private
	     */
	    _isNeedDataEncodeing: function _isNeedDataEncodeing() {
	        var isDownloadAttributeSupported = _tuiCodeSnippet2['default'].isExisty(document.createElement('a').download);
	        var isMsSaveOrOpenBlobSupported = window.Blob && window.navigator.msSaveOrOpenBlob;
	
	        if (!isMsSaveOrOpenBlobSupported && isDownloadAttributeSupported) {
	            return true;
	        }
	
	        return false;
	    },
	
	
	    /**
	     * Returns data extensions
	     * @returns {Array.<string>}
	     */
	    getExtensions: function getExtensions() {
	        return dataExtensions;
	    }
	};
	
	/**
	 * Get pivoted second dimension array from table to use element.innerText
	 * @param {rawData} rawData - chart's raw data
	 * @returns {Array.<Array>}
	 * @private
	 */
	function _get2DArrayFromRawData(rawData) {
	    var resultArray = [];
	    var isHeatMap = rawData.categories && _tuiCodeSnippet2['default'].isExisty(rawData.categories.x);
	    var isBullet = rawData.series && _tuiCodeSnippet2['default'].isExisty(rawData.series.bullet);
	    var return2DArrayData = false;
	
	    if (rawData) {
	        var categories = void 0;
	
	        if (isHeatMap) {
	            return2DArrayData = _get2DArrayFromHeatmapRawData(rawData);
	        } else if (isBullet) {
	            return2DArrayData = _get2DArrayFromBulletRawData(rawData);
	        } else if (rawData.categories) {
	            categories = rawData.categories;
	        }
	        if (return2DArrayData) {
	            return return2DArrayData;
	        }
	
	        resultArray.push([''].concat(categories));
	
	        Object.values(rawData.series || {}).forEach(function (seriesDatum) {
	            seriesDatum.forEach(function (seriesItem) {
	                var data = _tuiCodeSnippet2['default'].isArray(seriesItem.data) ? seriesItem.data : [seriesItem.data];
	
	                resultArray.push([seriesItem.name].concat(_toConsumableArray(data)));
	            });
	        });
	    }
	
	    return resultArray;
	}
	
	/**
	 * Make table head data for Excel
	 * @param {number} maxRangeCount - max range count
	 * @param {number} maxMarkerCount - max marker count
	 * @returns {Array.<string>} - table head data
	 * @private
	 */
	function _makeTHeadForBullet(maxRangeCount, maxMarkerCount) {
	    var tableHead = ['', _const2['default'].BULLET_TYPE_ACTUAL];
	
	    for (var i = 0; i < maxRangeCount; i += 1) {
	        tableHead.push(_const2['default'].BULLET_TYPE_RANGE + i);
	    }
	
	    for (var _i = 0; _i < maxMarkerCount; _i += 1) {
	        tableHead.push(_const2['default'].BULLET_TYPE_MARKER + _i);
	    }
	
	    return tableHead;
	}
	
	/**
	 * Make table cells from bullet ranges
	 * @param {Array.<Array.<number>>} ranges - series item's ranges data
	 * @param {number} maxRangeCount - max range count
	 * @returns {Array.<number>} - cells containing range data
	 * @private
	 */
	function _makeTCellsFromBulletRanges(ranges, maxRangeCount) {
	    var cells = [];
	
	    for (var i = 0; i < maxRangeCount; i += 1) {
	        var dataText = '';
	
	        if (ranges && ranges[i]) {
	            var rangeStart = ranges[i].length > 0 ? ranges[i][0] : '';
	            var rangeEnd = ranges[i].length > 1 ? ranges[i][1] : '';
	
	            dataText = rangeStart + '~' + rangeEnd;
	        }
	        cells.push(dataText);
	    }
	
	    return cells;
	}
	
	/**
	 * Make table cells from bullet markers
	 * @param {Array.<Array.<number>>} markers - series item's markers data
	 * @param {number} maxMarkerCount - max marker count
	 * @returns {Array.<number>} - cells containing marker data
	 * @private
	 */
	function _makeTCellsFromBulletMarkers(markers, maxMarkerCount) {
	    var cells = [];
	
	    for (var i = 0; i < maxMarkerCount; i += 1) {
	        var dataText = markers && markers[i] ? markers[i] : '';
	        cells.push(dataText);
	    }
	
	    return cells;
	}
	
	/**
	 * Make table data for importing in excel, by using bullet chart raw data
	 * @param {object} rawData - raw data
	 * @param {object} [options] download option
	 * @returns {Array.<Array.<string>>} - table data for importing in excel
	 * @private
	 */
	function _get2DArrayFromBulletRawData(rawData) {
	    var resultArray = [];
	    var maxCounts = _calculateMaxCounts(rawData.series.bullet);
	    var maxRangeCount = maxCounts.maxRangeCount,
	        maxMarkerCount = maxCounts.maxMarkerCount;
	
	
	    resultArray.push(_makeTHeadForBullet(maxRangeCount, maxMarkerCount));
	
	    _tuiCodeSnippet2['default'].forEach(rawData.series.bullet, function (seriesItem) {
	        var rangeArray = _makeTCellsFromBulletRanges(seriesItem.ranges, maxRangeCount);
	        var markerArray = _makeTCellsFromBulletMarkers(seriesItem.markers, maxMarkerCount);
	        var row = [seriesItem.name, seriesItem.data].concat(_toConsumableArray(rangeArray), _toConsumableArray(markerArray));
	        resultArray.push(row);
	    });
	
	    return resultArray;
	}
	
	/**
	 * Calculate maxinum count of range and marker property
	 * @param {object} bulletSeries - raw series data of bullet chart
	 * @returns {object} - maximum count of range and marker property
	 * @private
	 */
	function _calculateMaxCounts(bulletSeries) {
	    var maxRangeCount = 0;
	    var maxMarkerCount = 0;
	
	    _tuiCodeSnippet2['default'].forEach(bulletSeries, function (series) {
	        maxRangeCount = Math.max(maxRangeCount, series.ranges.length);
	        maxMarkerCount = Math.max(maxMarkerCount, series.markers.length);
	    });
	
	    return {
	        maxRangeCount: maxRangeCount,
	        maxMarkerCount: maxMarkerCount
	    };
	}
	
	/**
	 * Make table data for importing in excel, by using heatmap chart raw data
	 * @param {object} rawData - raw data
	 * @returns {Array.<Array.<string>>} - table data for importing in excel
	 * @private
	 */
	function _get2DArrayFromHeatmapRawData(rawData) {
	    var resultArray = [];
	
	    resultArray.push([''].concat(_toConsumableArray(rawData.categories.x)));
	
	    _tuiCodeSnippet2['default'].forEach(rawData.series, function (seriesDatum) {
	        _tuiCodeSnippet2['default'].forEach(seriesDatum, function (seriesItem, index) {
	            var row = [rawData.categories.y[index]].concat(_toConsumableArray(seriesItem));
	            resultArray.push(row);
	        });
	    });
	
	    return resultArray;
	}
	
	/**
	 * Get table element from chart data 2D array for xls content
	 * @param {Array.<Array<*>>} chartData2DArray - chart data 2D array
	 * @returns {string}
	 * @private
	 */
	function _getTableElementStringForXls(chartData2DArray) {
	    var tableElementString = '<table>';
	    _tuiCodeSnippet2['default'].forEach(chartData2DArray, function (row, rowIndex) {
	        var cellTagName = rowIndex === 0 ? 'th' : 'td';
	
	        tableElementString += '<tr>';
	
	        _tuiCodeSnippet2['default'].forEach(row, function (cell, cellIndex) {
	            var cellNumberClass = rowIndex !== 0 || cellIndex === 0 ? ' class="number"' : '';
	            var cellString = '<' + cellTagName + cellNumberClass + '>' + cell + '</' + cellTagName + '>';
	
	            tableElementString += cellString;
	        });
	
	        tableElementString += '</tr>';
	    });
	
	    tableElementString += '</table>';
	
	    return tableElementString;
	}
	
	/**
	 * Make xls file with chart series data
	 * @param {Array.<Array.<object>>} chartData2DArray - chart chartData2DArray
	 * @returns {string} base64 xls file content
	 * @private
	 */
	function _makeXlsBodyWithRawData(chartData2DArray) {
	    var xlsString = _renderUtil2['default'].oneLineTrim(_templateObject, _getTableElementStringForXls(chartData2DArray));
	
	    return xlsString;
	}
	
	/**
	 * Make csv text with chart series data
	 * @param {Array.<Array.<object>>} chartData2DArray - chart chartData2DArray
	 * @param {object} [option] - download option
	 * @param {object} [option.itemDelimiter = ','] - item delimiter
	 * @param {object} [option.lineDelimiter = '\n'] - line delimiter
	 * @returns {string} URI encoded csv text
	 * @private
	 */
	function _makeCsvBodyWithRawData(chartData2DArray) {
	    var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var _option$lineDelimiter = option.lineDelimiter,
	        lineDelimiter = _option$lineDelimiter === undefined ? '\n' : _option$lineDelimiter,
	        _option$itemDelimiter = option.itemDelimiter,
	        itemDelimiter = _option$itemDelimiter === undefined ? ',' : _option$itemDelimiter;
	
	    var lastRowIndex = chartData2DArray.length - 1;
	    var csvText = '';
	
	    _tuiCodeSnippet2['default'].forEachArray(chartData2DArray, function (row, rowIndex) {
	        var lastCellIndex = row.length - 1;
	
	        _tuiCodeSnippet2['default'].forEachArray(row, function (cell, cellIndex) {
	            var cellContent = _tuiCodeSnippet2['default'].isNumber(cell) ? cell : '"' + cell + '"';
	
	            csvText += cellContent;
	
	            if (cellIndex < lastCellIndex) {
	                csvText += itemDelimiter;
	            }
	        });
	
	        if (rowIndex < lastRowIndex) {
	            csvText += lineDelimiter;
	        }
	    });
	
	    return csvText;
	}
	
	// export private methods for Test
	Object.assign(dataExporter, {
	    _makeCsvBodyWithRawData: _makeCsvBodyWithRawData,
	    _makeXlsBodyWithRawData: _makeXlsBodyWithRawData,
	    _get2DArrayFromRawData: _get2DArrayFromRawData,
	    _get2DArrayFromBulletRawData: _get2DArrayFromBulletRawData,
	    _get2DArrayFromHeatmapRawData: _get2DArrayFromHeatmapRawData,
	    _makeTCellsFromBulletRanges: _makeTCellsFromBulletRanges,
	    _makeTCellsFromBulletMarkers: _makeTCellsFromBulletMarkers,
	    _makeTHeadForBullet: _makeTHeadForBullet
	});
	
	exports['default'] = dataExporter;

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var DOWNLOAD_HANDLERS = {
	    downloadAttribute: downloadWithAnchorElementDownloadAttribute,
	    msSaveOrOpenBlob: downloadWithMsSaveOrOpenBlob
	};
	
	/**
	 * Return download method name of current browser supports
	 * @returns {string}
	 * @ignore
	 */
	/**
	 * @fileOverview File downloader for client-side download
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	function getDownloadMethod() {
	    var isDownloadAttributeSupported = _tuiCodeSnippet2['default'].isExisty(document.createElement('a').download);
	    var isMsSaveOrOpenBlobSupported = window.Blob && window.navigator.msSaveOrOpenBlob;
	    var method = void 0;
	
	    if (isMsSaveOrOpenBlobSupported) {
	        method = 'msSaveOrOpenBlob';
	    } else if (isDownloadAttributeSupported) {
	        method = 'downloadAttribute';
	    }
	
	    return method;
	}
	
	/**
	 * Base64 string to blob
	 * original source ref: https://github.com/miguelmota/base64toblob/blob/master/base64toblob.js
	 * Licence: MIT Licence
	 * @param {string} base64String - base64 string
	 * @returns {Blob}
	 * @ignore
	 */
	function base64toBlob(base64String) {
	    var contentType = base64String.substr(0, base64String.indexOf(';base64,')).substr(base64String.indexOf(':') + 1);
	    var sliceSize = 1024;
	    var byteCharacters = atob(base64String.substr(base64String.indexOf(',') + 1));
	    var byteArrays = [];
	
	    for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
	        var slice = byteCharacters.slice(offset, offset + sliceSize);
	        var byteNumbers = new Array(slice.length);
	
	        for (var i = 0; i < slice.length; i += 1) {
	            byteNumbers[i] = slice.charCodeAt(i);
	        }
	
	        var byteArray = new window.Uint8Array(byteNumbers);
	
	        byteArrays.push(byteArray);
	    }
	
	    var resultBlob = new Blob(byteArrays, { type: contentType });
	
	    return resultBlob;
	}
	
	/**
	 * Return given extension type is image format
	 * @param {string} extension extension
	 * @returns {boolean}
	 * @ignore
	 */
	function isImageExtension(extension) {
	    return _arrayUtil2['default'].any(_const2['default'].IMAGE_EXTENSIONS, function (imageExtension) {
	        return extension === imageExtension;
	    });
	}
	
	/**
	 * Download content to file with msSaveOrOpenBlob
	 * @param {string} fileName - file name
	 * @param {string} extension - file extension
	 * @param {string} content - file content
	 * @param {string} contentType - file content type
	 * @ignore
	 */
	function downloadWithMsSaveOrOpenBlob(fileName, extension, content, contentType) {
	    var blobObject = isImageExtension(extension) ? base64toBlob(content) : new Blob([content], { type: contentType });
	    window.navigator.msSaveOrOpenBlob(blobObject, fileName + '.' + extension);
	}
	
	/**
	 * Download content to file with anchor element's download attribute
	 * @param {string} fileName - file name
	 * @param {string} extension - file extension
	 * @param {string} content - file content
	 * @ignore
	 */
	function downloadWithAnchorElementDownloadAttribute(fileName, extension, content) {
	    if (content) {
	        var anchorElement = document.createElement('a');
	
	        anchorElement.href = content;
	        anchorElement.target = '_blank';
	        anchorElement.download = fileName + '.' + extension;
	
	        document.body.appendChild(anchorElement);
	
	        anchorElement.click();
	        anchorElement.remove();
	    }
	}
	
	/**
	 * Download content to file with given filename and extension
	 * @param {string} fileName - file name
	 * @param {string} extension - file extension
	 * @param {string} content - file content
	 * @param {string} contentType - file content type
	 * @ignore
	 */
	function execDownload(fileName, extension, content, contentType) {
	    var downloadMethod = getDownloadMethod();
	
	    if (downloadMethod && _tuiCodeSnippet2['default'].isString(content)) {
	        DOWNLOAD_HANDLERS[downloadMethod](fileName, extension, content, contentType);
	    }
	}
	
	exports['default'] = {
	    execDownload: execDownload
	};

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _downloader = __webpack_require__(380);
	
	var _downloader2 = _interopRequireDefault(_downloader);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
	                                                                                                                                                                                                     * @fileOverview Chart image exporter
	                                                                                                                                                                                                     * @author NHN.
	                                                                                                                                                                                                     *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                     */
	
	var browser = _tuiCodeSnippet2['default'].browser;
	
	var isIE10OrIE11 = browser.msie && (browser.version === 10 || browser.version === 11);
	var DOMURL = window.URL || window.webkitURL || window;
	var imageExtensions = [].concat(_toConsumableArray(_const2['default'].IMAGE_EXTENSIONS));
	
	/**
	 * Return svg outerHTML string
	 * @param {HTMLElement} svgElement svg element
	 * @returns {string}
	 * @ignore
	 */
	function getSvgString(svgElement) {
	    var svgParent = svgElement.parentNode;
	    var tempWrapper = document.createElement('DIV');
	
	    tempWrapper.appendChild(svgElement);
	
	    var svgString = tempWrapper.innerHTML;
	
	    svgParent.appendChild(svgElement);
	
	    tempWrapper = null;
	    svgParent = null;
	
	    return svgString;
	}
	
	/**
	 * Download with SVG string and canvg
	 * @param {HTMLElement} canvas canvas element
	 * @param {string} svgString svg HTML string
	 * @param {string} fileName file name
	 * @param {string} extension file extension
	 * @ignore
	 */
	function downloadSvgWithCanvg(canvas, svgString, fileName, extension) {
	    var ctx = canvas.getContext('2d');
	
	    // remove name space for IE
	    if (isIE10OrIE11) {
	        svgString = svgString.replace(/xmlns:NS1=""/, '');
	        svgString = svgString.replace(/NS1:xmlns:xlink="http:\/\/www\.w3\.org\/1999\/xlink"/, '');
	        svgString = svgString.replace(/xmlns="http:\/\/www\.w3\.org\/2000\/svg"/, '');
	        svgString = svgString.replace(/xmlns:xlink="http:\/\/www\.w3\.org\/1999\/xlink"/, '');
	    }
	
	    ctx.drawSvg(svgString, 0, 0);
	
	    _downloader2['default'].execDownload(fileName, extension, canvas.toDataURL('image/' + extension, 1));
	}
	
	/**
	 * Download with SVG string and blob URL
	 * @param {HTMLElement} canvas canvas element
	 * @param {string} svgString svg HTML string
	 * @param {string} fileName file name
	 * @param {string} extension file extension
	 * @ignore
	 */
	function downloadSvgWithBlobURL(canvas, svgString, fileName, extension) {
	    var ctx = canvas.getContext('2d');
	    var blob = new Blob([svgString], { type: 'image/svg+xml' });
	    var url = DOMURL.createObjectURL(blob);
	    var img = new Image();
	
	    img.onload = function () {
	        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
	
	        _downloader2['default'].execDownload(fileName, extension, canvas.toDataURL('image/' + extension, 1));
	
	        DOMURL.revokeObjectURL(url);
	    };
	
	    img.src = url;
	}
	
	exports['default'] = {
	    /**
	     * Download image with png format
	     * @param {string} fileName - file name to save
	     * @param {string} extension - extension type
	     * @param {HTMLElement} imageSourceElement - image source element
	     */
	    downloadImage: function downloadImage(fileName, extension, imageSourceElement) {
	        var canvas = void 0;
	
	        if (imageSourceElement.tagName === 'svg') {
	            var parentNode = imageSourceElement.parentNode;
	
	            var svgString = getSvgString(imageSourceElement);
	
	            canvas = document.createElement('canvas');
	
	            canvas.width = parentNode.offsetWidth;
	            canvas.height = parentNode.offsetHeight;
	
	            if (isIE10OrIE11) {
	                downloadSvgWithCanvg(canvas, svgString, fileName, extension);
	            } else {
	                downloadSvgWithBlobURL(canvas, svgString, fileName, extension);
	            }
	        } else if (imageSourceElement.tagName === 'canvas') {
	            canvas = imageSourceElement;
	
	            _downloader2['default'].execDownload(fileName, extension, canvas.toDataURL('image/' + extension, 1));
	        }
	    },
	
	
	    /**
	     * Returns data extensions
	     * @returns {Array.<string>}
	     */
	    getExtensions: function getExtensions() {
	        return imageExtensions;
	    }
	};

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var bindHandlerMap = {};
	
	/**
	 * Event listener.
	 * @module eventListener
	 * @private */
	/**
	 * @fileoverview Event listener.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	var eventListener = {
	    /**
	     * Add event listener for IE.
	     * @memberOf module:eventListener
	     * @param {HTMLElement} target target element
	     * @param {string} type event type
	     * @param {function} handler callback function
	     * @param {?object} context context for callback
	     * @private
	     */
	    _attachEvent: function _attachEvent(target, type, handler, context) {
	        var bindHandler = void 0;
	
	        if (context) {
	            bindHandler = handler.bind(context);
	        } else {
	            bindHandler = handler;
	        }
	
	        bindHandlerMap[type + handler] = bindHandler;
	        target.attachEvent('on' + type, bindHandler);
	    },
	
	
	    /**
	     * Add event listener for other browsers.
	     * @memberOf module:eventListener
	     * @param {HTMLElement} target - target element
	     * @param {string} type - event type
	     * @param {function} handler - handler
	     * @param {object} [context] - context for handler
	     * @private
	     */
	    _addEventListener: function _addEventListener(target, type, handler, context) {
	        var bindHandler = void 0;
	
	        if (context) {
	            bindHandler = _tuiCodeSnippet2['default'].bind(handler, context);
	        } else {
	            bindHandler = handler;
	        }
	
	        bindHandlerMap[type + handler] = bindHandler;
	        target.addEventListener(type, bindHandler);
	    },
	
	
	    /**
	     * Bind DOM event.
	     * @memberOf module:eventListener
	     * @memberOf module:eventListener
	     * @param {HTMLElement} target target element
	     * @param {string} type event type
	     * @param {function} handler handler function
	     * @param {object} [context] - context for handler
	     * @private
	     */
	    _bindEvent: function _bindEvent(target, type, handler, context) {
	        var bindEvent = void 0;
	
	        if ('addEventListener' in target) {
	            bindEvent = this._addEventListener;
	        } else if ('attachEvent' in target) {
	            bindEvent = this._attachEvent;
	        }
	        eventListener._bindEvent = bindEvent;
	
	        bindEvent(target, type, handler, context);
	    },
	
	
	    /**
	     * Bind DOM events.
	     * @memberOf module:eventListener
	     * @param {HTMLElement} target - target element
	     * @param {string | object} types - type or map of type and handler
	     * @param {function | object} [handler] - handler or context
	     * @param {object} [context] - context
	     */
	    on: function on(target, types, handler, context) {
	        var handlerMap = {};
	        if (_tuiCodeSnippet2['default'].isString(types)) {
	            handlerMap[types] = handler;
	        } else {
	            handlerMap = types;
	            context = handler;
	        }
	
	        _tuiCodeSnippet2['default'].forEach(handlerMap, function (_handler, type) {
	            eventListener._bindEvent(target, type, _handler, context);
	        });
	    },
	
	
	    /**
	     * Remove event listener for IE.
	     * @memberOf module:eventListener
	     * @param {HTMLElement} target - target element
	     * @param {string} type - event type
	     * @param {function} handler - handler
	     * @private
	     */
	    _detachEvent: function _detachEvent(target, type, handler) {
	        if (bindHandlerMap[type + handler]) {
	            target.detachEvent('on' + type, bindHandlerMap[type + handler]);
	            delete bindHandlerMap[type + handler];
	        }
	    },
	
	
	    /**
	     * Add event listener for other browsers.
	     * @memberOf module:eventListener
	     * @param {HTMLElement} target - target element
	     * @param {string} type - event type
	     * @param {function} handler - handler
	     * @private
	     */
	    _removeEventListener: function _removeEventListener(target, type, handler) {
	        target.removeEventListener(type, bindHandlerMap[type + handler]);
	        delete bindHandlerMap[type + handler];
	    },
	
	
	    /**
	     * Unbind DOM event.
	     * @memberOf module:eventListener
	     * @param {HTMLElement} target - target element
	     * @param {string} type - event type
	     * @param {function} handler - handler
	     * @private
	     */
	    _unbindEvent: function _unbindEvent(target, type, handler) {
	        var unbindEvent = void 0;
	        if ('removeEventListener' in target) {
	            unbindEvent = eventListener._removeEventListener;
	        } else if ('detachEvent' in target) {
	            unbindEvent = eventListener._detachEvent;
	        }
	        eventListener._unbindEvent = unbindEvent;
	
	        unbindEvent(target, type, handler);
	    },
	
	
	    /**
	     * Unbind DOM events.
	     * @memberOf module:eventListener
	     * @param {HTMLElement} target - target element
	     * @param {string | object} types - type or map of type and handler
	     * @param {function} [handler] - handler
	     */
	    off: function off(target, types, handler) {
	        var handlerMap = {};
	        if (_tuiCodeSnippet2['default'].isString(types)) {
	            handlerMap[types] = handler;
	        } else {
	            handlerMap = types;
	        }
	
	        _tuiCodeSnippet2['default'].forEach(handlerMap, function (_handler, type) {
	            eventListener._unbindEvent(target, type, _handler);
	        });
	    }
	};
	
	exports['default'] = eventListener;

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = legendFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _legendModel = __webpack_require__(384);
	
	var _legendModel2 = _interopRequireDefault(_legendModel);
	
	var _pluginFactory = __webpack_require__(360);
	
	var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview  Legend component.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var LEGEND_ICON_HEIGHT = _const2['default'].LEGEND_ICON_HEIGHT,
	    LINE_MARGIN_TOP = _const2['default'].LINE_MARGIN_TOP,
	    LEGEND_AREA_H_PADDING = _const2['default'].LEGEND_AREA_H_PADDING,
	    PUBLIC_EVENT_PREFIX = _const2['default'].PUBLIC_EVENT_PREFIX;
	
	var Legend = function () {
	    /**
	     * Legend component.
	     * @constructs Legend
	     * @private
	     * @param {object} params parameters
	     *      @param {object} params.theme - axis theme
	     *      @param {?Array.<string>} params.seriesTypes - series types
	     *      @param {string} params.chart - chart type
	     *      @param {object} params.dataProcessor - data processor
	     *      @param {object} params.eventBus - chart event bus
	     */
	    function Legend(params) {
	        _classCallCheck(this, Legend);
	
	        /**
	         * legend theme
	         * @type {object}
	         */
	        this.theme = params.theme;
	
	        /**
	         * options
	         * @type {Object}
	         */
	        this.options = params.options || {};
	
	        /**
	         * chart type
	         * @type {string}
	         */
	        this.chartType = params.chartType;
	
	        /**
	         * series types
	         * @type {?Array.<string>}
	         */
	        this.seriesTypes = params.seriesTypes || [this.chartType];
	
	        /**
	         * event bus for transmitting message
	         * @type {object}
	         */
	        this.eventBus = params.eventBus;
	
	        /**
	         * Legend view className
	         */
	        this.className = 'tui-chart-legend-area';
	
	        /**
	         * DataProcessor instance
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = params.dataProcessor;
	
	        /**
	         * legend model
	         */
	        this.legendModel = new _legendModel2['default']({
	            theme: this.theme,
	            labels: params.dataProcessor.getLegendLabels(),
	            legendData: params.dataProcessor.getLegendData(),
	            seriesTypes: this.seriesTypes,
	            chartType: this.chartType
	        });
	
	        /**
	         * layout bounds information for this components
	         * @type {null|{dimension:{width:number, height:number}, position:{left:number, top:number}}}
	         */
	        this.layout = null;
	
	        /**
	         * Graph renderer
	         * @type {object}
	         */
	        this.graphRenderer = _pluginFactory2['default'].get(_const2['default'].COMPONENT_TYPE_RAPHAEL, 'legend');
	
	        /**
	         * Paper for rendering legend
	         * @type {object}
	         */
	        this.paper = null;
	
	        this.drawingType = _const2['default'].COMPONENT_TYPE_RAPHAEL;
	    }
	
	    /**
	     * Preset components for setData
	     * @param {object} theme theme object
	     * @ignore
	     */
	
	
	    Legend.prototype.presetForChangeData = function presetForChangeData() {
	        var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.theme;
	
	        this.theme = theme;
	
	        this.legendModel = new _legendModel2['default']({
	            theme: this.theme,
	            labels: this.dataProcessor.getLegendLabels(),
	            legendData: this.dataProcessor.getLegendData(),
	            seriesTypes: this.seriesTypes,
	            chartType: this.chartType
	        });
	    };
	
	    /**
	     * Set data for rendering.
	     * @param {{
	     *      layout: {
	     *          dimension: {width: number, height: number},
	     *          position: {left: number, top: number}
	     *      }
	     * }} data - bounds data
	     * @private
	     */
	
	
	    Legend.prototype._setDataForRendering = function _setDataForRendering(data) {
	        if (data) {
	            this.layout = data.layout;
	            this.paper = data.paper;
	        }
	    };
	
	    /**
	     * Render legend component.
	     * @param {object} data - bounds data
	     */
	
	
	    Legend.prototype._render = function _render(data) {
	        this._setDataForRendering(data);
	        this.legendSet = this._renderLegendArea(data.paper);
	    };
	
	    /**
	     * Render legend component and listen legend event.
	     * @param {object} data - bounds data
	     */
	
	
	    Legend.prototype.render = function render(data) {
	        this._render(data);
	        this._listenEvents();
	    };
	
	    /**
	     * Rerender.
	     * @param {object} data - bounds data
	     */
	
	
	    Legend.prototype.rerender = function rerender(data) {
	        this.legendSet.remove();
	
	        this._render(data);
	    };
	
	    /**
	     * Rerender, when resizing chart.
	     * @param {object} data - bounds data
	     */
	
	
	    Legend.prototype.resize = function resize(data) {
	        this.rerender(data);
	    };
	
	    /**
	     * Get legend rendering data
	     * @param {Array} legendData legned data
	     * @param {number} labelHeight lebel height
	     * @param {Array.<number>} labelWidths label widths
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    Legend.prototype._getLegendRenderingData = function _getLegendRenderingData(legendData, labelHeight, labelWidths) {
	        var _this = this;
	
	        var maxWidth = this.options.maxWidth;
	
	        var colorByPoint = (_predicate2['default'].isBarTypeChart(this.chartType) || _predicate2['default'].isBoxplotChart(this.chartType)) && this.dataProcessor.options.series.colorByPoint;
	
	        return legendData.map(function (legendDatum, index) {
	            var checkbox = _this.options.showCheckbox === false ? null : {
	                checked: _this.legendModel.isCheckedIndex(index)
	            };
	            var legendLabel = legendDatum.label;
	
	            if (maxWidth) {
	                legendLabel = _raphaelRenderUtil2['default'].getEllipsisText(legendLabel, maxWidth, _this.theme.label);
	            }
	
	            return {
	                checkbox: checkbox,
	                iconType: legendDatum.chartType || 'rect',
	                colorByPoint: colorByPoint,
	                index: index,
	                theme: legendDatum.theme,
	                label: legendLabel,
	                labelHeight: labelHeight,
	                labelWidth: labelWidths[index],
	                isUnselected: _this.legendModel.isUnselectedIndex(index)
	            };
	        });
	    };
	
	    /**
	     * Render legend area.
	     * @param {object} paper paper object
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    Legend.prototype._renderLegendArea = function _renderLegendArea(paper) {
	        var legendData = this.legendModel.getData();
	        var graphRenderer = this.graphRenderer;
	
	        var isHorizontal = _predicate2['default'].isHorizontalLegend(this.options.align);
	        var basePosition = this.layout.position;
	        var labelWidths = graphRenderer.makeLabelWidths(legendData, this.theme.label, this.options.maxWidth);
	        var labelTheme = legendData[0] ? legendData[0].theme : {};
	        var labelHeight = graphRenderer.getRenderedLabelHeight('DEFAULT_TEXT', labelTheme) - 1;
	        var labelCount = labelWidths.length;
	        var legendItemHeight = Math.max(LEGEND_ICON_HEIGHT, labelHeight);
	        var dimensionHeight = (LINE_MARGIN_TOP + legendItemHeight) * (isHorizontal ? 1 : labelCount);
	        var top = basePosition.top;
	        var left = basePosition.left;
	
	
	        if (!_predicate2['default'].isLegendAlignLeft(this.options.align)) {
	            left += LEGEND_AREA_H_PADDING;
	        }
	
	        return graphRenderer.render({
	            paper: paper,
	            legendData: this._getLegendRenderingData(legendData, labelHeight, labelWidths),
	            isHorizontal: isHorizontal,
	            position: {
	                left: left,
	                top: top
	            },
	            dimension: {
	                height: dimensionHeight,
	                width: this.layout.dimension.width
	            },
	            labelTheme: this.theme.label,
	            labelWidths: labelWidths,
	            eventBus: this.eventBus
	        });
	    };
	
	    /**
	     * Fire onChangeCheckedLegends event.
	     * @private
	     */
	
	
	    Legend.prototype._fireChangeCheckedLegendsEvent = function _fireChangeCheckedLegendsEvent() {
	        this.eventBus.fire('changeCheckedLegends', this.legendModel.getCheckedIndexes());
	    };
	
	    /**
	     * Fire changeCheckedLegends public event.
	     * @private
	     */
	
	
	    Legend.prototype._fireChangeCheckedLegendsPublicEvent = function _fireChangeCheckedLegendsPublicEvent() {
	        this.eventBus.fire(PUBLIC_EVENT_PREFIX + 'changeCheckedLegends', this.legendModel.getCheckedIndexes());
	    };
	
	    /**
	     * Fire selectLegend event.
	     * @param {{chartType: string, index: number}} data data
	     * @private
	     */
	
	
	    Legend.prototype._fireSelectLegendEvent = function _fireSelectLegendEvent(data) {
	        var index = this.legendModel.getSelectedIndex();
	        var legendIndex = !_tuiCodeSnippet2['default'].isNull(index) ? data.seriesIndex : index;
	
	        this.eventBus.fire('selectLegend', data.chartType, legendIndex);
	    };
	
	    /**
	     * Fire selectLegend public event.
	     * @param {{label: string, chartType: string, index: number}} data data
	     * @private
	     */
	
	
	    Legend.prototype._fireSelectLegendPublicEvent = function _fireSelectLegendPublicEvent(_ref) {
	        var label = _ref.label,
	            index = _ref.index,
	            chartType = _ref.chartType;
	
	        this.eventBus.fire(PUBLIC_EVENT_PREFIX + 'selectLegend', {
	            legend: label,
	            chartType: chartType,
	            index: index
	        });
	    };
	
	    /**
	     * Select legend.
	     * @param {number} index index
	     * @private
	     */
	
	
	    Legend.prototype._selectLegend = function _selectLegend(index) {
	        var data = this.legendModel.getDatum(index);
	
	        this.legendModel.toggleSelectedIndex(index);
	
	        if (!_tuiCodeSnippet2['default'].isNull(this.legendModel.getSelectedIndex()) && !this.legendModel.isCheckedSelectedIndex()) {
	            this.legendModel.checkSelectedIndex();
	            this._fireChangeCheckedLegendsEvent();
	        }
	
	        this.dataProcessor.selectLegendIndex = this.legendModel.getSelectedIndex();
	        this.graphRenderer.selectLegend(this.dataProcessor.selectLegendIndex, this.legendSet);
	
	        this._fireSelectLegendEvent(data);
	        this._fireSelectLegendPublicEvent(data);
	    };
	
	    /**
	     * Get checked indexes.
	     * @returns {Array} checked indexes
	     * @private
	     */
	
	
	    Legend.prototype._getCheckedIndexes = function _getCheckedIndexes() {
	        var checkedIndexes = [];
	
	        this.legendModel.checkedWholeIndexes.forEach(function (checkbox, index) {
	            if (checkbox) {
	                checkedIndexes.push(index);
	            }
	        });
	
	        return checkedIndexes;
	    };
	
	    /**
	     * Get checked indexes.
	     * @returns {{column: ?Array.<string>, line: ?Array.<string>}} object data that whether series has checked or not
	     * @ignore
	     */
	
	
	    Legend.prototype.getCheckedIndexes = function getCheckedIndexes() {
	        return this.legendModel.getCheckedIndexes();
	    };
	
	    /**
	     * Check legend.
	     * @private
	     */
	
	
	    Legend.prototype._checkLegend = function _checkLegend() {
	        var selectedData = this.legendModel.getSelectedDatum();
	
	        if (!this.legendModel.isCheckedSelectedIndex()) {
	            this.legendModel.updateSelectedIndex(null);
	        }
	
	        this._fireChangeCheckedLegendsEvent();
	        this._fireChangeCheckedLegendsPublicEvent();
	
	        if (selectedData) {
	            this._fireSelectLegendEvent(selectedData);
	        }
	    };
	
	    /**
	     * On click event handler.
	     * @param {number} index checkbox index
	     * @private
	     */
	
	
	    Legend.prototype._checkboxClick = function _checkboxClick(index) {
	        this.legendModel.toggleCheckedIndex(index);
	
	        var checkedIndexes = this._getCheckedIndexes();
	
	        if (checkedIndexes.length > 0) {
	            this.legendModel.updateCheckedLegendsWith(checkedIndexes);
	            this._checkLegend();
	        } else {
	            this.legendModel.toggleCheckedIndex(index);
	        }
	    };
	
	    /**
	     * On click event handler.
	     * @param {number} index selected index
	     * @private
	     */
	
	
	    Legend.prototype._labelClick = function _labelClick(index) {
	        this._selectLegend(index);
	    };
	
	    /**
	     * Listen legend events
	     * @private
	     */
	
	
	    Legend.prototype._listenEvents = function _listenEvents() {
	        this.eventBus.on('checkboxClicked', this._checkboxClick, this);
	        this.eventBus.on('labelClicked', this._labelClick, this);
	    };
	
	    return Legend;
	}();
	
	_tuiCodeSnippet2['default'].CustomEvents.mixin(Legend);
	
	/**
	 * Factory for Legend
	 * @param {object} params parameter
	 * @returns {object|null}
	 * @ignore
	 */
	function legendFactory(params) {
	    var options = params.options,
	        seriesTypes = params.dataProcessor.seriesTypes,
	        chartType = params.chartOptions.chartType;
	
	    var isLegendVisible = _tuiCodeSnippet2['default'].isUndefined(options.visible) ? true : options.visible;
	    var legend = null;
	
	    if (isLegendVisible) {
	        params.seriesTypes = seriesTypes;
	        params.chartType = chartType;
	
	        // @todo should extends additionalParams added when addComponents(), should grasp the omitted
	        legend = new Legend(params);
	    }
	
	    return legend;
	}
	
	legendFactory.componentType = 'legend';
	legendFactory.Legend = Legend;

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview LegendModel is a model for legend area(checkbox, icon, label text)
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var LegendModel = function () {
	    /**
	     * LegendModel is legend model.
	     * @constructs LegendModel
	     * @private
	     * @param {object} params parameters
	     *      @param {number} params.labels legend labels
	     *      @param {object} params.bound axis bound
	     *      @param {object} params.theme axis theme
	     */
	    function LegendModel(params) {
	        _classCallCheck(this, LegendModel);
	
	        /**
	         * legend theme
	         * @type {Object}
	         */
	        this.theme = params.theme;
	
	        /**
	         * legend labels
	         * @type {Array.<string> | {column: ?Array.<string>, line: ?Array.<string>}}
	         */
	        this.labels = params.labels;
	
	        /**
	         * label infos
	         * @type {Array.<{chartType: string, label: string, index: number}>}
	         */
	        this.legendData = params.legendData;
	
	        /**
	         * chart types
	         * @type {?Array.<string>}
	         */
	        this.seriesTypes = params.seriesTypes || [];
	
	        /**
	         * chart type
	         * @type {string}
	         */
	        this.chartType = params.chartType;
	
	        /**
	         * Legend data
	         * @type {?Array}
	         */
	        this.data = null;
	
	        /**
	         * Selected legend index.
	         * @type {?number}
	         */
	        this.selectedIndex = null;
	
	        /**
	         * sending data to series
	         * @type {object}
	         */
	        this.checkedIndexesMap = {};
	
	        /**
	         * checked indexes
	         * @type {Array}
	         */
	        this.checkedWholeIndexes = [];
	
	        this._setData();
	        this._initCheckedIndexes();
	    }
	
	    /**
	     * Initialize checked data.
	     * @private
	     */
	
	
	    LegendModel.prototype._initCheckedIndexes = function _initCheckedIndexes() {
	        var _this = this;
	
	        var checkedIndexes = [];
	        this.legendData.forEach(function (_ref, index) {
	            var visible = _ref.visible;
	
	            if (visible) {
	                checkedIndexes.push(index);
	            }
	            _this.checkedWholeIndexes[index] = visible;
	        });
	
	        this.updateCheckedLegendsWith(checkedIndexes);
	    };
	
	    /**
	     * Set theme to legend data.
	     * @param {Array.<object>} legendData - legend data
	     * @param {{
	     *     colors: Array.<string>,
	     *     borderColor: ?string
	     *     }} colorTheme - legend theme
	     * @param {Array.<boolean>} [checkedIndexes] - checked indexes
	     * @private
	     */
	
	
	    LegendModel.prototype._setThemeToLegendData = function _setThemeToLegendData(legendData, _ref2, checkedIndexes) {
	        var colors = _ref2.colors,
	            borderColor = _ref2.borderColor;
	
	        var seriesIndex = 0;
	
	        legendData.forEach(function (datum, index) {
	            var itemTheme = {
	                color: colors[index]
	            };
	
	            if (borderColor) {
	                itemTheme.borderColor = borderColor;
	            }
	
	            datum.theme = itemTheme;
	            datum.index = index;
	
	            if (!checkedIndexes || !_tuiCodeSnippet2['default'].isUndefined(checkedIndexes[index])) {
	                datum.seriesIndex = seriesIndex;
	                seriesIndex += 1;
	            } else {
	                datum.seriesIndex = -1;
	            }
	        });
	    };
	
	    /**
	     * Set legend data.
	     * @private
	     */
	
	
	    LegendModel.prototype._setData = function _setData() {
	        var _this2 = this;
	
	        var theme = this.theme,
	            chartType = this.chartType,
	            seriesTypes = this.seriesTypes,
	            legendData = this.legendData,
	            checkedIndexesMap = this.checkedIndexesMap;
	
	        var data = void 0;
	
	        if (!seriesTypes || seriesTypes.length < 2) {
	            this._setThemeToLegendData(legendData, theme[chartType], checkedIndexesMap[chartType]);
	            data = legendData;
	        } else {
	            var _ref3;
	
	            var startIndex = 0;
	            var dataItems = seriesTypes.map(function (seriesType) {
	                var labelLen = _this2.labels[seriesType].length;
	                var endIndex = startIndex + labelLen;
	                var slicedLegendData = legendData.slice(startIndex, endIndex);
	                var checkedIndexes = checkedIndexesMap[seriesType];
	
	                startIndex = endIndex;
	                _this2._setThemeToLegendData(slicedLegendData, theme[seriesType], checkedIndexes);
	
	                return slicedLegendData;
	            });
	            data = (_ref3 = []).concat.apply(_ref3, _toConsumableArray(dataItems));
	        }
	
	        this.data = data;
	    };
	
	    /**
	     * Get legend data.
	     * @returns {Array.<{chartType: string, label: string, theme: object}>} legend data
	     */
	
	
	    LegendModel.prototype.getData = function getData() {
	        return this.data;
	    };
	
	    /**
	     * Get legend datum by index.
	     * @param {number} index legend index
	     * @returns {{chartType: string, label: string, theme: object}} legend datum
	     */
	
	
	    LegendModel.prototype.getDatum = function getDatum(index) {
	        return this.data[index];
	    };
	
	    /**
	     * Get legend datum by label
	     * @param {string} label - legend label
	     * @returns {{chartType: string, label: string, theme: object}} legend datum
	     */
	
	
	    LegendModel.prototype.getDatumByLabel = function getDatumByLabel(label) {
	        var foundDatum = null;
	        this.data.forEach(function (datum) {
	            if (datum.label === label) {
	                foundDatum = datum;
	            }
	
	            return !foundDatum;
	        });
	
	        return foundDatum;
	    };
	
	    /**
	     * Get selected datum.
	     * @returns {{chartType: string, label: string, theme: Object}} legend datum
	     */
	
	
	    LegendModel.prototype.getSelectedDatum = function getSelectedDatum() {
	        return this.getDatum(this.selectedIndex);
	    };
	
	    /**
	     * Update selected index.
	     * @param {?number} value value
	     */
	
	
	    LegendModel.prototype.updateSelectedIndex = function updateSelectedIndex(value) {
	        this.selectedIndex = value;
	    };
	
	    /**
	     * Toggle selected index.
	     * @param {number} index legend index
	     */
	
	
	    LegendModel.prototype.toggleSelectedIndex = function toggleSelectedIndex(index) {
	        var selectedIndex = void 0;
	
	        if (this.selectedIndex === index) {
	            selectedIndex = null;
	        } else {
	            selectedIndex = index;
	        }
	
	        this.updateSelectedIndex(selectedIndex);
	    };
	
	    /**
	     * Get selected index.
	     * @returns {number} selected index
	     */
	
	
	    LegendModel.prototype.getSelectedIndex = function getSelectedIndex() {
	        return this.selectedIndex;
	    };
	
	    /**
	     * Whether unselected index or not.
	     * @param {number} index legend index
	     * @returns {boolean} true if selected
	     */
	
	
	    LegendModel.prototype.isUnselectedIndex = function isUnselectedIndex(index) {
	        return !_tuiCodeSnippet2['default'].isNull(this.selectedIndex) && this.selectedIndex !== index;
	    };
	
	    /**
	     * Whether checked selected index or not.
	     * @returns {boolean} true if checked
	     */
	
	
	    LegendModel.prototype.isCheckedSelectedIndex = function isCheckedSelectedIndex() {
	        return this.isCheckedIndex(this.selectedIndex);
	    };
	
	    /**
	     * Toggle checked index.
	     * @param {number} index legend index
	     */
	
	
	    LegendModel.prototype.toggleCheckedIndex = function toggleCheckedIndex(index) {
	        this.checkedWholeIndexes[index] = !this.checkedWholeIndexes[index];
	    };
	
	    /**
	     * Update checked index.
	     * @param {number} index legend index
	     * @private
	     */
	
	
	    LegendModel.prototype._updateCheckedIndex = function _updateCheckedIndex(index) {
	        this.checkedWholeIndexes[index] = true;
	    };
	
	    /**
	     * Whether checked index.
	     * @param {number} index legend index
	     * @returns {boolean} true if checked
	     */
	
	
	    LegendModel.prototype.isCheckedIndex = function isCheckedIndex(index) {
	        return !!this.checkedWholeIndexes[index];
	    };
	
	    /**
	     * Add sending datum.
	     * @param {number} index legend index
	     * @private
	     */
	
	
	    LegendModel.prototype._addSendingDatum = function _addSendingDatum(index) {
	        var legendDatum = this.getDatum(index);
	        var chartType = legendDatum.chartType,
	            chartIndex = legendDatum.index;
	
	
	        if (!this.checkedIndexesMap[chartType]) {
	            this.checkedIndexesMap[chartType] = new Array(this.labels[chartType].length).fill(false);
	        }
	        this.checkedIndexesMap[chartType][chartIndex] = true;
	    };
	
	    /**
	     * Check selected index;
	     */
	
	
	    LegendModel.prototype.checkSelectedIndex = function checkSelectedIndex() {
	        this._updateCheckedIndex(this.selectedIndex);
	        this._addSendingDatum(this.selectedIndex);
	        this._setData();
	    };
	
	    /**
	     * Get checked indexes.
	     * @returns {object} object data that whether series has checked or not
	     */
	
	
	    LegendModel.prototype.getCheckedIndexes = function getCheckedIndexes() {
	        var _this3 = this;
	
	        return Object.keys(this.checkedIndexesMap).reduce(function (booleanizeObject, chartType) {
	            booleanizeObject[chartType] = Array.from(_this3.checkedIndexesMap[chartType], function (checked) {
	                return !!checked;
	            });
	
	            return booleanizeObject;
	        }, {});
	    };
	
	    /**
	     * Reset checked data.
	     * @private
	     */
	
	
	    LegendModel.prototype._resetCheckedData = function _resetCheckedData() {
	        this.checkedWholeIndexes = [];
	        this.checkedIndexesMap = {};
	    };
	
	    /**
	     * Update checked legend's indexes
	     * @param {Array.<number>} indexes indexes
	     */
	
	
	    LegendModel.prototype.updateCheckedLegendsWith = function updateCheckedLegendsWith(indexes) {
	        var _this4 = this;
	
	        this._resetCheckedData();
	        indexes.forEach(function (index) {
	            _this4._updateCheckedIndex(index);
	            _this4._addSendingDatum(index);
	        });
	        this._setData();
	    };
	
	    return LegendModel;
	}();
	
	exports['default'] = LegendModel;

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = spectrumLegendFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _pluginFactory = __webpack_require__(360);
	
	var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview  Spectrum Legend component.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var COMPONENT_TYPE_RAPHAEL = _const2['default'].COMPONENT_TYPE_RAPHAEL,
	    MAP_LEGEND_LABEL_PADDING = _const2['default'].MAP_LEGEND_LABEL_PADDING,
	    MAP_LEGEND_GRAPH_SIZE = _const2['default'].MAP_LEGEND_GRAPH_SIZE,
	    CHART_PADDING = _const2['default'].CHART_PADDING;
	
	var SpectrumLegend = function () {
	    /**
	     * Spectrum Legend component.
	     * @constructs SpectrumLegend
	     * @private
	     * @param {object} params parameters
	     *      @param {object} params.theme axis theme
	     *      @param {?Array.<string>} params.options legend options
	     *      @param {MapChartDataProcessor} params.dataProcessor data processor
	     */
	    function SpectrumLegend(params) {
	        _classCallCheck(this, SpectrumLegend);
	
	        var libType = params.libType,
	            chartType = params.chartType,
	            theme = params.theme,
	            _params$options = params.options,
	            options = _params$options === undefined ? {} : _params$options,
	            dataProcessor = params.dataProcessor,
	            colorSpectrum = params.colorSpectrum,
	            eventBus = params.eventBus;
	
	        /**
	         * chart type
	         * @type {string}
	         */
	
	        this.chartType = chartType;
	
	        /**
	         * legend theme
	         * @type {Object}
	         */
	        this.theme = theme;
	
	        if (!_predicate2['default'].isTreemapChart(this.chartType)) {
	            this.theme.label.color = '#fff';
	        }
	
	        /**
	         * options
	         * @type {object}
	         */
	        this.options = options;
	
	        /**
	         * data processor
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = dataProcessor;
	
	        /**
	         * color spectrum
	         * @type {ColorSpectrum}
	         */
	        this.colorSpectrum = colorSpectrum;
	
	        /**
	         * event bus for transmitting message
	         * @type {object}
	         */
	        this.eventBus = eventBus;
	
	        /**
	         * Graph renderer
	         * @type {object}
	         */
	        this.graphRenderer = _pluginFactory2['default'].get(libType, 'mapLegend');
	
	        /**
	         * Whether horizontal legend or not.
	         * @type {boolean}
	         */
	        this.isHorizontal = _predicate2['default'].isHorizontalLegend(this.options.align);
	
	        /**
	         * scale data for legend
	         * @type {null|object}
	         */
	        this.scaleData = null;
	
	        this.drawingType = COMPONENT_TYPE_RAPHAEL;
	
	        this._attachToEventBus();
	    }
	
	    /**
	     * Attach to event bus.
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._attachToEventBus = function _attachToEventBus() {
	        this.eventBus.on({
	            showWedge: this.onShowWedge,
	            hideTooltip: this.onHideWedge
	        }, this);
	        this.eventBus.on('beforeImageDownload', _tuiCodeSnippet2['default'].bind(this._removeLocationURLFromFillAttribute, this));
	        this.eventBus.on('afterImageDownload', _tuiCodeSnippet2['default'].bind(this._restoreLocationURLToFillAttribute, this));
	    };
	
	    /**
	     * Remove location URL from fill attribute
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._removeLocationURLFromFillAttribute = function _removeLocationURLFromFillAttribute() {
	        this.graphRenderer.removeLocationURLFromFillAttribute();
	    };
	
	    /**
	     * Restore location URL to fill attribute
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._restoreLocationURLToFillAttribute = function _restoreLocationURLToFillAttribute() {
	        this.graphRenderer.restoreLocationURLToFillAttribute();
	    };
	
	    /**
	     * Make base data to make tick html.
	     * @returns {{startPositionValue: number, step: number, positionType: string, labelSize: ?number}} base data
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._makeBaseDataToMakeTickArea = function _makeBaseDataToMakeTickArea() {
	        var dimension = this.layout.dimension;
	        var scaleData = this.scaleData,
	            align = this.options.align;
	
	        var stepCount = scaleData.stepCount || scaleData.tickCount - 1;
	        var baseData = {};
	
	        baseData.position = this.layout.position;
	
	        if (this.isHorizontal) {
	            baseData.step = dimension.width / stepCount;
	
	            if (_predicate2['default'].isLegendAlignTop(align)) {
	                baseData.position.top -= MAP_LEGEND_LABEL_PADDING;
	            } else {
	                baseData.position.top += MAP_LEGEND_GRAPH_SIZE + MAP_LEGEND_LABEL_PADDING;
	            }
	        } else {
	            baseData.step = dimension.height / stepCount;
	
	            if (_predicate2['default'].isLegendAlignLeft(align)) {
	                baseData.position.left = CHART_PADDING;
	            } else {
	                baseData.position.left += MAP_LEGEND_GRAPH_SIZE + MAP_LEGEND_LABEL_PADDING;
	            }
	        }
	
	        return baseData;
	    };
	
	    /**
	     * Render tick area.
	     * @param {Array.<object>} legendSet legend set
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._renderTickArea = function _renderTickArea(legendSet) {
	        if (this.options.reversed) {
	            this.scaleData.labels.sort(function (prev, next) {
	                return next - prev;
	            });
	        }
	
	        this.graphRenderer.renderTickLabels(this.paper, this._makeBaseDataToMakeTickArea(), this.scaleData.labels, this.options.align, legendSet);
	    };
	
	    /**
	     * Make graph dimension of vertical legend
	     * @returns {{width: number, height: number}} dimension
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._makeVerticalGraphDimension = function _makeVerticalGraphDimension() {
	        return {
	            width: MAP_LEGEND_GRAPH_SIZE,
	            height: this.layout.dimension.height
	        };
	    };
	
	    /**
	     * Make graph dimension of horizontal legend
	     * @returns {{width: number, height: number}} dimension
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._makeHorizontalGraphDimension = function _makeHorizontalGraphDimension() {
	        return {
	            width: this.layout.dimension.width,
	            height: MAP_LEGEND_GRAPH_SIZE
	        };
	    };
	
	    /**
	     * Render graph.
	     * @param {Array.<object>} legendSet legend set
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._renderGraph = function _renderGraph(legendSet) {
	        var position = this.layout.position;
	
	        var dimension = void 0;
	
	        if (this.isHorizontal) {
	            dimension = this._makeHorizontalGraphDimension();
	        } else {
	            dimension = this._makeVerticalGraphDimension();
	        }
	
	        if (this.options.reversed) {
	            var startForSwap = this.colorSpectrum.start;
	            this.colorSpectrum.start = this.colorSpectrum.end;
	            this.colorSpectrum.end = startForSwap;
	        }
	
	        this.graphRenderer.render({
	            paper: this.paper,
	            layout: {
	                dimension: dimension,
	                position: position
	            },
	            colorSpectrum: this.colorSpectrum,
	            align: this.options.align,
	            legendSet: legendSet,
	            theme: this.theme.label,
	            labels: this.scaleData.labels
	        });
	    };
	
	    /**
	     * Render legend area.
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._renderLegendArea = function _renderLegendArea() {
	        var legendSet = this.paper.set();
	
	        this._renderGraph(legendSet);
	        this._renderTickArea(legendSet);
	
	        return legendSet;
	    };
	
	    /**
	     * Set data for rendering.
	     * @param {{
	     *      layout: object,
	     *      legendScaleData: object
	     * }} data - scale data
	     * @private
	     */
	
	
	    SpectrumLegend.prototype._setDataForRendering = function _setDataForRendering(_ref) {
	        var layout = _ref.layout,
	            paper = _ref.paper,
	            legendScaleData = _ref.legendScaleData;
	
	        this.layout = layout;
	        this.paper = paper;
	        this.scaleData = legendScaleData;
	    };
	
	    /**
	     * Render legend component.
	     * @param {object} data - scale data
	     */
	
	
	    SpectrumLegend.prototype.render = function render(data) {
	        this._setDataForRendering(data);
	        this.legendSet = this._renderLegendArea();
	    };
	
	    /**
	     * Rerender legend component.
	     * @param {object} data - scale data
	     */
	
	
	    SpectrumLegend.prototype.rerender = function rerender(data) {
	        this.legendSet.remove();
	        this.render(data);
	    };
	
	    /**
	     * Resize legend component.
	     * @param {object} data - scale data
	     */
	
	
	    SpectrumLegend.prototype.resize = function resize(data) {
	        this.rerender(data);
	    };
	
	    /**
	     * On show wedge.
	     * @param {number} ratio ratio
	     * @param {string} label label
	     */
	
	
	    SpectrumLegend.prototype.onShowWedge = function onShowWedge(ratio, label) {
	        ratio = this.options.reversed ? 1 - ratio : ratio;
	        this.graphRenderer.showWedge(ratio, label);
	    };
	
	    /**
	     * On hide wedge.
	     */
	
	
	    SpectrumLegend.prototype.onHideWedge = function onHideWedge() {
	        this.graphRenderer.hideWedge();
	    };
	
	    return SpectrumLegend;
	}();
	
	/**
	 * Factory for SpectrumLegend
	 * @param {object} params parameter
	 * @returns {object|null}
	 * @ignore
	 */
	
	
	function spectrumLegendFactory(params) {
	    var isLegendVisible = _tuiCodeSnippet2['default'].isUndefined(params.options.visible) ? true : params.options.visible;
	    var chartType = params.chartOptions.chartType;
	
	    var spectrumLegend = null;
	
	    if (isLegendVisible) {
	        params.chartType = chartType;
	
	        spectrumLegend = new SpectrumLegend(params);
	    }
	
	    return spectrumLegend;
	}
	
	spectrumLegendFactory.componentType = 'legend';
	spectrumLegendFactory.SpectrumLegend = SpectrumLegend;

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = circleLegendFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _pluginFactory = __webpack_require__(360);
	
	var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview  Circle legend component render a legend in the form of overlapping circles
	                                                                                                                                                           *                  by representative radius values.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var CircleLegend = function () {
	  /**
	   * Circle legend component render a legend in the form of overlapping circles by representative radius values.
	   * @constructs CircleLegend
	   * @private
	   * @param {object} params parameters
	   *      @param {?string} params.libType - library type for graph rendering
	   *      @param {string} params.chartType - chart type
	   *      @param {DataProcessor} params.dataProcessor - DataProcessor
	   *      @param {string} params.baseFontFamily - base fontFamily of chart
	   */
	  function CircleLegend(_ref) {
	    var libType = _ref.libType,
	        chartType = _ref.chartType,
	        dataProcessor = _ref.dataProcessor,
	        baseFontFamily = _ref.baseFontFamily;
	
	    _classCallCheck(this, CircleLegend);
	
	    /**
	     * ratios for rendering circle
	     * @type {Array.<number>}
	     */
	    this.circleRatios = [1, 0.5, 0.25];
	
	    /**
	     * chart type
	     * @type {string}
	     */
	    this.chartType = chartType;
	
	    /**
	     * data processor
	     * @type {DataProcessor}
	     */
	    this.dataProcessor = dataProcessor;
	
	    /**
	     * theme for label of circle legend area
	     * @type {{fontSize: number, fontFamily: *}}
	     */
	    this.labelTheme = {
	      fontSize: _const2['default'].CIRCLE_LEGEND_LABEL_FONT_SIZE,
	      fontFamily: baseFontFamily
	    };
	
	    /**
	     * Graph renderer
	     * @type {object}
	     */
	    this.graphRenderer = _pluginFactory2['default'].get(libType, 'circleLegend');
	
	    /**
	     * layout bounds information for this components
	     * @type {null|{dimension:{width:number, height:number}, position:{left:number, top:number}}}
	     */
	    this.layout = null;
	
	    /**
	     * max radius for rendering circle legend
	     * @type {null|number}
	     */
	    this.maxRadius = null;
	
	    this.drawingType = _const2['default'].COMPONENT_TYPE_RAPHAEL;
	  }
	
	  /**
	   * Format label.
	   * @param {number} label - label
	   * @param {number} decimalLength - decimal length
	   * @returns {string}
	   * @private
	   */
	
	
	  CircleLegend.prototype._formatLabel = function _formatLabel(label, decimalLength) {
	    var formatFunctions = this.dataProcessor.getFormatFunctions();
	    var formattedLabel = void 0;
	
	    if (decimalLength === 0) {
	      formattedLabel = String(parseInt(label, 10));
	    } else {
	      formattedLabel = _renderUtil2['default'].formatToDecimal(String(label), decimalLength);
	    }
	
	    return _renderUtil2['default'].formatValue({
	      value: formattedLabel,
	      formatFunctions: formatFunctions,
	      chartType: this.chartType,
	      areaType: 'circleLegend',
	      valueType: 'r'
	    });
	  };
	
	  /**
	   * Make label html.
	   * @returns {Array.<string>}
	   * @private
	   */
	
	
	  CircleLegend.prototype._makeLabels = function _makeLabels() {
	    var _this = this;
	
	    var maxValueRadius = this.dataProcessor.getMaxValue(this.chartType, 'r');
	    var decimalLength = _calculator2['default'].getDecimalLength(maxValueRadius);
	
	    return this.circleRatios.map(function (ratio) {
	      return _this._formatLabel(maxValueRadius * ratio, decimalLength);
	    });
	  };
	
	  /**
	   * Render for circle legend area.
	   * @param {object} paper paper object
	   * @returns {Array.<object>}
	   * @private
	   */
	
	
	  CircleLegend.prototype._render = function _render(paper) {
	    return this.graphRenderer.render(paper, this.layout, this.maxRadius, this.circleRatios, this._makeLabels());
	  };
	
	  /**
	   * Set data for rendering.
	   * @param {{
	   *      layout: {
	   *          dimension: {width: number, height: number},
	   *          position: {left: number, top: number}
	   *      },
	   *      maxRadius: number
	   * }} data - bounds data
	   * @private
	   */
	
	
	  CircleLegend.prototype._setDataForRendering = function _setDataForRendering(data) {
	    this.layout = data.layout;
	    this.maxRadius = data.maxRadius;
	  };
	
	  /**
	   * Render.
	   * @param {object} data - bounds data
	   */
	
	
	  CircleLegend.prototype.render = function render(data) {
	    this._setDataForRendering(data);
	    this.circleLegendSet = this._render(data.paper);
	  };
	
	  /**
	   * Rerender.
	   * @param {object} data - bounds data
	   */
	
	
	  CircleLegend.prototype.rerender = function rerender(data) {
	    this.circleLegendSet.remove();
	
	    this._setDataForRendering(data);
	    this.circleLegendSet = this._render(data.paper);
	  };
	
	  /**
	   * Resize.
	   * @param {object} data - bounds data
	   */
	
	
	  CircleLegend.prototype.resize = function resize(data) {
	    this.rerender(data);
	  };
	
	  return CircleLegend;
	}();
	
	/**
	 * Factory for CircleLegend
	 * @param {object} params parameter
	 * @returns {object|null}
	 * @ignore
	 */
	
	
	function circleLegendFactory(params) {
	  var chartTheme = params.chartTheme,
	      chartType = params.chartOptions.chartType;
	
	  var visibleOption = _tuiCodeSnippet2['default'].pick(params.chartOptions, 'circleLegend', 'visible');
	  var circleLegend = null;
	  var isLegendVisible = void 0;
	
	  if (_tuiCodeSnippet2['default'].isUndefined(visibleOption)) {
	    isLegendVisible = true;
	  } else {
	    isLegendVisible = visibleOption;
	  }
	
	  if (isLegendVisible) {
	    params.chartType = chartType;
	    params.baseFontFamily = chartTheme.chart.fontFamily;
	
	    circleLegend = new CircleLegend(params);
	  }
	
	  return circleLegend;
	}
	
	circleLegendFactory.componentType = 'legend';
	circleLegendFactory.CircleLegend = CircleLegend;

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = tooltipFactory;
	
	var _normalTooltip = __webpack_require__(388);
	
	var _normalTooltip2 = _interopRequireDefault(_normalTooltip);
	
	var _groupTooltip = __webpack_require__(393);
	
	var _groupTooltip2 = _interopRequireDefault(_groupTooltip);
	
	var _mapChartTooltip = __webpack_require__(395);
	
	var _mapChartTooltip2 = _interopRequireDefault(_mapChartTooltip);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Label formatter function for pie chart
	 * @param {object} seriesItem series item
	 * @param {object} tooltipDatum tooltip datum object
	 * @param {string} labelPrefix label prefix
	 * @returns {object}
	 * @ignore
	 */
	function pieTooltipLabelFormatter(seriesItem, tooltipDatum, labelPrefix) {
	    var percentageString = (seriesItem.ratio * 100).toFixed(4);
	    var percent = parseFloat(percentageString);
	    var needSlice = percent < 0.0009 || percentageString.length > 5;
	
	    percentageString = needSlice ? percentageString.substr(0, 4) : String(percent);
	    var ratioLabel = percentageString + '&nbsp;%&nbsp;' || '';
	
	    tooltipDatum.ratioLabel = labelPrefix + ratioLabel;
	    tooltipDatum.label = seriesItem.tooltipLabel || (seriesItem.label ? seriesItem.label : '');
	
	    return tooltipDatum;
	}
	
	/**
	 * Factory for Tooltip
	 * @param {object} params parameter
	 * @returns {object|null}
	 * @ignore
	 */
	/**
	 * @fileoverview NormalTooltip component.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	function tooltipFactory(params) {
	    var chartType = params.chartOptions.chartType,
	        seriesTypes = params.seriesTypes;
	
	    var xAxisOptions = params.chartOptions.xAxis;
	    var colors = [];
	    var factory = void 0;
	
	    var legendTheme = Object.values(params.chartTheme.legend).filter(function (item) {
	        return _tuiCodeSnippet2['default'].isArray(item.colors);
	    });
	
	    legendTheme.forEach(function (series) {
	        colors = colors.concat(series.colors);
	    });
	
	    if (chartType === 'map') {
	        factory = _mapChartTooltip2['default'];
	    } else if (params.options.grouped) {
	        factory = _groupTooltip2['default'];
	    } else {
	        factory = _normalTooltip2['default'];
	    }
	
	    if (chartType === 'pie' || _predicate2['default'].isPieDonutComboChart(chartType, seriesTypes)) {
	        params.labelFormatter = pieTooltipLabelFormatter;
	    }
	
	    params.chartType = chartType;
	    params.chartTypes = seriesTypes;
	    params.xAxisType = xAxisOptions.type;
	    params.dateFormat = xAxisOptions.dateFormat;
	    params.colors = colors;
	
	    return factory(params);
	}
	
	tooltipFactory.componentType = 'tooltip';

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = normalTooltipFactory;
	
	var _tooltipBase = __webpack_require__(389);
	
	var _tooltipBase2 = _interopRequireDefault(_tooltipBase);
	
	var _singleTooltipMixer = __webpack_require__(390);
	
	var _singleTooltipMixer2 = _interopRequireDefault(_singleTooltipMixer);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _tooltipTemplate = __webpack_require__(391);
	
	var _tooltipTemplate2 = _interopRequireDefault(_tooltipTemplate);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview NormalTooltip component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	var DEFALUT_TOOLTIP_COLOR = '#aaa';
	
	/**
	 * @classdesc NormalTooltip component.
	 * @class NormalTooltip
	 * @private
	 */
	
	var NormalTooltip = function (_TooltipBase) {
	    _inherits(NormalTooltip, _TooltipBase);
	
	    /**
	     * NormalTooltip component.
	     * @constructs NormalTooltip
	     * @private
	     * @override
	     */
	    function NormalTooltip(params) {
	        _classCallCheck(this, NormalTooltip);
	
	        /**
	         * Color spectrum
	         * @type {ColorSpectrum}
	         */
	        var _this = _possibleConstructorReturn(this, _TooltipBase.call(this, params));
	
	        _this.colorSpectrum = params.colorSpectrum;
	        return _this;
	    }
	
	    /**
	     * Make tooltip html.
	     * @param {string} category category
	     * @param {{value: string, legend: string, chartType: string, suffix: ?string}} item item data
	     * @returns {string} tooltip html
	     * @private
	     */
	
	
	    NormalTooltip.prototype._makeTooltipHtml = function _makeTooltipHtml(category, item) {
	        var template = this._getTooltipTemplate(item);
	
	        return template(_tuiCodeSnippet2['default'].extend({
	            categoryVisible: category ? 'show' : 'hide',
	            category: category
	        }, item));
	    };
	
	    /**
	     * get tooltip template from a templates collection
	     * @param {{value: string, legend: string, chartType: string, suffix: ?string}} item item data
	     * @returns {string} tooltip template
	     * @private
	     */
	
	
	    NormalTooltip.prototype._getTooltipTemplate = function _getTooltipTemplate(item) {
	        var template = _tooltipTemplate2['default'].tplDefault;
	
	        if (_predicate2['default'].isBoxplotChart(this.chartType)) {
	            template = this._getBoxplotTooltipTemplate(item);
	        } else if (_predicate2['default'].isPieChart(this.chartType) || _predicate2['default'].isPieDonutComboChart(this.chartType, this.chartTypes)) {
	            template = _tooltipTemplate2['default'].tplPieChart;
	        } else if (this.dataProcessor.coordinateType) {
	            template = _tooltipTemplate2['default'].tplCoordinatetypeChart;
	        } else if (_predicate2['default'].isBulletChart(this.chartType)) {
	            template = _tooltipTemplate2['default'].tplBulletChartDefault;
	        } else if (_predicate2['default'].isHeatmapChart(this.chartType)) {
	            template = _tooltipTemplate2['default'].tplHeatmapChart;
	        }
	
	        return template;
	    };
	
	    /**
	     * Get tooltip template of box plot chart
	     * If item has outlierIndex, return outlier template
	     * Otherwise, return box plot default template
	     * @param {{value: string, legend: string, chartType: string, suffix: ?string}} item item data
	     * @returns {string} tooltip template
	     * @private
	     */
	
	
	    NormalTooltip.prototype._getBoxplotTooltipTemplate = function _getBoxplotTooltipTemplate(item) {
	        var template = _tooltipTemplate2['default'].tplBoxplotChartDefault;
	
	        if (_tuiCodeSnippet2['default'].isNumber(item.outlierIndex)) {
	            template = _tooltipTemplate2['default'].tplBoxplotChartOutlier;
	            item.label = item.outliers[item.outlierIndex].label;
	        }
	
	        return template;
	    };
	
	    /**
	     * Make html for value types like x, y, r
	     * @param {{x: ?number, y: ?number, r: ?number}} data - data
	     * @param {Array.<string>} valueTypes - types of value
	     * @returns {string}
	     * @private
	     */
	
	
	    NormalTooltip.prototype._makeHtmlForValueTypes = function _makeHtmlForValueTypes(data, valueTypes) {
	        return valueTypes.map(function (type) {
	            if (data[type]) {
	                return '<tr><td>' + type + '</td><td class="' + _const2['default'].CLASS_NAME_TOOLTIP_VALUE + '">' + data[type] + '</td></tr>';
	            }
	
	            return '';
	        }).join('');
	    };
	
	    /**
	     * Make single tooltip html.
	     * @param {string} chartType chart type
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     * @returns {string} tooltip html
	     * @private
	     */
	
	
	    NormalTooltip.prototype._makeSingleTooltipHtml = function _makeSingleTooltipHtml(chartType, indexes) {
	        var groupIndex = indexes.groupIndex;
	
	        var data = this._findTooltipData(chartType, indexes);
	        var color = this._findTooltipColor(chartType, indexes, data);
	
	        if (_predicate2['default'].isBoxplotChart(this.chartType) && _tuiCodeSnippet2['default'].isNumber(indexes.outlierIndex)) {
	            data.outlierIndex = indexes.outlierIndex;
	        }
	        if (this.colorSpectrum) {
	            color = this.colorSpectrum.getColor(data.colorRatio || data.ratio);
	        }
	
	        data.chartType = this.chartType;
	        data.cssText = 'background-color: ' + color;
	        data = Object.assign({
	            suffix: this.suffix
	        }, data);
	        data.valueTypes = this._makeHtmlForValueTypes(data, ['x', 'y', 'r']);
	
	        return this.templateFunc(data.category, data, this.getRawCategory(groupIndex));
	    };
	
	    /**
	     * Find data for tooltip
	     * @param {string} chartType chart type
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     * @returns {string} data for tooltip
	     * @private
	     */
	
	
	    NormalTooltip.prototype._findTooltipData = function _findTooltipData(chartType, indexes) {
	        var chartData = this.data[chartType];
	        var selectIndex = indexes.groupIndex;
	
	        if (_predicate2['default'].isRadialChart(chartType) && chartData.length === selectIndex) {
	            selectIndex = 0;
	        }
	
	        return Object.assign({}, _tuiCodeSnippet2['default'].pick(chartData, selectIndex, indexes.index));
	    };
	
	    /**
	     * Find data for tooltip
	     * @param {string} hoveredChartType - chart type
	     * @param {{groupIndex: number, index: number}} indexes - indexes
	     * @param {Object} data - data for tooltip render
	     * @returns {string} color hex string
	     * @private
	     */
	
	
	    NormalTooltip.prototype._findTooltipColor = function _findTooltipColor(hoveredChartType, indexes, data) {
	        var isBar = _predicate2['default'].isBarTypeChart(this.chartType);
	        var isBoxplot = _predicate2['default'].isBoxplotChart(this.chartType);
	        var colorByPoint = (isBar || isBoxplot) && this.dataProcessor.options.series.colorByPoint;
	
	        var groupIndex = indexes.groupIndex;
	        var seriesIndex = indexes.index;
	
	
	        if (_predicate2['default'].isBulletChart(this.chartType)) {
	            seriesIndex = groupIndex;
	        } else if (_predicate2['default'].isTreemapChart(this.chartType)) {
	            seriesIndex = data.tooltipColorIndex;
	        }
	
	        return colorByPoint ? DEFALUT_TOOLTIP_COLOR : this.tooltipColors[hoveredChartType][seriesIndex];
	    };
	
	    /**
	     * Set default align option of tooltip.
	     * @private
	     * @override
	     */
	
	
	    NormalTooltip.prototype._setDefaultTooltipPositionOption = function _setDefaultTooltipPositionOption() {
	        if (this.options.align) {
	            return;
	        }
	
	        if (this.isVertical) {
	            this.options.align = _const2['default'].TOOLTIP_DEFAULT_ALIGN_OPTION;
	        } else {
	            this.options.align = _const2['default'].TOOLTIP_DEFAULT_HORIZONTAL_ALIGN_OPTION;
	        }
	    };
	
	    /**
	     * Make parameters for show tooltip user event.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     * @param {object} additionParams addition parameters
	     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} parameters for show tooltip
	     * @private
	     */
	
	
	    NormalTooltip.prototype._makeShowTooltipParams = function _makeShowTooltipParams(indexes, additionParams) {
	        var legendIndex = indexes.index;
	        var legendData = this.dataProcessor.getLegendItem(legendIndex);
	
	        if (!legendData) {
	            return null;
	        }
	
	        var chartType = legendData.chartType,
	            label = legendData.label;
	
	        var params = _tuiCodeSnippet2['default'].extend({
	            chartType: chartType,
	            legend: label,
	            legendIndex: legendIndex,
	            index: indexes.groupIndex
	        }, additionParams);
	
	        if (_predicate2['default'].isBoxplotChart(chartType) && _tuiCodeSnippet2['default'].isNumber(indexes.outlierIndex)) {
	            params.outlierIndex = indexes.outlierIndex;
	        }
	
	        return params;
	    };
	
	    /**
	     * Make tooltip datum.
	     * @param {string} legendLabel - legend label
	     * @param {string} category - category
	     * @param {SeriesItem} seriesItem - SeriesItem
	     * @returns {Object}
	     * @private
	     */
	
	
	    NormalTooltip.prototype._makeTooltipDatum = function _makeTooltipDatum() {
	        var legendLabel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	        var category = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	        var seriesItem = arguments[2];
	        var tooltipLabel = seriesItem.tooltipLabel;
	        var labelFormatter = this.labelFormatter;
	
	        var tooltipDatum = {
	            legend: legendLabel,
	            label: tooltipLabel || (seriesItem.label ? seriesItem.label : ''),
	            category: category
	        };
	
	        if (labelFormatter) {
	            tooltipDatum = labelFormatter(seriesItem, tooltipDatum, '');
	        }
	
	        tooltipDatum.category = category;
	
	        return _tuiCodeSnippet2['default'].extend(tooltipDatum, seriesItem.pickValueMapForTooltip());
	    };
	
	    /**
	     * Make tooltip data.
	     * @returns {Array.<object>} tooltip data
	     * @override
	     */
	
	
	    NormalTooltip.prototype.makeTooltipData = function makeTooltipData() {
	        var _this2 = this;
	
	        var orgLegendLabels = this.dataProcessor.getLegendLabels();
	        var isPivot = _predicate2['default'].isTreemapChart(this.chartType);
	        var legendLabels = {};
	        var tooltipData = {};
	
	        if (_tuiCodeSnippet2['default'].isArray(orgLegendLabels)) {
	            legendLabels[this.chartType] = orgLegendLabels;
	        } else {
	            legendLabels = orgLegendLabels;
	        }
	
	        this.dataProcessor.eachBySeriesGroup(function (seriesGroup, groupIndex, chartType) {
	            chartType = chartType || _this2.chartType;
	            var isBulletChart = _predicate2['default'].isBulletChart(chartType);
	
	            var data = seriesGroup.map(function (seriesItem, index) {
	                var category = _this2.dataProcessor.makeTooltipCategory(groupIndex, index, _this2.isVertical);
	                var legendIndex = isBulletChart ? groupIndex : index;
	
	                if (!seriesItem) {
	                    return null;
	                }
	
	                return _this2._makeTooltipDatum(legendLabels[chartType][legendIndex], category, seriesItem);
	            });
	
	            if (!tooltipData[chartType]) {
	                tooltipData[chartType] = [];
	            }
	
	            tooltipData[chartType].push(data);
	        }, isPivot);
	
	        return tooltipData;
	    };
	
	    return NormalTooltip;
	}(_tooltipBase2['default']);
	
	_singleTooltipMixer2['default'].mixin(NormalTooltip);
	
	/**
	 * normalTooltipFactory
	 * @param {object} params chart options
	 * @returns {object} normal tooltip instanse
	 * @ignore
	 */
	function normalTooltipFactory(params) {
	    return new NormalTooltip(params);
	}
	
	normalTooltipFactory.componentType = 'tooltip';
	normalTooltipFactory.NormalTooltip = NormalTooltip;

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _raphael = __webpack_require__(330);
	
	var _raphael2 = _interopRequireDefault(_raphael);
	
	var _objectUtil = __webpack_require__(364);
	
	var _objectUtil2 = _interopRequireDefault(_objectUtil);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview TooltipBase is base class of tooltip components.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var TooltipBase = function () {
	    /**
	     * TooltipBase is base class of tooltip components.
	     * @constructs TooltipBase
	     * @private
	     * @param {object} params - parameters
	     *      @param {string} params.chartType - chart type
	     *      @param {Array.<string>} params.chartTypes - chart types
	     *      @param {DataProcessor} params.dataProcessor - DataProcessor instance
	     *      @param {object} params.options - tooltip options
	     *      @param {object} params.theme - tooltip theme
	     *      @param {boolean} params.isVertical - whether vertical or not
	     *      @param {object} params.eventBus - snippet.CustomEvents instance
	     *      @param {object} params.labelTheme - theme for label
	     *      @param {string} params.xAxisType - xAxis type
	     *      @param {string} params.dateFormat - date format
	     *      @param {object} params.labelFormatter - label formatter function
	     */
	    function TooltipBase(params) {
	        _classCallCheck(this, TooltipBase);
	
	        var isPieChart = _predicate2['default'].isPieChart(params.chartType);
	
	        /**
	         * Chart type
	         * @type {string}
	         */
	        this.chartType = params.chartType;
	
	        /**
	         * Chart types
	         * @type {Array.<string>}
	         */
	        this.chartTypes = params.chartTypes;
	
	        /**
	         * Data processor
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = params.dataProcessor;
	
	        /**
	         * Options
	         * @type {object}
	         */
	        this.options = params.options;
	        this.colors = params.colors;
	
	        /**
	         * Theme
	         * @type {object}
	         */
	        this.theme = params.theme;
	
	        /**
	         * Original Theme
	         * @type {object}
	         */
	        this.originalTheme = _objectUtil2['default'].deepCopy(params.theme);
	
	        /**
	         * whether vertical or not
	         * @type {boolean}
	         */
	        this.isVertical = params.isVertical;
	
	        /**
	         * event bus for transmitting message
	         * @type {object}
	         */
	        this.eventBus = params.eventBus;
	
	        /**
	         * label theme
	         * @type {object}
	         */
	        this.labelTheme = params.labelTheme;
	
	        /**
	         * x axis type
	         * @type {?string}
	         */
	        this.xAxisType = params.xAxisType;
	
	        /**
	         * dateFormat option for xAxis
	         * @type {?string}
	         */
	        this.dateFormat = params.dateFormat;
	
	        /**
	         * tooltip options for each chart
	         * @type {?function}
	         */
	        this.labelFormatter = params.labelFormatter;
	
	        /**
	         * className
	         * @type {string}
	         */
	        this.className = 'tui-chart-tooltip-area';
	
	        /**
	         * Tooltip container.
	         * @type {HTMLElement}
	         */
	        this.tooltipContainer = null;
	
	        /**
	         * Tooltip suffix.
	         * @type {string}
	         */
	        this.suffix = this.options.suffix ? '&nbsp;' + this.options.suffix : '';
	
	        /**
	         * Tooltip template function.
	         * @type {function}
	         */
	        this.templateFunc = this.options.template || _tuiCodeSnippet2['default'].bind(this._makeTooltipHtml, this);
	
	        /**
	         * Tooltip animation time.
	         * @type {number}
	         */
	        this.animationTime = isPieChart ? _const2['default'].TOOLTIP_PIE_ANIMATION_TIME : _const2['default'].TOOLTIP_ANIMATION_TIME;
	
	        /**
	         * TooltipBase base data.
	         * @type {Array.<Array.<object>>}
	         */
	        this.data = [];
	
	        /**
	         * layout bounds information for this components
	         * @type {null|{dimension:{width:number, height:number}, position:{left:number, top:number}}}
	         */
	        this.layout = null;
	
	        /**
	         * dimension map for layout of chart
	         * @type {null|object}
	         */
	        this.dimensionMap = null;
	
	        /**
	         * position map for layout of chart
	         * @type {null|object}
	         */
	        this.positionMap = null;
	
	        /**
	         * Drawing type
	         * @type {string}
	         */
	        this.drawingType = _const2['default'].COMPONENT_TYPE_DOM;
	
	        this._setDefaultTooltipPositionOption();
	        this._saveOriginalPositionOptions();
	
	        this._attachToEventBus();
	    }
	
	    /**
	     * Preset components for setData
	     * @param {object} theme theme object
	     * @ignore
	     */
	
	
	    TooltipBase.prototype.presetForChangeData = function presetForChangeData() {
	        var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.theme;
	
	        this.theme = theme;
	        this.originalTheme = _objectUtil2['default'].deepCopy(theme);
	    };
	
	    /**
	     * Attach to event bus.
	     * @private
	     */
	
	
	    TooltipBase.prototype._attachToEventBus = function _attachToEventBus() {
	        this.eventBus.on({
	            showTooltip: this.onShowTooltip,
	            hideTooltip: this.onHideTooltip
	        }, this);
	
	        if (this.onShowTooltipContainer) {
	            this.eventBus.on({
	                showTooltipContainer: this.onShowTooltipContainer,
	                hideTooltipContainer: this.onHideTooltipContainer
	            }, this);
	        }
	    };
	
	    /**
	     * Make tooltip html.
	     * @private
	     * @abstract
	     */
	
	
	    TooltipBase.prototype._makeTooltipHtml = function _makeTooltipHtml() {};
	
	    /**
	     * Set default align option of tooltip.
	     * @private
	     * @abstract
	     */
	
	
	    TooltipBase.prototype._setDefaultTooltipPositionOption = function _setDefaultTooltipPositionOption() {};
	
	    /**
	     * Save position options.
	     * @private
	     */
	
	
	    TooltipBase.prototype._saveOriginalPositionOptions = function _saveOriginalPositionOptions() {
	        this.orgPositionOptions = {
	            align: this.options.align,
	            offset: this.options.offset
	        };
	    };
	
	    /**
	     * Render tooltip component.
	     * @param {HTMLElement} iconElement - icon element
	     */
	
	
	    TooltipBase.prototype.makeLineLegendIcon = function makeLineLegendIcon(iconElement) {
	        var iconElementLength = iconElement.length;
	
	        for (var i = 0; i < iconElementLength; i += 1) {
	            var icon = iconElement[i];
	            var strokeColor = icon.style['background-color'];
	            var paper = (0, _raphael2['default'])(icon, 10, 10);
	            var line = paper.path(_const2['default'].LEGEND_LINE_ICON_PATH);
	            icon.style['background-color'] = '';
	            line.attr({
	                'stroke': strokeColor,
	                'stroke-width': 2,
	                'stroke-opacity': 1
	            });
	        }
	    };
	
	    /**
	     * Make tooltip data.
	     * @private
	     * @abstract
	     */
	
	
	    TooltipBase.prototype.makeTooltipData = function makeTooltipData() {};
	
	    /**
	     * Set data for rendering.
	     * @param {{
	     *      layout: {
	     *          dimension: {width: number, height: number},
	     *          position: {left: number, top: number}
	     *      },
	     *      dimensionMap: object
	     * }} data - bounds data
	     * @private
	     */
	
	
	    TooltipBase.prototype._setDataForRendering = function _setDataForRendering(data) {
	        this.layout = data.layout;
	        this.dimensionMap = data.dimensionMap;
	        this.positionMap = data.positionMap;
	    };
	
	    /**
	     * Render tooltip component.
	     * @param {object} data - bounds data
	     * @returns {HTMLElement} tooltip element
	     */
	
	
	    TooltipBase.prototype.render = function render(data) {
	        var el = data.paper;
	
	        _domHandler2['default'].addClass(el, this.className);
	
	        this._setDataForRendering(data);
	        this.data = this.makeTooltipData();
	        this.tooltipColors = this.makeTooltipLegendColor(data.checkedLegends);
	        _renderUtil2['default'].renderPosition(el, this.layout.position);
	
	        this.tooltipContainer = el;
	
	        return el;
	    };
	
	    /**
	     * Rerender.
	     * @param {object} data - bounds data
	     */
	
	
	    TooltipBase.prototype.rerender = function rerender(data) {
	        this.resize(data);
	        this.data = this.makeTooltipData();
	        this.tooltipColors = this.makeTooltipLegendColor(data.checkedLegends);
	    };
	
	    /**
	     * make legend color
	     * @param {object | Array.<boolean>}checkedLegends checked legends
	     * @returns {{colors: Array.<string>}} legend colors
	     * @private
	     */
	
	
	    TooltipBase.prototype.makeTooltipLegendColor = function makeTooltipLegendColor(checkedLegends) {
	        var _this = this;
	
	        var colors = {};
	
	        if (checkedLegends) {
	            Object.keys(this.theme).forEach(function (themeKey) {
	                if (!colors[themeKey]) {
	                    colors[themeKey] = [];
	                }
	                (checkedLegends[themeKey] || []).forEach(function (checked, index) {
	                    if (checked) {
	                        colors[themeKey].push(_this.theme[themeKey].colors[index]);
	                    }
	                });
	            });
	        }
	
	        return colors;
	    };
	
	    /**
	     * Resize tooltip component.
	     * @param {object} data - bounds data
	     * @override
	     */
	
	
	    TooltipBase.prototype.resize = function resize(data) {
	        this._setDataForRendering(data);
	
	        _renderUtil2['default'].renderPosition(this.tooltipContainer, this.layout.position);
	        if (this.positionModel) {
	            this.positionModel.updateBound(this.layout);
	        }
	    };
	
	    /**
	     * Zoom.
	     */
	
	
	    TooltipBase.prototype.zoom = function zoom() {
	        this.data = this.makeTooltipData();
	    };
	
	    /**
	     * Get tooltip element.
	     * @returns {HTMLElement} tooltip element
	     * @private
	     */
	
	
	    TooltipBase.prototype._getTooltipElement = function _getTooltipElement() {
	        if (!this.tooltipElement) {
	            var tooltipElement = this.tooltipElement = _domHandler2['default'].create('DIV', 'tui-chart-tooltip');
	            _domHandler2['default'].append(this.tooltipContainer, tooltipElement);
	        }
	
	        return this.tooltipElement;
	    };
	
	    /**
	     * onShowTooltip is callback of mouse event detector showTooltip for SeriesView.
	     * @param {object} params coordinate event parameters
	     */
	
	
	    TooltipBase.prototype.onShowTooltip = function onShowTooltip(params) {
	        var tooltipElement = this._getTooltipElement();
	        var isScatterCombo = _predicate2['default'].isComboChart(this.chartType) && _predicate2['default'].isScatterChart(params.chartType);
	        var prevPosition = void 0;
	
	        if ((!_predicate2['default'].isChartToDetectMouseEventOnSeries(params.chartType) || isScatterCombo) && tooltipElement.offsetWidth) {
	            prevPosition = {
	                left: tooltipElement.offsetLeft,
	                top: tooltipElement.offsetTop
	            };
	        }
	        this._showTooltip(tooltipElement, params, prevPosition);
	    };
	
	    /**
	     * Get tooltip dimension
	     * @param {HTMLElement} tooltipElement tooltip element
	     * @returns {{width: number, height: number}} rendered tooltip dimension
	     */
	
	
	    TooltipBase.prototype.getTooltipDimension = function getTooltipDimension(_ref) {
	        var offsetWidth = _ref.offsetWidth,
	            offsetHeight = _ref.offsetHeight;
	
	        return {
	            width: offsetWidth,
	            height: offsetHeight
	        };
	    };
	
	    /**
	     * Move to Position.
	     * @param {HTMLElement} tooltipElement tooltip element
	     * @param {{left: number, top: number}} position position
	     * @param {{left: number, top: number}} prevPosition prev position
	     * @private
	     */
	
	
	    TooltipBase.prototype._moveToPosition = function _moveToPosition(tooltipElement, position, prevPosition) {
	        if (prevPosition) {
	            this._slideTooltip(tooltipElement, prevPosition, position);
	        } else {
	            _renderUtil2['default'].renderPosition(tooltipElement, position);
	        }
	    };
	
	    /**
	     * Slide tooltip
	     * @param {HTMLElement} tooltipElement tooltip element
	     * @param {{left: number, top: number}} prevPosition prev position
	     * @param {{left: number, top: number}} position position
	     * @private
	     */
	
	
	    TooltipBase.prototype._slideTooltip = function _slideTooltip(tooltipElement, prevPosition, position) {
	        var moveTop = position.top - prevPosition.top;
	        var moveLeft = position.left - prevPosition.left;
	
	        _renderUtil2['default'].cancelAnimation(this.slidingAnimation);
	
	        this.slidingAnimation = _renderUtil2['default'].startAnimation(this.animationTime, function (ratio) {
	            var left = moveLeft * ratio;
	            var top = moveTop * ratio;
	            tooltipElement.style.left = prevPosition.left + left + 'px';
	            tooltipElement.style.top = prevPosition.top + top + 'px';
	        });
	    };
	
	    /**
	     * onHideTooltip is callback of mouse event detector hideTooltip for SeriesView
	     * @param {number|object} prevFound - showing tooltip object in case single tooltip,
	     *                                  - showing tooltip index in case group tooltip
	     * @param {{silent: {boolean}}} [options] - hide tooltip options
	     */
	
	
	    TooltipBase.prototype.onHideTooltip = function onHideTooltip(prevFound, options) {
	        var tooltipElement = this._getTooltipElement();
	
	        this._hideTooltip(tooltipElement, prevFound, options);
	    };
	
	    /**
	     * Set align option.
	     * @param {string} align align
	     */
	
	
	    TooltipBase.prototype.setAlign = function setAlign(align) {
	        this.options.align = align;
	        if (this.positionModel) {
	            this.positionModel.updateOptions(this.options);
	        }
	    };
	
	    /**
	     * Update offset option.
	     * @param {{x: number, y: number}} offset - offset
	     * @private
	     */
	
	
	    TooltipBase.prototype._updateOffsetOption = function _updateOffsetOption(offset) {
	        this.options.offset = offset;
	
	        if (this.positionModel) {
	            this.positionModel.updateOptions(this.options);
	        }
	    };
	
	    /**
	     * Set offset.
	     * @param {{x: number, y: number}} offset - offset
	     */
	
	
	    TooltipBase.prototype.setOffset = function setOffset(offset) {
	        var offsetOption = Object.assign({}, this.options.offset);
	
	        if (_tuiCodeSnippet2['default'].isExisty(offset.x)) {
	            offsetOption.x = offset.x;
	        }
	
	        if (_tuiCodeSnippet2['default'].isExisty(offset.y)) {
	            offsetOption.y = offset.y;
	        }
	
	        this._updateOffsetOption(_tuiCodeSnippet2['default'].extend({}, this.options.offset, offsetOption));
	    };
	
	    /**
	     * Set position option.
	     * @param {{left: number, top: number}} position moving position
	     * @deprecated
	     */
	
	
	    TooltipBase.prototype.setPosition = function setPosition(position) {
	        var offsetOption = Object.assign({}, this.options.offset);
	
	        if (_tuiCodeSnippet2['default'].isExisty(position.left)) {
	            offsetOption.x = position.left;
	        }
	
	        if (_tuiCodeSnippet2['default'].isExisty(position.top)) {
	            offsetOption.y = position.y;
	        }
	
	        this._updateOffsetOption(offsetOption);
	    };
	
	    /**
	     * Reset align option.
	     */
	
	
	    TooltipBase.prototype.resetAlign = function resetAlign() {
	        var align = this.orgPositionOptions.align;
	
	
	        this.options.align = align;
	
	        if (this.positionModel) {
	            this.positionModel.updateOptions(this.options);
	        }
	    };
	
	    /**
	     * Reset offset option.
	     */
	
	
	    TooltipBase.prototype.resetOffset = function resetOffset() {
	        this.options.offset = this.orgPositionOptions.offset;
	        this._updateOffsetOption(this.options.offset);
	    };
	
	    /**
	     * Get category's raw data
	     * @param {number} index - index of categories
	     * @param {string} format - date format
	     * @returns {string} - category's raw data
	     */
	
	
	    TooltipBase.prototype.getRawCategory = function getRawCategory(index, format) {
	        var axis = this.isVertical ? 'x' : 'y';
	        var categories = this.dataProcessor.categoriesMap ? this.dataProcessor.categoriesMap[axis] : null;
	        var rawCategory = '';
	
	        if (categories) {
	            rawCategory = categories[index];
	        }
	
	        if (format) {
	            rawCategory = _renderUtil2['default'].formatDate(rawCategory, format);
	        }
	
	        return rawCategory;
	    };
	
	    return TooltipBase;
	}();
	
	exports['default'] = TooltipBase;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * singleTooltipMixer is single tooltip mixer of map chart.
	 * @mixin
	 * @private */
	exports['default'] = {
	    /**
	     * Set data indexes.
	     * @param {HTMLElement} elTooltip tooltip element
	     * @param {{groupIndex: number, index:number}} indexes indexes
	     * @private
	     */
	    _setIndexesCustomAttribute: function _setIndexesCustomAttribute(elTooltip, indexes) {
	        elTooltip.setAttribute('data-groupIndex', indexes.groupIndex);
	        elTooltip.setAttribute('data-index', indexes.index);
	    },
	
	
	    /**
	     * Get data indexes
	     * @param {HTMLElement} elTooltip tooltip element
	     * @returns {{groupIndex: number, index: number}} indexes
	     * @private
	     */
	    _getIndexesCustomAttribute: function _getIndexesCustomAttribute(elTooltip) {
	        var groupIndex = elTooltip.getAttribute('data-groupIndex');
	        var index = elTooltip.getAttribute('data-index');
	        var indexes = null;
	
	        if (!_tuiCodeSnippet2['default'].isNull(groupIndex) && !_tuiCodeSnippet2['default'].isNull(index)) {
	            indexes = {
	                groupIndex: parseInt(groupIndex, 10),
	                index: parseInt(index, 10)
	            };
	        }
	
	        return indexes;
	    },
	
	
	    /**
	     * Set showed custom attribute.
	     * @param {HTMLElement} elTooltip tooltip element
	     * @param {boolean} status whether showed or not
	     * @private
	     */
	    _setShowedCustomAttribute: function _setShowedCustomAttribute(elTooltip, status) {
	        elTooltip.setAttribute('data-showed', status);
	    },
	
	
	    /**
	     * Whether showed tooltip or not.
	     * @param {HTMLElement} elTooltip tooltip element
	     * @returns {boolean} whether showed tooltip or not
	     * @private
	     */
	    _isShowedTooltip: function _isShowedTooltip(elTooltip) {
	        var isShowed = elTooltip.getAttribute('data-showed');
	
	        return isShowed === 'true' || isShowed === true; // true in ie7
	    },
	
	
	    /**
	     * Make tooltip position for bullet chart
	     * @param {object} params - mouse position
	     * @returns {object} - position of single tooltip
	     * @private
	     */
	    _makeTooltipPositionForBulletChart: function _makeTooltipPositionForBulletChart(_ref) {
	        var mousePosition = _ref.mousePosition;
	
	        var tooltipAreaPosition = this.layout.position;
	
	        return {
	            left: mousePosition.left - tooltipAreaPosition.left,
	            top: mousePosition.top - tooltipAreaPosition.top
	        };
	    },
	
	
	    /**
	     * Make left position of not bar chart.
	     * @param {number} baseLeft base left
	     * @param {string} alignOption align option
	     * @param {number} minusWidth minus width
	     * @param {number} lineGap line gap
	     * @returns {number} left position value
	     * @private
	     */
	    _makeLeftPositionOfNotBarChart: function _makeLeftPositionOfNotBarChart(baseLeft, alignOption, minusWidth, lineGap) {
	        var left = baseLeft;
	        var offsetNegative = minusWidth || 0;
	        var lineGapOffset = lineGap || _const2['default'].TOOLTIP_GAP;
	
	        if (alignOption.indexOf('left') > -1) {
	            left -= offsetNegative + lineGapOffset;
	        } else if (alignOption.indexOf('center') > -1 && offsetNegative) {
	            left -= offsetNegative / 2;
	        } else {
	            left += lineGapOffset;
	        }
	
	        return left;
	    },
	
	
	    /**
	     * Make top position of not bar chart.
	     * @param {number} baseTop base top
	     * @param {string} alignOption align option
	     * @param {number} tooltipHeight tooltip height
	     * @param {number} lineGap line gap
	     * @returns {number} top position value
	     * @private
	     */
	    _makeTopPositionOfNotBarChart: function _makeTopPositionOfNotBarChart(baseTop, alignOption, tooltipHeight, lineGap) {
	        var top = baseTop;
	        var offsetNegative = tooltipHeight || 0;
	
	        if (alignOption.indexOf('bottom') > -1) {
	            top += offsetNegative + lineGap;
	        } else if (alignOption.indexOf('middle') > -1 && offsetNegative) {
	            top += offsetNegative / 2;
	        } else {
	            top -= offsetNegative + _const2['default'].TOOLTIP_GAP;
	        }
	
	        return top;
	    },
	
	
	    /**
	     * Make tooltip position for not bar chart.
	     * @param {object} params parameters
	     *      @param {{bound: object}} params.data graph information
	     *      @param {{width: number, height: number}} params.dimension tooltip dimension
	     *      @param {string} params.alignOption position option (ex: 'left top')
	     * @returns {{top: number, left: number}} position
	     * @private
	     */
	    _makeTooltipPositionForNotBarChart: function _makeTooltipPositionForNotBarChart(params) {
	        var bound = params.bound,
	            positionOption = params.positionOption,
	            dimension = params.dimension,
	            _params$alignOption = params.alignOption,
	            alignOption = _params$alignOption === undefined ? '' : _params$alignOption;
	
	        var minusWidth = dimension.width - (bound.width || 0);
	        var lineGap = bound.width ? 0 : _const2['default'].TOOLTIP_GAP;
	        var tooltipHeight = dimension.height;
	        var baseLeft = bound.left - this.layout.position.left + positionOption.left;
	        var baseTop = bound.top - this.layout.position.top + positionOption.top - _const2['default'].TOOLTIP_GAP;
	
	        return {
	            left: this._makeLeftPositionOfNotBarChart(baseLeft, alignOption, minusWidth, lineGap),
	            top: this._makeTopPositionOfNotBarChart(baseTop, alignOption, tooltipHeight, lineGap)
	        };
	    },
	
	
	    /**
	     * Make tooltip position to event position.
	     * @param {object} params parameters
	     *      @param {{left: number, top: number}} params.bound bound
	     *      @param {{left: number, top: number}} params.mousePosition mouse position
	     * @returns {{top: number, left: number}} position
	     * @private
	     */
	    _makeTooltipPositionToMousePosition: function _makeTooltipPositionToMousePosition(params) {
	        if (!params.bound) {
	            params.bound = params.bound || {};
	            _tuiCodeSnippet2['default'].extend(params.bound, params.mousePosition);
	        }
	
	        return this._makeTooltipPositionForNotBarChart(params);
	    },
	
	
	    /**
	     * Make left position for bar chart.
	     * @param {number} baseLeft base left
	     * @param {string} alignOption align option
	     * @param {number} tooltipWidth tooltip width
	     * @returns {number} left position value
	     * @private
	     */
	    _makeLeftPositionForBarChart: function _makeLeftPositionForBarChart(baseLeft, alignOption, tooltipWidth) {
	        var left = baseLeft;
	
	        if (alignOption.indexOf('left') > -1) {
	            left -= tooltipWidth;
	        } else if (alignOption.indexOf('center') > -1) {
	            left -= tooltipWidth / 2;
	        } else {
	            left += _const2['default'].TOOLTIP_GAP;
	        }
	
	        return left;
	    },
	
	
	    /**
	     * Make top position for bar chart.
	     * @param {number} baseTop base top
	     * @param {string} alignOption align option
	     * @param {number} minusHeight minus width
	     * @returns {number} top position value
	     * @private
	     */
	    _makeTopPositionForBarChart: function _makeTopPositionForBarChart(baseTop, alignOption, minusHeight) {
	        var top = baseTop;
	
	        if (alignOption.indexOf('top') > -1) {
	            top -= minusHeight;
	        } else if (alignOption.indexOf('middle') > -1) {
	            top -= minusHeight / 2;
	        }
	
	        return top;
	    },
	
	
	    /**
	     * Make tooltip position for bar chart.
	     * @param {object} params parameters
	     *      @param {{bound: object}} params.data graph information
	     *      @param {{width: number, height: number}} params.dimension tooltip dimension
	     *      @param {string} params.alignOption position option (ex: 'left top')
	     * @returns {{top: number, left: number}} position
	     * @private
	     */
	    _makeTooltipPositionForBarChart: function _makeTooltipPositionForBarChart(params) {
	        var position = this.layout.position;
	        var bound = params.bound,
	            positionOption = params.positionOption,
	            dimension = params.dimension,
	            _params$alignOption2 = params.alignOption,
	            alignOption = _params$alignOption2 === undefined ? '' : _params$alignOption2;
	
	        var minusHeight = dimension.height - (bound.height || 0);
	        var tooltipWidth = dimension.width;
	        var baseLeft = bound.left + bound.width + positionOption.left - position.left;
	        var baseTop = bound.top + positionOption.top - position.top;
	
	        return {
	            left: this._makeLeftPositionForBarChart(baseLeft, alignOption, tooltipWidth),
	            top: this._makeTopPositionForBarChart(baseTop, alignOption, minusHeight)
	        };
	    },
	
	
	    /**
	     * Make tooltip position for treemap chart.
	     * @param {object} params parameters
	     *      @param {{bound: object}} params.data - graph information
	     *      @param {{width: number, height: number}} params.dimension - tooltip dimension
	     * @returns {{left: number, top: number}}
	     * @private
	     */
	    _makeTooltipPositionForTreemapChart: function _makeTooltipPositionForTreemapChart(params) {
	        var position = this.layout.position;
	        var bound = params.bound,
	            positionOption = params.positionOption,
	            dimension = params.dimension;
	
	        var labelHeight = _renderUtil2['default'].getRenderedLabelHeight(_const2['default'].MAX_HEIGHT_WORD, this.labelTheme);
	
	        return {
	            left: bound.left + (bound.width - dimension.width) / 2 + positionOption.left - position.left,
	            top: bound.top + bound.height / 2 - labelHeight + positionOption.top - position.top
	        };
	    },
	
	
	    /**
	     * Adjust position.
	     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
	     * @param {{left: number, top: number}} position position
	     * @returns {{left: number, top: number}} adjusted position
	     * @private
	     */
	    _adjustPosition: function _adjustPosition(tooltipDimension, position) {
	        var chartDimension = this.dimensionMap.chart;
	        var areaPosition = this.layout.position;
	
	        position.left = Math.max(position.left, -areaPosition.left);
	        position.left = Math.min(position.left, chartDimension.width - areaPosition.left - tooltipDimension.width);
	        position.top = Math.max(position.top, -areaPosition.top);
	        position.top = Math.min(position.top, chartDimension.height - areaPosition.top - tooltipDimension.height);
	
	        return position;
	    },
	
	
	    /**
	     * Make tooltip position.
	     * @param {object} params parameters
	     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
	     *      @param {string} params.chartType chart type
	     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
	     *      @param {{width: number, height: number}} params.dimension tooltip dimension
	     *      @param {string} params.alignOption position option (ex: 'left top')
	     * @returns {{top: number, left: number}} position
	     * @private
	     */
	    _makeTooltipPosition: function _makeTooltipPosition(params) {
	        var position = {};
	
	        if (params.mousePosition) {
	            position = this._makeTooltipPositionToMousePosition(params);
	        } else {
	            var sizeType = void 0,
	                positionType = void 0,
	                addPadding = void 0;
	            if (_predicate2['default'].isBarChart(params.chartType)) {
	                position = this._makeTooltipPositionForBarChart(params);
	                sizeType = 'width';
	                positionType = 'left';
	                addPadding = 1;
	            } else if (_predicate2['default'].isTreemapChart(params.chartType)) {
	                position = this._makeTooltipPositionForTreemapChart(params);
	            } else {
	                position = this._makeTooltipPositionForNotBarChart(params);
	                sizeType = 'height';
	                positionType = 'top';
	                addPadding = -1;
	            }
	
	            if (params.allowNegativeTooltip) {
	                position = this._moveToSymmetry(position, {
	                    bound: params.bound,
	                    indexes: params.indexes,
	                    dimension: params.dimension,
	                    chartType: params.chartType,
	                    sizeType: sizeType,
	                    positionType: positionType,
	                    addPadding: addPadding
	                });
	            }
	
	            position = this._adjustPosition(params.dimension, position);
	        }
	
	        return position;
	    },
	
	
	    /**
	     * Move to symmetry.
	     * @param {{left: number, top: number}} position tooltip position
	     * @param {object} params parameters
	     *      @param {{left: number, top: number, width: number, height: number}} params.bound graph bound
	     *      @param {string} params.id tooltip id
	     *      @param {{width: number, height: number}} params.dimension tooltip dimension
	     *      @param {string} params.sizeType size type (width or height)
	     *      @param {string} params.positionType position type (left or top)
	     *      @param {number} params.addPadding add padding
	     * @returns {{left: number, top: number}} moved position
	     * @private
	     */
	    _moveToSymmetry: function _moveToSymmetry(position, params) {
	        var bound = params.bound,
	            sizeType = params.sizeType,
	            positionType = params.positionType,
	            indexes = params.indexes;
	
	        var seriesType = params.seriesType || params.chartType;
	        var value = this.dataProcessor.getValue(indexes.groupIndex, indexes.index, seriesType);
	        var direction = _predicate2['default'].isBarChart(this.chartType) ? -1 : 1;
	
	        if (value < 0) {
	            var tooltipSize = params.dimension[sizeType];
	            var barSize = bound[sizeType];
	            var movedPositionValue = position[positionType] + (barSize + tooltipSize) * direction;
	            position[positionType] = movedPositionValue;
	        }
	
	        return position;
	    },
	
	
	    /**
	     * Whether changed indexes or not.
	     * @param {{groupIndex: number, index: number}} prevIndexes prev indexes
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     * @returns {boolean} whether changed or not
	     * @private
	     */
	    _isChangedIndexes: function _isChangedIndexes(prevIndexes, indexes) {
	        return !!prevIndexes && (prevIndexes.groupIndex !== indexes.groupIndex || prevIndexes.index !== indexes.index);
	    },
	
	
	    /**
	     * Show tooltip.
	     * @param {HTMLElement} elTooltip tooltip element
	     * @param {{indexes: {groupIndex: number, index: number}, bound: object}} params tooltip data
	     * @param {{left: number, top: number}} prevPosition prev position
	     * @private
	     */
	    _showTooltip: function _showTooltip(elTooltip, params, prevPosition) {
	        var boundingClientRect = this.tooltipContainer.parentNode.getBoundingClientRect();
	        var indexes = params.indexes;
	
	        var prevIndexes = this._getIndexesCustomAttribute(elTooltip);
	        var offset = this.options.offset || {};
	        var positionOption = {};
	        var prevChartType = elTooltip && elTooltip.getAttribute('data-chart-type');
	
	        if (!params.bound && params.mousePosition) {
	            params.bound = {
	                left: params.mousePosition.left - boundingClientRect.left + _const2['default'].CHART_PADDING,
	                top: params.mousePosition.top - boundingClientRect.top + _const2['default'].CHART_PADDING
	            };
	        }
	
	        if (this._isChangedIndexes(prevIndexes, indexes) || prevChartType !== params.chartType) {
	            this.eventBus.fire('hoverOffSeries', prevIndexes, prevChartType);
	        }
	
	        elTooltip.innerHTML = this._makeSingleTooltipHtml(params.seriesType || params.chartType, indexes);
	
	        if (params.chartType === 'line') {
	            this.makeLineLegendIcon(elTooltip.querySelectorAll('.tui-chart-legend-rect.line'));
	        }
	
	        elTooltip.setAttribute('data-chart-type', params.chartType);
	        this._setIndexesCustomAttribute(elTooltip, indexes);
	        this._setShowedCustomAttribute(elTooltip, true);
	
	        this._fireBeforeShowTooltipPublicEvent(indexes, params.silent);
	
	        _domHandler2['default'].addClass(elTooltip, 'show');
	
	        positionOption.left = offset.x || 0;
	        positionOption.top = offset.y || 0;
	
	        var position = this._makeTooltipPosition(_tuiCodeSnippet2['default'].extend({
	            dimension: this.getTooltipDimension(elTooltip),
	            positionOption: positionOption,
	            alignOption: this.options.align || ''
	        }, params));
	
	        this._moveToPosition(elTooltip, position, prevPosition);
	        this.eventBus.fire('hoverSeries', indexes, params.chartType);
	        this._fireAfterShowTooltipPublicEvent(indexes, {
	            element: elTooltip,
	            position: position
	        }, params.silent);
	        delete params.silent;
	    },
	
	
	    /**
	     * To call beforeShowTooltip callback of public event.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     * @param {boolean} [silent] - whether invoke a public beforeHideTooltip event or not
	     * @private
	     */
	    _fireBeforeShowTooltipPublicEvent: function _fireBeforeShowTooltipPublicEvent(indexes, silent) {
	        if (silent) {
	            return;
	        }
	
	        var params = this._makeShowTooltipParams(indexes);
	        this.eventBus.fire(_const2['default'].PUBLIC_EVENT_PREFIX + 'beforeShowTooltip', params);
	    },
	
	
	    /**
	     * To call afterShowTooltip callback of public event.
	     * @param {{groupIndex: number, index: number}} indexes indexes
	     * @param {object} additionParams addition parameters
	     * @param {boolean} [silent] - whether invoke a public beforeHideTooltip event or not
	     * @private
	     */
	    _fireAfterShowTooltipPublicEvent: function _fireAfterShowTooltipPublicEvent(indexes, additionParams, silent) {
	        if (silent) {
	            return;
	        }
	
	        var params = this._makeShowTooltipParams(indexes, additionParams);
	        this.eventBus.fire(_const2['default'].PUBLIC_EVENT_PREFIX + 'afterShowTooltip', params);
	    },
	
	
	    /**
	     * Execute hiding tooltip.
	     * @param {HTMLElement} tooltipElement tooltip element
	     * @private
	     */
	    _executeHidingTooltip: function _executeHidingTooltip(tooltipElement) {
	        _domHandler2['default'].removeClass(tooltipElement, 'show');
	        tooltipElement.removeAttribute('data-groupIndex');
	        tooltipElement.removeAttribute('data-index');
	        tooltipElement.style.cssText = '';
	    },
	
	
	    /**
	     * Hide tooltip.
	     * @param {HTMLElement} tooltipElement - tooltip element
	     * @param {object} prevFoundData - data represented by tooltip elements
	     * @param {{silent: {boolean}}} [options] - options for hiding a tooltip element
	     * @private
	     */
	    _hideTooltip: function _hideTooltip(tooltipElement, prevFoundData, options) {
	        var _this = this;
	
	        var indexes = this._getIndexesCustomAttribute(tooltipElement);
	        var chartType = tooltipElement.getAttribute('data-chart-type');
	        var silent = !!(options && options.silent);
	
	        if (_predicate2['default'].isChartToDetectMouseEventOnSeries(chartType)) {
	            this.eventBus.fire('hoverOffSeries', indexes, chartType);
	            this._fireBeforeHideTooltipPublicEvent(indexes, silent);
	            this._executeHidingTooltip(tooltipElement);
	        } else if (chartType) {
	            this._setShowedCustomAttribute(tooltipElement, false);
	            this.eventBus.fire('hoverOffSeries', indexes, chartType);
	
	            if (this._isChangedIndexes(this.prevIndexes, indexes)) {
	                delete this.prevIndexes;
	            }
	
	            setTimeout(function () {
	                if (_this._isShowedTooltip(tooltipElement)) {
	                    return;
	                }
	                _this._fireBeforeHideTooltipPublicEvent(indexes, silent);
	                _this._executeHidingTooltip(tooltipElement);
	            }, _const2['default'].HIDE_DELAY);
	        }
	    },
	
	
	    /**
	     * To call afterShowTooltip callback of public event.
	     * @param {{groupIndex: number, index: number}} indexes indexes=
	     * @param {boolean} [silent] - whether invoke a public beforeHideTooltip event or not
	     * @private
	     */
	    _fireBeforeHideTooltipPublicEvent: function _fireBeforeHideTooltipPublicEvent(indexes, silent) {
	        var params = void 0;
	        if (silent) {
	            return;
	        }
	
	        this.eventBus.fire(_const2['default'].PUBLIC_EVENT_PREFIX + 'beforeHideTooltip', params);
	    },
	
	
	    /**
	     * On show tooltip container.
	     */
	    onShowTooltipContainer: function onShowTooltipContainer() {
	        this.tooltipContainer.style.zIndex = _const2['default'].TOOLTIP_ZINDEX;
	    },
	
	
	    /**
	     * On hide tooltip container.
	     */
	    onHideTooltipContainer: function onHideTooltipContainer() {
	        this.tooltipContainer.style.zIndex = 0;
	    },
	
	
	    /**
	     * Mix in.
	     * @param {function} func target function
	     * @ignore
	     */
	    mixin: function mixin(func) {
	        _tuiCodeSnippet2['default'].extend(func.prototype, this);
	    }
	}; /**
	    * @fileoverview singleTooltipMixer is single tooltip mixer of map chart.
	    * @author NHN.
	    *         FE Development Lab <dl_javascript@nhn.com>
	    */

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _templateMaker = __webpack_require__(392);
	
	var _templateMaker2 = _interopRequireDefault(_templateMaker);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var htmls = {
	    HTML_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">' + '<div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>' + '<div class="tui-chart-tooltip-body">' + '<span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>' + '<span>{{ legend }}</span>' + '<span class="tui-chart-tooltip-value">{{ label }}{{ suffix }}</span>' + '</div>' + '</div>',
	
	    HTML_PIE_TEMPLATE: '<div class="tui-chart-default-tooltip">' + '<div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>' + '<div class="tui-chart-tooltip-body">' + '<span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>' + '<span>{{ legend }}</span>' + '<span class="tui-chart-tooltip-value">{{ ratioLabel }} ( {{ label }} {{ suffix }})</span>' + '</div>' + '</div>',
	
	    HTML_COORDINATE_TYPE_CHART_TEMPLATE: '<div class="tui-chart-default-tooltip">' + '<div class="tui-chart-tooltip-head {{ categoryVisible }}">' + '<span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>' + '{{ category }}' + '</div>' + '<div class="tui-chart-tooltip-body">' + '<span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>' + '<span>{{ legend }}</span>' + '<span class="tui-chart-tooltip-value">{{ label }}</span>' + '</div><table class="tui-chart-tooltip-body">{{ valueTypes }}</table>' + '</div>',
	
	    HTML_GROUP: '<div class="tui-chart-default-tooltip tui-chart-group-tooltip">' + '<div class="tui-chart-tooltip-head">{{ category }}</div>' + '<table class="tui-chart-tooltip-body">' + '{{ items }}' + '</table>' + '</div>',
	
	    HTML_GROUP_TYPE: '<tr>' + '<td colspan="3" class="tui-chart-tooltip-type">{{ type }}</div>' + '</tr>',
	
	    HTML_GROUP_ITEM: '<tr>' + '<td>' + '<div class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></div>' + '</td>' + '<td>{{ legend }}</td>' + '<td class="tui-chart-tooltip-value">{{ value }} {{ suffix }}</td>' + '</tr>',
	
	    GROUP_CSS_TEXT: 'background-color:{{ color }}',
	    HTML_MAP_CHART_DEFAULT_TEMPLATE: '<div class="tui-chart-default-tooltip">' + '<div class="tui-chart-tooltip-body">' + '<span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>' + '<span>{{ name }}</span>' + '<span class="tui-chart-tooltip-value">{{ value }}{{ suffix }}</span>' + '</div>' + '</div>',
	    HTML_HEATMAP_TEMPLATE: '<div class="tui-chart-default-tooltip">' + '<div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>' + '<div class="tui-chart-tooltip-body">' + '<span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>' + '<span>{{ label }}{{ suffix }}</span>' + '</div>' + '</div>',
	    HTML_BOXPLOT_TEMPLATE: '<div class="tui-chart-default-tooltip">' + '<div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>' + '<table class="tui-chart-tooltip-body">' + '<tr>' + '<td colspan="2"><span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>{{ legend }}</td>' + '</tr>' + '<tr>' + '<td>Maximum: </td>' + '<td class="tui-chart-tooltip-value">{{ maxLabel }} {{ suffix }}</td>' + '</tr>' + '<tr>' + '<td>Upper Quartile: </td>' + '<td class="tui-chart-tooltip-value">{{ uqLabel }} {{ suffix }}</td>' + '</tr>' + '<tr>' + '<td>Median: </td>' + '<td class="tui-chart-tooltip-value">{{ medianLabel }} {{ suffix }}</td>' + '</tr>' + '<tr>' + '<td>Lower Quartile: </td>' + '<td class="tui-chart-tooltip-value">{{ lqLabel }} {{ suffix }}</td>' + '</tr>' + '<tr>' + '<td>Minimum: </td>' + '<td class="tui-chart-tooltip-value">{{ minLabel }} {{ suffix }}</td>' + '</tr>' + '</table>' + '</div>',
	    HTML_BOXPLOT_OUTLIER: '<div class="tui-chart-default-tooltip">' + '<div class="tui-chart-tooltip-head {{ categoryVisible }}">{{ category }}</div>' + '<div class="tui-chart-tooltip-body">' + '<span>{{ legend }}</span>' + '</div>' + '<div class="tui-chart-tooltip-body">' + '<span>Outlier: </span>' + '<span class="tui-chart-tooltip-value">{{ label }} {{ suffix }}</span>' + '</div>' + '</div>',
	    HTML_BULLET_TEMPLATE: '<div class="tui-chart-default-tooltip">' + '<div class="tui-chart-tooltip-body {{ categoryVisible }}">' + '<span class="tui-chart-legend-rect {{ chartType }}" style="{{ cssText }}"></span>' + '<span>{{ category }}</span>' + '<span class="tui-chart-tooltip-value">{{ label }} {{ suffix }}</span>' + '</div>' + '</div>'
	}; /**
	    * @fileoverview This is templates of tooltip.
	    * @author NHN.
	    *         FE Development Lab <dl_javascript@nhn.com>
	    */
	
	exports['default'] = {
	    tplDefault: _templateMaker2['default'].template(htmls.HTML_DEFAULT_TEMPLATE),
	    tplPieChart: _templateMaker2['default'].template(htmls.HTML_PIE_TEMPLATE),
	    tplCoordinatetypeChart: _templateMaker2['default'].template(htmls.HTML_COORDINATE_TYPE_CHART_TEMPLATE),
	    tplGroup: _templateMaker2['default'].template(htmls.HTML_GROUP),
	    tplGroupType: _templateMaker2['default'].template(htmls.HTML_GROUP_TYPE),
	    tplGroupItem: _templateMaker2['default'].template(htmls.HTML_GROUP_ITEM),
	    tplGroupCssText: _templateMaker2['default'].template(htmls.GROUP_CSS_TEXT),
	    tplMapChartDefault: _templateMaker2['default'].template(htmls.HTML_MAP_CHART_DEFAULT_TEMPLATE),
	    tplHeatmapChart: _templateMaker2['default'].template(htmls.HTML_HEATMAP_TEMPLATE),
	    tplBoxplotChartDefault: _templateMaker2['default'].template(htmls.HTML_BOXPLOT_TEMPLATE),
	    tplBoxplotChartOutlier: _templateMaker2['default'].template(htmls.HTML_BOXPLOT_OUTLIER),
	    tplBulletChartDefault: _templateMaker2['default'].template(htmls.HTML_BULLET_TEMPLATE)
	};

/***/ }),
/* 392 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	/**
	 * @fileoverview This is template maker.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	exports['default'] = {
	    /**
	     * This is template maker.
	     * @param {string} html html
	     * @returns {function} template function
	     * @eaxmple
	     *
	     *   var template = templateMaker.template('<span>{{ name }}</span>'),
	     *       result = template({name: 'John');
	     *   console.log(result); // <span>John</span>
	     *
	     */
	    template: function template(html) {
	        return function (data) {
	            var result = html;
	
	            Object.entries(data).forEach(function (_ref) {
	                var _ref2 = _slicedToArray(_ref, 2),
	                    key = _ref2[0],
	                    value = _ref2[1];
	
	                var regExp = new RegExp('{{\\s*' + key + '\\s*}}', 'g');
	                result = result.replace(regExp, String(value).replace('$', '＄'));
	            });
	
	            return result;
	        };
	    }
	};

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = groupTooltipFactory;
	
	var _tooltipBase = __webpack_require__(389);
	
	var _tooltipBase2 = _interopRequireDefault(_tooltipBase);
	
	var _groupTooltipPositionModel = __webpack_require__(394);
	
	var _groupTooltipPositionModel2 = _interopRequireDefault(_groupTooltipPositionModel);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _defaultTheme = __webpack_require__(362);
	
	var _defaultTheme2 = _interopRequireDefault(_defaultTheme);
	
	var _tooltipTemplate = __webpack_require__(391);
	
	var _tooltipTemplate2 = _interopRequireDefault(_tooltipTemplate);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Group tooltip component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION = _const2['default'].TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION,
	    TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION = _const2['default'].TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION,
	    SERIES_EXPAND_SIZE = _const2['default'].SERIES_EXPAND_SIZE,
	    PUBLIC_EVENT_PREFIX = _const2['default'].PUBLIC_EVENT_PREFIX;
	
	/**
	 * @classdesc GroupTooltip component.
	 * @class GroupTooltip
	 * @private
	 */
	
	var GroupTooltip = function (_TooltipBase) {
	    _inherits(GroupTooltip, _TooltipBase);
	
	    /**
	     * Group tooltip component.
	     * @constructs GroupTooltip
	     * @private
	     * @override
	     */
	    function GroupTooltip(params) {
	        _classCallCheck(this, GroupTooltip);
	
	        var _this = _possibleConstructorReturn(this, _TooltipBase.call(this, params));
	
	        _this.prevIndex = null;
	        _this.isBullet = _predicate2['default'].isBulletChart(params.chartType);
	        return _this;
	    }
	
	    /**
	     * Make tooltip html.
	     * @param {string} category category
	     * @param {Array.<{value: string, legend: string, chartType: string, suffix: ?string}>} items items data
	     * @param {string} rawCategory raw category
	     * @param {number} groupIndex group index
	     * @returns {string} tooltip html
	     * @private
	     */
	
	
	    GroupTooltip.prototype._makeTooltipHtml = function _makeTooltipHtml(category, items, rawCategory, groupIndex) {
	        var template = _tooltipTemplate2['default'].tplGroupItem;
	        var cssTextTemplate = _tooltipTemplate2['default'].tplGroupCssText;
	        var isBar = _predicate2['default'].isBarTypeChart(this.chartType);
	        var isBoxplot = _predicate2['default'].isBoxplotChart(this.chartType);
	        var colorByPoint = (isBar || isBoxplot) && this.dataProcessor.options.series.colorByPoint;
	        var colors = this._makeColors(this.theme, groupIndex);
	        var prevType = void 0;
	
	        var itemsHtml = items.map(function (item, index) {
	            var type = item.type;
	
	            var typeVisible = type !== 'data' && prevType !== type;
	            var itemHtml = '';
	
	            prevType = type;
	
	            if (!item.value) {
	                return null;
	            }
	
	            if (typeVisible) {
	                itemHtml = _tooltipTemplate2['default'].tplGroupType({
	                    type: type
	                });
	            }
	
	            itemHtml += template(_tuiCodeSnippet2['default'].extend({
	                cssText: cssTextTemplate({ color: colorByPoint ? '#aaa' : colors[index] })
	            }, item));
	
	            return itemHtml;
	        }).join('');
	
	        return _tooltipTemplate2['default'].tplGroup({
	            category: category,
	            items: itemsHtml
	        });
	    };
	
	    /**
	     * Set default align option of tooltip.
	     * @private
	     * @override
	     */
	
	
	    GroupTooltip.prototype._setDefaultTooltipPositionOption = function _setDefaultTooltipPositionOption() {
	        if (this.options.align) {
	            return;
	        }
	
	        if (this.isVertical) {
	            this.options.align = TOOLTIP_DEFAULT_GROUP_ALIGN_OPTION;
	        } else {
	            this.options.align = TOOLTIP_DEFAULT_GROUP_HORIZONTAL_ALIGN_OPTION;
	        }
	    };
	
	    /**
	     * Render tooltip component.
	     * @returns {HTMLElement}
	     * @override
	     */
	
	
	    GroupTooltip.prototype.render = function render(data) {
	        var container = _tooltipBase2['default'].prototype.render.call(this, data);
	        var chartDimension = this.dimensionMap.chart;
	        var bound = this.layout;
	
	        if (data.checkedLegends) {
	            this.theme = this._updateLegendTheme(data.checkedLegends);
	        }
	
	        this.positionModel = new _groupTooltipPositionModel2['default'](chartDimension, bound, this.isVertical, this.options);
	
	        return container;
	    };
	
	    /**
	     * Rerender.
	     * @param {{checkedLegends: Array.<boolean>}} data rendering data
	     * @override
	     */
	
	
	    GroupTooltip.prototype.rerender = function rerender(data) {
	        _tooltipBase2['default'].prototype.rerender.call(this, data);
	        this.prevIndex = null;
	
	        if (data.checkedLegends) {
	            this.theme = this._updateLegendTheme(data.checkedLegends);
	        }
	    };
	
	    /**
	     * Zoom.
	     */
	
	
	    GroupTooltip.prototype.zoom = function zoom() {
	        this.prevIndex = null;
	        _tooltipBase2['default'].prototype.zoom.call(this);
	    };
	
	    /**
	     * Update legend theme.
	     * @param {object | Array.<boolean>}checkedLegends checked legends
	     * @returns {{colors: Array.<string>}} legend theme
	     * @private
	     */
	
	
	    GroupTooltip.prototype._updateLegendTheme = function _updateLegendTheme(checkedLegends) {
	        var _this2 = this;
	
	        var colors = [];
	        var chartTypes = Object.keys(this.originalTheme);
	
	        chartTypes.forEach(function (chartType) {
	            var chartColors = _this2.originalTheme[chartType].colors;
	            chartColors.forEach(function (color, index) {
	                var _checkedLegends = checkedLegends[chartType] || checkedLegends;
	                if (_checkedLegends[index]) {
	                    colors.push(color);
	                }
	            });
	        });
	
	        return {
	            colors: colors
	        };
	    };
	
	    /**
	     * Make tooltip data.
	     * @returns {Array.<object>} tooltip data
	     * @override
	     */
	
	
	    GroupTooltip.prototype.makeTooltipData = function makeTooltipData() {
	        var _this3 = this;
	
	        var length = this.dataProcessor.getCategoryCount(this.isVertical);
	
	        return this.dataProcessor.getSeriesGroups().map(function (seriesGroup, index) {
	            var values = seriesGroup.map(function (item) {
	                return {
	                    type: item.type || 'data',
	                    label: item.tooltipLabel || item.label
	                };
	            });
	
	            return {
	                category: _this3.dataProcessor.makeTooltipCategory(index, length - index, _this3.isVertical),
	                values: values
	            };
	        });
	    };
	
	    /**
	     * Make colors.
	     * @param {object} theme tooltip theme
	     * @param {number} [groupIndex] groupIndex
	     * @returns {Array.<string>} colors
	     * @private
	     */
	
	
	    GroupTooltip.prototype._makeColors = function _makeColors(theme, groupIndex) {
	        var colorIndex = 0;
	        var legendLabels = this.dataProcessor.getLegendData();
	        var colors = void 0,
	            prevChartType = void 0;
	
	        if (this.isBullet) {
	            return this.dataProcessor.getGraphColors()[groupIndex];
	        }
	
	        if (theme.colors) {
	            return theme.colors;
	        }
	
	        var defaultColors = _defaultTheme2['default'].series.colors.slice(0, legendLabels.length);
	
	        return _tuiCodeSnippet2['default'].pluck(legendLabels, 'chartType').map(function (chartType) {
	            if (prevChartType !== chartType) {
	                colors = theme[chartType] ? theme[chartType].colors : defaultColors;
	                colorIndex = 0;
	            }
	
	            prevChartType = chartType;
	            var color = colors[colorIndex];
	            colorIndex += 1;
	
	            return color;
	        });
	    };
	
	    /**
	     * Make rendering data about legend item.
	     * @param {Array.<string>} values values
	     * @param {number} groupIndex groupIndex
	     * @returns {Array.<{value: string, legend: string, chartType: string, suffix: ?string}>} legend item data.
	     * @private
	     */
	
	
	    GroupTooltip.prototype._makeItemRenderingData = function _makeItemRenderingData(values, groupIndex) {
	        var _this4 = this;
	
	        var dataProcessor = this.dataProcessor,
	            suffix = this.suffix;
	
	
	        return values.map(function (data, index) {
	            var item = {
	                value: data.label,
	                type: data.type,
	                suffix: suffix,
	                legend: ''
	            };
	            var legendLabel = void 0;
	
	            if (_this4.isBullet) {
	                legendLabel = dataProcessor.getLegendItem(groupIndex);
	            } else {
	                legendLabel = dataProcessor.getLegendItem(index);
	                item.legend = legendLabel.label;
	            }
	
	            item.chartType = legendLabel.chartType;
	
	            return item;
	        });
	    };
	
	    /**
	     * Make tooltip.
	     * @param {number} groupIndex group index
	     * @returns {string} tooltip html
	     * @private
	     */
	
	
	    GroupTooltip.prototype._makeGroupTooltipHtml = function _makeGroupTooltipHtml(groupIndex) {
	        var data = this.data[groupIndex];
	        var htmlString = '';
	
	        if (data) {
	            var items = this._makeItemRenderingData(data.values, groupIndex);
	            htmlString = this.templateFunc(data.category, items, this.getRawCategory(groupIndex), groupIndex);
	        }
	
	        return htmlString;
	    };
	
	    /**
	     * Get tooltip sector element.
	     * @returns {HTMLElement} sector element
	     * @private
	     */
	
	
	    GroupTooltip.prototype._getTooltipSectorElement = function _getTooltipSectorElement() {
	        if (!this.groupTooltipSector) {
	            var groupTooltipSector = this.groupTooltipSector = _domHandler2['default'].create('DIV', 'tui-chart-group-tooltip-sector');
	            _domHandler2['default'].append(this.tooltipContainer, groupTooltipSector);
	        }
	
	        return this.groupTooltipSector;
	    };
	
	    /**
	     * Make bound about tooltip sector of vertical type chart.
	     * @param {number} height height
	     * @param {{start: number, end: number}} range range
	     * @param {boolean} isLine whether line or not
	     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
	     * @private
	     */
	
	
	    GroupTooltip.prototype._makeVerticalTooltipSectorBound = function _makeVerticalTooltipSectorBound(height, range, isLine) {
	        var width = void 0;
	
	        if (isLine) {
	            width = 1;
	        } else {
	            width = range.end - range.start;
	        }
	
	        return {
	            dimension: {
	                width: width,
	                height: height
	            },
	            position: {
	                left: range.start,
	                top: SERIES_EXPAND_SIZE
	            }
	        };
	    };
	
	    /**
	     * Make bound about tooltip sector of horizontal type chart.
	     * @param {number} width width
	     * @param {{start: number, end:number}} range range
	     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
	     * @private
	     */
	
	
	    GroupTooltip.prototype._makeHorizontalTooltipSectorBound = function _makeHorizontalTooltipSectorBound(width, range) {
	        return {
	            dimension: {
	                width: width,
	                height: range.end - range.start
	            },
	            position: {
	                left: SERIES_EXPAND_SIZE,
	                top: range.start
	            }
	        };
	    };
	
	    /**
	     * Make bound about tooltip sector.
	     * @param {number} size width or height
	     * @param {{start: number, end:number}} range range
	     * @param {boolean} isVertical whether vertical or not
	     * @param {boolean} isLine whether line type or not
	     * @returns {{dimension: {width: number, height: number}, position: {left: number, top: number}}} bound
	     * @private
	     */
	
	
	    GroupTooltip.prototype._makeTooltipSectorBound = function _makeTooltipSectorBound(size, range, isVertical, isLine) {
	        if (isVertical) {
	            return this._makeVerticalTooltipSectorBound(size, range, isLine);
	        }
	
	        return this._makeHorizontalTooltipSectorBound(size, range);
	    };
	
	    /**
	     * Show tooltip sector.
	     * @param {number} size width or height
	     * @param {{start: number, end:number}} range range
	     * @param {boolean} isVertical whether vertical or not
	     * @param {number} index index
	     * @param {boolean} [isMoving] whether moving or not
	     * @private
	     */
	
	
	    GroupTooltip.prototype._showTooltipSector = function _showTooltipSector(size, range, isVertical, index, isMoving) {
	        var groupTooltipSector = this._getTooltipSectorElement();
	        var isLine = range.start === range.end;
	        var bound = this._makeTooltipSectorBound(size, range, isVertical, isLine);
	
	        if (isLine) {
	            this.eventBus.fire('showGroupTooltipLine', bound);
	        } else {
	            _renderUtil2['default'].renderDimension(groupTooltipSector, bound.dimension);
	            _renderUtil2['default'].renderPosition(groupTooltipSector, bound.position);
	            _domHandler2['default'].addClass(groupTooltipSector, 'show');
	        }
	
	        if (isMoving) {
	            index -= 1;
	        }
	
	        this.eventBus.fire('showGroupAnimation', index);
	    };
	
	    /**
	     * Hide tooltip sector.
	     * @param {number} index index
	     * @private
	     */
	
	
	    GroupTooltip.prototype._hideTooltipSector = function _hideTooltipSector(index) {
	        var groupTooltipSector = this._getTooltipSectorElement();
	
	        if (!_domHandler2['default'].hasClass(groupTooltipSector, 'show')) {
	            this.eventBus.fire('hideGroupTooltipLine');
	        } else {
	            _domHandler2['default'].removeClass(groupTooltipSector, 'show');
	        }
	        this.eventBus.fire('hideGroupAnimation', index);
	        this.eventBus.fire('hideGroupTooltipLine');
	    };
	
	    /**
	     * Show tooltip.
	     * @param {HTMLElement} elTooltip tooltip element
	     * @param {{index: number, range: {start: number, end: number},
	     *          size: number, direction: string, isVertical: boolean
	     *        }} params coordinate event parameters
	     * @param {{left: number, top: number}} prevPosition prev position
	     * @private
	     */
	
	
	    GroupTooltip.prototype._showTooltip = function _showTooltip(elTooltip, params, prevPosition) {
	        if (!_tuiCodeSnippet2['default'].isNull(this.prevIndex)) {
	            this.eventBus.fire('hideGroupAnimation', this.prevIndex);
	        }
	
	        elTooltip.innerHTML = this._makeGroupTooltipHtml(params.index);
	
	        this._fireBeforeShowTooltipPublicEvent(params.index, params.range, params.silent);
	
	        if (document.getElementsByClassName) {
	            this.makeLineLegendIcon(elTooltip.querySelectorAll('.tui-chart-legend-rect.line'));
	        }
	
	        _domHandler2['default'].addClass(elTooltip, 'show');
	
	        this._showTooltipSector(params.size, params.range, params.isVertical, params.index, params.isMoving);
	
	        var dimension = this.getTooltipDimension(elTooltip);
	        var position = this.positionModel.calculatePosition(dimension, params.range);
	
	        this._moveToPosition(elTooltip, position, prevPosition);
	
	        this._fireAfterShowTooltipPublicEvent(params.index, params.range, {
	            element: elTooltip,
	            position: position
	        }, params.silent);
	
	        this.prevIndex = params.index;
	    };
	
	    /**
	     * To call beforeShowTooltip callback of public event.
	     * @param {number} index index
	     * @param {{start: number, end: number}} range range
	     * @param {boolean} [silent] - whether invoke a public beforeHideTooltip event or not
	     * @private
	     */
	
	
	    GroupTooltip.prototype._fireBeforeShowTooltipPublicEvent = function _fireBeforeShowTooltipPublicEvent(index, range, silent) {
	        if (silent) {
	            return;
	        }
	
	        this.eventBus.fire(PUBLIC_EVENT_PREFIX + 'beforeShowTooltip', {
	            chartType: this.chartType,
	            index: index,
	            range: range
	        });
	    };
	
	    /**
	     * To call afterShowTooltip callback of public event.
	     * @param {number} index index
	     * @param {{start: number, end: number}} range range
	     * @param {object} additionParams addition parameters
	     * @param {boolean} [silent] - whether invoke a public beforeHideTooltip event or not
	     * @private
	     */
	
	
	    GroupTooltip.prototype._fireAfterShowTooltipPublicEvent = function _fireAfterShowTooltipPublicEvent(index, range, additionParams, silent) {
	        if (silent) {
	            return;
	        }
	        this.eventBus.fire(PUBLIC_EVENT_PREFIX + 'afterShowTooltip', Object.assign({
	            chartType: this.chartType,
	            index: index,
	            range: range
	        }, additionParams));
	    };
	
	    /**
	     * Hide tooltip.
	     * @param {HTMLElement} tooltipElement tooltip element
	     * @param {number} prevFoundIndex - showing tooltip index
	     * @param {object} [options] - options for hiding tooltip
	     * @private
	     */
	
	
	    GroupTooltip.prototype._hideTooltip = function _hideTooltip(tooltipElement, prevFoundIndex, options) {
	        var silent = !!(options && options.silent);
	        this.prevIndex = null;
	        this._fireBeforeHideTooltipPublicEvent(prevFoundIndex, silent);
	        this._hideTooltipSector(prevFoundIndex);
	        _domHandler2['default'].removeClass(tooltipElement, 'show');
	        tooltipElement.style.cssText = '';
	    };
	
	    /**
	     * To call beforeHideTooltip callback of public event.
	     * @param {number} index index
	     * @param {boolean} [silent] - options for hiding tooltip
	     * @private
	     */
	
	
	    GroupTooltip.prototype._fireBeforeHideTooltipPublicEvent = function _fireBeforeHideTooltipPublicEvent(index, silent) {
	        if (silent) {
	            return;
	        }
	
	        this.eventBus.fire(PUBLIC_EVENT_PREFIX + 'beforeHideTooltip', {
	            chartType: this.chartType,
	            index: index
	        });
	    };
	
	    return GroupTooltip;
	}(_tooltipBase2['default']);
	
	/**
	 * groupTooltipFactory
	 * @param {object} params chart options
	 * @returns {object} group tooltip instanse
	 * @ignore
	 */
	
	
	function groupTooltipFactory(params) {
	    return new GroupTooltip(params);
	}
	
	groupTooltipFactory.componentType = 'tooltip';
	groupTooltipFactory.GroupTooltip = GroupTooltip;

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview GroupTooltipPositionModel is position model for group tooltip..
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var GroupTooltipPositionModel = function () {
	    /**
	     * GroupTooltipPositionModel is position model for group tooltip.
	     * @constructs GroupTooltipPositionModel
	     * @private
	     * @param {{width: number, height: number}} chartDimension chart dimension
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }} areaBound tooltip area bound
	     * @param {boolean} isVertical whether vertical or not
	     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
	     */
	    function GroupTooltipPositionModel(chartDimension, areaBound, isVertical, options) {
	        _classCallCheck(this, GroupTooltipPositionModel);
	
	        /**
	         * chart dimension
	         * @type {{width: number, height: number}}
	         */
	        this.chartDimension = chartDimension;
	
	        /**
	         * tooltip area bound
	         * @type {{dimension: {width: number, height: number}, position: {left: number, top: number}}}
	         */
	        this.areaBound = areaBound;
	
	        /**
	         * Whether vertical or not
	         * @type {boolean}
	         */
	        this.isVertical = isVertical;
	
	        /**
	         * tooltip options
	         * @type {{align: ?string, position: {left: number, top: number}}}
	         */
	        this.options = options;
	
	        /**
	         * For caching
	         * @type {object}
	         */
	        this.positions = {};
	
	        this._setData(chartDimension, areaBound, isVertical, options);
	    }
	
	    /**
	     * Get horizontal direction.
	     * @param {?string} alignOption align option
	     * @returns {string} direction
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._getHorizontalDirection = function _getHorizontalDirection() {
	        var alignOption = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	
	        var direction = void 0;
	
	        if (alignOption.indexOf('left') > -1) {
	            direction = _const2['default'].TOOLTIP_DIRECTION_BACKWARD;
	        } else if (alignOption.indexOf('center') > -1) {
	            direction = _const2['default'].TOOLTIP_DIRECTION_CENTER;
	        } else {
	            direction = _const2['default'].TOOLTIP_DIRECTION_FORWARD;
	        }
	
	        return direction;
	    };
	
	    /**
	     * Make vertical data.
	     * @param {{width: number, height: number}} chartDimension chart dimension
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }} areaBound tooltip area bound
	     * @param {?string} alignOption align option
	     * @returns {{
	     *      positionType: string, sizeType: string, direction: (string),
	     *      areaPosition: number, areaSize: number, chartSize: number,
	     *      basePosition: (number)
	     * }} vertical data
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._makeVerticalData = function _makeVerticalData(chartDimension, areaBound, alignOption) {
	        var hDirection = this._getHorizontalDirection(alignOption);
	
	        return {
	            positionType: 'left',
	            sizeType: 'width',
	            direction: hDirection,
	            areaPosition: areaBound.position.left,
	            areaSize: areaBound.dimension.width,
	            chartSize: chartDimension.width,
	            basePosition: _const2['default'].SERIES_EXPAND_SIZE
	        };
	    };
	
	    /**
	     * Get vertical direction.
	     * @param {?string} alignOption align option
	     * @returns {string} direction
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._getVerticalDirection = function _getVerticalDirection(alignOption) {
	        var direction = void 0;
	
	        alignOption = alignOption || '';
	
	        if (alignOption.indexOf('top') > -1) {
	            direction = _const2['default'].TOOLTIP_DIRECTION_BACKWARD;
	        } else if (alignOption.indexOf('bottom') > -1) {
	            direction = _const2['default'].TOOLTIP_DIRECTION_FORWARD;
	        } else {
	            direction = _const2['default'].TOOLTIP_DIRECTION_CENTER;
	        }
	
	        return direction;
	    };
	
	    /**
	     * Make horizontal data.
	     * @param {{width: number, height: number}} chartDimension chart dimension
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }} areaBound tooltip area bound
	     * @param {?string} alignOption align option
	     * @returns {{
	     *      positionType: string, sizeType: string, direction: (string),
	     *      areaPosition: number, areaSize: number, chartSize: number,
	     *      basePosition: (number)
	     * }} horizontal data
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._makeHorizontalData = function _makeHorizontalData(chartDimension, areaBound, alignOption) {
	        var vDirection = this._getVerticalDirection(alignOption);
	
	        return {
	            positionType: 'top',
	            sizeType: 'height',
	            direction: vDirection,
	            areaPosition: areaBound.position.top,
	            areaSize: areaBound.dimension.height,
	            chartSize: chartDimension.height,
	            basePosition: _const2['default'].SERIES_EXPAND_SIZE
	        };
	    };
	
	    /**
	     * Set data.
	     * @param {{width: number, height: number}} chartDimension chart dimension
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }} areaBound tooltip area bound
	     * @param {boolean} isVertical whether vertical or not
	     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._setData = function _setData(chartDimension, areaBound, isVertical, options) {
	        var verticalData = this._makeVerticalData(chartDimension, areaBound, options.align);
	        var horizontalData = this._makeHorizontalData(chartDimension, areaBound, options.align);
	        var offset = options.offset || {};
	
	        if (isVertical) {
	            this.mainData = verticalData;
	            this.subData = horizontalData;
	        } else {
	            this.mainData = horizontalData;
	            this.subData = verticalData;
	        }
	
	        this.positionOption = {};
	        this.positionOption.left = offset.x || 0;
	        this.positionOption.top = offset.y || 0;
	
	        this.positions = {};
	    };
	
	    /**
	     * Calculate main position value.
	     * @param {number} tooltipSize tooltip size (width or height)
	     * @param {{start: number, end: number}} range range
	     * @param {object} data data
	     *      @param {string} data.direction direction
	     *      @param {number} data.basePosition basePosition
	     * @returns {number} position value
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._calculateMainPositionValue = function _calculateMainPositionValue(tooltipSize, range, data) {
	        var isLine = range.start === range.end;
	        var lineTypePadding = 9;
	        var otherTypePadding = 5;
	        var padding = isLine ? lineTypePadding : otherTypePadding;
	        var value = data.basePosition;
	
	        if (data.direction === _const2['default'].TOOLTIP_DIRECTION_FORWARD) {
	            value += range.end + padding;
	        } else if (data.direction === _const2['default'].TOOLTIP_DIRECTION_BACKWARD) {
	            value += range.start - tooltipSize - padding;
	        } else if (isLine) {
	            value += range.start - tooltipSize / 2;
	        } else {
	            value += range.start + (range.end - range.start - tooltipSize) / 2;
	        }
	
	        return value;
	    };
	
	    /**
	     * Calculate sub position value.
	     * @param {number} tooltipSize tooltip size (width or height)
	     * @param {object} data data
	     *      @param {number} data.areaSize tooltip area size (width or height)
	     *      @param {string} data.direction direction
	     *      @param {number} data.basePosition basePosition
	     * @returns {number} position value
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._calculateSubPositionValue = function _calculateSubPositionValue(tooltipSize, data) {
	        var middle = data.areaSize / 2;
	        var value = void 0;
	
	        if (data.direction === _const2['default'].TOOLTIP_DIRECTION_FORWARD) {
	            value = middle + data.basePosition;
	        } else if (data.direction === _const2['default'].TOOLTIP_DIRECTION_BACKWARD) {
	            value = middle - tooltipSize + data.basePosition;
	        } else {
	            value = middle - tooltipSize / 2 + data.basePosition;
	        }
	
	        return value;
	    };
	
	    /**
	     * Make position value diff.
	     * @param {number} value positoin value
	     * @param {number} tooltipSize tooltip size (width or height)
	     * @param {object} data data
	     *      @param {number} data.chartSize chart size (width or height)
	     *      @param {number} data.areaPosition tooltip area position (left or top)
	     * @returns {number} diff
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._makePositionValueDiff = function _makePositionValueDiff(value, tooltipSize, data) {
	        return value + data.areaPosition + tooltipSize - data.chartSize;
	    };
	
	    /**
	     * Adjust backward position value.
	     * @param {number} value position value
	     * @param {{start: number, end: number}} range range
	     * @param {number} tooltipSize tooltip size (width or height)
	     * @param {object} data data
	     *      @param {number} data.chartSize chart size (width or height)
	     *      @param {number} data.areaPosition tooltip area position (left or top)
	     *      @param {number} data.basePosition basePosition
	     * @returns {number} position value
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._adjustBackwardPositionValue = function _adjustBackwardPositionValue(value, range, tooltipSize, data) {
	        var changedValue = void 0;
	
	        if (value < -data.areaPosition) {
	            changedValue = this._calculateMainPositionValue(tooltipSize, range, {
	                direction: _const2['default'].TOOLTIP_DIRECTION_FORWARD,
	                basePosition: data.basePosition
	            });
	            if (this._makePositionValueDiff(changedValue, tooltipSize, data) > 0) {
	                value = -data.areaPosition;
	            } else {
	                value = changedValue;
	            }
	        }
	
	        return value;
	    };
	
	    /**
	     * Adjust forward position value.
	     * @param {number} value position value
	     * @param {{start: number, end: number}} range range
	     * @param {number} tooltipSize tooltip size (width or height)
	     * @param {object} data data
	     *      @param {number} data.chartSize chart size (width or height)
	     *      @param {number} data.areaPosition tooltip area position (left or top)
	     *      @param {number} data.basePosition basePosition
	     * @returns {number} position value
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._adjustForwardPositionValue = function _adjustForwardPositionValue(value, range, tooltipSize, data) {
	        var diff = this._makePositionValueDiff(value, tooltipSize, data);
	
	        if (diff > 0) {
	            var changedValue = this._calculateMainPositionValue(tooltipSize, range, {
	                direction: _const2['default'].TOOLTIP_DIRECTION_BACKWARD,
	                basePosition: data.basePosition
	            });
	            if (changedValue < -data.areaPosition) {
	                value -= diff;
	            } else {
	                value = changedValue;
	            }
	        }
	
	        return value;
	    };
	
	    /**
	     * Adjust main position value
	     * @param {number} value position value
	     * @param {{start: number, end: number}} range range
	     * @param {number} tooltipSize tooltip size (width or height)
	     * @param {object} data data
	     *      @param {number} data.chartSize chart size (width or height)
	     *      @param {number} data.areaPosition tooltip area position (left or top)
	     * @returns {number} position value
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._adjustMainPositionValue = function _adjustMainPositionValue(value, range, tooltipSize, data) {
	        if (data.direction === _const2['default'].TOOLTIP_DIRECTION_BACKWARD) {
	            value = this._adjustBackwardPositionValue(value, range, tooltipSize, data);
	        } else if (data.direction === _const2['default'].TOOLTIP_DIRECTION_FORWARD) {
	            value = this._adjustForwardPositionValue(value, range, tooltipSize, data);
	        } else {
	            value = Math.max(value, -data.areaPosition);
	            value = Math.min(value, data.chartSize - data.areaPosition - tooltipSize);
	        }
	
	        return value;
	    };
	
	    /**
	     * Adjust sub position value.
	     * @param {number} value position value
	     * @param {number} tooltipSize tooltip size (width or height)
	     * @param {object} data data
	     *      @param {number} data.chartSize chart size (width or height)
	     *      @param {number} data.areaPosition tooltip area position (left or top)
	     *      @param {number} data.basePosition basePosition
	     * @returns {number} position value
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._adjustSubPositionValue = function _adjustSubPositionValue(value, tooltipSize, data) {
	        if (data.direction === _const2['default'].TOOLTIP_DIRECTION_FORWARD) {
	            value = Math.min(value, data.chartSize - data.areaPosition - tooltipSize);
	        } else {
	            value = Math.max(value, -data.areaPosition);
	        }
	
	        return value;
	    };
	
	    /**
	     * Make caching key.
	     * @param {{start: number, end: number}} range range
	     * @returns {string} key
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._makeCachingKey = function _makeCachingKey(_ref) {
	        var start = _ref.start,
	            end = _ref.end;
	
	        return start + '-' + end;
	    };
	
	    /**
	     * Add position option.
	     * @param {number} position position
	     * @param {string} positionType position type (left or top)
	     * @returns {number} position
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._addPositionOptionValue = function _addPositionOptionValue(position, positionType) {
	        return position + this.positionOption[positionType];
	    };
	
	    /**
	     * Make main position value.
	     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
	     * @param {{start: number, end: number}} range tooltip sector range
	     * @param {{
	     *      positionType: string, sizeType: string, direction: (string),
	     *      areaPosition: number, areaSize: number, chartSize: number,
	     *      basePosition: (number)
	     * }} main main data
	     * @returns {number} position value
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._makeMainPositionValue = function _makeMainPositionValue(tooltipDimension, range, main) {
	        var value = this._calculateMainPositionValue(tooltipDimension[main.sizeType], range, main);
	        value = this._addPositionOptionValue(value, main.positionType);
	        value = this._adjustMainPositionValue(value, range, tooltipDimension[main.sizeType], main);
	
	        return value;
	    };
	
	    /**
	     * Make sub position value.
	     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
	     * @param {{
	     *      positionType: string, sizeType: string, direction: (string),
	     *      areaPosition: number, areaSize: number, chartSize: number,
	     *      basePosition: (number)
	     * }} sub sub data
	     * @returns {number} position value
	     * @private
	     */
	
	
	    GroupTooltipPositionModel.prototype._makeSubPositionValue = function _makeSubPositionValue(tooltipDimension, sub) {
	        var value = this._calculateSubPositionValue(tooltipDimension[sub.sizeType], sub);
	        value = this._addPositionOptionValue(value, sub.positionType);
	        value = this._adjustSubPositionValue(value, tooltipDimension[sub.sizeType], sub);
	
	        return value;
	    };
	
	    /**
	     * Calculate group tooltip position.
	     * @param {{width: number, height: number}} tooltipDimension tooltip dimension
	     * @param {{start: number, end: number}} range tooltip sector range
	     * @returns {{left: number, top: number}} group tooltip position
	     */
	
	
	    GroupTooltipPositionModel.prototype.calculatePosition = function calculatePosition(tooltipDimension, range) {
	        var key = this._makeCachingKey(range);
	        var main = this.mainData;
	        var sub = this.subData;
	        var position = this.positions[key];
	
	        if (!position) {
	            position = {};
	            position[main.positionType] = this._makeMainPositionValue(tooltipDimension, range, main);
	            position[sub.positionType] = this._makeSubPositionValue(tooltipDimension, sub);
	            this.positions[key] = position;
	        }
	
	        return position;
	    };
	
	    /**
	     * Update tooltip options for position calculation.
	     * @param {{align: ?string, position: {left: number, top: number}}} options tooltip options
	     */
	
	
	    GroupTooltipPositionModel.prototype.updateOptions = function updateOptions(options) {
	        this.options = options;
	        this._setData(this.chartDimension, this.areaBound, this.isVertical, options);
	    };
	
	    /**
	     * Update tooltip bound for position calculation.
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }} bound tooltip area bound
	     */
	
	
	    GroupTooltipPositionModel.prototype.updateBound = function updateBound(bound) {
	        this.areaBound = bound;
	        this._setData(this.chartDimension, bound, this.isVertical, this.options);
	    };
	
	    return GroupTooltipPositionModel;
	}();
	
	exports['default'] = GroupTooltipPositionModel;

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = mapChartTooltipFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _tooltipBase = __webpack_require__(389);
	
	var _tooltipBase2 = _interopRequireDefault(_tooltipBase);
	
	var _singleTooltipMixer = __webpack_require__(390);
	
	var _singleTooltipMixer2 = _interopRequireDefault(_singleTooltipMixer);
	
	var _tooltipTemplate = __webpack_require__(391);
	
	var _tooltipTemplate2 = _interopRequireDefault(_tooltipTemplate);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Tooltip component for map chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/**
	 * @classdesc MapChartTooltip component.
	 * @class MapChartTooltip
	 * @private
	 */
	var MapChartTooltip = function (_TooltipBase) {
	  _inherits(MapChartTooltip, _TooltipBase);
	
	  /**
	   * Map chart tooltip component.
	   * @constructs MapChartTooltip
	   * @private
	   * @override
	   */
	  function MapChartTooltip(params) {
	    _classCallCheck(this, MapChartTooltip);
	
	    /**
	     * Map model
	     * @type {MapChartMapModel}
	     */
	    var _this = _possibleConstructorReturn(this, _TooltipBase.call(this, params));
	
	    _this.mapModel = params.mapModel;
	
	    /**
	     * Color spectrum
	     * @type {ColorSpectrum}
	     */
	    _this.colorSpectrum = params.colorSpectrum;
	    return _this;
	  }
	
	  /**
	   * Make tooltip html.
	   * @param {{name: string, value: number}} datum tooltip datum
	   * @returns {string} tooltip html
	   * @private
	   */
	
	
	  MapChartTooltip.prototype._makeTooltipHtml = function _makeTooltipHtml(datum) {
	    return _tooltipTemplate2['default'].tplMapChartDefault(datum);
	  };
	
	  /**
	   * Make single tooltip html.
	   * @param {string} chartType chart type
	   * @param {{groupIndex: number, index: number}} indexes indexes
	   * @returns {string} tooltip html
	   * @private
	   */
	
	
	  MapChartTooltip.prototype._makeSingleTooltipHtml = function _makeSingleTooltipHtml(chartType, indexes) {
	    var datum = this.mapModel.getDatum(indexes.index);
	    var suffix = this.options.suffix ? ' ' + this.options.suffix : '';
	
	    return this.templateFunc({
	      name: datum.name || datum.code,
	      value: datum.label,
	      suffix: suffix,
	      cssText: 'background-color: ' + this.colorSpectrum.getColor(datum.ratio)
	    });
	  };
	
	  /**
	   * Make parameters for show tooltip user event.
	   * @param {{groupIndex: number, index: number}} indexes indexes
	   * @param {object} additionParams addition parameters
	   * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} parameters for show tooltip
	   * @private
	   */
	
	
	  MapChartTooltip.prototype._makeShowTooltipParams = function _makeShowTooltipParams(indexes, additionParams) {
	    var datum = this.mapModel.getDatum(indexes.index);
	    var params = _tuiCodeSnippet2['default'].extend({
	      chartType: this.chartType,
	      code: datum.code,
	      name: datum.name,
	      value: datum.label,
	      index: indexes.index
	    }, additionParams);
	
	    return params;
	  };
	
	  /**
	   * Set default align option of tooltip.
	   * @private
	   * @override
	   */
	
	
	  MapChartTooltip.prototype._setDefaultTooltipPositionOption = function _setDefaultTooltipPositionOption() {
	    if (!this.options.align) {
	      this.options.align = _const2['default'].TOOLTIP_DEFAULT_ALIGN_OPTION;
	    }
	  };
	
	  return MapChartTooltip;
	}(_tooltipBase2['default']);
	
	_singleTooltipMixer2['default'].mixin(MapChartTooltip);
	
	/**
	 * mapChartTooltipFactory
	 * @param {object} params chart options
	 * @returns {object} mapChart tooptip instanse
	 * @ignore
	 */
	function mapChartTooltipFactory(params) {
	  return new MapChartTooltip(params);
	}
	
	mapChartTooltipFactory.componentType = 'tooltip';

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = mapChartEventDetectorFactory;
	
	var _mouseEventDetectorBase = __webpack_require__(397);
	
	var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _eventListener = __webpack_require__(382);
	
	var _eventListener2 = _interopRequireDefault(_eventListener);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview MapChartEventDetector is mouse event detector for map chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var MapChartEventDetector = function (_MouseEventDetectorBa) {
	    _inherits(MapChartEventDetector, _MouseEventDetectorBa);
	
	    /**
	     * MapChartEventDetector is mouse event detector for map chart.
	     * @param {object} params parameters
	     *      @param {string} params.chartType - chart type
	     * @constructs MapChartEventDetector
	     * @private
	     * @extends MouseEventDetectorBase
	     */
	    function MapChartEventDetector(params) {
	        _classCallCheck(this, MapChartEventDetector);
	
	        /**
	         * chart type
	         * {string}
	         *
	         */
	        var _this = _possibleConstructorReturn(this, _MouseEventDetectorBa.call(this));
	
	        _this.chartType = params.chartType;
	
	        /**
	         * event bus for transmitting message
	         * @type {object}
	         */
	        _this.eventBus = params.eventBus;
	
	        /**
	         * whether mouse down or not
	         * @type {boolean}
	         */
	        _this.isDown = false;
	
	        _this.drawingType = _const2['default'].COMPONENT_TYPE_DOM;
	        return _this;
	    }
	
	    /**
	     * Render event handle layer area
	     * @param {HTMLElement} mouseEventDetectorContainer mouse event detector container element
	     * @private
	     */
	
	
	    MapChartEventDetector.prototype._renderMouseEventDetectorArea = function _renderMouseEventDetectorArea(mouseEventDetectorContainer) {
	        _renderUtil2['default'].renderDimension(mouseEventDetectorContainer, this.layout.dimension);
	        _renderUtil2['default'].renderPosition(mouseEventDetectorContainer, this.layout.position);
	    };
	
	    /**
	     * On click.
	     * @private
	     * @override
	     */
	
	
	    MapChartEventDetector.prototype._onClick = function _onClick() {};
	
	    /**
	     * Call 'dragStartMapSeries' event, when occur mouse down event.
	     * @param {mouseevent} e mouse event
	     * @private
	     * @override
	     */
	
	
	    MapChartEventDetector.prototype._onMousedown = function _onMousedown(e) {
	        this.isDown = true;
	        this.eventBus.fire('dragStartMapSeries', {
	            left: e.clientX,
	            top: e.clientY
	        });
	    };
	
	    /**
	     * Drag end.
	     * @private
	     */
	
	
	    MapChartEventDetector.prototype._dragEnd = function _dragEnd() {
	        this.isDrag = false;
	        _domHandler2['default'].removeClass(this.mouseEventDetectorContainer, 'drag');
	        this.eventBus.fire('dragEndMapSeries');
	    };
	
	    /**
	     * If drag, call dragEnd function.
	     * But if not drag, occur click event.
	     * @param {mouseevent} e mouse event
	     * @private
	     * @override
	     */
	
	
	    MapChartEventDetector.prototype._onMouseup = function _onMouseup(e) {
	        this.isDown = false;
	
	        if (this.isDrag) {
	            this._dragEnd();
	        } else {
	            this._onMouseEvent('click', e);
	        }
	
	        this.isMove = false;
	    };
	
	    /**
	     * If mouse downed, set drag mode.
	     * But if not downed, set move mode.
	     * @param {mouseevent} e mouse event
	     * @private
	     * @override
	     */
	
	
	    MapChartEventDetector.prototype._onMousemove = function _onMousemove(e) {
	        if (this.isDown) {
	            if (!this.isDrag) {
	                _domHandler2['default'].addClass(this.mouseEventDetectorContainer, 'drag');
	            }
	            this.isDrag = true;
	            this.eventBus.fire('dragMapSeries', {
	                left: e.clientX,
	                top: e.clientY
	            });
	        } else {
	            this.isMove = true;
	            this._onMouseEvent('move', e);
	        }
	    };
	
	    /**
	     * If drag mode, call dragEnd.
	     * But if not drag mode, occur move event.
	     * @private
	     * @override
	     */
	
	
	    MapChartEventDetector.prototype._onMouseout = function _onMouseout(e) {
	        if (this.isDrag) {
	            this._dragEnd();
	        } else {
	            this._onMouseEvent('move', e);
	        }
	        this.isDown = false;
	    };
	
	    /**
	     * On mouse wheel.
	     * @param {mouseevent} e mouse event
	     * @returns {?boolean}
	     * @private
	     */
	
	
	    MapChartEventDetector.prototype._onMousewheel = function _onMousewheel(e) {
	        var wheelDelta = e.wheelDelta || e.detail * _const2['default'].FF_WHEELDELTA_ADJUSTING_VALUE;
	
	        this.eventBus.fire('wheel', wheelDelta, {
	            left: e.clientX,
	            top: e.clientY
	        });
	
	        if (e.preventDefault) {
	            e.preventDefault();
	        }
	
	        return false;
	    };
	
	    /**
	     * Attach event.
	     * @param {HTMLElement} target target element
	     * @override
	     */
	
	
	    MapChartEventDetector.prototype.attachEvent = function attachEvent(target) {
	        _mouseEventDetectorBase2['default'].prototype.attachEvent.call(this, target);
	
	        if (_tuiCodeSnippet2['default'].browser.firefox) {
	            _eventListener2['default'].on(target, 'DOMMouseScroll', this._onMousewheel, this);
	        } else {
	            _eventListener2['default'].on(target, 'mousewheel', this._onMousewheel, this);
	        }
	    };
	
	    return MapChartEventDetector;
	}(_mouseEventDetectorBase2['default']);
	
	/**
	 * mapChartEventDetectorFactory
	 * @param {object} params chart options
	 * @returns {object} map chart event detector instanse
	 * @ignore
	 */
	
	
	function mapChartEventDetectorFactory(params) {
	    return new MapChartEventDetector(params);
	}
	
	mapChartEventDetectorFactory.componentType = 'mouseEventDetector';

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tickBaseCoordinateModel = __webpack_require__(398);
	
	var _tickBaseCoordinateModel2 = _interopRequireDefault(_tickBaseCoordinateModel);
	
	var _boundsBaseCoordinateModel = __webpack_require__(399);
	
	var _boundsBaseCoordinateModel2 = _interopRequireDefault(_boundsBaseCoordinateModel);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _eventListener = __webpack_require__(382);
	
	var _eventListener2 = _interopRequireDefault(_eventListener);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview MouseEventDetectorBase is base class for mouse event detector components.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var MouseEventDetectorBase = function () {
	    /**
	     * MouseEventDetectorBase is base class for mouse event detector components.
	     * @constructs MouseEventDetectorBase
	     * @private
	     * @param {object} params parameters
	     *      @param {string} params.chartType - chart type
	     *      @param {Array.<string>} params.chartTypes - chart types
	     *      @param {boolean} params.isVertical - whether vertical or not
	     *      @param {DataProcessor} params.dataProcessor - DataProcessor instance
	     *      @param {boolean} params.allowSelect - whether has allowSelect option or not
	     */
	    function MouseEventDetectorBase(params) {
	        _classCallCheck(this, MouseEventDetectorBase);
	
	        if (!params) {
	            return;
	        }
	
	        /**
	         * type of chart
	         * @type {string}
	         */
	        this.chartType = params.chartType;
	
	        /**
	         * chartTypes is available in combo chart
	         * @type {Array.<string>}
	         */
	        this.chartTypes = params.chartTypes;
	
	        /**
	         * whether vertical or not
	         * @type {boolean}
	         */
	        this.isVertical = params.isVertical;
	
	        /**
	         * data processor
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = params.dataProcessor;
	
	        /**
	         * whether allow select series or not
	         * @type {boolean}
	         */
	        this.allowSelect = params.allowSelect;
	
	        /**
	         * event bus for transmitting message
	         * @type {object}
	         */
	        this.eventBus = params.eventBus;
	
	        /**
	         * layout bounds information for this components
	         * @type {null|{dimension:{width:number, height:number}, position:{left:number, top:number}}}
	         */
	        this.layout = null;
	
	        /**
	         * selected series item.
	         * @type {null | object}
	         */
	        this.selectedData = null;
	
	        var isLineTypeChart = _predicate2['default'].isLineTypeChart(this.chartType, this.chartTypes);
	        /**
	         * expand size
	         * @type {number}
	         */
	        this.expandSize = isLineTypeChart ? _const2['default'].SERIES_EXPAND_SIZE : 0;
	
	        /**
	         * series item bounds data
	         * @type {Array}
	         */
	        this.seriesItemBoundsData = [];
	
	        /**
	         * series count
	         * @type {number}
	         */
	        this.seriesCount = _predicate2['default'].isComboChart(this.chartType) ? 2 : 1;
	
	        this._attachToEventBus();
	
	        this.drawingType = _const2['default'].COMPONENT_TYPE_DOM;
	    }
	
	    /**
	     * Attach to event bus.
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._attachToEventBus = function _attachToEventBus() {
	        this.eventBus.on('receiveSeriesData', this.onReceiveSeriesData, this);
	    };
	
	    /**
	     * Get bound for rendering.
	     * @returns {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }}
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._getRenderingBound = function _getRenderingBound() {
	        var renderingBound = _renderUtil2['default'].expandBound(this.layout);
	
	        return renderingBound;
	    };
	
	    /**
	     * Render event handle layer area.
	     * @param {HTMLElement} mouseEventDetectorContainer - container element for mouse event detector
	     * @param {number} tickCount - tick count
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._renderMouseEventDetectorArea = function _renderMouseEventDetectorArea(mouseEventDetectorContainer, tickCount) {
	        this.dimension = this.layout.dimension;
	
	
	        var tbcm = new _tickBaseCoordinateModel2['default'](this.layout, tickCount, this.chartType, this.isVertical, this.chartTypes);
	        this.tickBaseCoordinateModel = tbcm;
	
	        var _getRenderingBound2 = this._getRenderingBound(),
	            dimension = _getRenderingBound2.dimension,
	            position = _getRenderingBound2.position;
	
	        _renderUtil2['default'].renderDimension(mouseEventDetectorContainer, dimension);
	        _renderUtil2['default'].renderPosition(mouseEventDetectorContainer, position);
	    };
	
	    /**
	     * Set data for rendering.
	     * @param {{
	     *      layout: {
	     *          dimension: {width: number, height: number},
	     *          position: {left: number, top: number}
	     *      }
	     * }} data - bounds data
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._setDataForRendering = function _setDataForRendering(data) {
	        this.layout = data.layout;
	    };
	
	    /**
	     * Pick tick count.
	     * @param {{xAxis: object, yAxis: object}} axisDataMap - axis data map
	     * @returns {number}
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._pickTickCount = function _pickTickCount(axisDataMap) {
	        if (this.isVertical) {
	            return axisDataMap.xAxis.eventTickCount || axisDataMap.xAxis.tickCount;
	        }
	
	        return axisDataMap.yAxis.tickCount;
	    };
	
	    /**
	     * Render for mouseEventDetector component.
	     * @param {object} data - bounds data and tick count
	     * @returns {HTMLElement} container for mouse event detector
	     */
	
	
	    MouseEventDetectorBase.prototype.render = function render(data) {
	        this.positionMap = data.positionMap;
	        var container = data.paper;
	        var tickCount = void 0;
	
	        _domHandler2['default'].addClass(container, 'tui-chart-series-custom-event-area');
	        container.style.backgroundColor = 'aliceblue';
	
	        if (data.axisDataMap.xAxis) {
	            tickCount = this._pickTickCount(data.axisDataMap);
	        }
	
	        this._setDataForRendering(data);
	        this._renderMouseEventDetectorArea(container, tickCount);
	        this.attachEvent(container);
	        this.mouseEventDetectorContainer = container;
	
	        this.transparentChild = this._createTransparentChild();
	        _domHandler2['default'].append(container, this.transparentChild);
	
	        return container;
	    };
	
	    /**
	     * Create a transparent element
	     * @param {string} height - value of css heigth property
	     * @returns {HTMLElement} transparent element
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._createTransparentChild = function _createTransparentChild() {
	        var child = document.createElement('DIV');
	        var style = child.style;
	
	
	        style.backgroundColor = '#fff';
	        style.height = _renderUtil2['default'].getStyle(this.mouseEventDetectorContainer).height;
	        _renderUtil2['default'].setOpacity(child, 0);
	
	        return child;
	    };
	
	    /**
	     * Calculate layer position by client position.
	     * @param {number} clientX - clientX
	     * @param {number} [clientY] - clientY
	     * @param {boolean} [checkLimit] - whether check limit or not
	     * @returns {{x: number, y: ?number}}
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._calculateLayerPosition = function _calculateLayerPosition(clientX, clientY, checkLimit) {
	        var _mouseEventDetectorCo = this.mouseEventDetectorContainer.getBoundingClientRect(),
	            left = _mouseEventDetectorCo.left,
	            right = _mouseEventDetectorCo.right,
	            top = _mouseEventDetectorCo.top;
	
	        var seriesPosition = this.positionMap.series;
	        var expandSize = this.expandSize;
	
	        var layerPosition = {};
	
	        checkLimit = _tuiCodeSnippet2['default'].isUndefined(checkLimit) ? true : checkLimit;
	
	        if (checkLimit) {
	            var maxLeft = right - expandSize;
	            var minLeft = left + expandSize;
	            clientX = Math.min(Math.max(clientX, minLeft), maxLeft);
	        }
	
	        layerPosition.x = clientX - left + seriesPosition.left - _const2['default'].CHART_PADDING;
	
	        if (!_tuiCodeSnippet2['default'].isUndefined(clientY)) {
	            layerPosition.y = clientY - top + seriesPosition.top - _const2['default'].CHART_PADDING;
	        }
	
	        return layerPosition;
	    };
	
	    /**
	     * Create BoundsBaseCoordinateModel from seriesItemBoundsData for mouse event detector.
	     * @param {{chartType: string, data: object}} seriesItemBoundsDatum - series item bounds datum
	     */
	
	
	    MouseEventDetectorBase.prototype.onReceiveSeriesData = function onReceiveSeriesData(seriesItemBoundsDatum) {
	        var seriesCount = this.seriesCount;
	        var seriesItemBoundsData = this.seriesItemBoundsData;
	
	
	        if (seriesItemBoundsData.length === seriesCount) {
	            seriesItemBoundsData = [];
	        }
	
	        seriesItemBoundsData.push(seriesItemBoundsDatum);
	
	        if (seriesItemBoundsData.length === seriesCount) {
	            this.boundsBaseCoordinateModel = new _boundsBaseCoordinateModel2['default'](seriesItemBoundsData);
	        }
	    };
	
	    /**
	     * Rerender mouse event detector component.
	     * @param {object} data - bounds data and tick count
	     */
	
	
	    MouseEventDetectorBase.prototype.rerender = function rerender(data) {
	        var tickCount = void 0;
	
	        this.positionMap = data.positionMap;
	
	        if (data.axisDataMap.xAxis) {
	            tickCount = this._pickTickCount(data.axisDataMap);
	        }
	
	        this.selectedData = null;
	        this._setDataForRendering(data);
	        this._renderMouseEventDetectorArea(this.mouseEventDetectorContainer, tickCount);
	
	        this.transparentChild.style.height = _renderUtil2['default'].getStyle(this.mouseEventDetectorContainer).height;
	    };
	
	    /**
	     * Rerender, when resizing chart.
	     * @param {object} data - bounds data and tick count
	     */
	
	
	    MouseEventDetectorBase.prototype.resize = function resize(data) {
	        this.containerBound = null;
	        this.rerender(data);
	    };
	
	    /**
	     * Whether changed select data or not.
	     * @param {object} prev - previous data
	     * @param {object} cur - current data
	     * @returns {boolean}
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._isChangedSelectData = function _isChangedSelectData(prev, cur) {
	        return !prev || !cur || prev.chartType !== cur.chartType || prev.indexes.groupIndex !== cur.indexes.groupIndex || prev.indexes.index !== cur.indexes.index;
	    };
	
	    /**
	     * Find coordinate data from boundsCoordinateModel.
	     * @param {{x: number, y: number}} layerPosition - layer position
	     * @returns {object}
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._findDataFromBoundsCoordinateModel = function _findDataFromBoundsCoordinateModel(layerPosition) {
	        var layerX = layerPosition.x;
	        var layerY = layerPosition.y;
	        var groupIndex = void 0;
	
	        if (_predicate2['default'].isTreemapChart(this.chartType)) {
	            groupIndex = 0;
	        } else {
	            groupIndex = this.tickBaseCoordinateModel.findIndex(this.isVertical ? layerX : layerY);
	        }
	
	        return this.boundsBaseCoordinateModel.findData(groupIndex, layerX, layerY);
	    };
	
	    /**
	     * Find data.
	     * @param {number} clientX - clientX
	     * @param {number} clientY - clientY
	     * @returns {object}
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._findData = function _findData(clientX, clientY) {
	        var layerPosition = this._calculateLayerPosition(clientX, clientY);
	
	        return this._findDataFromBoundsCoordinateModel(layerPosition);
	    };
	
	    /**
	     * Show tooltip
	     * @private
	     * @abstract
	     */
	
	
	    MouseEventDetectorBase.prototype._showTooltip = function _showTooltip() {};
	
	    /**
	     * hide tooltip
	     * @private
	     * @abstract
	     */
	
	
	    MouseEventDetectorBase.prototype._hideTooltip = function _hideTooltip() {};
	
	    /**
	     * When mouse event happens,
	     * hide MouseEventDetector container so that detect event of series elements
	     * and send mouse position data to series component
	     * @param {string} eventType - mouse event detector type
	     * @param {MouseEvent} e - mouse event
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._onMouseEvent = function _onMouseEvent(eventType, e) {
	        _domHandler2['default'].addClass(this.mouseEventDetectorContainer, 'hide');
	        this.eventBus.fire(eventType + 'Series', {
	            left: e.clientX,
	            top: e.clientY
	        });
	        _domHandler2['default'].removeClass(this.mouseEventDetectorContainer, 'hide');
	    };
	
	    /**
	     * deselect selected data.
	     * @ignore
	     */
	
	
	    MouseEventDetectorBase.prototype.unselectSeries = function unselectSeries() {
	        if (this.selectedData) {
	            this.eventBus.fire('unselectSeries', this.selectedData);
	            this.selectedData = null;
	        }
	    };
	
	    /**
	     * Call 'selectSeries' event, when changed found position data.
	     * And call 'unselectSeries' event, when not changed found position data.
	     * @param {MouseEvent} e - mouse event
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._onClick = function _onClick(e) {
	        var foundData = this._findData(e.clientX, e.clientY);
	        this.selectSeries(foundData);
	    };
	
	    /**
	     * To call selectSeries callback of public event.
	     * @TODO: Need to change the selectedData location (Not used for mouse events only)
	     * @param {object} seriesData - series data
	     * @param {?boolean} shouldSelect - whether should select or not
	     */
	
	
	    MouseEventDetectorBase.prototype.selectSeries = function selectSeries(seriesData) {
	        var shouldSelect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	        if (!this._isChangedSelectData(this.selectedData, seriesData)) {
	            this.unselectSeries();
	        } else if (seriesData) {
	            if (this.selectedData) {
	                this.unselectSeries();
	            }
	
	            this.eventBus.fire('selectSeries', seriesData, shouldSelect);
	            if (this.allowSelect) {
	                this.selectedData = seriesData;
	            }
	        }
	    };
	
	    /**
	     * On mouse down
	     * @private
	     * @abstract
	     */
	
	
	    MouseEventDetectorBase.prototype._onMousedown = function _onMousedown() {};
	
	    /**
	     * On mouse up
	     * @private
	     * @abstract
	     */
	
	
	    MouseEventDetectorBase.prototype._onMouseup = function _onMouseup() {};
	
	    /**
	     * Store client position, when occur mouse move event.
	     * @param {MouseEvent} e - mouse event
	     * @abstract
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._onMousemove = function _onMousemove() {};
	
	    /**
	     * Abstract mouseout handler
	     * @abstract
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._onMouseout = function _onMouseout() {};
	
	    /**
	     * Attach mouse event.
	     * @param {HTMLElement} target - target element
	     */
	
	
	    MouseEventDetectorBase.prototype.attachEvent = function attachEvent(target) {
	        _eventListener2['default'].on(target, {
	            click: this._onClick,
	            mousedown: this._onMousedown,
	            mouseup: this._onMouseup,
	            mousemove: this._onMousemove,
	            mouseout: this._onMouseout
	        }, this);
	    };
	
	    /**
	     * find data by indexes
	     * @abstract
	     */
	
	
	    MouseEventDetectorBase.prototype.findDataByIndexes = function findDataByIndexes() {};
	
	    /**
	     * Set prevClientPosition by MouseEvent
	     * @param {?MouseEvent} event - mouse event
	     * @private
	     */
	
	
	    MouseEventDetectorBase.prototype._setPrevClientPosition = function _setPrevClientPosition(event) {
	        if (!event) {
	            this.prevClientPosition = null;
	        } else {
	            this.prevClientPosition = {
	                x: event.clientX,
	                y: event.clientY
	            };
	        }
	    };
	
	    return MouseEventDetectorBase;
	}();
	
	_tuiCodeSnippet2['default'].CustomEvents.mixin(MouseEventDetectorBase);
	
	exports['default'] = MouseEventDetectorBase;

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview TickBaseDataModel is tick base data model.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var TickBaseDataModel = function () {
	    /**
	     * TickBaseDataModel is tick base data model.
	     * @param {{
	     *     dimension: {
	     *         width: number,
	     *         height: number
	     *     }, position: {
	     *         left: number,
	     *         top: number
	     *     }
	     * }} layout layout
	     * @param {number} tickCount tick count
	     * @param {string} chartType chart type
	     * @param {boolean} isVertical whether vertical or not
	     * @param {Array.<string>} [chartTypes] - chart types of combo chart
	     * @constructs TickBaseDataModel
	     * @private
	     */
	    function TickBaseDataModel(layout, tickCount, chartType, isVertical, chartTypes) {
	        _classCallCheck(this, TickBaseDataModel);
	
	        /**
	         * whether line type or not
	         * @type {boolean}
	         */
	        this.isLineType = _predicate2['default'].isLineTypeChart(chartType, chartTypes);
	
	        this.data = this._makeData(layout, tickCount, isVertical);
	    }
	
	    /**
	     * Get each tick ranges
	     * @param {number} tickCount tick count
	     * @param {number} firstPosition first position value
	     * @param {number} tickInterval tick distance
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    TickBaseDataModel.prototype._getRanges = function _getRanges(tickCount, firstPosition, tickInterval) {
	        var prev = firstPosition;
	        var halfInterval = tickInterval / 2;
	
	        return _tuiCodeSnippet2['default'].range(0, tickCount).map(function () {
	            var limit = {
	                min: prev - halfInterval,
	                max: prev + halfInterval
	            };
	
	            prev += tickInterval;
	
	            return limit;
	        });
	    };
	
	    /**
	     * Make tick base data about line type chart.
	     * @param {number} width width
	     * @param {number} tickCount tick count
	     * @param {number} firstPosition firstPosition of group
	     * @returns {Array} tick base data
	     * @private
	     */
	
	
	    TickBaseDataModel.prototype._makeLineTypeData = function _makeLineTypeData(width, tickCount, firstPosition) {
	        var tickInterval = (width + 1) / (tickCount - 1);
	        var ranges = this._getRanges(tickCount, firstPosition || 0, tickInterval);
	
	        ranges[tickCount - 1].max -= 1;
	
	        return ranges;
	    };
	
	    /**
	     * Make tick base data about non line type chart.
	     * @param {number} size width or height
	     * @param {number} tickCount tick count
	     * @param {number} firstPosition firstPosition of group
	     * @returns {Array} tick base data
	     * @private
	     */
	
	
	    TickBaseDataModel.prototype._makeNormalData = function _makeNormalData(size, tickCount, firstPosition) {
	        var len = tickCount - 1;
	        var tickInterval = size / len;
	        var prev = firstPosition || 0;
	
	        return _tuiCodeSnippet2['default'].range(0, len).map(function () {
	            var max = _arrayUtil2['default'].min([size + prev, tickInterval + prev]);
	            var limit = {
	                min: prev,
	                max: max
	            };
	            prev = max;
	
	            return limit;
	        });
	    };
	
	    /**
	     * Make tick base data for mouse event detector.
	     * @param {{dimension: object, position: object}} layout layout
	     * @param {number} tickCount tick count
	     * @param {boolean} isVertical whether vertical or not
	     * @returns {Array.<object>} tick base data
	     * @private
	     */
	
	
	    TickBaseDataModel.prototype._makeData = function _makeData(layout, tickCount, isVertical) {
	        var sizeType = isVertical ? 'width' : 'height';
	        var positionType = isVertical ? 'left' : 'top';
	
	        if (this.isLineType) {
	            return this._makeLineTypeData(layout.dimension[sizeType], tickCount, layout.position[positionType]);
	        }
	
	        return this._makeNormalData(layout.dimension[sizeType], tickCount, layout.position[positionType]);
	    };
	
	    /**
	     * Find index.
	     * @param {number} pointValue mouse position point value
	     * @returns {number} group index
	     */
	
	
	    TickBaseDataModel.prototype.findIndex = function findIndex(pointValue) {
	        var foundIndex = -1;
	
	        this.data.forEach(function (limit, index) {
	            if (limit.min < pointValue && limit.max >= pointValue) {
	                foundIndex = index;
	
	                return false;
	            }
	
	            return true;
	        });
	
	        return foundIndex;
	    };
	
	    /**
	     * Get last index.
	     * @returns {number}
	     */
	
	
	    TickBaseDataModel.prototype.getLastIndex = function getLastIndex() {
	        return this.data.length - 1;
	    };
	
	    /**
	     * Make range of tooltip position.
	     * @param {number} index index
	     * @param {number} positionValue positionValue
	     * @returns {{start: number, end: number}} range type value
	     * @private
	     */
	
	
	    TickBaseDataModel.prototype.makeRange = function makeRange(index, positionValue) {
	        var limit = this.data[index];
	        var range = void 0,
	            center = void 0;
	
	        if (this.isLineType) {
	            center = parseInt(limit.max - (limit.max - limit.min) / 2, 10);
	            range = {
	                start: center,
	                end: center
	            };
	        } else {
	            range = {
	                start: limit.min - (positionValue || 0),
	                end: limit.max - (positionValue || 0)
	            };
	        }
	
	        return range;
	    };
	
	    return TickBaseDataModel;
	}();
	
	exports['default'] = TickBaseDataModel;

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview BoundsBaseCoordinateModel is data model for mouse event detector of bounds type.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	/**
	 * position
	 * @typedef {{left: number, top: number}} position
	 * @private
	 */
	
	/**
	 * bound
	 * @typedef {{
	 *      dimension: {width: number, height: number},
	 *      position: position
	 *}} bound
	 * @private
	 */
	
	/**
	 * group bound
	 *  @typedef {Array.<Array.<bound>>} groupBound
	 * @private
	 */
	
	/**
	 * group position
	 *  @typedef {Array.<Array.<position>>} groupPosition
	 * @private
	 */
	
	/**
	 * series info
	 * @typedef {{
	 *      chartType: {string},
	 *      data: {
	 *          groupBounds: ?groupBound,
	 *          groupValues: ?Array.<Array.<number>>,
	 *          groupPositions: ?groupPosition
	 *      }
	 *}} seriesInfo
	 * @private
	 */
	
	var BoundsBaseCoordinateModel = function () {
	    /**
	     * BoundsBaseCoordinateModel is data mode for mouse event detector of bounds type.
	     * @constructs BoundsBaseCoordinateModel
	     * @private
	     * @param {Array} seriesItemBoundsData - series item bounds data
	     */
	    function BoundsBaseCoordinateModel(seriesItemBoundsData) {
	        _classCallCheck(this, BoundsBaseCoordinateModel);
	
	        this.data = this._makeData(seriesItemBoundsData);
	    }
	
	    /**
	     * @param {string} chartType - chart type
	     * @param {object} indexes - index of SeriesDataModel
	     * @param {boolean} allowNegativeTooltip - whether allow negative tooltip or not
	     * @param {object} bound - coordinate data for rendering graph
	     * @returns {object} - `sendData`: tooltip contents, `bound`: for detecting hovered or not
	     * @private
	     */
	
	
	    BoundsBaseCoordinateModel.prototype._makeTooltipData = function _makeTooltipData(chartType, indexes, allowNegativeTooltip, bound) {
	        return {
	            sendData: {
	                chartType: chartType,
	                indexes: indexes,
	                allowNegativeTooltip: allowNegativeTooltip,
	                bound: bound
	            },
	            bound: {
	                left: bound.left,
	                top: bound.top,
	                right: bound.left + bound.width,
	                bottom: bound.top + bound.height
	            }
	        };
	    };
	
	    /**
	     * Make position data for rect type graph
	     * @param {groupBound} groupBounds group bounds
	     * @param {string} chartType chart type
	     * @returns {Array}
	     * @private
	     */
	
	
	    BoundsBaseCoordinateModel.prototype._makeRectTypePositionData = function _makeRectTypePositionData(groupBounds, chartType) {
	        var _this = this;
	
	        var allowNegativeTooltip = !_predicate2['default'].isBoxTypeChart(chartType);
	
	        return groupBounds.map(function (bounds, groupIndex) {
	            return bounds.map(function (bound, index) {
	                if (!bound) {
	                    return null;
	                }
	
	                return _this._makeTooltipData(chartType, {
	                    groupIndex: groupIndex,
	                    index: index
	                }, allowNegativeTooltip, bound.end || bound);
	            });
	        });
	    };
	
	    /**
	     * Make position data for rect type graph
	     * @param {groupBound} groupBounds group bounds
	     * @param {string} chartType chart type
	     * @param {object} resultData resultData
	     * @private
	     */
	
	
	    BoundsBaseCoordinateModel.prototype._makeOutliersPositionDataForBoxplot = function _makeOutliersPositionDataForBoxplot(groupBounds, chartType, resultData) {
	        var _this2 = this;
	
	        var allowNegativeTooltip = !_predicate2['default'].isBoxTypeChart(chartType);
	        var _groupBounds = [].concat(_toConsumableArray(groupBounds));
	
	        _groupBounds.forEach(function (bounds, groupIndex) {
	            bounds.forEach(function (bound, index) {
	                var outliers = void 0;
	
	                if (bound.outliers && bound.outliers.length) {
	                    outliers = bound.outliers.map(function (outlier, outlierIndex) {
	                        var outlierBound = {
	                            top: outlier.top - 3,
	                            left: outlier.left - 3,
	                            width: 6,
	                            height: 6
	                        };
	
	                        return _this2._makeTooltipData(chartType, {
	                            groupIndex: groupIndex,
	                            index: index,
	                            outlierIndex: outlierIndex
	                        }, allowNegativeTooltip, outlierBound);
	                    });
	
	                    resultData[groupIndex] = resultData[groupIndex].concat(outliers);
	                }
	            });
	        });
	    };
	
	    /**
	     * Make position data for dot type graph
	     * @param {groupPositions} groupPositions group positions
	     * @param {string} chartType chart type
	     * @returns {Array.<Array.<object>>}
	     * @private
	     */
	
	
	    BoundsBaseCoordinateModel.prototype._makeDotTypePositionData = function _makeDotTypePositionData(groupPositions, chartType) {
	        if (!groupPositions) {
	            return [];
	        }
	
	        return _arrayUtil2['default'].pivot(groupPositions).map(function (positions, groupIndex) {
	            return positions.map(function (position, index) {
	                if (!position) {
	                    return null;
	                }
	
	                return {
	                    sendData: {
	                        chartType: chartType,
	                        indexes: {
	                            groupIndex: groupIndex,
	                            index: index
	                        },
	                        bound: position
	                    },
	                    bound: {
	                        left: position.left - _const2['default'].DOT_RADIUS,
	                        top: position.top - _const2['default'].DOT_RADIUS,
	                        right: position.left + _const2['default'].DOT_RADIUS,
	                        bottom: position.top + _const2['default'].DOT_RADIUS
	                    }
	                };
	            });
	        });
	    };
	
	    /**
	     * Join data.
	     * @param {Array.<Array.<Array.<object>>>} dataGroupSet data group set
	     * @returns {Array.<Array.<object>>} joined data
	     * @private
	     */
	
	
	    BoundsBaseCoordinateModel.prototype._joinData = function _joinData(dataGroupSet) {
	        var results = [];
	        dataGroupSet.forEach(function (dataGroup) {
	            dataGroup.forEach(function (data, index) {
	                var additionalIndex = void 0;
	
	                if (!results[index]) {
	                    results[index] = data;
	                } else {
	                    additionalIndex = results[index].length;
	                    data.forEach(function (datum) {
	                        if (datum) {
	                            datum.sendData.indexes.legendIndex = datum.sendData.indexes.index + additionalIndex;
	                        }
	                    });
	                    results[index] = results[index].concat(data);
	                }
	            });
	        });
	
	        return results;
	    };
	
	    /**
	     * Make data for detecting mouse event.
	     * @param {Array} seriesItemBoundsData - series item bounds data
	     * @returns {Array.<Array.<object>>} coordinate data
	     * @private
	     */
	
	
	    BoundsBaseCoordinateModel.prototype._makeData = function _makeData(seriesItemBoundsData) {
	        var _this3 = this;
	
	        var data = seriesItemBoundsData.map(function (info) {
	            var result = void 0;
	
	            if (_predicate2['default'].isLineTypeChart(info.chartType)) {
	                result = _this3._makeDotTypePositionData(info.data.groupPositions, info.chartType);
	            } else {
	                result = _this3._makeRectTypePositionData(info.data.groupBounds, info.chartType);
	            }
	
	            if (_predicate2['default'].isBoxplotChart(info.chartType)) {
	                _this3._makeOutliersPositionDataForBoxplot(info.data.groupBounds, info.chartType, result);
	            }
	
	            return result;
	        });
	
	        return this._joinData(data);
	    };
	
	    /**
	     * Find candidates.
	     * @param {{bound: {left: number, top: number, right: number, bottom: number}}} data data *
	     * @param {number} layerX layerX
	     * @param {number} layerY layerY
	     * @returns {Array.<{sendData: object}>} candidates
	     * @private
	     */
	
	
	    BoundsBaseCoordinateModel.prototype._findCandidates = function _findCandidates(data, layerX, layerY) {
	        var _this4 = this;
	
	        return data.filter(function (datum) {
	            var bound = datum && datum.bound;
	
	            if (bound) {
	                if (bound.top === bound.bottom) {
	                    bound.top -= _const2['default'].SERIES_EXTRA_EVENT_AREA_FOR_ZERO;
	                    bound.bottom += _const2['default'].SERIES_EXTRA_EVENT_AREA_FOR_ZERO;
	                }
	                if (bound.left === bound.right) {
	                    bound.left -= _const2['default'].SERIES_EXTRA_EVENT_AREA_FOR_ZERO;
	                    bound.right += _const2['default'].SERIES_EXTRA_EVENT_AREA_FOR_ZERO;
	                }
	
	                return _this4._isCandidateTarget(bound, {
	                    layerX: layerX,
	                    layerY: layerY
	                });
	            }
	
	            return false;
	        });
	    };
	
	    /**
	     * Whether candidate target.
	     * @param {{left: number, top: number, right: number, bottom: number}} bound bound info
	     * @param {object} layout layout position
	     *   @param {number} layout.layerX layerX
	     *   @param {number} layout.layerY layerY
	     * @returns {boolean} is target
	     * @private
	     */
	
	
	    BoundsBaseCoordinateModel.prototype._isCandidateTarget = function _isCandidateTarget(bound, _ref) {
	        var layerX = _ref.layerX,
	            layerY = _ref.layerY;
	
	        var includedX = bound.left <= layerX && bound.right >= layerX;
	        var includedY = bound.top <= layerY && bound.bottom >= layerY;
	
	        return includedX && includedY;
	    };
	
	    /**
	     * Find data.
	     * @param {number} groupIndex group index
	     * @param {number} layerX mouse position x
	     * @param {number} layerY mouse position y
	     * @returns {object} tooltip data
	     */
	
	
	    BoundsBaseCoordinateModel.prototype.findData = function findData(groupIndex, layerX, layerY) {
	        var min = 10000;
	        var result = null;
	
	        if (groupIndex > -1 && this.data[groupIndex]) {
	            // extract data containing layerX, layerY
	            var candidates = this._findCandidates(this.data[groupIndex], layerX, layerY);
	
	            // find nearest data to top position among extracted data
	            candidates.forEach(function (data) {
	                var diff = Math.abs(layerY - data.bound.top);
	
	                if (min > diff) {
	                    min = diff;
	                    result = data.sendData;
	                }
	            });
	        }
	
	        return result;
	    };
	
	    /**
	     * Find data by indexes.
	     * @param {{index: {number}, seriesIndex: {number}}} indexes - indexe of series item displaying a tooltip
	     * @param {number} [indexes.outlierIndex] - index of outlier of boxplot series, it only exists in boxplot chart
	     * @returns {object} tooltip data
	     */
	
	
	    BoundsBaseCoordinateModel.prototype.findDataByIndexes = function findDataByIndexes(indexes) {
	        var foundData = this.data[indexes.index][indexes.seriesIndex].sendData;
	
	        if (_tuiCodeSnippet2['default'].isNumber(indexes.outlierIndex)) {
	            return this._findOutlierDataByIndexes(indexes);
	        }
	
	        return foundData;
	    };
	
	    /**
	     * find plot chart data by indexes
	     * @param {{
	     *  index: {number},
	     *  seriesIndex: {number},
	     *  outlierIndex: {number}
	     * }} indexes - indexe of series item displaying a tooltip
	     * @returns {object} - outlier tooltip data
	     * @private
	     */
	
	
	    BoundsBaseCoordinateModel.prototype._findOutlierDataByIndexes = function _findOutlierDataByIndexes(indexes) {
	        var foundData = null;
	
	        this.data[indexes.index].forEach(function (datum) {
	            var datumIndexes = datum.sendData.indexes;
	            var found = datumIndexes.index === indexes.seriesIndex && datumIndexes.outlierIndex === indexes.outlierIndex;
	
	            if (found) {
	                foundData = datum.sendData;
	            }
	
	            return !found;
	        });
	
	        return foundData;
	    };
	
	    return BoundsBaseCoordinateModel;
	}();
	
	exports['default'] = BoundsBaseCoordinateModel;

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = mouseEventDetectorFactory;
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _areaTypeEventDetector = __webpack_require__(401);
	
	var _areaTypeEventDetector2 = _interopRequireDefault(_areaTypeEventDetector);
	
	var _simpleEventDetector = __webpack_require__(404);
	
	var _simpleEventDetector2 = _interopRequireDefault(_simpleEventDetector);
	
	var _groupTypeEventDetector = __webpack_require__(405);
	
	var _groupTypeEventDetector2 = _interopRequireDefault(_groupTypeEventDetector);
	
	var _boundsTypeEventDetector = __webpack_require__(406);
	
	var _boundsTypeEventDetector2 = _interopRequireDefault(_boundsTypeEventDetector);
	
	var _mapChartEventDetector = __webpack_require__(396);
	
	var _mapChartEventDetector2 = _interopRequireDefault(_mapChartEventDetector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Factory for MouseEventDetector
	 * @param {object} params parameter
	 * @returns {object}
	 * @ignore
	 */
	/**
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	function mouseEventDetectorFactory(params) {
	    var chartOptions = params.chartOptions,
	        seriesTypes = params.seriesTypes;
	    var chartType = chartOptions.chartType,
	        _chartOptions$series = chartOptions.series,
	        zoomable = _chartOptions$series.zoomable,
	        seriesAllowSelect = _chartOptions$series.allowSelect;
	
	    var factory = void 0;
	
	    if (params.chartOptions.tooltip.grouped) {
	        factory = _groupTypeEventDetector2['default'];
	    } else if (_predicate2['default'].isMapChart(chartType)) {
	        factory = _mapChartEventDetector2['default'];
	    } else if (_predicate2['default'].isBarTypeChart(chartType) || _predicate2['default'].isBoxplotChart(chartType) || _predicate2['default'].isHeatmapChart(chartType) || _predicate2['default'].isTreemapChart(chartType) || _predicate2['default'].isBulletChart(chartType)) {
	        factory = _boundsTypeEventDetector2['default'];
	    } else if (_predicate2['default'].isCoordinateTypeChart(chartType) || _predicate2['default'].isPieChart(chartType) || _predicate2['default'].isPieDonutComboChart(chartType, seriesTypes)) {
	        factory = _simpleEventDetector2['default'];
	    } else {
	        factory = _areaTypeEventDetector2['default'];
	    }
	
	    params.chartType = chartType;
	    // @todo replace chartType, chartTypes to seriesTypes, problem of the whole component
	    params.chartTypes = seriesTypes;
	    params.zoomable = zoomable;
	    params.allowSelect = seriesAllowSelect;
	
	    return factory(params);
	}
	
	mouseEventDetectorFactory.componentType = 'mouseEventDetector';

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = areaTypeEventDetectorFactory;
	
	var _mouseEventDetectorBase = __webpack_require__(397);
	
	var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
	
	var _zoomMixer = __webpack_require__(402);
	
	var _zoomMixer2 = _interopRequireDefault(_zoomMixer);
	
	var _areaTypeDataModel = __webpack_require__(403);
	
	var _areaTypeDataModel2 = _interopRequireDefault(_areaTypeDataModel);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview AreaTypeEventDetector is mouse event detector for line type chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	var AREA_DETECT_DISTANCE_THRESHOLD = 50;
	
	var AreaTypeEventDetector = function (_MouseEventDetectorBa) {
	    _inherits(AreaTypeEventDetector, _MouseEventDetectorBa);
	
	    /**
	     * AreaTypeEventDetector is mouse event detector for line type chart.
	     * @param {object} params parameters
	     * @constructs AreaTypeEventDetector
	     * @private
	     * @extends MouseEventDetectorBase
	     */
	    function AreaTypeEventDetector(params) {
	        _classCallCheck(this, AreaTypeEventDetector);
	
	        /**
	         * previous found data
	         * @type {null | object}
	         */
	        var _this = _possibleConstructorReturn(this, _MouseEventDetectorBa.call(this, params));
	
	        _this.prevFoundData = null;
	
	        /**
	         * previous client position of mouse event (clientX, clientY)
	         * @type {null | object}
	         */
	        _this.prevClientPosition = null;
	
	        /**
	         * whether zoomable or not
	         * @type {boolean}
	         */
	        _this.zoomable = params.zoomable;
	
	        if (_this.zoomable) {
	            _tuiCodeSnippet2['default'].extend(_this, _zoomMixer2['default']);
	            _this._initForZoom(params.zoomable);
	        }
	        return _this;
	    }
	
	    /**
	     * Animate for adding data.
	     */
	
	
	    AreaTypeEventDetector.prototype.animateForAddingData = function animateForAddingData() {
	        if (!this.prevClientPosition) {
	            return;
	        }
	
	        var foundData = this._findData(this.prevClientPosition.x, this.prevClientPosition.y);
	
	        if (foundData) {
	            var isMatchedIndex = this.prevFoundData.indexes.groupIndex === foundData.indexes.groupIndex;
	            var isMoving = this.prevFoundData && isMatchedIndex;
	            this._showTooltip(foundData, isMoving);
	        }
	
	        this.prevFoundData = foundData;
	    };
	
	    /**
	     * Create areaTypeDataModel from seriesItemBoundsData for mouse event detector.
	     * @param {Array.<object>} seriesItemBoundsDatum - series item bounds datum
	     * @override
	     */
	
	
	    AreaTypeEventDetector.prototype.onReceiveSeriesData = function onReceiveSeriesData(seriesItemBoundsDatum) {
	        var seriesCount = this.seriesCount;
	        var seriesItemBoundsData = this.seriesItemBoundsData;
	
	
	        if (seriesItemBoundsData.length === seriesCount) {
	            seriesItemBoundsData = [];
	        }
	
	        seriesItemBoundsData.push(seriesItemBoundsDatum);
	
	        if (seriesItemBoundsData.length === seriesCount) {
	            this.dataModel = new _areaTypeDataModel2['default'](seriesItemBoundsData);
	        }
	
	        if (this.zoomable) {
	            this._showTooltipAfterZoom();
	        }
	    };
	
	    /**
	     * Find data by client position.
	     * @param {number} clientX - clientX
	     * @param {number} clientY - clientY
	     * @returns {object}
	     * @private
	     * @override
	     */
	
	
	    AreaTypeEventDetector.prototype._findData = function _findData(clientX, clientY) {
	        var layerPosition = this._calculateLayerPosition(clientX, clientY);
	        var selectLegendIndex = this.dataProcessor.selectLegendIndex;
	
	        var isCoordinateTypeChart = this.dataProcessor.isCoordinateType();
	
	        return this.dataModel.findData(layerPosition, selectLegendIndex, {
	            distanceLimit: AREA_DETECT_DISTANCE_THRESHOLD,
	            isCoordinateTypeChart: isCoordinateTypeChart
	        });
	    };
	
	    /**
	     * Find data by client position for zoomable
	     * @param {number} clientX - clientX
	     * @param {number} clientY - clientY
	     * @returns {object}
	     * @private
	     */
	
	
	    AreaTypeEventDetector.prototype._findDataForZoomable = function _findDataForZoomable(clientX, clientY) {
	        var layerPosition = this._calculateLayerPosition(clientX, clientY);
	
	        return this.dataModel.findData(layerPosition);
	    };
	
	    /**
	     * Get first model data.
	     * @param {number} index - index
	     * @returns {object}
	     * @private
	     */
	
	
	    AreaTypeEventDetector.prototype._getFirstData = function _getFirstData(index) {
	        return this.dataModel.getFirstData(index);
	    };
	
	    /**
	     * Get last model data.
	     * @param {number} index - index
	     * @returns {object}
	     * @private
	     */
	
	
	    AreaTypeEventDetector.prototype._getLastData = function _getLastData(index) {
	        return this.dataModel.getLastData(index);
	    };
	
	    /**
	     * Show tooltip.
	     * @param {object} foundData - model data
	     * @private
	     */
	
	
	    AreaTypeEventDetector.prototype._showTooltip = function _showTooltip(foundData) {
	        this.eventBus.fire('showTooltip', foundData);
	        this.prevFoundData = foundData;
	    };
	
	    /**
	     * Hide tooltip.
	     * @param {{silent: {boolean}}} [options] - options for hiding tooltip
	     * @private
	     */
	
	
	    AreaTypeEventDetector.prototype._hideTooltip = function _hideTooltip(options) {
	        this.eventBus.fire('hideTooltip', this.prevFoundData, options);
	        this.prevFoundData = null;
	    };
	
	    /**
	     * On mousemove.
	     * @param {MouseEvent} e - mouse event
	     * @private
	     * @override
	     */
	
	
	    AreaTypeEventDetector.prototype._onMousemove = function _onMousemove(e) {
	        var dragMoseupResult = void 0;
	
	        this._setPrevClientPosition(e);
	        var foundData = this._findData(e.clientX, e.clientY);
	
	        if (this.zoomable) {
	            dragMoseupResult = this._isAfterDragMouseup();
	        }
	
	        if (dragMoseupResult || !this._isChangedSelectData(this.prevFoundData, foundData)) {
	            return;
	        }
	
	        if (foundData) {
	            this._showTooltip(foundData);
	        } else if (this.prevFoundData) {
	            this._hideTooltip();
	        }
	
	        this.prevFoundData = foundData;
	    };
	
	    /**
	     * On mouseout.
	     * @private
	     * @override
	     */
	
	
	    AreaTypeEventDetector.prototype._onMouseout = function _onMouseout() {
	        if (this.prevFoundData) {
	            this._hideTooltip();
	        }
	
	        this.prevClientPosition = null;
	        this.prevFoundData = null;
	    };
	
	    /**
	     * find data by indexes
	     * @param {{index: {number}, seriesIndex: {number}}} indexes - indexe of series item displaying a tooltip
	     * @returns {object} - series item data
	     */
	
	
	    AreaTypeEventDetector.prototype.findDataByIndexes = function findDataByIndexes(indexes) {
	        return this.dataModel.findDataByIndexes(indexes);
	    };
	
	    /**
	     * Set prevClientPosition by MouseEvent
	     * @param {?MouseEvent} event - mouse event
	     * @private
	     */
	
	
	    AreaTypeEventDetector.prototype._setPrevClientPosition = function _setPrevClientPosition(event) {
	        if (!event) {
	            this.prevClientPosition = null;
	        } else {
	            this.prevClientPosition = {
	                x: event.clientX,
	                y: event.clientY
	            };
	        }
	    };
	
	    return AreaTypeEventDetector;
	}(_mouseEventDetectorBase2['default']);
	
	/**
	 * areaTypeEventDetectorFactory
	 * @param {object} params chart options
	 * @returns {object} areatype event detector instanse
	 * @ignore
	 */
	
	
	function areaTypeEventDetectorFactory(params) {
	    return new AreaTypeEventDetector(params);
	}
	
	areaTypeEventDetectorFactory.componentType = 'mouseEventDetector';

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @fileoverview  Mixer for zoom event of area type mouse event detector.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
	
	
	var _mouseEventDetectorBase = __webpack_require__(397);
	
	var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _eventListener = __webpack_require__(382);
	
	var _eventListener2 = _interopRequireDefault(_eventListener);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Mixer for zoom event of area type mouse event detector.
	 * @mixin
	 * @private */
	exports['default'] = {
	    /**
	     * Initialize for zoom.
	     * @param {boolean} zoomable - whether zoomable or not
	     * @private
	     */
	    _initForZoom: function _initForZoom(zoomable) {
	        /**
	         * whether zoomable or not
	         * @type {boolean}
	         */
	        this.zoomable = zoomable;
	
	        /**
	         * drag start index.
	         * @type {null | object}
	         */
	        this.dragStartIndexes = null;
	
	        /**
	         * start client position(clientX, clientY) of mouse event.
	         * @type {null | {x: number, y: number}}
	         */
	        this.startClientPosition = null;
	
	        /**
	         * start layerX position
	         * @type {null | number}
	         */
	        this.startLayerX = null;
	
	        /**
	         * drag selection element
	         * @type {null | HTMLElement}
	         */
	        this.dragSelectionElement = null;
	
	        /**
	         * container bound
	         * @type {null | {left: number, right: number, top: number}}
	         */
	        this.containerBound = null;
	
	        /**
	         * whether show tooltip after zoom or not.
	         * @type {boolean}
	         */
	        this.isShowTooltipAfterZoom = false;
	
	        /**
	         * whether after mouseup or not.
	         * @type {boolean}
	         */
	        this.afterMouseup = false;
	
	        /**
	         * previouse distance of range
	         * @type {null | number}
	         */
	        this.prevDistanceOfRange = null;
	
	        /**
	         * whether reverse move or not.
	         * @type {null | number}
	         */
	        this.reverseMove = null;
	
	        /**
	         * reset zoom button element.
	         * @type {null | HTMLElement}
	         */
	        this.resetZoomBtn = null;
	    },
	
	
	    /**
	     * preset zoom data before rerender.
	     */
	    presetBeforeRerender: function presetBeforeRerender() {
	        if (this.resetZoomBtn) {
	            this.mouseEventDetectorContainer.removeChild(this.resetZoomBtn);
	            this.resetZoomBtn = null;
	        }
	        this._hideTooltip();
	        this.prevDistanceOfRange = null;
	    },
	
	
	    /**
	     * Show tooltip after zoom.
	     * @private
	     */
	    _showTooltipAfterZoom: function _showTooltipAfterZoom() {
	        var isShowTooltipAfterZoom = this.isShowTooltipAfterZoom;
	
	        var lastDataBeforeZoom = void 0;
	
	        this.isShowTooltipAfterZoom = false;
	
	        if (!isShowTooltipAfterZoom || !this.dragStartIndexes) {
	            return;
	        }
	
	        if (this.reverseMove) {
	            lastDataBeforeZoom = this._getFirstData(this.dragStartIndexes.index);
	        } else {
	            lastDataBeforeZoom = this._getLastData(this.dragEndIndexes.index);
	        }
	
	        if (lastDataBeforeZoom) {
	            this._showTooltip(lastDataBeforeZoom);
	        }
	    },
	
	
	    /**
	     * Update dimension for drag selection element.
	     * @param {HTMLElement} selectionElement - drag selection element
	     * @private
	     */
	    _updateDimensionForDragSelection: function _updateDimensionForDragSelection(selectionElement) {
	        _renderUtil2['default'].renderDimension(selectionElement, {
	            height: this.layout.dimension.height
	        });
	    },
	
	
	    /**
	     * Render drag selection.
	     * @returns {HTMLElement}
	     * @private
	     */
	    _renderDragSelection: function _renderDragSelection() {
	        var selectionElement = _domHandler2['default'].create('DIV', 'tui-chart-drag-selection');
	
	        this._updateDimensionForDragSelection(selectionElement);
	
	        return selectionElement;
	    },
	
	
	    /**
	     * Render.
	     * @param {object} data - data for rendering
	     * @returns {HTMLElement}
	     * @override
	     */
	    render: function render(data) {
	        var container = _mouseEventDetectorBase2['default'].prototype.render.call(this, data);
	        var selectionElement = this._renderDragSelection();
	
	        _domHandler2['default'].append(container, selectionElement);
	        this.dragSelectionElement = selectionElement;
	
	        return container;
	    },
	
	
	    /**
	     * Resize.
	     * @param {{tickCount: number}} data - data for resizing
	     * @override
	     */
	    resize: function resize(data) {
	        this.containerBound = null;
	        _mouseEventDetectorBase2['default'].prototype.resize.call(this, data);
	        this._updateDimensionForDragSelection(this.dragSelectionElement);
	    },
	
	
	    /**
	     * On click
	     * @private
	     * @override
	     */
	    _onClick: function _onClick() {},
	
	
	    /**
	     * Whether after drag mouseup or not.
	     * @returns {boolean}
	     * @private
	     */
	    _isAfterDragMouseup: function _isAfterDragMouseup() {
	        var afterMouseup = this.afterMouseup;
	
	
	        if (afterMouseup) {
	            this.afterMouseup = false;
	        }
	
	        return afterMouseup;
	    },
	
	
	    /**
	     * Bind drag event for zoom.
	     * @param {HTMLElement} target - target element
	     * @private
	     */
	    _bindDragEvent: function _bindDragEvent(target) {
	        if (target.setCapture) {
	            target.setCapture();
	        }
	
	        _eventListener2['default'].on(document, 'mousemove', this._onDrag, this);
	        _eventListener2['default'].off(this.mouseEventDetectorContainer, 'mouseup', this._onMouseup, this);
	        _eventListener2['default'].on(document, 'mouseup', this._onMouseupAfterDrag, this);
	    },
	
	
	    /**
	     * Unbind drag event for zoom.
	     * @private
	     */
	    _unbindDragEvent: function _unbindDragEvent() {
	        if (this.downTarget && this.downTarget.releaseCapture) {
	            this.downTarget.releaseCapture();
	        }
	
	        _eventListener2['default'].off(document, 'mousemove', this._onDrag, this);
	        _eventListener2['default'].off(document, 'mouseup', this._onMouseupAfterDrag, this);
	        _eventListener2['default'].on(this.mouseEventDetectorContainer, 'mouseup', this._onMouseup, this);
	    },
	
	
	    /**
	     * On mouse down.
	     * @param {MouseEvent} e - mouse event
	     * @private
	     * @override
	     */
	    _onMousedown: function _onMousedown(e) {
	        if (!this.zoomable) {
	            return;
	        }
	
	        var target = e.target || e.srcElement;
	
	        this.startClientPosition = {
	            x: e.clientX,
	            y: e.clientY
	        };
	
	        this.startLayerX = this._calculateLayerPosition(e.clientX).x;
	        this.downTarget = target;
	
	        this._bindDragEvent(target);
	    },
	
	
	    /**
	     * Show drag selection.
	     * @param {number} clientX - clientX
	     * @private
	     */
	    _showDragSelection: function _showDragSelection(clientX) {
	        var _mouseEventDetectorCo = this.mouseEventDetectorContainer.getBoundingClientRect(),
	            eventContainerLeft = _mouseEventDetectorCo.left;
	
	        var layerX = this._calculateLayerPosition(clientX).x;
	        var clientPos = this.startClientPosition;
	        var diffArea = eventContainerLeft - (clientPos.x - this.startLayerX);
	        var left = Math.min(layerX, this.startLayerX) - diffArea;
	        var width = Math.abs(layerX - this.startLayerX);
	        var element = this.dragSelectionElement;
	
	        element.style.left = left + 'px';
	        element.style.width = width + 'px';
	
	        _domHandler2['default'].addClass(element, 'show');
	    },
	
	
	    /**
	     * Hide drag selection.
	     * @private
	     */
	    _hideDragSelection: function _hideDragSelection() {
	        _domHandler2['default'].removeClass(this.dragSelectionElement, 'show');
	    },
	
	
	    /**
	     * On mouse drag.
	     * @param {MouseEvent} e - mouse event
	     * @private
	     */
	    _onDrag: function _onDrag(e) {
	        var clientPos = this.startClientPosition;
	        var target = e.target || e.srcElement;
	
	        if (clientPos) {
	            var dataForZoomable = this._findDataForZoomable(clientPos.x, clientPos.y);
	
	            if (!_domHandler2['default'].hasClass(target, _const2['default'].CLASS_NAME_RESET_ZOOM_BTN)) {
	                if (_tuiCodeSnippet2['default'].isNull(this.dragStartIndexes)) {
	                    this.dragStartIndexes = dataForZoomable ? dataForZoomable.indexes : {};
	                } else {
	                    this._showDragSelection(e.clientX);
	                }
	            }
	        }
	    },
	
	
	    /**
	     * Adjust index range for ensure three indexes.
	     * @param {Array.<{startIndex: number, endIndex: number}>} indexRange - index range
	     * @returns {object} startIndex, endIndex
	     * @private
	     */
	    _changeIndexToHaveMinimumIndexes: function _changeIndexToHaveMinimumIndexes(_ref) {
	        var _ref2 = _slicedToArray(_ref, 2),
	            startIndex = _ref2[0],
	            endIndex = _ref2[1];
	
	        var distanceOfRange = endIndex - startIndex;
	
	        if (distanceOfRange === 0) {
	            if (startIndex === 0) {
	                endIndex += 2;
	            } else {
	                startIndex -= 1;
	                endIndex += 1;
	            }
	        } else if (distanceOfRange === 1) {
	            if (startIndex === 0) {
	                endIndex += 1;
	            } else {
	                startIndex -= 1;
	            }
	        }
	
	        return {
	            startIndex: startIndex,
	            endIndex: endIndex
	        };
	    },
	
	
	    /**
	     * Adjust index range for ensure three indexes.
	     * @param {number} startIndex - start index
	     * @param {number} endIndex - end index
	     * @returns {Array.<number>}
	     * @private
	     */
	    _adjustIndexRange: function _adjustIndexRange(startIndex, endIndex) {
	        var indexRange = [startIndex, endIndex].sort(function (a, b) {
	            return a - b;
	        });
	
	        return this._changeIndexToHaveMinimumIndexes(indexRange);
	    },
	
	
	    /**
	     * Fire zoom mouse event detector.
	     * @private
	     */
	    _fireZoom: function _fireZoom() {
	        if (this.dataProcessor.isLineCoordinateType()) {
	            this._fireZoomUsingValue(this.dragStartIndexes, this.dragEndIndexes);
	        } else {
	            this._fireZoomUsingIndex(this.dragStartIndexes.groupIndex, this.dragEndIndexes.groupIndex);
	        }
	    },
	
	
	    /**
	     * Fire zoom mouse event detector using Index.
	     * @param {number} startIndex - start index
	     * @param {number} endIndex - end index
	     * @private
	     */
	    _fireZoomUsingIndex: function _fireZoomUsingIndex(startIndex, endIndex) {
	        var reverseMove = startIndex > endIndex;
	
	        var _adjustIndexRange2 = this._adjustIndexRange(startIndex, endIndex),
	            adjustedStartIndex = _adjustIndexRange2.startIndex,
	            adjustedEndIndex = _adjustIndexRange2.endIndex;
	
	        var distanceOfRange = adjustedEndIndex - adjustedStartIndex;
	
	        if (this.prevDistanceOfRange === distanceOfRange) {
	            return;
	        }
	
	        this.prevDistanceOfRange = distanceOfRange;
	        this.reverseMove = reverseMove;
	        this.eventBus.fire('zoom', [adjustedStartIndex, adjustedEndIndex]);
	    },
	
	
	    /**
	     * Adjust value range for ensure three indexes.
	     * @param {number} startValue - start index
	     * @param {number} endValue - end index
	     * @returns {Array.<number>}
	     * @private
	     */
	    _adjustValueRange: function _adjustValueRange(startValue, endValue) {
	        var startValueIndex = void 0,
	            endValueIndex = void 0;
	        var _dataProcessor = this.dataProcessor,
	            integratedXAxisData = _dataProcessor.integratedXAxisData,
	            xAxisOptions = _dataProcessor.options.xAxis;
	
	        var isDatetime = _predicate2['default'].isDatetimeType(xAxisOptions.type);
	
	        if (isDatetime) {
	            startValueIndex = _arrayUtil2['default'].findIndexFromDateTypeArray(integratedXAxisData, new Date(startValue));
	            endValueIndex = _arrayUtil2['default'].findIndexFromDateTypeArray(integratedXAxisData, new Date(endValue));
	        } else {
	            startValueIndex = integratedXAxisData.indexOf(startValue);
	            endValueIndex = integratedXAxisData.indexOf(endValue);
	        }
	
	        var indexRange = [startValueIndex, endValueIndex].sort(function (a, b) {
	            return a - b;
	        });
	
	        var _changeIndexToHaveMin = this._changeIndexToHaveMinimumIndexes(indexRange),
	            startIndex = _changeIndexToHaveMin.startIndex,
	            endIndex = _changeIndexToHaveMin.endIndex;
	
	        return [integratedXAxisData[startIndex], integratedXAxisData[endIndex]];
	    },
	
	
	    /**
	     * Fire zoom mouse event detector for coordinateChart.
	     * @param {object} startIndexes - start index
	     * @param {object} endIndexes - end index
	     * @private
	     */
	    _fireZoomUsingValue: function _fireZoomUsingValue(startIndexes, endIndexes) {
	        var startIndex = startIndexes.index,
	            startGroupIndex = startIndexes.groupIndex;
	        var endIndex = endIndexes.index,
	            endGroupIndex = endIndexes.groupIndex;
	
	        var seriesData = this.dataProcessor.rawData.series.line;
	
	        var _seriesData$startInde = _slicedToArray(seriesData[startIndex].data[startGroupIndex], 1),
	            startValue = _seriesData$startInde[0];
	
	        var _seriesData$endIndex$ = _slicedToArray(seriesData[endIndex].data[endGroupIndex], 1),
	            endValue = _seriesData$endIndex$[0];
	
	        var valueRange = this._adjustValueRange(startValue, endValue);
	
	        this.eventBus.fire('zoom', valueRange);
	    },
	
	
	    /**
	     * Set flag about whether show tooltip after zoom or not.
	     * @param {number} clientX - clientX of mouse event
	     * @param {number} clientY - clientY of mouse event
	     * @private
	     */
	    _setIsShowTooltipAfterZoomFlag: function _setIsShowTooltipAfterZoomFlag(clientX, clientY) {
	        var layerX = this._calculateLayerPosition(clientX, clientY, false).x;
	        var limitLayerX = this._calculateLayerPosition(clientX, clientY).x;
	
	        this.isShowTooltipAfterZoom = layerX === limitLayerX;
	    },
	
	
	    /**
	     * On mouseup after drag event.
	     * @param {MouseEvent} e - mouse event
	     * @private
	     */
	    _onMouseupAfterDrag: function _onMouseupAfterDrag(e) {
	        // @TODO: define zoomable policy, when there is no data
	        // To find dragEndIndex for zoom, data should not be null.
	        // To avoid zooming avoid zooming with no data, check dragStartIndexes first
	        // Becault chart without data returns invalid dragStartIndexes
	        var foundedDragEndData = this._findDataForZoomable(e.clientX, e.clientY);
	
	        this._unbindDragEvent();
	
	        if (_tuiCodeSnippet2['default'].isNull(this.dragStartIndexes)) {
	            var target = e.target || e.srcElement;
	            if (_domHandler2['default'].hasClass(target, _const2['default'].CLASS_NAME_RESET_ZOOM_BTN)) {
	                this._hideTooltip();
	                this.prevDistanceOfRange = null;
	                this.eventBus.fire('resetZoom');
	            } else {
	                _mouseEventDetectorBase2['default'].prototype._onClick.call(this, e);
	            }
	        } else if (this.dragStartIndexes && foundedDragEndData) {
	            this.dragEndIndexes = foundedDragEndData.indexes;
	            this._setIsShowTooltipAfterZoomFlag(e.clientX, e.clientY);
	            this._hideDragSelection();
	            this._fireZoom();
	        } else {
	            this._setIsShowTooltipAfterZoomFlag(e.clientX, e.clientY);
	            this._hideDragSelection();
	        }
	
	        this.startClientPosition = null;
	        this.dragStartIndexes = null;
	        this.startLayerX = null;
	        this.afterMouseup = true;
	    },
	
	
	    /**
	     * Render reset zoom button element.
	     * @returns {HTMLElement}
	     * @private
	     */
	    _renderResetZoomBtn: function _renderResetZoomBtn() {
	        var resetBtn = _domHandler2['default'].create('DIV', _const2['default'].CLASS_NAME_RESET_ZOOM_BTN);
	
	        return resetBtn;
	    },
	
	
	    /**
	     * Zoom.
	     * @param {object} data - data for rendering
	     */
	    zoom: function zoom(data) {
	        this.prevFoundData = null;
	        this.rerender(data);
	        this._updateDimensionForDragSelection(this.dragSelectionElement);
	
	        if (!this.resetZoomBtn) {
	            this.resetZoomBtn = this._renderResetZoomBtn();
	            _domHandler2['default'].append(this.mouseEventDetectorContainer, this.resetZoomBtn);
	        } else if (data.isResetZoom) {
	            this.mouseEventDetectorContainer.removeChild(this.resetZoomBtn);
	            this.resetZoomBtn = null;
	        }
	    }
	};

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview AreaTypeDataModel is data model for mouse event detector of area type.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var AreaTypeDataModel = function () {
	    /**
	     * AreaTypeDataModel is data mode for mouse event detector of area type.
	     * @constructs AreaTypeDataModel
	     * @private
	     * @param {Array} seriesItemBoundsData - series item bounds data
	     */
	    function AreaTypeDataModel(seriesItemBoundsData) {
	        _classCallCheck(this, AreaTypeDataModel);
	
	        this.data = this._makeData(seriesItemBoundsData);
	
	        /**
	         * last group index
	         * @type {number}
	         */
	        this.lastGroupIndex = 0;
	    }
	
	    /**
	     * Make data for detecting mouse event.
	     * @param {Array} seriesItemBoundsData - series item bounds data
	     * @returns {Array}
	     * @private
	     */
	
	
	    AreaTypeDataModel.prototype._makeData = function _makeData(seriesItemBoundsData) {
	        var _this = this,
	            _ref,
	            _ref2;
	
	        var seriesItemBoundsLength = seriesItemBoundsData.length;
	        var lastGroupIndex = 0;
	        var data = seriesItemBoundsData.map(function (seriesDatum, seriesIndex) {
	            var chartType = seriesDatum.chartType,
	                dotumData = seriesDatum.data;
	
	            var groupPositions = dotumData.groupPositions || dotumData.groupBounds;
	
	            if (_predicate2['default'].isLineTypeChart(chartType) || _predicate2['default'].isRadialChart(chartType)) {
	                groupPositions = _arrayUtil2['default'].pivot(groupPositions);
	            }
	
	            lastGroupIndex = Math.max(groupPositions.length - 1, lastGroupIndex);
	
	            var hasGroupPositon = groupPositions.length > 1 && groupPositions[1][0] && groupPositions[0][0];
	            _this.leftStepLength = hasGroupPositon ? groupPositions[1][0].left - groupPositions[0][0].left : 0;
	
	            return groupPositions.map(function (positions, groupIndex) {
	                return positions.map(function (position, index) {
	                    var datum = null;
	
	                    if (position) {
	                        datum = {
	                            chartType: chartType,
	                            indexes: {
	                                groupIndex: groupIndex,
	                                index: index
	                            },
	                            bound: position
	                        };
	                    }
	
	                    // Add legendIndex to datum on making multi series chart data, especially for LineScatterComboChart.
	                    if (seriesItemBoundsLength > 1) {
	                        datum.indexes.legendIndex = seriesIndex;
	                    }
	
	                    return datum;
	                });
	            });
	        });
	
	        data = (_ref = []).concat.apply(_ref, _toConsumableArray(data));
	        this.lastGroupIndex = lastGroupIndex;
	
	        return (_ref2 = []).concat.apply(_ref2, _toConsumableArray(data)).filter(function (datum) {
	            return !!datum;
	        });
	    };
	
	    /**
	     * Find Data by layer position.
	     * @param {{x: number, y: number}} layerPosition - layer position
	     * @param {number} [selectLegendIndex] select legend sereis index
	     * @param {object} [searchInfo] distance limitation to find data
	     *   @param {number} searchInfo.distanceLimit distance limitation to find data
	     *   @param {boolean} searchInfo.isCoordinateTypeChart whether coordinate type chart or not
	     * @returns {object}
	     */
	
	
	    AreaTypeDataModel.prototype.findData = function findData(layerPosition, selectLegendIndex) {
	        var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	            distanceLimit = _ref3.distanceLimit,
	            isCoordinateTypeChart = _ref3.isCoordinateTypeChart;
	
	        var isLooseDistancePosition = distanceLimit && distanceLimit < this.leftStepLength;
	        var useCoordinateDistanceSearch = isCoordinateTypeChart || isLooseDistancePosition;
	
	        if (useCoordinateDistanceSearch) {
	            return this._findDataForCoordinateDistance(layerPosition, distanceLimit, selectLegendIndex);
	        }
	
	        return this._findDataForFirstXPosition(layerPosition, selectLegendIndex);
	    };
	
	    /**
	     * Find Data by layer position at dense area.
	     * @param {{x: number, y: number}} layerPosition - layer position
	     * @param {number} selectLegendIndex select legend sereis index
	     * @returns {object}
	     * @private
	     */
	
	
	    AreaTypeDataModel.prototype._findDataForFirstXPosition = function _findDataForFirstXPosition(layerPosition, selectLegendIndex) {
	        var _data$reduce = this.data.reduce(function (findMinObj, datum) {
	            var xDiff = Math.abs(layerPosition.x - datum.bound.left);
	            if (xDiff <= findMinObj.xMin) {
	                findMinObj.xMin = xDiff;
	                findMinObj.xMinValue = datum.bound.left;
	            }
	
	            return findMinObj;
	        }, {
	            xMin: Number.MAX_VALUE,
	            xMinValue: 0
	        }),
	            xMinValue = _data$reduce.xMinValue;
	
	        var _data$reduce2 = this.data.reduce(function (findResultObj, datum) {
	            var yDiff = Math.abs(layerPosition.y - datum.bound.top);
	            var remakeFindObj = {};
	
	            if (datum.bound.left !== xMinValue) {
	                remakeFindObj = findResultObj;
	            } else if (!_tuiCodeSnippet2['default'].isNull(selectLegendIndex) && selectLegendIndex === datum.indexes.index) {
	                remakeFindObj.yMin = Number.MIN_VALUE;
	                remakeFindObj.findFound = datum;
	            } else if (yDiff <= findResultObj.yMin) {
	                remakeFindObj.yMin = yDiff;
	                remakeFindObj.findFound = datum;
	            } else {
	                remakeFindObj = findResultObj;
	            }
	
	            return remakeFindObj;
	        }, {
	            yMin: Number.MAX_VALUE,
	            findFound: null
	        }),
	            findFound = _data$reduce2.findFound;
	
	        return findFound;
	    };
	
	    /**
	     * Find Data by layer position at loose area.
	     * @param {{x: number, y: number}} layerPosition - layer position
	     * @param {number} [distanceLimit] distance limitation to find data
	     * @param {number} selectLegendIndex select legend sereis index
	     * @returns {object}
	     * @private
	     */
	
	
	    AreaTypeDataModel.prototype._findDataForCoordinateDistance = function _findDataForCoordinateDistance(layerPosition, distanceLimit, selectLegendIndex) {
	        var min = 100000;
	        var findFound = void 0;
	
	        distanceLimit = distanceLimit || Number.MAX_VALUE;
	
	        this.data.forEach(function (datum) {
	            var xDiff = layerPosition.x - datum.bound.left;
	            var yDiff = layerPosition.y - datum.bound.top;
	            var distance = Math.sqrt(Math.pow(xDiff, 2) + Math.pow(yDiff, 2));
	
	            if (distance > distanceLimit) {
	                return;
	            }
	
	            if (!_tuiCodeSnippet2['default'].isNull(selectLegendIndex) && selectLegendIndex !== datum.indexes.index) {
	                return;
	            }
	
	            if (distance <= min) {
	                min = distance;
	                findFound = datum;
	            }
	        });
	
	        return findFound;
	    };
	
	    /**
	     * Find data by indexes.
	     * @param {{index: {number}, seriesIndex: {number}}} indexes - indexe of series item displaying a tooltip
	     * @returns {object}
	     */
	
	
	    AreaTypeDataModel.prototype.findDataByIndexes = function findDataByIndexes(_ref4) {
	        var index = _ref4.index,
	            seriesIndex = _ref4.seriesIndex;
	
	        var foundData = null;
	
	        this.data.forEach(function (datum) {
	            if (datum.indexes.groupIndex === index && datum.indexes.index === seriesIndex) {
	                foundData = datum;
	            }
	
	            return !foundData;
	        });
	
	        return foundData;
	    };
	
	    /**
	     * Get first data.
	     * @param {number} index - index
	     * @returns {object}
	     */
	
	
	    AreaTypeDataModel.prototype.getFirstData = function getFirstData(index) {
	        var indexes = {
	            index: 0,
	            seriesIndex: index
	        };
	
	        return this.findDataByIndexes(indexes);
	    };
	
	    /**
	     * Get last data.
	     * @param {number} index - index
	     * @returns {object}
	     */
	
	
	    AreaTypeDataModel.prototype.getLastData = function getLastData(index) {
	        var indexes = {
	            index: this.lastGroupIndex,
	            seriesIndex: index
	        };
	
	        return this.findDataByIndexes(indexes);
	    };
	
	    return AreaTypeDataModel;
	}();
	
	exports['default'] = AreaTypeDataModel;

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = simpleTypeEventDetectorFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _mouseEventDetectorBase = __webpack_require__(397);
	
	var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview SimpleEventDetector is event handle layer for simply sending clientX, clientY.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var SimpleEventDetector = function (_MouseEventDetectorBa) {
	  _inherits(SimpleEventDetector, _MouseEventDetectorBa);
	
	  /**
	   * SimpleEventDetector is event handle layer for simply sending clientX, clientY.
	   * @constructs SimpleEventDetector
	   * @private
	   * @param {object} params parameters
	   *      @param {string} params.chartType - chart type
	   * @extends MouseEventDetectorBase
	   */
	  function SimpleEventDetector(params) {
	    _classCallCheck(this, SimpleEventDetector);
	
	    /**
	     * chart type
	     * @type {string}
	     */
	    var _this = _possibleConstructorReturn(this, _MouseEventDetectorBa.call(this));
	
	    _this.chartType = params.chartType;
	
	    _this.drawingType = _const2['default'].COMPONENT_TYPE_DOM;
	
	    /**
	     * event bus for transmitting message
	     * @type {object}
	     */
	    _this.eventBus = params.eventBus;
	    return _this;
	  }
	
	  /**
	   * Render mouse event detector area
	   * @param {HTMLElement} mouseEventDetectorContainer - container element for mouse event detector
	   * @private
	   */
	
	
	  SimpleEventDetector.prototype._renderMouseEventDetectorArea = function _renderMouseEventDetectorArea(mouseEventDetectorContainer) {
	    _renderUtil2['default'].renderDimension(mouseEventDetectorContainer, this.layout.dimension);
	    _renderUtil2['default'].renderPosition(mouseEventDetectorContainer, this.layout.position);
	  };
	
	  /**
	   * Initialize data of mouse event detector
	   * @override
	   */
	
	
	  SimpleEventDetector.prototype.onReceiveSeriesData = function onReceiveSeriesData() {};
	
	  /**
	   * On click.
	   * @param {MouseEvent} e - mouse event
	   * @private
	   * @override
	   */
	
	
	  SimpleEventDetector.prototype._onClick = function _onClick(e) {
	    this._onMouseEvent('click', e);
	  };
	
	  /**
	   * On mouse move.
	   * @param {MouseEvent} e - mouse event
	   * @private
	   * @override
	   */
	
	
	  SimpleEventDetector.prototype._onMousemove = function _onMousemove(e) {
	    this._onMouseEvent('move', e);
	  };
	
	  /**
	   * On mouse out.
	   * @param {MouseEvent} e - mouse event
	   * @private
	   * @override
	   */
	
	
	  SimpleEventDetector.prototype._onMouseout = function _onMouseout(e) {
	    this._onMouseEvent('move', e);
	  };
	
	  return SimpleEventDetector;
	}(_mouseEventDetectorBase2['default']);
	
	/**
	 * simpleTypeEventDetectorFactory
	 * @param {object} params chart options
	 * @returns {object} simple type event detector instanse
	 * @ignore
	 */
	
	
	function simpleTypeEventDetectorFactory(params) {
	  return new SimpleEventDetector(params);
	}
	
	simpleTypeEventDetectorFactory.componentType = 'mouseEventDetector';

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = groupTypeEventDetectorFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _mouseEventDetectorBase = __webpack_require__(397);
	
	var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
	
	var _zoomMixer = __webpack_require__(402);
	
	var _zoomMixer2 = _interopRequireDefault(_zoomMixer);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview GroupTypeEventDetector is mouse event detector for grouped tooltip.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	var GroupTypeEventDetector = function (_EventDetectorBase) {
	    _inherits(GroupTypeEventDetector, _EventDetectorBase);
	
	    /**
	     * GroupTypeEventDetector is mouse event detector for grouped tooltip.
	     * @param {object} params parameters
	     * @constructs GroupTypeEventDetector
	     * @private
	     * @extends EventDetectorBase
	     */
	    function GroupTypeEventDetector(params) {
	        _classCallCheck(this, GroupTypeEventDetector);
	
	        /**
	         * previous index of group data
	         * @type {null}
	         */
	        var _this = _possibleConstructorReturn(this, _EventDetectorBase.call(this, params));
	
	        _this.prevIndex = null;
	
	        /**
	         * whether zoomable or not
	         * @type {boolean}
	         */
	        _this.zoomable = params.zoomable;
	
	        /**
	         * type of size
	         * @type {string}
	         */
	        _this.sizeType = _this.isVertical ? 'height' : 'width';
	
	        if (_this.zoomable) {
	            _tuiCodeSnippet2['default'].extend(_this, _zoomMixer2['default']);
	            _this._initForZoom(params.zoomable);
	        }
	        return _this;
	    }
	
	    /**
	     * Initialize data of mouse event detector
	     * @param {Array.<object>} seriesInfos series infos
	     * @override
	     */
	
	
	    GroupTypeEventDetector.prototype.initMouseEventDetectorData = function initMouseEventDetectorData(seriesInfos) {
	        _mouseEventDetectorBase2['default'].prototype.initMouseEventDetectorData.call(this, seriesInfos);
	
	        if (this.zoomable) {
	            this._showTooltipAfterZoom();
	        }
	    };
	
	    /**
	     * Find data by client position.
	     * @param {number} clientX - clientX
	     * @param {number} clientY - clientY
	     * @returns {object}
	     * @private
	     */
	
	
	    GroupTypeEventDetector.prototype._findGroupData = function _findGroupData(clientX, clientY) {
	        var layerPosition = this._calculateLayerPosition(clientX, clientY, true);
	        var pointValue = void 0;
	
	        if (this.isVertical) {
	            pointValue = layerPosition.x;
	        } else {
	            pointValue = layerPosition.y;
	        }
	
	        return {
	            indexes: {
	                groupIndex: this.tickBaseCoordinateModel.findIndex(pointValue)
	            }
	        };
	    };
	
	    /**
	     * Find data by client position for zoomable
	     * @param {number} clientX - clientX
	     * @param {number} clientY - clientY
	     * @returns {object}
	     * @private
	     */
	
	
	    GroupTypeEventDetector.prototype._findDataForZoomable = function _findDataForZoomable(clientX, clientY) {
	        return this._findGroupData(clientX, clientY);
	    };
	
	    /**
	     * Get first data.
	     * @returns {{indexes: {groupIndex: number}}} - data
	     * @private
	     */
	
	
	    GroupTypeEventDetector.prototype._getFirstData = function _getFirstData() {
	        return {
	            indexes: {
	                groupIndex: 0
	            }
	        };
	    };
	
	    /**
	     * Get last data.
	     * @returns {{indexes: {groupIndex: number}}} - data
	     * @private
	     */
	
	
	    GroupTypeEventDetector.prototype._getLastData = function _getLastData() {
	        return {
	            indexes: {
	                groupIndex: this.tickBaseCoordinateModel.getLastIndex()
	            }
	        };
	    };
	
	    /**
	     * Whether outer position or not.
	     * @param {number} layerX layerX
	     * @param {number} layerY layerY
	     * @returns {boolean} result boolean
	     * @private
	     */
	
	
	    GroupTypeEventDetector.prototype._isOuterPosition = function _isOuterPosition(layerX, layerY) {
	        var _dimension = this.dimension,
	            width = _dimension.width,
	            height = _dimension.height;
	        var _layout$position = this.layout.position,
	            top = _layout$position.top,
	            left = _layout$position.left;
	
	
	        return layerX < left || layerX > left + width || layerY < top || layerY > top + height;
	    };
	
	    /**
	     * Show tooltip.
	     * @param {{indexes: {groupIndex: number}, silent: boolean}} foundData - data
	     * @param {boolean} [isMoving] - whether moving or not
	     * @private
	     */
	
	
	    GroupTypeEventDetector.prototype._showTooltip = function _showTooltip(foundData, isMoving) {
	        var index = foundData.indexes.groupIndex;
	        var positionValue = (this.isVertical ? this.layout.position.left : this.layout.position.top) - _const2['default'].CHART_PADDING;
	
	        /**
	         * Can be called with showTooltip function
	         * At this time, the index may be larger than the data size.
	         */
	        if (this.tickBaseCoordinateModel.data.length > index) {
	            this.eventBus.fire('showTooltip', {
	                index: index,
	                range: this.tickBaseCoordinateModel.makeRange(index, positionValue),
	                size: this.dimension[this.sizeType],
	                isVertical: this.isVertical,
	                isMoving: isMoving,
	                silent: foundData.silent
	            });
	            this.prevIndex = index;
	        }
	    };
	
	    /**
	     * Hide tooltip
	     * @param {{silent: {boolean}}} [options] - options for hiding tooltip
	     * @private
	     */
	
	
	    GroupTypeEventDetector.prototype._hideTooltip = function _hideTooltip(options) {
	        this.eventBus.fire('hideTooltip', this.prevIndex, options);
	        this.prevIndex = null;
	    };
	
	    /**
	     * If found position data by client position, show tooltip.
	     * And if not found, call onMouseout function.
	     * @param {MouseEvent} e mouse event object
	     * @private
	     * @override
	     */
	
	
	    GroupTypeEventDetector.prototype._onMousemove = function _onMousemove(e) {
	        if (this.zoomable && this._isAfterDragMouseup()) {
	            return;
	        }
	
	        var foundData = this._findGroupData(e.clientX, e.clientY);
	        var index = foundData.indexes.groupIndex;
	
	        if (index === -1) {
	            this._onMouseout(e);
	        } else if (this.prevIndex !== index) {
	            this._showTooltip(foundData);
	        }
	    };
	
	    /**
	     * If mouse position gets out mouse event detector area, hide tooltip.
	     * @override
	     */
	
	
	    GroupTypeEventDetector.prototype._onMouseout = function _onMouseout(e) {
	        var _calculateLayerPositi = this._calculateLayerPosition(e.clientX, e.clientY, false),
	            x = _calculateLayerPositi.x,
	            y = _calculateLayerPositi.y;
	
	        if (this._isOuterPosition(x, y) && !_tuiCodeSnippet2['default'].isNull(this.prevIndex)) {
	            this._hideTooltip();
	        }
	    };
	
	    return GroupTypeEventDetector;
	}(_mouseEventDetectorBase2['default']);
	
	/**
	 * groupTypeEventDetectorFactory
	 * @param {object} params chart options
	 * @returns {object} group type event detector instanse
	 * @ignore
	 */
	
	
	function groupTypeEventDetectorFactory(params) {
	    return new GroupTypeEventDetector(params);
	}
	
	groupTypeEventDetectorFactory.componentType = 'mouseEventDetector';

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = boundsTypeEventDetectorFactory;
	
	var _mouseEventDetectorBase = __webpack_require__(397);
	
	var _mouseEventDetectorBase2 = _interopRequireDefault(_mouseEventDetectorBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview BoundsTypeEventDetector is mouse event detector for bounds type charts
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *                                                                              like bar, column, heatmap, treemap.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var BoundsTypeEventDetector = function (_EventDetectorBase) {
	    _inherits(BoundsTypeEventDetector, _EventDetectorBase);
	
	    /**
	     * BoundsTypeEventDetector is mouse event detector for bounds type charts like bar, column, heatmap, treemap.
	     * @constructs BoundsTypeEventDetector
	     * @private
	     * @extends EventDetectorBase
	     */
	    function BoundsTypeEventDetector() {
	        _classCallCheck(this, BoundsTypeEventDetector);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        /**
	         * previous found data
	         * @type {null | object}
	         */
	        var _this = _possibleConstructorReturn(this, _EventDetectorBase.call.apply(_EventDetectorBase, [this].concat(args)));
	
	        _this.prevFoundData = null;
	
	        /**
	         * history array for treemap chart.
	         * @type {array}
	         */
	        _this.zoomHistory = [-1];
	
	        /**
	         * button for zoom history back
	         * @type {null | HTMLElement}
	         */
	        _this.historyBackBtn = null;
	        return _this;
	    }
	
	    /**
	     * Attach to event bus.
	     * @private
	     * @override
	     */
	
	
	    BoundsTypeEventDetector.prototype._attachToEventBus = function _attachToEventBus() {
	        _mouseEventDetectorBase2['default'].prototype._attachToEventBus.call(this);
	
	        this.eventBus.on('afterZoom', this.onAfterZoom, this);
	    };
	
	    /**
	     * Show tooltip.
	     * @param {object} foundData - model data
	     * @private
	     */
	
	
	    BoundsTypeEventDetector.prototype._showTooltip = function _showTooltip(foundData) {
	        this.eventBus.fire('showTooltip', foundData);
	        this.prevFoundData = foundData;
	    };
	
	    /**
	     * Hide tooltip.
	     * @param {{silent: {boolean}}} [options] - options for hiding a tooltip
	     * @private
	     */
	
	
	    BoundsTypeEventDetector.prototype._hideTooltip = function _hideTooltip(options) {
	        this.eventBus.fire('hideTooltip', this.prevFoundData, options);
	        this.prevFoundData = null;
	        this.styleCursor(false);
	    };
	
	    /**
	     * Style css cursor.
	     * @param {boolean} hasChild - whether has child or not
	     */
	
	
	    BoundsTypeEventDetector.prototype.styleCursor = function styleCursor(hasChild) {
	        var container = this.mouseEventDetectorContainer;
	        if (hasChild) {
	            container.style.cursor = 'pointer';
	        } else {
	            container.style.cursor = 'default';
	        }
	    };
	
	    /**
	     * On mousemove.
	     * @param {MouseEvent} e - mouse event
	     * @private
	     * @override
	     */
	
	
	    BoundsTypeEventDetector.prototype._onMousemove = function _onMousemove(_ref) {
	        var clientX = _ref.clientX,
	            clientY = _ref.clientY;
	
	        var layerPosition = this._calculateLayerPosition(clientX, clientY);
	        var foundData = this._findDataFromBoundsCoordinateModel(layerPosition);
	
	        if (!this._isChangedSelectData(this.prevFoundData, foundData)) {
	            return;
	        }
	
	        if (this.prevFoundData) {
	            this._hideTooltip();
	        }
	
	        this.prevFoundData = foundData;
	
	        if (!foundData) {
	            return;
	        }
	
	        if (_predicate2['default'].isTreemapChart(this.chartType)) {
	            var seriesItem = this._getSeriesItemByIndexes(foundData.indexes);
	            this.styleCursor(seriesItem.hasChild);
	        } else if (_predicate2['default'].isBulletChart(this.chartType)) {
	            foundData.mousePosition = {
	                left: clientX,
	                top: clientY
	            };
	        }
	        this._showTooltip(foundData);
	    };
	
	    /**
	     * Zoom history back.
	     * @private
	     */
	
	
	    BoundsTypeEventDetector.prototype._zoomHistoryBack = function _zoomHistoryBack() {
	        var index = this.zoomHistory[this.zoomHistory.length - 2];
	
	        this.zoomHistory.pop();
	        this.eventBus.fire('zoom', index);
	
	        if (this.zoomHistory.length === 1) {
	            this.mouseEventDetectorContainer.removeChild(this.historyBackBtn);
	            this.historyBackBtn = null;
	        }
	    };
	
	    /**
	     * Get seriesItem by indexes
	     * @param {{groupIndex: number, index: number}} indexes - indexes
	     * @returns {SeriesItem}
	     * @private
	     */
	
	
	    BoundsTypeEventDetector.prototype._getSeriesItemByIndexes = function _getSeriesItemByIndexes(indexes) {
	        var seriesDataModel = this.dataProcessor.getSeriesDataModel(_const2['default'].CHART_TYPE_TREEMAP);
	
	        return seriesDataModel.getSeriesItem(indexes.groupIndex, indexes.index, true);
	    };
	
	    /**
	     * On mousemove.
	     * @param {MouseEvent} e - mouse event
	     * @private
	     * @override
	     */
	
	
	    BoundsTypeEventDetector.prototype._onClick = function _onClick(e) {
	        var target = e.target || e.srcElement;
	
	        _mouseEventDetectorBase2['default'].prototype._onClick.call(this, e);
	
	        if (!_predicate2['default'].isTreemapChart(this.chartType)) {
	            return;
	        }
	
	        if (_domHandler2['default'].hasClass(target, _const2['default'].CLASS_NAME_RESET_ZOOM_BTN)) {
	            this._hideTooltip();
	            this._zoomHistoryBack();
	
	            return;
	        }
	
	        var layerPosition = this._calculateLayerPosition(e.clientX, e.clientY);
	        var foundData = this._findDataFromBoundsCoordinateModel(layerPosition);
	
	        if (foundData) {
	            var seriesItem = this._getSeriesItemByIndexes(foundData.indexes);
	
	            if (!seriesItem.hasChild) {
	                return;
	            }
	
	            this._hideTooltip();
	            this.eventBus.fire('zoom', foundData.indexes.index);
	        }
	    };
	
	    /**
	     * On mouseout.
	     * @override
	     */
	
	
	    BoundsTypeEventDetector.prototype._onMouseout = function _onMouseout(_ref2) {
	        var clientX = _ref2.clientX,
	            clientY = _ref2.clientY;
	
	        // do not cache getBoundingClientRect() - if not, it will cause error when chart location changed
	        var bound = this.mouseEventDetectorContainer.getBoundingClientRect();
	        var left = bound.left,
	            right = bound.right,
	            top = bound.top,
	            bottom = bound.bottom;
	
	
	        if (left <= clientX && top <= clientY && right >= clientX && bottom >= clientY) {
	            return;
	        }
	
	        if (this.prevFoundData) {
	            this._hideTooltip();
	        }
	
	        this.prevFoundData = null;
	    };
	
	    /**
	     * On after zoom.
	     * @param {number} index - index of target seriesItem
	     */
	
	
	    BoundsTypeEventDetector.prototype.onAfterZoom = function onAfterZoom(index) {
	        if (!this.historyBackBtn) {
	            this.historyBackBtn = _domHandler2['default'].create('DIV', _const2['default'].CLASS_NAME_RESET_ZOOM_BTN);
	            _domHandler2['default'].append(this.mouseEventDetectorContainer, this.historyBackBtn);
	        }
	
	        if (this.zoomHistory[this.zoomHistory.length - 1] !== index) {
	            this.zoomHistory.push(index);
	        }
	    };
	
	    /**
	     * Find data by indexes.
	     * @param {{index: {number}, seriesIndex: {number}}} indexes - indexe of series item displaying a tooltip
	     * @param {number} [indexes.outlierIndex] - index of outlier of boxplot series, it only exists in boxplot chart
	     * @returns {object} - series item data
	     */
	
	
	    BoundsTypeEventDetector.prototype.findDataByIndexes = function findDataByIndexes(indexes) {
	        return this.boundsBaseCoordinateModel.findDataByIndexes(indexes);
	    };
	
	    return BoundsTypeEventDetector;
	}(_mouseEventDetectorBase2['default']);
	
	/**
	 * boundsTypeEventDetectorFactory
	 * @param {object} params chart options
	 * @returns {object} event detect instanse
	 * @ignore
	 */
	
	
	function boundsTypeEventDetectorFactory(params) {
	    return new BoundsTypeEventDetector(params);
	}
	
	boundsTypeEventDetectorFactory.componentType = 'mouseEventDetector';

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = barSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _barTypeSeriesBase = __webpack_require__(409);
	
	var _barTypeSeriesBase2 = _interopRequireDefault(_barTypeSeriesBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Bar chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	var OVERLAPPING_WIDTH = _const2['default'].OVERLAPPING_WIDTH,
	    TEXT_PADDING = _const2['default'].TEXT_PADDING;
	
	var BarChartSeries = function (_Series) {
	    _inherits(BarChartSeries, _Series);
	
	    function BarChartSeries() {
	        _classCallCheck(this, BarChartSeries);
	
	        return _possibleConstructorReturn(this, _Series.apply(this, arguments));
	    }
	
	    /**
	     * Bar chart series component.
	     * @constructs BarChartSeries
	     * @private
	     * @extends Series
	     * @param {object} params parameters
	     *      @param {object} params.model series model
	     *      @param {object} params.options series options
	     *      @param {object} params.theme series theme
	     */
	
	    /**
	     * Make bound of bar chart.
	     * @param {number} width width
	     * @param {number} height height
	     * @param {number} top top position value
	     * @param {number} startLeft start left position value
	     * @param {number} endLeft end left position value
	     * @returns {{
	     *      start: {left: number, top: number, width: number, height: number},
	     *      end: {left: number, top: number, width: number, height: number}
	     * }} column chart bound
	     * @private
	     */
	    BarChartSeries.prototype._makeBound = function _makeBound(width, height, top, startLeft, endLeft) {
	        return {
	            start: {
	                top: top,
	                left: startLeft,
	                width: 0,
	                height: height
	            },
	            end: {
	                top: top,
	                left: endLeft,
	                width: width,
	                height: height
	            }
	        };
	    };
	
	    /**
	     * Calculate additional left for divided option.
	     * @param {number} value value
	     * @returns {number}
	     * @private
	     */
	
	
	    BarChartSeries.prototype._calculateAdditionalLeft = function _calculateAdditionalLeft(value) {
	        var additionalLeft = 0;
	
	        if (this.options.divided && value > 0) {
	            additionalLeft = this.dimensionMap.yAxis.width + OVERLAPPING_WIDTH;
	        }
	
	        return additionalLeft;
	    };
	
	    /**
	     * Make bar chart bound.
	     * @param {{
	     *      baseBarSize: number,
	     *      groupSize: number,
	     *      barSize: number,
	     *      pointInterval: number,
	     *      firstAdditionalPosition: number,
	     *      basePosition: number
	     * }} baseData base data for making bound
	     * @param {{
	     *      baseTop: number,
	     *      top: number,
	     *      plusLeft: number,
	     *      minusLeft: number,
	     *      prevStack: ?string
	     * }} iterationData iteration data
	     * @param {?boolean} isStackType whether stackType option or not.
	     * @param {SeriesItem} seriesItem series item
	     * @param {number} index index
	     * @returns {{
	     *      start: {left: number, top: number, width: number, height: number},
	     *      end: {left: number, top: number, width: number, height: number}
	     * }}
	     * @private
	     */
	
	
	    BarChartSeries.prototype._makeBarChartBound = function _makeBarChartBound(baseData, iterationData, isStackType, seriesItem, index) {
	        var baseBarSize = baseData.baseBarSize,
	            basePosition = baseData.basePosition,
	            barSize = baseData.barSize,
	            itemCount = baseData.itemCount,
	            groupSize = baseData.groupSize,
	            pointInterval = baseData.pointInterval;
	        var ratioDistance = seriesItem.ratioDistance,
	            value = seriesItem.value,
	            startRatio = seriesItem.startRatio,
	            stack = seriesItem.stack;
	
	
	        var barWidth = baseBarSize * ratioDistance;
	        var additionalLeft = this._calculateAdditionalLeft(value);
	        var barStartLeft = baseBarSize * startRatio;
	        var startLeft = basePosition + barStartLeft + additionalLeft;
	        var changedStack = stack !== iterationData.prevStack;
	        var isOverLapBar = barSize * itemCount > groupSize;
	        var barInterval = isOverLapBar ? pointInterval : barSize;
	        var endLeft = void 0;
	
	        if (!isStackType || !this.options.diverging && changedStack) {
	            var pointCount = isStackType ? this.dataProcessor.findStackIndex(stack) : index;
	            iterationData.top = iterationData.baseTop + barInterval * pointCount;
	            iterationData.plusLeft = 0;
	            iterationData.minusLeft = 0;
	        }
	
	        if (value >= 0) {
	            endLeft = startLeft + iterationData.plusLeft;
	            iterationData.plusLeft += barWidth;
	        } else {
	            iterationData.minusLeft -= barWidth;
	            endLeft = startLeft + iterationData.minusLeft;
	        }
	
	        iterationData.prevStack = stack;
	
	        var boundTop = iterationData.top + pointInterval - barSize / 2;
	        if (!isOverLapBar) {
	            boundTop += (pointInterval - barSize) / 2 * (itemCount - 1);
	        }
	
	        return this._makeBound(barWidth, barSize, boundTop, startLeft, endLeft);
	    };
	
	    /**
	     * Make series bounds for rendering
	     * @returns {Array.<Array.<object>>} bounds
	     * @private
	     */
	
	
	    BarChartSeries.prototype._makeBounds = function _makeBounds() {
	        var _this2 = this;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var isStacked = _predicate2['default'].isValidStackOption(this.options.stackType);
	        var _layout = this.layout,
	            _layout$dimension = _layout.dimension,
	            width = _layout$dimension.width,
	            height = _layout$dimension.height,
	            top = _layout.position.top;
	
	        var baseData = this._makeBaseDataForMakingBound(height, width);
	
	        return seriesDataModel.map(function (seriesGroup, groupIndex) {
	            var baseTop = groupIndex * baseData.groupSize + top;
	            var iterationData = {
	                baseTop: baseTop,
	                top: baseTop,
	                plusLeft: 0,
	                minusLeft: 0,
	                prevStack: null
	            };
	            var iteratee = _this2._makeBarChartBound.bind(_this2, baseData, iterationData, isStacked);
	
	            return seriesGroup.map(iteratee);
	        });
	    };
	
	    /**
	     * Calculate top position of sum label.
	     * @param {{left: number, top: number}} bound bound
	     * @param {number} labelHeight label height
	     * @returns {number} top position value
	     * @private
	     */
	
	
	    BarChartSeries.prototype._calculateTopPositionOfSumLabel = function _calculateTopPositionOfSumLabel(bound, labelHeight) {
	        return bound.top + (bound.height - labelHeight + TEXT_PADDING) / 2;
	    };
	
	    return BarChartSeries;
	}(_series2['default']);
	
	_barTypeSeriesBase2['default'].mixin(BarChartSeries);
	
	/**
	 * barSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} bar series instanse
	 * @ignore
	 */
	function barSeriesFactory(params) {
	    var chartTheme = params.chartTheme,
	        libType = params.chartOptions.libType;
	
	
	    params.libType = libType;
	    params.chartType = 'bar';
	    params.chartBackground = chartTheme.chart.background;
	
	    return new BarChartSeries(params);
	}
	
	// @todo let's find better way
	barSeriesFactory.componentType = 'series';
	barSeriesFactory.BarChartSeries = BarChartSeries;

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _pluginFactory = __webpack_require__(360);
	
	var _pluginFactory2 = _interopRequireDefault(_pluginFactory);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Series base component.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var LABEL_FADE_IN_DURATION = 600;
	var browser = _tuiCodeSnippet2['default'].browser;
	
	var IS_IE7 = browser.msie && browser.version === 7;
	
	var COMPONENT_TYPE_RAPHAEL = _const2['default'].COMPONENT_TYPE_RAPHAEL,
	    PUBLIC_EVENT_PREFIX = _const2['default'].PUBLIC_EVENT_PREFIX,
	    CLASS_NAME_SERIES_LABEL = _const2['default'].CLASS_NAME_SERIES_LABEL;
	
	var Series = function () {
	    /*
	     * Series base component.
	     * @constructs Series
	     * @private
	     * @param {object} params parameters
	     *      @param {object} params.options series options
	     *      @param {object} params.theme series theme
	     */
	    function Series(params) {
	        _classCallCheck(this, Series);
	
	        var libType = params.libType;
	
	        /**
	         * Series component className
	         * @type {string}
	         */
	
	        this.className = 'tui-chart-series-area';
	
	        /**
	         * Chart type
	         * @type {string}
	         */
	        this.chartType = params.chartType;
	
	        /**
	         * Series name
	         * @tpye {string}
	         */
	        this.seriesType = params.seriesType || params.chartType;
	
	        /**
	         * Component type
	         * @type {string}
	         */
	        this.componentType = params.componentType;
	
	        /**
	         * Data processor
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = params.dataProcessor;
	
	        /**
	         * event bus for transmitting message
	         * @type {object}
	         */
	        this.eventBus = params.eventBus;
	
	        /**
	         * chart background.
	         * @type {string}
	         */
	        this.chartBackground = params.chartBackground;
	
	        /**
	         * Options
	         * @type {object}
	         */
	        this.options = params.options || {};
	
	        /**
	         * Theme
	         * @type {object}
	         */
	        this.orgTheme = this.theme = params.theme;
	
	        /**
	         * Graph renderer
	         * @type {object}
	         */
	        this.graphRenderer = _pluginFactory2['default'].get(libType, params.chartType);
	
	        /**
	         * series container
	         * @type {HTMLElement}
	         */
	        this.seriesContainer = null;
	
	        /**
	         * series label container
	         * @type {HTMLElement}
	         */
	        this.seriesLabelContainer = null;
	
	        /**
	         * series data
	         * @type {object}
	         */
	        this.seriesData = {};
	
	        /**
	         * Selected legend index
	         * @type {?number}
	         */
	        this.selectedLegendIndex = null;
	
	        /**
	         * effector for show layer
	         * @type {object}
	         */
	        this.labelShowEffector = null;
	
	        /**
	         * raphael object
	         * @type {null|object}
	         */
	        this.paper = null;
	
	        /**
	         * limit(min, max) data for series
	         * @type {null|{min:number, max:number}}
	         */
	        this.limit = null;
	
	        /**
	         * aligned
	         * @type {null|boolean}
	         */
	        this.aligned = null;
	
	        /**
	         * layout bounds information for this components
	         * @type {null|{dimension:{width:number, height:number}, position:{left:number, top:number}}}
	         */
	        this.layout = null;
	
	        /**
	         * dimension map for layout of chart
	         * @type {null|object}
	         */
	        this.dimensionMap = null;
	
	        /**
	         * position map for layout of chart
	         * @type {null|object}
	         */
	        this.positionMap = null;
	
	        /**
	         * axis data map
	         * @type {null|object}
	         */
	        this.axisDataMap = null;
	
	        /**
	         * before axis data map
	         * @type {null|object}
	         */
	        this.beforeAxisDataMap = null;
	
	        /**
	         * Drawing type
	         * @type {string}
	         */
	        this.drawingType = COMPONENT_TYPE_RAPHAEL;
	
	        /**
	         * whether series lable is supported
	         * @type {boolean}
	         */
	        this.supportSeriesLable = true;
	
	        this._attachToEventBus();
	    }
	
	    /**
	     * Add suffix prefix
	     * @param {sting|array} targetLabel - target label
	     * @returns {string|array} - decorated label
	     */
	
	
	    Series.prototype.decorateLabel = function decorateLabel(targetLabel) {
	        var _options = this.options,
	            _options$labelPrefix = _options.labelPrefix,
	            labelPrefix = _options$labelPrefix === undefined ? '' : _options$labelPrefix,
	            _options$labelSuffix = _options.labelSuffix,
	            labelSuffix = _options$labelSuffix === undefined ? '' : _options$labelSuffix;
	        var addPrefixSuffix = _renderUtil2['default'].addPrefixSuffix,
	            addPrefixSuffixItem = _renderUtil2['default'].addPrefixSuffixItem;
	
	        var decorateFunc = (_tuiCodeSnippet2['default'].isArray(targetLabel) ? addPrefixSuffix : addPrefixSuffixItem).bind(_renderUtil2['default']);
	
	        return decorateFunc(targetLabel, labelPrefix, labelSuffix);
	    };
	
	    /**
	     * Preset components for setData
	     * @param {object} theme theme object
	     * @ignore
	     */
	
	
	    Series.prototype.presetForChangeData = function presetForChangeData() {
	        var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.orgTheme;
	
	        this.orgTheme = theme;
	        this.theme = theme;
	        if (this.chartType === 'treemap') {
	            this.boundMap = null;
	        }
	    };
	
	    /**
	     * Attach to event bus.
	     * @private
	     */
	
	
	    Series.prototype._attachToEventBus = function _attachToEventBus() {
	        var firstRenderCheck = function () {
	            this.isInitRenderCompleted = true;
	            this.eventBus.off('load', firstRenderCheck);
	        }.bind(this);
	
	        this.eventBus.on(PUBLIC_EVENT_PREFIX + 'load', firstRenderCheck);
	
	        this.eventBus.on({
	            selectLegend: this.onSelectLegend,
	            selectSeries: this.onSelectSeries,
	            unselectSeries: this.onUnselectSeries,
	            hoverSeries: this.onHoverSeries,
	            hoverOffSeries: this.onHoverOffSeries,
	            showGroupAnimation: this.onShowGroupAnimation,
	            hideGroupAnimation: this.onHideGroupAnimation
	        }, this);
	
	        if (this.onShowTooltip) {
	            this.eventBus.on('showTooltip', this.onShowTooltip, this);
	        }
	
	        if (this.onShowGroupTooltipLine) {
	            this.eventBus.on({
	                showGroupTooltipLine: this.onShowGroupTooltipLine,
	                hideGroupTooltipLine: this.onHideGroupTooltipLine
	            }, this);
	        }
	
	        if (this.onClickSeries) {
	            this.eventBus.on({
	                clickSeries: this.onClickSeries,
	                moveSeries: this.onMoveSeries
	            }, this);
	        }
	    };
	
	    /**
	     * Get seriesDataModel.
	     * @returns {SeriesDataModel}
	     * @private
	     */
	
	
	    Series.prototype._getSeriesDataModel = function _getSeriesDataModel() {
	        return this.dataProcessor.getSeriesDataModel(this.seriesType);
	    };
	
	    /**
	     * Make series data.
	     * @private
	     * @abstract
	     */
	
	
	    Series.prototype._makeSeriesData = function _makeSeriesData() {};
	
	    /**
	     * Get seriesData
	     * @returns {object} series data
	     */
	
	
	    Series.prototype.getSeriesData = function getSeriesData() {
	        return this.seriesData;
	    };
	
	    /**
	     * Render series label.
	     * @private
	     * @abstract
	     */
	
	
	    Series.prototype._renderSeriesLabel = function _renderSeriesLabel() {};
	
	    /**
	     * Render series label area
	     * @param {object} paper series label area element
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    Series.prototype._renderSeriesLabelArea = function _renderSeriesLabelArea(paper) {
	        return this._renderSeriesLabel(paper);
	    };
	
	    /**
	     * Send boudns to mouseEventDetector component.
	     * @param {object} seriesData - series data
	     * @private
	     */
	
	
	    Series.prototype._sendBoundsToMouseEventDetector = function _sendBoundsToMouseEventDetector(seriesData) {
	        this.eventBus.fire('receiveSeriesData', {
	            chartType: this.chartType,
	            data: seriesData
	        });
	    };
	
	    /**
	     * Render series area.
	     * @param {object} paper - raphael object
	     * @param {function} funcRenderGraph - function for graph rendering
	     * @private
	     */
	
	
	    Series.prototype._renderSeriesArea = function _renderSeriesArea(paper, funcRenderGraph) {
	        var dimension = this.dimensionMap.extendedSeries;
	        var seriesData = this.seriesData = this._makeSeriesData();
	
	        this._sendBoundsToMouseEventDetector(seriesData);
	
	        if (this.hasDataForRendering(seriesData) || this.chartType === 'map') {
	            if (funcRenderGraph) {
	                this.seriesSet = funcRenderGraph(dimension, seriesData, paper);
	            }
	
	            if (_predicate2['default'].isShowLabel(this.options) && this.supportSeriesLable) {
	                this.labelSet = this._renderSeriesLabelArea(paper);
	            }
	        }
	    };
	
	    /**
	     * Make parameters for graph rendering.
	     * @param {{width: number, height: number}} dimension dimension
	     * @param {object} seriesData series data
	     * @returns {object} parameters for graph rendering
	     * @private
	     */
	
	
	    Series.prototype._makeParamsForGraphRendering = function _makeParamsForGraphRendering(dimension, seriesData) {
	        return Object.assign({
	            dimension: dimension,
	            position: this.layout.position,
	            chartType: this.seriesType,
	            theme: this.theme,
	            options: this.options
	        }, seriesData);
	    };
	
	    /**
	     * Render raphael graph.
	     * @param {{width: number, height: number}} dimension - dimension
	     * @param {object} seriesData - series data
	     * @param {object} [paper] - raphael paper
	     * @returns {object}
	     * @private
	     */
	
	
	    Series.prototype._renderGraph = function _renderGraph(dimension, seriesData, paper) {
	        var params = this._makeParamsForGraphRendering(dimension, seriesData);
	
	        return this.graphRenderer.render(paper, params);
	    };
	
	    /**
	     * Set data for rendering.
	     * @param {{
	     *      paper: ?object,
	     *      limit: {
	     *          min: number,
	     *          max: number
	     *      },
	     *      aligned: boolean,
	     *      layout: {
	     *          dimension: {width: number, height: number},
	     *          position: {left: number, top: number}
	     *      },
	     *      dimensionMap: object,
	     *      positionMap: object,
	     *      axisDataMap: object
	     * }} data - data for rendering
	     * @private
	     */
	
	
	    Series.prototype._setDataForRendering = function _setDataForRendering(data) {
	        this.paper = data.paper;
	        this.limit = data.limitMap[this.chartType];
	        if (data.axisDataMap && data.axisDataMap.xAxis) {
	            this.aligned = data.axisDataMap.xAxis.aligned;
	        }
	        this.layout = data.layout;
	        this.dimensionMap = data.dimensionMap;
	        this.positionMap = data.positionMap;
	        this.axisDataMap = data.axisDataMap;
	    };
	
	    /**
	     * Render series component.
	     * @param {object} data - data for rendering
	     */
	
	
	    Series.prototype.render = function render(data) {
	        this.paper = data.paper;
	        this._setDataForRendering(data);
	        this._clearSeriesContainer();
	        this.beforeAxisDataMap = this.axisDataMap;
	
	        if (data.checkedLegends) {
	            var checkedLegends = data.checkedLegends[this.seriesType];
	            if (!this.options.colorByPoint) {
	                this.theme = this._getCheckedSeriesTheme(this.orgTheme, checkedLegends);
	            }
	        }
	
	        this._renderSeriesArea(data.paper, _tuiCodeSnippet2['default'].bind(this._renderGraph, this));
	
	        if (this.paper.pushDownBackgroundToBottom) {
	            this.paper.pushDownBackgroundToBottom();
	        }
	    };
	
	    /**
	     * Get checked series theme.
	     * @param {object} theme legend theme
	     * @param {?Array.<?boolean>} checkedLegends checked legends
	     * @returns {object} checked series theme
	     * @private
	     */
	
	
	    Series.prototype._getCheckedSeriesTheme = function _getCheckedSeriesTheme(theme, checkedLegends) {
	        if (!checkedLegends.length) {
	            return theme;
	        }
	
	        var cloneTheme = JSON.parse(JSON.stringify(theme));
	        cloneTheme.colors = cloneTheme.colors.filter(function (color, index) {
	            return checkedLegends[index];
	        });
	
	        return cloneTheme;
	    };
	
	    /**
	     * Clear series container.
	     * @private
	     */
	
	
	    Series.prototype._clearSeriesContainer = function _clearSeriesContainer() {
	        if (this.seriesSet && this.seriesSet.remove) {
	            this.seriesSet.forEach(function (series) {
	                series.remove();
	            }, this);
	            this.seriesSet.remove();
	        }
	        if (this.labelSet && this.labelSet.remove) {
	            this.labelSet.forEach(function (label) {
	                label.remove();
	            }, this);
	            this.labelSet.remove();
	        }
	
	        this.seriesData = {};
	    };
	
	    /**
	     * Rerender series
	     * @param {object} data - data for rendering
	     */
	
	
	    Series.prototype.rerender = function rerender(data) {
	        var checkedLegends = void 0;
	
	        if (this.seriesType === 'map' || this.dataProcessor.getGroupCount(this.seriesType)) {
	            if (data.checkedLegends) {
	                checkedLegends = data.checkedLegends[this.seriesType];
	                this.theme = this._getCheckedSeriesTheme(this.orgTheme, checkedLegends);
	            }
	
	            this._setDataForRendering(data);
	            this._clearSeriesContainer();
	            this._renderSeriesArea(data.paper, _tuiCodeSnippet2['default'].bind(this._renderGraph, this));
	
	            if (this.labelShowEffector) {
	                clearInterval(this.labelShowEffector.timerId);
	            }
	
	            // if rerender have excuted in the middle of animate,
	            // we should rerun animate
	            if (checkedLegends || !this.isInitRenderCompleted) {
	                this.animateComponent(true);
	            }
	
	            if (!_tuiCodeSnippet2['default'].isNull(this.selectedLegendIndex)) {
	                this.graphRenderer.selectLegend(this.selectedLegendIndex);
	            }
	        } else {
	            this._clearSeriesContainer();
	        }
	    };
	
	    /**
	     * Return whether label visible or not.
	     * @returns {boolean}
	     * @private
	     */
	
	
	    Series.prototype._isLabelVisible = function _isLabelVisible() {
	        return !!(this.options.showLabel || this.options.showLegend);
	    };
	
	    /**
	     * Resize raphael graph by given dimension and series data
	     * @param {{width: number, height: number}} dimension - chart dimension
	     * @param {object} seriesData - series data
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    Series.prototype._resizeGraph = function _resizeGraph(dimension, seriesData) {
	        this.graphRenderer.resize(_tuiCodeSnippet2['default'].extend({
	            dimension: this.dimensionMap.chart
	        }, seriesData));
	
	        return this.seriesSet;
	    };
	
	    /**
	     * Resize series component.
	     * }} bound series bound
	     * @param {object} data data for rendering
	     */
	
	
	    Series.prototype.resize = function resize(data) {
	        this._clearSeriesContainer();
	        this._setDataForRendering(data);
	        this._renderSeriesArea(data.paper, _tuiCodeSnippet2['default'].bind(this._resizeGraph, this));
	        this.rerender(data);
	    };
	
	    /**
	     * Set element's top, left given top, left position
	     * @param {HTMLElement} el - series element
	     * @param {{top: number, left: number}} position - series top, left position
	     * @private
	     */
	
	
	    Series.prototype._renderPosition = function _renderPosition(el, position) {
	        var hiddenWidth = _renderUtil2['default'].isOldBrowser() ? 1 : 0;
	
	        _renderUtil2['default'].renderPosition(el, {
	            top: position.top - hiddenWidth,
	            left: position.left - hiddenWidth * 2
	        });
	    };
	
	    /**
	     * Get limit distance from zero point.
	     * @param {number} size chart size (width or height)
	     * @param {{min: number, max: number}} limit limit
	     * @returns {{toMax: number, toMin: number}} pixel distance
	     * @private
	     */
	
	
	    Series.prototype._getLimitDistanceFromZeroPoint = function _getLimitDistanceFromZeroPoint(size, limit) {
	        var min = limit.min,
	            max = limit.max;
	
	        var distance = max - min;
	        var toMax = 0;
	        var toMin = 0;
	
	        if (min <= 0 && max >= 0) {
	            toMax = (distance + min) / distance * size;
	            toMin = (distance - max) / distance * size;
	        } else if (min > 0) {
	            toMax = size;
	        }
	
	        return {
	            toMax: toMax,
	            toMin: toMin
	        };
	    };
	
	    /**
	     * Find label element.
	     * @param {HTMLElement} elTarget target element
	     * @returns {HTMLElement} label element
	     * @private
	     */
	
	
	    Series.prototype._findLabelElement = function _findLabelElement(elTarget) {
	        if (_domHandler2['default'].hasClass(elTarget, CLASS_NAME_SERIES_LABEL)) {
	            return elTarget;
	        }
	
	        return _domHandler2['default'].findParentByClass(elTarget, CLASS_NAME_SERIES_LABEL);
	    };
	
	    /**
	     * To call showAnimation function of graphRenderer.
	     * @param {{groupIndex: number, index: number}} data data
	     * @param {string} chartType - chart type
	     */
	
	
	    Series.prototype.onHoverSeries = function onHoverSeries(data, chartType) {
	        if (chartType !== this.chartType) {
	            return;
	        }
	
	        if (!this.graphRenderer.showAnimation) {
	            return;
	        }
	
	        this.graphRenderer.showAnimation(data);
	    };
	
	    /**
	     * To call hideAnimation function of graphRenderer.
	     * @param {{groupIndex: number, index: number}} data data
	     * @param {string} chartType - chart type
	     */
	
	
	    Series.prototype.onHoverOffSeries = function onHoverOffSeries(data, chartType) {
	        if (chartType !== this.chartType) {
	            return;
	        }
	
	        if (!this.graphRenderer.hideAnimation || !data) {
	            return;
	        }
	
	        this.graphRenderer.hideAnimation(data);
	    };
	
	    /**
	     * To call showGroupAnimation function of graphRenderer.
	     * @param {number} index index
	     */
	
	
	    Series.prototype.onShowGroupAnimation = function onShowGroupAnimation(index) {
	        if (!this.graphRenderer.showGroupAnimation) {
	            return;
	        }
	        this.graphRenderer.showGroupAnimation(index);
	    };
	
	    /**
	     * To call hideGroupAnimation function of graphRenderer.
	     * @param {number} index index
	     */
	
	
	    Series.prototype.onHideGroupAnimation = function onHideGroupAnimation(index) {
	        if (!this.graphRenderer.hideGroupAnimation) {
	            return;
	        }
	        this.graphRenderer.hideGroupAnimation(index);
	    };
	
	    /**
	     * Animate component.
	     * @param {boolean} [isRerendering] - whether rerendering or not
	     */
	
	
	    Series.prototype.animateComponent = function animateComponent(isRerendering) {
	        if (this.graphRenderer.animate && this.seriesSet) {
	            this.graphRenderer.animate(_tuiCodeSnippet2['default'].bind(this.animateSeriesLabelArea, this, isRerendering), this.seriesSet);
	        } else {
	            this.animateSeriesLabelArea(isRerendering);
	        }
	    };
	
	    /**
	     * Fire load event.
	     * @param {boolean} [isRerendering] - whether rerendering or not
	     * @private
	     */
	
	
	    Series.prototype._fireLoadEvent = function _fireLoadEvent(isRerendering) {
	        if (!isRerendering) {
	            this.eventBus.fire(PUBLIC_EVENT_PREFIX + 'load');
	        }
	    };
	
	    /**
	     * Animate series label area.
	     * @param {boolean} [isRerendering] - whether rerendering or not
	     */
	
	
	    Series.prototype.animateSeriesLabelArea = function animateSeriesLabelArea(isRerendering) {
	        if (!this._isLabelVisible()) {
	            this._fireLoadEvent(isRerendering);
	
	            return;
	        }
	
	        if (IS_IE7) {
	            this._fireLoadEvent(isRerendering);
	            this.labelSet.attr({
	                opacity: 1
	            });
	        } else if (this.labelSet && this.labelSet.length) {
	            _raphaelRenderUtil2['default'].animateOpacity(this.labelSet, 0, 1, LABEL_FADE_IN_DURATION);
	        }
	    };
	
	    /**
	     * Make exportation data for public event of series type.
	     * @param {object} seriesData series data
	     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} export data
	     * @private
	     */
	
	
	    Series.prototype._makeExportationSeriesData = function _makeExportationSeriesData(seriesData) {
	        var indexes = seriesData.indexes;
	
	        var legendIndex = _tuiCodeSnippet2['default'].isExisty(indexes.legendIndex) ? indexes.legendIndex : indexes.index;
	        var legendData = this.dataProcessor.getLegendItem(legendIndex);
	        var index = _tuiCodeSnippet2['default'].isExisty(indexes.groupIndex) ? indexes.groupIndex : 0;
	        var seriesItem = this._getSeriesDataModel().getSeriesItem(index, indexes.index);
	        var result = void 0;
	
	        if (_tuiCodeSnippet2['default'].isExisty(seriesItem)) {
	            result = {
	                chartType: legendData.chartType,
	                legend: legendData.label,
	                legendIndex: legendIndex
	            };
	            result.index = seriesItem.index;
	        }
	
	        return result;
	    };
	
	    /**
	     * Execute graph renderer.
	     * @param {{left: number, top: number}} position mouse position
	     * @param {string} funcName function name
	     * @returns {*} result.
	     * @private
	     */
	
	
	    Series.prototype._executeGraphRenderer = function _executeGraphRenderer(position, funcName) {
	        var isShowLabel = false;
	
	        this.eventBus.fire('hideTooltipContainer');
	        if (this.seriesLabelContainer && _domHandler2['default'].hasClass(this.seriesLabelContainer, 'show')) {
	            _domHandler2['default'].removeClass(this.seriesLabelContainer, 'show');
	            isShowLabel = true;
	        }
	
	        var result = this.graphRenderer[funcName](position);
	
	        if (isShowLabel) {
	            _domHandler2['default'].addClass(this.seriesLabelContainer, 'show');
	        }
	
	        this.eventBus.fire('showTooltipContainer');
	
	        return result;
	    };
	
	    /**
	     * To call selectSeries callback of public event.
	     * @param {object} seriesData - series data
	     * @param {?boolean} shouldSelect - whether should select or not
	     */
	
	
	    Series.prototype.onSelectSeries = function onSelectSeries(seriesData, shouldSelect) {
	        if (seriesData.chartType !== this.chartType) {
	            return;
	        }
	
	        var eventName = PUBLIC_EVENT_PREFIX + 'selectSeries';
	
	        this.eventBus.fire(eventName, this._makeExportationSeriesData(seriesData));
	        shouldSelect = _tuiCodeSnippet2['default'].isEmpty(shouldSelect) ? true : shouldSelect;
	
	        if (this.options.allowSelect && this.graphRenderer.selectSeries && shouldSelect) {
	            this.graphRenderer.selectSeries(seriesData.indexes);
	        }
	    };
	
	    /**
	     * To call unselectSeries callback of public event.
	     * @param {object} seriesData series data.
	     */
	
	
	    Series.prototype.onUnselectSeries = function onUnselectSeries(seriesData) {
	        if (seriesData.chartType !== this.chartType) {
	            return;
	        }
	
	        var eventName = PUBLIC_EVENT_PREFIX + 'unselectSeries';
	
	        this.eventBus.fire(eventName, this._makeExportationSeriesData(seriesData));
	        if (this.options.allowSelect && this.graphRenderer.unselectSeries) {
	            this.graphRenderer.unselectSeries(seriesData.indexes);
	        }
	    };
	
	    /**
	     *On select legend.
	     * @param {string} seriesType - series name
	     * @param {?number} legendIndex - legend index
	     */
	
	
	    Series.prototype.onSelectLegend = function onSelectLegend(seriesType, legendIndex) {
	        if (this.seriesType !== seriesType && !_tuiCodeSnippet2['default'].isNull(legendIndex)) {
	            legendIndex = -1;
	        }
	
	        this.selectedLegendIndex = legendIndex;
	
	        if (this._getSeriesDataModel().getGroupCount()) {
	            this.graphRenderer.selectLegend(legendIndex);
	        }
	    };
	
	    /**
	     * Show label.
	     */
	
	
	    Series.prototype.showLabel = function showLabel() {
	        this.options.showLabel = true;
	
	        if (!this.seriesLabelContainer && this.supportSeriesLable) {
	            this._renderSeriesLabelArea(this.paper);
	        }
	    };
	
	    /**
	     * Hide label.
	     */
	
	
	    Series.prototype.hideLabel = function hideLabel() {
	        this.options.showLabel = false;
	
	        if (this.seriesLabelContainer) {
	            _domHandler2['default'].removeClass(this.seriesLabelContainer, 'show');
	            _domHandler2['default'].removeClass(this.seriesLabelContainer, 'opacity');
	        }
	    };
	
	    Series.prototype.isAvailableSeriesData = function isAvailableSeriesData() {
	        return !!(this.seriesData && this.seriesData.isAvailable && this.seriesData.isAvailable());
	    };
	
	    /**
	     * Return boolean value whether seriesData contains data
	     * @param {object} seriesData seriesData object
	     * @returns {boolean}
	     */
	
	
	    Series.prototype.hasDataForRendering = function hasDataForRendering(seriesData) {
	        return !!(seriesData && seriesData.isAvailable());
	    };
	
	    return Series;
	}();
	
	exports['default'] = Series;

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _renderingLabelHelper = __webpack_require__(410);
	
	var _renderingLabelHelper2 = _interopRequireDefault(_renderingLabelHelper);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview BarTypeSeriesBase is base class for bar type series.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var CHART_PADDING = _const2['default'].CHART_PADDING,
	    LEGEND_LABEL_LEFT_PADDING = _const2['default'].LEGEND_LABEL_LEFT_PADDING;
	
	var DEFAULT_BAR_SIZE_RATIO_BY_POINT_INTERVAL = 0.85;
	
	var BarTypeSeriesBase = function () {
	    function BarTypeSeriesBase() {
	        _classCallCheck(this, BarTypeSeriesBase);
	    }
	
	    /**
	     * Make series data.
	     * @returns {object} add data
	     * @private
	     * @override
	     */
	    BarTypeSeriesBase.prototype._makeSeriesData = function _makeSeriesData() {
	        var groupBounds = this._makeBounds(this.layout.dimension);
	        this.groupBounds = groupBounds;
	
	        return {
	            groupBounds: groupBounds,
	            seriesDataModel: this._getSeriesDataModel(),
	            isAvailable: function isAvailable() {
	                return groupBounds && groupBounds.length > 0;
	            }
	        };
	    };
	
	    /**
	     * Get bar width option size.
	     * @param {number} pointInterval point interval
	     * @param {number} [optionBarWidth] barWidth option
	     * @returns {number} option size
	     * @private
	     */
	
	
	    BarTypeSeriesBase.prototype._getBarWidthOptionSize = function _getBarWidthOptionSize(pointInterval, optionBarWidth) {
	        var optionsSize = 0;
	
	        if (optionBarWidth) {
	            if (optionBarWidth / 2 >= pointInterval) {
	                optionBarWidth = pointInterval * 2;
	            } else if (optionBarWidth < 0) {
	                optionBarWidth = 0;
	            }
	            optionsSize = optionBarWidth;
	        }
	
	        return optionsSize;
	    };
	
	    /**
	     * Calculate difference between optionSize and barSize.
	     * @param {number} barSize bar size
	     * @param {number} optionSize option size
	     * @param {number} itemCount item count
	     * @returns {number} addition padding
	     * @private
	     */
	
	
	    BarTypeSeriesBase.prototype._calculateAdditionalPosition = function _calculateAdditionalPosition(barSize, optionSize, itemCount) {
	        var additionalPosition = 0;
	
	        if (optionSize && optionSize < barSize) {
	            additionalPosition = barSize / 2 + (barSize - optionSize) * itemCount / 2;
	        }
	
	        return additionalPosition;
	    };
	
	    /**
	     * Make base data for making bound.
	     * @param {number} baseGroupSize base group size
	     * @param {number} baseBarSize base bar size
	     * @returns {undefined|{
	     *      baseBarSize: number,
	     *      groupSize: number,
	     *      barSize: number,
	     *      pointInterval: number,
	     *      firstAdditionalPosition: number,
	     *      basePosition: number
	     * }}
	     * @private
	     */
	
	
	    BarTypeSeriesBase.prototype._makeBaseDataForMakingBound = function _makeBaseDataForMakingBound(baseGroupSize, baseBarSize) {
	        var isStackType = _predicate2['default'].isValidStackOption(this.options.stackType);
	        var seriesDataModel = this._getSeriesDataModel();
	        var groupSize = baseGroupSize / seriesDataModel.getGroupCount();
	        var columnTopOffset = -this.layout.position.top + CHART_PADDING;
	        var zeroToMin = this._getLimitDistanceFromZeroPoint(baseBarSize, this.limit).toMin;
	        var positionValue = void 0,
	            baseBounds = void 0;
	
	        if (_predicate2['default'].isColumnChart(this.chartType)) {
	            positionValue = columnTopOffset;
	        } else if (_predicate2['default'].isBoxplotChart(this.chartType)) {
	            positionValue = this.layout.position.top - CHART_PADDING;
	        } else {
	            positionValue = this.layout.position.left;
	        }
	
	        if (seriesDataModel.rawSeriesData.length > 0) {
	            var itemCount = void 0;
	
	            if (!isStackType) {
	                itemCount = seriesDataModel.getFirstSeriesGroup().getSeriesItemCount();
	            } else {
	                itemCount = this.options.diverging ? 1 : this.dataProcessor.getStackCount(this.seriesType);
	            }
	
	            var pointInterval = groupSize / (itemCount + 1);
	            var optionSize = this.options.barWidth || this.options.pointWidth;
	
	            var barSize = pointInterval * DEFAULT_BAR_SIZE_RATIO_BY_POINT_INTERVAL;
	            var basePosition = zeroToMin + positionValue;
	
	            barSize = this._getBarWidthOptionSize(pointInterval, optionSize) || barSize;
	
	            if (_predicate2['default'].isColumnChart(this.chartType)) {
	                basePosition = baseBarSize - basePosition;
	            }
	
	            if (_predicate2['default'].isBoxplotChart(this.chartType) && zeroToMin) {
	                basePosition -= zeroToMin * 2;
	            }
	
	            baseBounds = {
	                baseBarSize: baseBarSize,
	                groupSize: groupSize,
	                barSize: barSize,
	                pointInterval: pointInterval,
	                basePosition: basePosition,
	                itemCount: itemCount,
	                firstAdditionalPosition: pointInterval
	            };
	        }
	
	        return baseBounds;
	    };
	
	    /**
	     * Render normal series label.
	     * @param {object} paper paper
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    BarTypeSeriesBase.prototype._renderNormalSeriesLabel = function _renderNormalSeriesLabel(paper) {
	        var _this = this;
	
	        var graphRenderer = this.graphRenderer;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var boundsSet = this.seriesData.groupBounds;
	        var labelTheme = this.theme.label;
	        var selectedIndex = this.selectedLegendIndex;
	        var groupLabels = seriesDataModel.map(function (seriesGroup) {
	            return seriesGroup.map(function (_ref) {
	                var start = _ref.start,
	                    startLabel = _ref.startLabel,
	                    endLabel = _ref.endLabel;
	
	                var label = {
	                    end: _this.decorateLabel(endLabel)
	                };
	
	                if (_tuiCodeSnippet2['default'].isExisty(start)) {
	                    label.start = _this.decorateLabel(startLabel);
	                }
	
	                return label;
	            });
	        });
	
	        var positionsSet = void 0;
	
	        if (_predicate2['default'].isBarChart(this.chartType)) {
	            positionsSet = _renderingLabelHelper2['default'].boundsToLabelPositionsForBarChart(seriesDataModel, boundsSet, labelTheme);
	        } else {
	            positionsSet = _renderingLabelHelper2['default'].boundsToLabelPositionsForColumnChart(seriesDataModel, boundsSet, labelTheme);
	        }
	
	        return graphRenderer.renderSeriesLabel(paper, positionsSet, groupLabels, labelTheme, selectedIndex);
	    };
	
	    /**
	     * Make sum values.
	     * @param {Array.<number>} values values
	     * @returns {number} sum result.
	     * @private
	     */
	
	
	    BarTypeSeriesBase.prototype._makeSumValues = function _makeSumValues(values) {
	        return _renderUtil2['default'].formatValue({
	            value: _calculator2['default'].sum(values),
	            formatFunctions: this.dataProcessor.getFormatFunctions(),
	            chartType: this.chartType,
	            areaType: 'series'
	        });
	    };
	
	    /**
	     * Make stackType label position.
	     * @param {{width: number, height: number, left: number, top: number}} bound element bound
	     * @returns {{left: number, top: number}} position
	     * @private
	     */
	
	
	    BarTypeSeriesBase.prototype._makeStackedLabelPosition = function _makeStackedLabelPosition(_ref2) {
	        var top = _ref2.top,
	            left = _ref2.left,
	            width = _ref2.width,
	            height = _ref2.height;
	
	        return {
	            left: left + width / 2,
	            top: top + height / 2
	        };
	    };
	
	    /**
	     * Make labels html, when has stackType option.
	     * @param {object} params parameters
	     *      @param {number} params.groupIndex group index
	     *      @param {Array.<object>} params.bounds bounds,
	     * @returns {string} label positions
	     * @private
	     */
	
	
	    BarTypeSeriesBase.prototype._makeStackedLabelPositions = function _makeStackedLabelPositions(params) {
	        var _this2 = this;
	
	        var seriesGroup = params.seriesGroup;
	
	        var positions = seriesGroup.map(function (seriesItem, index) {
	            var bound = params.bounds[index];
	            var position = void 0;
	
	            if (bound && seriesItem) {
	                position = _this2._makeStackedLabelPosition(bound.end);
	            }
	
	            return {
	                end: position
	            };
	        });
	
	        return positions;
	    };
	
	    BarTypeSeriesBase.prototype.getGroupLabels = function getGroupLabels(seriesDataModel, sumPlusValues, sumMinusValues) {
	        var _this3 = this;
	
	        var isNormalStack = _predicate2['default'].isNormalStack(this.options.stackType);
	
	        return seriesDataModel.map(function (seriesGroup) {
	            var labels = seriesGroup.map(function (seriesDatum) {
	                return {
	                    end: _this3.decorateLabel(seriesDatum.endLabel)
	                };
	            });
	
	            if (isNormalStack) {
	                sumPlusValues.push(_calculator2['default'].sumPlusValues(seriesGroup.pluck('value')));
	
	                var minusSum = _calculator2['default'].sumMinusValues(seriesGroup.pluck('value'));
	                if (minusSum < 0) {
	                    sumMinusValues.push(minusSum);
	                }
	            }
	
	            return labels;
	        });
	    };
	
	    BarTypeSeriesBase.prototype.getGroupPositions = function getGroupPositions(seriesDataModel, groupBounds) {
	        var _this4 = this;
	
	        return seriesDataModel.map(function (seriesGroup, index) {
	            return _this4._makeStackedLabelPositions({
	                seriesGroup: seriesGroup,
	                bounds: groupBounds[index]
	            });
	        });
	    };
	
	    /**
	     * Render series label, when has stackType option.
	     * @param {object} paper paper
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    BarTypeSeriesBase.prototype._renderStackedSeriesLabel = function _renderStackedSeriesLabel(paper) {
	        var _this5 = this;
	
	        var sumPlusValues = [];
	        var sumMinusValues = [];
	        var labelTheme = this.theme.label;
	        var groupBounds = this.seriesData.groupBounds;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var groupPositions = this.getGroupPositions(seriesDataModel, groupBounds);
	        var groupLabels = this.getGroupLabels(seriesDataModel, sumPlusValues, sumMinusValues);
	        var isStacked = true;
	        var isNormalStack = _predicate2['default'].isNormalStack(this.options.stackType);
	        var isBarChart = _predicate2['default'].isBarChart(this.chartType);
	        var dimensionType = isBarChart ? 'width' : 'height';
	        var positionType = isBarChart ? 'left' : 'top';
	        var direction = isBarChart ? 1 : -1;
	
	        if (isNormalStack) {
	            groupLabels.forEach(function (labels, index) {
	                var plusSumValue = sumPlusValues[index];
	                var minusSumValue = sumMinusValues[index];
	
	                if (minusSumValue < 0 && _this5.options.diverging) {
	                    minusSumValue *= -1;
	                }
	
	                labels.push({
	                    end: _this5.decorateLabel(_renderUtil2['default'].formatToComma(plusSumValue))
	                });
	
	                if (sumMinusValues.length) {
	                    labels.push({
	                        end: _this5.decorateLabel(_renderUtil2['default'].formatToComma(minusSumValue))
	                    });
	                }
	            });
	
	            groupPositions.forEach(function (positions, index) {
	                var bounds = groupBounds[index];
	                var lastBound = bounds[bounds.length - 1].end;
	                var firstBound = bounds[Math.max(parseInt(bounds.length / 2, 10), 1) - 1].end;
	                var plusEnd = _this5._makeStackedLabelPosition(lastBound);
	                var minusEnd = _this5._makeStackedLabelPosition(firstBound);
	                var plusLabel = sumPlusValues[index];
	                var minusLabel = sumMinusValues[index];
	                var plusLabelSize = _raphaelRenderUtil2['default'].getRenderedTextSize(plusLabel, labelTheme.fontSize, labelTheme.fontFamily);
	                var minusLabelSize = _raphaelRenderUtil2['default'].getRenderedTextSize(minusLabel, labelTheme.fontSize, labelTheme.fontFamily);
	                var lastBoundEndPosition = (lastBound[dimensionType] + plusLabelSize[dimensionType]) / 2;
	                var firstBoundStartPosition = (firstBound[dimensionType] + minusLabelSize[dimensionType]) / 2;
	
	                plusEnd[positionType] += (lastBoundEndPosition + LEGEND_LABEL_LEFT_PADDING) * direction;
	                minusEnd[positionType] -= (firstBoundStartPosition + LEGEND_LABEL_LEFT_PADDING) * direction;
	
	                positions.push({
	                    end: plusEnd
	                });
	                if (sumMinusValues.length) {
	                    positions.push({
	                        end: minusEnd
	                    });
	                }
	            });
	        }
	
	        return this.graphRenderer.renderSeriesLabel(paper, groupPositions, groupLabels, labelTheme, isStacked);
	    };
	
	    /**
	     * Render series label.
	     * @param {object} paper paper
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    BarTypeSeriesBase.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
	        if (this.options.stackType) {
	            return this._renderStackedSeriesLabel(paper);
	        }
	
	        return this._renderNormalSeriesLabel(paper);
	    };
	
	    return BarTypeSeriesBase;
	}();
	
	BarTypeSeriesBase.mixin = function (func) {
	    Object.assign(func.prototype, BarTypeSeriesBase.prototype);
	};
	
	exports['default'] = BarTypeSeriesBase;

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * @fileoverview  renderingLabelHelper is helper for rendering of series label.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	var MAX_HEIGHT_WORD = _const2['default'].MAX_HEIGHT_WORD,
	    SERIES_LABEL_PADDING = _const2['default'].SERIES_LABEL_PADDING;
	
	/**
	 * renderingLabelHelper is helper for rendering of series label.
	 * @module renderingLabelHelper
	 * @private
	 */
	
	exports['default'] = {
	    /**
	     * Calculate left position for center align of series label.
	     * @param {{left: number, top: number, width:number, height: number}} bound - bound
	     * @returns {number}
	     * @private
	     */
	    _calculateLeftPositionForCenterAlign: function _calculateLeftPositionForCenterAlign(bound) {
	        return bound.left + bound.width / 2;
	    },
	
	
	    /**
	     * Calculate top position for middle align of series label.
	     * @param {{left: number, top: number, width:number, height: number}} bound - bound
	     * @returns {number}
	     * @private
	     */
	    _calculateTopPositionForMiddleAlign: function _calculateTopPositionForMiddleAlign(bound) {
	        return bound.top + bound.height / 2;
	    },
	
	
	    /**
	     * Make position for type of bound for rendering label.
	     * @param {{left: number, top: number, width:number, height: number}} bound - bound
	     * @returns {{left: number, top: number}}
	     * @private
	     */
	    _makePositionForBoundType: function _makePositionForBoundType(bound) {
	        return {
	            left: this._calculateLeftPositionForCenterAlign(bound),
	            top: this._calculateTopPositionForMiddleAlign(bound)
	        };
	    },
	
	
	    /**
	     * Make position map for rendering label.
	     * @param {SeriesItem} seriesItem - series itemyuio
	     * @param {{left: number, top: number, width: number, height: number}} bound - bound
	     * @param {number} labelHeight - label height
	     * @param {object} theme - theme for series label
	     * @param {function} makePosition - function for making position of label
	     * @returns {{end: *}}
	     * @private
	     */
	    _makePositionMap: function _makePositionMap(seriesItem, bound, labelHeight, theme, makePosition) {
	        var value = seriesItem.value;
	
	        var isOppositeSide = value >= 0;
	
	        var positionMap = {
	            end: makePosition(bound, labelHeight, seriesItem.endLabel || seriesItem.label, theme, isOppositeSide)
	        };
	
	        if (seriesItem.isRange) {
	            isOppositeSide = value < 0;
	            positionMap.start = makePosition(bound, labelHeight, seriesItem.startLabel, theme, isOppositeSide);
	        }
	
	        return positionMap;
	    },
	
	
	    /**
	     * Bounds to label positions.
	     * @param {SeriesDataModel} seriesDataModel - series data model
	     * @param {Array.<Array.<{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set
	     * @param {object} theme - theme for series label
	     * @param {function} [makePosition] - function for making position of label
	     * @param {boolean} [isPivot] - whether pivot or not
	     * @returns {Array.<Object>}
	     */
	    boundsToLabelPositions: function boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePosition, isPivot) {
	        var _this = this;
	
	        var labelHeight = _renderUtil2['default'].getRenderedLabelHeight(MAX_HEIGHT_WORD, theme);
	
	        makePosition = makePosition || this._makePositionForBoundType.bind(this);
	        isPivot = !!isPivot;
	
	        return seriesDataModel.map(function (seriesGroup, groupIndex) {
	            var bounds = boundsSet[groupIndex];
	
	            return seriesGroup.map(function (seriesItem, index) {
	                var bound = bounds[index].end;
	
	                return _this._makePositionMap(seriesItem, bound, labelHeight, theme, makePosition);
	            });
	        }, isPivot);
	    },
	
	
	    /**
	     * Make label position for bar chart.
	     * @param {{left: number, top: number, width:number, height: number}} bound - bound
	     * @param {number} labelHeight - label height
	     * @param {string} label - label
	     * @param {object} theme - theme for series label
	     * @param {boolean} isOppositeSide - whether opossite side or not
	     * @returns {{left: number, top: number}}
	     * @private
	     */
	    _makePositionForBarChart: function _makePositionForBarChart(bound, labelHeight, label, theme, isOppositeSide) {
	        var labelWidth = _renderUtil2['default'].getRenderedLabelWidth(label, theme);
	        var left = bound.left;
	
	
	        if (isOppositeSide) {
	            left += bound.width + SERIES_LABEL_PADDING;
	        } else {
	            left -= labelWidth + SERIES_LABEL_PADDING;
	        }
	
	        return {
	            left: left,
	            top: this._calculateTopPositionForMiddleAlign(bound)
	        };
	    },
	
	
	    /**
	     * Bounds to label positions for bar chart.
	     * @param {SeriesDataModel} seriesDataModel - series data model
	     * @param {Array.<Array.<{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set
	     * @param {object} theme - theme for series label
	     * @returns {*|Array.<Object>|Array}
	     */
	    boundsToLabelPositionsForBarChart: function boundsToLabelPositionsForBarChart(seriesDataModel, boundsSet, theme) {
	        var makePositionFunction = this._makePositionForBarChart.bind(this);
	
	        return this.boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePositionFunction);
	    },
	
	
	    /**
	     * Make label position for column chart.
	     * @param {{left: number, top: number, width:number, height: number}} bound - bound
	     * @param {number} labelHeight - label height
	     * @param {string} label - label
	     * @param {object} theme - theme for series label
	     * @param {boolean} isOppositeSide - whether opossite side or not
	     * @returns {{left: number, top: number}}
	     * @private
	     */
	    _makePositionForColumnChart: function _makePositionForColumnChart(bound, labelHeight, label, theme, isOppositeSide) {
	        var top = bound.top;
	
	
	        if (isOppositeSide) {
	            top -= labelHeight + SERIES_LABEL_PADDING;
	        } else {
	            top += bound.height + SERIES_LABEL_PADDING;
	        }
	
	        return {
	            left: this._calculateLeftPositionForCenterAlign(bound),
	            top: top
	        };
	    },
	
	
	    /**
	     * Bounds to label positions for column chart.
	     * @param {SeriesDataModel} seriesDataModel - series data model
	     * @param {Array.<Array.<{left: number, top: number, width: number, height: number}>>} boundsSet - bounds set
	     * @param {object} theme - theme for series label
	     * @returns {*|Array.<Object>|Array}
	     */
	    boundsToLabelPositionsForColumnChart: function boundsToLabelPositionsForColumnChart(seriesDataModel, boundsSet, theme) {
	        var makePositionFunction = this._makePositionForColumnChart.bind(this);
	
	        return this.boundsToLabelPositions(seriesDataModel, boundsSet, theme, makePositionFunction);
	    },
	
	
	    /**
	     * Make labels html for treemap chart.
	     * @param {Array.<SeriesItem>} seriesItems - seriesItems
	     * @param {object.<string, {left: number, top: number, width: number, height: number}>} boundMap - bound map
	     * @returns {string}
	     */
	    boundsToLabelPostionsForTreemap: function boundsToLabelPostionsForTreemap(seriesItems, boundMap) {
	        var _this2 = this;
	
	        var positions = seriesItems.map(function (seriesItem) {
	            var bound = boundMap[seriesItem.id];
	            var position = void 0;
	
	            if (bound) {
	                position = _this2._makePositionForBoundType(bound);
	            }
	
	            return position;
	        });
	
	        return positions;
	    }
	};

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = columnSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _barTypeSeriesBase = __webpack_require__(409);
	
	var _barTypeSeriesBase2 = _interopRequireDefault(_barTypeSeriesBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Column chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var ColumnChartSeries = function (_Series) {
	    _inherits(ColumnChartSeries, _Series);
	
	    function ColumnChartSeries() {
	        _classCallCheck(this, ColumnChartSeries);
	
	        return _possibleConstructorReturn(this, _Series.apply(this, arguments));
	    }
	
	    /**
	     * Column chart series component.
	     * @constructs ColumnChartSeries
	     * @private
	     * @extends Series
	     * @param {object} params parameters
	     *      @param {object} params.model series model
	     *      @param {object} params.options series options
	     *      @param {object} params.theme series theme
	     */
	
	    /**
	     * Make bound of column chart.
	     * @param {number} width width
	     * @param {number} height height
	     * @param {number} left top position value
	     * @param {number} startTop start top position value
	     * @param {number} endTop end top position value
	     * @returns {{
	     *      start: {left: number, top: number, width: number, height: number},
	     *      end: {left: number, top: number, width: number, height: number}
	     * }} column chart bound
	     * @private
	     */
	    ColumnChartSeries.prototype._makeBound = function _makeBound(width, height, left, startTop, endTop) {
	        return {
	            start: {
	                top: startTop,
	                left: left,
	                width: width,
	                height: 0
	            },
	            end: {
	                top: endTop,
	                left: left,
	                width: width,
	                height: height
	            }
	        };
	    };
	
	    /**
	     * Make column chart bound.
	     * @param {{
	     *      baseBarSize: number,
	     *      groupSize: number,
	     *      barSize: number,
	     *      pointInterval: number,
	     *      firstAdditionalPosition: number,
	     *      basePosition: number
	     * }} baseData base data for making bound
	     * @param {{
	     *      baseLeft: number,
	     *      left: number,
	     *      plusTop: number,
	     *      minusTop: number,
	     *      prevStack: ?string
	     * }} iterationData iteration data
	     * @param {?boolean} isStackType whether stackType option or not.
	     * @param {SeriesItem} seriesItem series item
	     * @param {number} index index
	     * @returns {{
	     *      start: {left: number, top: number, width: number, height: number},
	     *      end: {left: number, top: number, width: number, height: number}
	     * }}
	     * @private
	     */
	
	
	    ColumnChartSeries.prototype._makeColumnChartBound = function _makeColumnChartBound(baseData, iterationData, isStackType, seriesItem, index) {
	        var baseBarSize = baseData.baseBarSize,
	            basePosition = baseData.basePosition,
	            barSize = baseData.barSize,
	            itemCount = baseData.itemCount,
	            groupSize = baseData.groupSize,
	            pointInterval = baseData.pointInterval;
	
	        var barHeight = Math.abs(baseBarSize * seriesItem.ratioDistance);
	        var barStartTop = baseBarSize * seriesItem.startRatio;
	        var startTop = basePosition + barStartTop + _const2['default'].SERIES_EXPAND_SIZE;
	        var changedStack = seriesItem.stack !== iterationData.prevStack;
	        var isOverLapBar = barSize * itemCount > groupSize;
	        var columnInterval = isOverLapBar ? pointInterval : barSize;
	        var endTop = void 0,
	            boundLeft = void 0;
	
	        if (!isStackType || !this.options.diverging && changedStack) {
	            var pointCount = isStackType ? this.dataProcessor.findStackIndex(seriesItem.stack) : index;
	            iterationData.left = iterationData.baseLeft + columnInterval * pointCount;
	            iterationData.plusTop = 0;
	            iterationData.minusTop = 0;
	        }
	
	        if (seriesItem.value >= 0) {
	            iterationData.plusTop -= barHeight;
	            endTop = startTop + iterationData.plusTop;
	        } else {
	            endTop = startTop + iterationData.minusTop;
	            iterationData.minusTop += barHeight;
	        }
	
	        iterationData.prevStack = seriesItem.stack;
	
	        if (isOverLapBar) {
	            boundLeft = iterationData.left + pointInterval - barSize / 2;
	        } else {
	            boundLeft = iterationData.left + pointInterval - barSize / 2 + (pointInterval - barSize) / 2 * (itemCount - 1);
	        }
	
	        return this._makeBound(barSize, barHeight, boundLeft, startTop, endTop);
	    };
	
	    /**
	     * Make bounds of column chart.
	     * @returns {Array.<Array.<object>>} bounds
	     * @private
	     */
	
	
	    ColumnChartSeries.prototype._makeBounds = function _makeBounds() {
	        var _this2 = this;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var isStackType = _predicate2['default'].isValidStackOption(this.options.stackType);
	        var _layout$dimension = this.layout.dimension,
	            width = _layout$dimension.width,
	            height = _layout$dimension.height;
	
	        var baseData = this._makeBaseDataForMakingBound(width, height);
	
	        return seriesDataModel.map(function (seriesGroup, groupIndex) {
	            var baseLeft = groupIndex * baseData.groupSize + _this2.layout.position.left;
	            var iterationData = {
	                baseLeft: baseLeft,
	                left: baseLeft,
	                plusTop: 0,
	                minusTop: 0,
	                prevStack: null
	            };
	            var iteratee = _this2._makeColumnChartBound.bind(_this2, baseData, iterationData, isStackType);
	
	            return seriesGroup.map(iteratee);
	        });
	    };
	
	    /**
	     * Calculate left position of sum label.
	     * @param {{left: number, top: number}} bound bound
	     * @param {string} formattedSum formatted sum.
	     * @returns {number} left position value
	     * @private
	     */
	
	
	    ColumnChartSeries.prototype._calculateLeftPositionOfSumLabel = function _calculateLeftPositionOfSumLabel(_ref, formattedSum) {
	        var left = _ref.left,
	            width = _ref.width;
	
	        var labelWidth = _renderUtil2['default'].getRenderedLabelWidth(formattedSum, this.theme.label);
	
	        return left + (width - labelWidth + _const2['default'].TEXT_PADDING) / 2;
	    };
	
	    return ColumnChartSeries;
	}(_series2['default']);
	
	_barTypeSeriesBase2['default'].mixin(ColumnChartSeries);
	
	/**
	 * columnSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} column series instanse
	 * @ignore
	 */
	function columnSeriesFactory(params) {
	    params.libType = params.chartOptions.libType;
	    params.chartType = 'column';
	    params.chartBackground = params.chartTheme.chart.background;
	
	    return new ColumnChartSeries(params);
	}
	
	columnSeriesFactory.componentType = 'series';
	columnSeriesFactory.ColumnChartSeries = ColumnChartSeries;

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = lineSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _lineTypeSeriesBase = __webpack_require__(413);
	
	var _lineTypeSeriesBase2 = _interopRequireDefault(_lineTypeSeriesBase);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Line chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var LineChartSeries = function (_Series) {
	  _inherits(LineChartSeries, _Series);
	
	  /**
	   * Line chart series component.
	   * @constructs LineChartSeries
	   * @private
	   * @extends Series
	   * @mixes LineTypeSeriesBase
	   * @param {object} params parameters
	   *      @param {object} params.model series model
	   *      @param {object} params.options series options
	   *      @param {object} params.theme series theme
	   */
	  function LineChartSeries() {
	    _classCallCheck(this, LineChartSeries);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    /**
	     * object for requestAnimationFrame
	     * @type {null | {id: number}}
	     */
	    var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
	
	    _this.movingAnimation = null;
	    return _this;
	  }
	
	  /**
	   * Make positions for rendering graph and sending to mouse event detector.
	   * @param {number} [seriesWidth] - series width
	   * @returns {Array.<Array.<{left: number, top: number}>>} positions
	   * @private
	   */
	
	
	  LineChartSeries.prototype._makePositions = function _makePositions(seriesWidth) {
	    return this._makeBasicPositions(seriesWidth);
	  };
	
	  /**
	   * Make series data for rendering graph and sending to mouse event detector.
	   * @returns {object} series data
	   * @private
	   * @override
	   */
	
	
	  LineChartSeries.prototype._makeSeriesData = function _makeSeriesData() {
	    var groupPositions = this._makePositions();
	
	    return {
	      chartBackground: this.chartBackground,
	      groupPositions: groupPositions,
	      isAvailable: function isAvailable() {
	        return groupPositions && groupPositions.length > 0;
	      }
	    };
	  };
	
	  /**
	   * Rerender.
	   * @param {object} data - data for rerendering
	   * @override
	   */
	
	
	  LineChartSeries.prototype.rerender = function rerender(data) {
	    this._cancelMovingAnimation();
	
	    return _series2['default'].prototype.rerender.call(this, data);
	  };
	
	  return LineChartSeries;
	}(_series2['default']);
	
	_lineTypeSeriesBase2['default'].mixin(LineChartSeries);
	
	/**
	 * lineSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} linechart series instanse
	 * @ignore
	 */
	function lineSeriesFactory(params) {
	  params.libType = params.chartOptions.libType;
	  params.chartType = 'line';
	  params.chartBackground = params.chartTheme.chart.background;
	
	  return new LineChartSeries(params);
	}
	
	lineSeriesFactory.componentType = 'series';

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview LineTypeSeriesBase is base class for line type series.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var SERIES_EXPAND_SIZE = _const2['default'].SERIES_EXPAND_SIZE,
	    SERIES_LABEL_PADDING = _const2['default'].SERIES_LABEL_PADDING,
	    MAX_HEIGHT_WORD = _const2['default'].MAX_HEIGHT_WORD,
	    ADDING_DATA_ANIMATION_DURATION = _const2['default'].ADDING_DATA_ANIMATION_DURATION;
	
	/**
	 * @classdesc LineTypeSeriesBase is base class for line type series.
	 * @class LineTypeSeriesBase
	 * @private
	 * @mixin
	 * @private */
	
	var LineTypeSeriesBase = function () {
	    function LineTypeSeriesBase() {
	        _classCallCheck(this, LineTypeSeriesBase);
	    }
	
	    /**
	     * Make positions for default data type.
	     * @param {number} [seriesWidth] - width of series area
	     * @returns {Array.<Array.<object>>}
	     * @private
	     */
	    LineTypeSeriesBase.prototype._makePositionsForDefaultType = function _makePositionsForDefaultType(seriesWidth) {
	        var _layout$dimension = this.layout.dimension,
	            height = _layout$dimension.height,
	            dimensionWidth = _layout$dimension.width;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var width = seriesWidth || dimensionWidth || 0;
	        var len = seriesDataModel.getGroupCount();
	        var baseTop = this.layout.position.top;
	        var baseLeft = this.layout.position.left;
	        var step = void 0;
	
	        if (this.aligned) {
	            step = width / (len > 1 ? len - 1 : len);
	        } else {
	            step = width / len;
	            baseLeft += step / 2;
	        }
	
	        return seriesDataModel.map(function (seriesGroup) {
	            return seriesGroup.map(function (seriesItem, index) {
	                var position = void 0;
	
	                if (!_tuiCodeSnippet2['default'].isNull(seriesItem.end)) {
	                    position = {
	                        left: baseLeft + step * index,
	                        top: baseTop + height - seriesItem.ratio * height
	                    };
	
	                    if (_tuiCodeSnippet2['default'].isExisty(seriesItem.startRatio)) {
	                        position.startTop = baseTop + height - seriesItem.startRatio * height;
	                    }
	                }
	
	                return position;
	            });
	        }, true);
	    };
	
	    /**
	     * Make positions for coordinate data type.
	     * @param {number} [seriesWidth] - width of series area
	     * @returns {Array.<Array.<object>>}
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._makePositionForCoordinateType = function _makePositionForCoordinateType(seriesWidth) {
	        var dimension = this.layout.dimension;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var height = dimension.height;
	        var xAxis = this.axisDataMap.xAxis;
	
	        var baseTop = this.layout.position.top;
	        var baseLeft = this.layout.position.left;
	        var width = seriesWidth || dimension.width || 0;
	        var additionalLeft = 0;
	
	        if (xAxis.sizeRatio) {
	            additionalLeft = _calculator2['default'].multiply(width, xAxis.positionRatio);
	            width = _calculator2['default'].multiply(width, xAxis.sizeRatio);
	        }
	
	        return seriesDataModel.map(function (seriesGroup) {
	            return seriesGroup.map(function (seriesItem) {
	                var position = void 0;
	
	                if (!_tuiCodeSnippet2['default'].isNull(seriesItem.end)) {
	                    position = {
	                        left: baseLeft + seriesItem.ratioMap.x * width + additionalLeft,
	                        top: baseTop + height - seriesItem.ratioMap.y * height
	                    };
	
	                    if (_tuiCodeSnippet2['default'].isExisty(seriesItem.ratioMap.start)) {
	                        position.startTop = height - seriesItem.ratioMap.start * height + _const2['default'].SERIES_EXPAND_SIZE;
	                    }
	                }
	
	                return position;
	            });
	        }, true);
	    };
	
	    /**
	     * Make basic positions for rendering line graph.
	     * @param {number} [seriesWidth] - width of series area
	     * @returns {Array.<Array.<object>>}
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._makeBasicPositions = function _makeBasicPositions(seriesWidth) {
	        if (this.dataProcessor.isCoordinateType()) {
	            return this._makePositionForCoordinateType(seriesWidth);
	        }
	
	        return this._makePositionsForDefaultType(seriesWidth);
	    };
	
	    /**
	     * Calculate label position top.
	     * @param {{top: number, startTop: number}} basePosition - base position
	     * @param {number} value - value of seriesItem
	     * @param {number} labelHeight - label height
	     * @param {boolean} [isStart] - whether start value of seriesItem or not
	     * @returns {number} position top
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._calculateLabelPositionTop = function _calculateLabelPositionTop(basePosition, value, labelHeight, isStart) {
	        var baseTop = basePosition.top;
	        var top = void 0;
	
	        if (_predicate2['default'].isValidStackOption(this.options.stackType)) {
	            top = (basePosition.startTop + baseTop - labelHeight) / 2 + 1;
	        } else if (value >= 0 && !isStart || value < 0 && isStart) {
	            top = baseTop - labelHeight - SERIES_LABEL_PADDING;
	        } else {
	            top = baseTop + SERIES_LABEL_PADDING;
	        }
	
	        return top;
	    };
	
	    /**
	     * Make label position for rendering label of series area.
	     * @param {{left: number, top: number, startTop: ?number}} basePosition - base position for calculating
	     * @param {number} labelHeight - label height
	     * @param {(string | number)} label - label of seriesItem
	     * @param {number} value - value of seriesItem
	     * @param {boolean} [isStart] - whether start label position or not
	     * @returns {{left: number, top: number}}
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._makeLabelPosition = function _makeLabelPosition(basePosition, labelHeight, label, value, isStart) {
	        return {
	            left: basePosition.left,
	            top: this._calculateLabelPositionTop(basePosition, value, labelHeight / 2, isStart)
	
	        };
	    };
	
	    /**
	     * Get label positions for line type chart
	     * @param {object} seriesDataModel series data model
	     * @param {object} theme label theme
	     * @returns {object}
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._getLabelPositions = function _getLabelPositions(seriesDataModel, theme) {
	        var _this = this;
	
	        var basePositions = _arrayUtil2['default'].pivot(this.seriesData.groupPositions);
	        var labelHeight = _renderUtil2['default'].getRenderedLabelHeight(MAX_HEIGHT_WORD, theme);
	
	        return seriesDataModel.map(function (seriesGroup, groupIndex) {
	            return seriesGroup.map(function (seriesItem, index) {
	                var basePosition = basePositions[groupIndex][index];
	                var end = _this._makeLabelPosition(basePosition, labelHeight, seriesItem.endLabel, seriesItem.end);
	                var position = { end: end };
	
	                if (seriesItem.isRange) {
	                    basePosition.top = basePosition.startTop;
	                    position.start = _this._makeLabelPosition(basePosition, labelHeight, seriesItem.startLabel, seriesItem.start);
	                }
	
	                return position;
	            });
	        });
	    };
	
	    /**
	     * Get label texts
	     * @param {object} seriesDataModel sereis data model
	     * @returns {Array.<string>}
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._getLabelTexts = function _getLabelTexts(seriesDataModel) {
	        var _this2 = this;
	
	        return seriesDataModel.map(function (seriesGroup) {
	            return seriesGroup.map(function (_ref) {
	                var endLabel = _ref.endLabel,
	                    isRange = _ref.isRange,
	                    startLabel = _ref.startLabel;
	
	                var label = {
	                    end: _this2.decorateLabel(endLabel)
	                };
	
	                if (isRange) {
	                    label.start = _this2.decorateLabel(startLabel);
	                }
	
	                return label;
	            });
	        });
	    };
	
	    /**
	     * Render series label.
	     * @param {object} paper paper
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
	        var theme = this.theme.label;
	        var seriesDataModel = this._getSeriesDataModel();
	        var groupLabels = this._getLabelTexts(seriesDataModel);
	        var positionsSet = this._getLabelPositions(seriesDataModel, theme);
	
	        return this.graphRenderer.renderSeriesLabel(paper, positionsSet, groupLabels, theme);
	    };
	
	    /**
	     * To call showGroupTooltipLine function of graphRenderer.
	     * @param {{
	     *      dimension: {width: number, height: number},
	     *      position: {left: number, top: number}
	     * }} bound bound
	     */
	
	
	    LineTypeSeriesBase.prototype.onShowGroupTooltipLine = function onShowGroupTooltipLine(bound) {
	        if (!this.graphRenderer.showGroupTooltipLine) {
	            return;
	        }
	
	        this.graphRenderer.showGroupTooltipLine(bound, this.layout);
	    };
	
	    /**
	     * To call hideGroupTooltipLine function of graphRenderer.
	     */
	
	
	    LineTypeSeriesBase.prototype.onHideGroupTooltipLine = function onHideGroupTooltipLine() {
	        if (!this.isAvailableSeriesData() || !this.graphRenderer.hideGroupTooltipLine) {
	            return;
	        }
	        this.graphRenderer.hideGroupTooltipLine();
	    };
	
	    /**
	     * Zoom by mouse drag.
	     * @param {object} data - data
	     */
	
	
	    LineTypeSeriesBase.prototype.zoom = function zoom(data) {
	        this._cancelMovingAnimation();
	        this._clearSeriesContainer(data.paper);
	        this._setDataForRendering(data);
	        this._renderSeriesArea(data.paper, _tuiCodeSnippet2['default'].bind(this._renderGraph, this));
	        this.animateComponent(true);
	
	        if (!_tuiCodeSnippet2['default'].isNull(this.selectedLegendIndex)) {
	            this.graphRenderer.selectLegend(this.selectedLegendIndex);
	        }
	    };
	
	    /**
	     * Whether changed or not.
	     * @param {{min: number, max: number}} before - before limit
	     * @param {{min: number, max: number}} after - after limit
	     * @returns {boolean}
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._isChangedLimit = function _isChangedLimit(before, after) {
	        return before.min !== after.min || before.max !== after.max;
	    };
	
	    /**
	     * Whether changed axis limit(min, max) or not.
	     * @returns {boolean}
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._isChangedAxisLimit = function _isChangedAxisLimit() {
	        var beforeAxisDataMap = this.beforeAxisDataMap,
	            axisDataMap = this.axisDataMap;
	
	        var changed = true;
	
	        if (beforeAxisDataMap) {
	            changed = this._isChangedLimit(beforeAxisDataMap.yAxis.limit, axisDataMap.yAxis.limit);
	
	            if (axisDataMap.xAxis.limit) {
	                changed = changed || this._isChangedLimit(beforeAxisDataMap.xAxis.limit, axisDataMap.xAxis.limit);
	            }
	        }
	
	        this.beforeAxisDataMap = axisDataMap;
	
	        return changed;
	    };
	
	    /**
	     * Animate for motion of series area.
	     * @param {function} callback - callback function
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._animate = function _animate(callback) {
	        var _this3 = this;
	
	        var duration = ADDING_DATA_ANIMATION_DURATION;
	        var changedLimit = this._isChangedAxisLimit();
	
	        if (changedLimit && this.seriesLabelContainer) {
	            this.seriesLabelContainer.innerHTML = '';
	        }
	
	        if (!callback) {
	            return;
	        }
	
	        this.movingAnimation = _renderUtil2['default'].startAnimation(duration, callback, function () {
	            _this3.movingAnimation = null;
	        });
	    };
	
	    /**
	     * Make top of zero point for adding data.
	     * @returns {number}
	     * @private
	     * @override
	     */
	
	
	    LineTypeSeriesBase.prototype._makeZeroTopForAddingData = function _makeZeroTopForAddingData() {
	        var seriesHeight = this.layout.dimension.height;
	        var limit = this.axisDataMap.yAxis.limit;
	
	
	        return this._getLimitDistanceFromZeroPoint(seriesHeight, limit).toMax + SERIES_EXPAND_SIZE;
	    };
	
	    /**
	     * Animate for adding data.
	     * @param {{tickSize: number}} data - parameters for adding data.
	     */
	
	
	    LineTypeSeriesBase.prototype.animateForAddingData = function animateForAddingData(_ref2) {
	        var tickSize = _ref2.tickSize,
	            limitMap = _ref2.limitMap,
	            axisDataMap = _ref2.axisDataMap;
	
	        var dimension = this.dimensionMap.extendedSeries;
	        var shiftingOption = this.options.shifting;
	        var seriesWidth = this.layout.dimension.width;
	
	        this.limit = limitMap[this.chartType];
	        this.axisDataMap = axisDataMap;
	
	        var seriesData = this._makeSeriesData();
	        var paramsForRendering = this._makeParamsForGraphRendering(dimension, seriesData);
	
	        if (shiftingOption) {
	            seriesWidth += tickSize;
	        }
	
	        var groupPositions = this._makePositions(seriesWidth);
	        var zeroTop = this._makeZeroTopForAddingData();
	
	        this.graphRenderer.animateForAddingData(paramsForRendering, tickSize, groupPositions, shiftingOption, zeroTop);
	    };
	
	    /**
	     * Cancel moving animation.
	     * @private
	     */
	
	
	    LineTypeSeriesBase.prototype._cancelMovingAnimation = function _cancelMovingAnimation() {
	        if (this.movingAnimation) {
	            cancelAnimationFrame(this.movingAnimation.id);
	            this.movingAnimation = null;
	        }
	    };
	
	    return LineTypeSeriesBase;
	}();
	
	LineTypeSeriesBase.mixin = function (func) {
	    _tuiCodeSnippet2['default'].extend(func.prototype, LineTypeSeriesBase.prototype);
	};
	
	exports['default'] = LineTypeSeriesBase;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = radialSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _geometric = __webpack_require__(376);
	
	var _geometric2 = _interopRequireDefault(_geometric);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Radial chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var COMPONENT_TYPE_RAPHAEL = _const2['default'].COMPONENT_TYPE_RAPHAEL,
	    RADIAL_PLOT_PADDING = _const2['default'].RADIAL_PLOT_PADDING,
	    RADIAL_MARGIN_FOR_CATEGORY = _const2['default'].RADIAL_MARGIN_FOR_CATEGORY;
	
	var RadialChartSeries = function (_Series) {
	    _inherits(RadialChartSeries, _Series);
	
	    /**
	     * Line chart series component.
	     * @constructs RadialChartSeries
	     * @private
	     * @extends Series
	     * @param {object} params parameters
	     *      @param {object} params.model series model
	     *      @param {object} params.options series options
	     *      @param {object} params.theme series theme
	     */
	    function RadialChartSeries() {
	        _classCallCheck(this, RadialChartSeries);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
	
	        _this.options = Object.assign({
	            showDot: false,
	            showArea: false
	        }, _this.options);
	
	        /**
	         * object for requestAnimationFrame
	         * @type {null | {id: number}}
	         */
	        _this.movingAnimation = null;
	
	        _this.drawingType = COMPONENT_TYPE_RAPHAEL;
	        return _this;
	    }
	
	    /**
	     * Make positions data for radial series
	     * @param {Array.<Array>} seriesGroups series data per category
	     * @param {number} groupCount category count
	     * @returns {Array.<Array.<object>>}
	     * @private
	     */
	
	
	    RadialChartSeries.prototype._makePositionsForRadial = function _makePositionsForRadial(seriesGroups, groupCount) {
	        var _layout = this.layout,
	            dimension = _layout.dimension,
	            _layout$position = _layout.position,
	            top = _layout$position.top,
	            left = _layout$position.left;
	
	        var width = dimension.width - RADIAL_PLOT_PADDING - RADIAL_MARGIN_FOR_CATEGORY;
	        var height = dimension.height - RADIAL_PLOT_PADDING - RADIAL_MARGIN_FOR_CATEGORY;
	        var centerX = _calculator2['default'].sum([width / 2, RADIAL_PLOT_PADDING / 2, RADIAL_MARGIN_FOR_CATEGORY / 2, left]);
	        var centerY = _calculator2['default'].sum([height / 2, -(RADIAL_PLOT_PADDING / 2), -(RADIAL_MARGIN_FOR_CATEGORY / 2), -top]);
	
	        var stepAngle = 360 / groupCount;
	
	        var radius = Math.min(width, height) / 2;
	
	        return seriesGroups.map(function (seriesGroup) {
	            var positions = seriesGroup.map(function (seriesItem, index) {
	                var position = void 0;
	
	                if (!_tuiCodeSnippet2['default'].isNull(seriesItem.end)) {
	                    var valueSize = seriesItem.ratio * radius;
	
	                    // center y + real vaule size
	                    var y = centerY + valueSize;
	
	                    // turn angle to clockwise
	                    var angle = 360 - stepAngle * index;
	
	                    var point = _geometric2['default'].rotatePointAroundOrigin(centerX, centerY, centerX, y, angle);
	
	                    position = {
	                        left: point.x,
	                        top: height - point.y // convert y coordinate to top
	                    };
	                }
	
	                return position;
	            });
	
	            positions.push(positions[0]);
	
	            return positions;
	        });
	    };
	
	    /**
	     * Get pivoted seriesGroups
	     * @returns {Array.<Array>} series group
	     * @private
	     */
	
	
	    RadialChartSeries.prototype._getSeriesGroups = function _getSeriesGroups() {
	        var seriesDataModel = this._getSeriesDataModel();
	
	        return seriesDataModel.map(function (group) {
	            return group.map(function (item) {
	                return item;
	            });
	        }, true);
	    };
	
	    /**
	     * Make series data for rendering graph and sending to mouse event detector.
	     * @returns {object} series data
	     * @private
	     * @override
	     */
	
	
	    RadialChartSeries.prototype._makeSeriesData = function _makeSeriesData() {
	        var groups = this._getSeriesGroups();
	        var groupPositions = this._makePositionsForRadial(groups, this._getSeriesDataModel().getGroupCount());
	
	        return {
	            groupPositions: groupPositions,
	            isAvailable: function isAvailable() {
	                return groupPositions && groupPositions.length > 0;
	            }
	        };
	    };
	
	    /**
	     * Rerender.
	     * @param {object} data - data for rerendering
	     * @returns {Raphael.Paper} raphael paper
	     * @override
	     */
	
	
	    RadialChartSeries.prototype.rerender = function rerender(data) {
	        return _series2['default'].prototype.rerender.call(this, data);
	    };
	
	    return RadialChartSeries;
	}(_series2['default']);
	
	/**
	 * radialSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} radial series instanse
	 * @ignore
	 */
	
	
	function radialSeriesFactory(params) {
	    params.libType = params.chartOptions.libType;
	    params.chartType = params.chartOptions.chartType;
	    params.chartBackground = params.chartTheme.background;
	
	    return new RadialChartSeries(params);
	}
	
	radialSeriesFactory.componentType = 'series';
	radialSeriesFactory.RadialChartSeries = RadialChartSeries;

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = areaSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _lineTypeSeriesBase = __webpack_require__(413);
	
	var _lineTypeSeriesBase2 = _interopRequireDefault(_lineTypeSeriesBase);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Area chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var AreaChartSeries = function (_Series) {
	    _inherits(AreaChartSeries, _Series);
	
	    /**
	     * Area chart series component.
	     * @constructs AreaChartSeries
	     * @private
	     * @extends Series
	     * @mixes LineTypeSeriesBase
	     */
	    function AreaChartSeries() {
	        _classCallCheck(this, AreaChartSeries);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        /**
	         * object for requestAnimationFrame
	         * @type {null | {id: number}}
	         */
	        var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
	
	        _this.movingAnimation = null;
	        return _this;
	    }
	
	    /**
	     * Make position top of zero point.
	     * @returns {number} position top
	     * @private
	     */
	
	
	    AreaChartSeries.prototype._makePositionTopOfZeroPoint = function _makePositionTopOfZeroPoint() {
	        var _layout = this.layout,
	            height = _layout.dimension.height,
	            baseTop = _layout.position.top;
	        var limit = this.axisDataMap.yAxis.limit;
	
	        var top = this._getLimitDistanceFromZeroPoint(height, limit).toMax + baseTop;
	
	        if (limit.min >= 0 && !top) {
	            top = height;
	        }
	
	        return top;
	    };
	
	    /**
	     * Make positions, when has stackType option.
	     * @param {Array.<Array.<{left: number, top: number}>>} groupPositions group positions
	     * @returns {Array.<Array.<{left: number, top: number, startTop: number}>>} stackType positions
	     * @private
	     */
	
	
	    AreaChartSeries.prototype._makeStackedPositions = function _makeStackedPositions(groupPositions) {
	        var _layout2 = this.layout,
	            height = _layout2.dimension.height,
	            baseTop = _layout2.position.top;
	
	
	        var firstStartTop = this._makePositionTopOfZeroPoint();
	        var prevPositionTops = [];
	
	        return groupPositions.map(function (positions) {
	            return positions.map(function (position, index) {
	                var prevTop = prevPositionTops[index] || firstStartTop;
	                var positionTop = position ? position.top : 0;
	                var stackedHeight = height - positionTop + baseTop;
	                var top = position ? prevTop - stackedHeight : prevTop;
	
	                if (position) {
	                    position.startTop = prevTop;
	                    position.top = top;
	                }
	
	                prevPositionTops[index] = top;
	
	                return position;
	            });
	        });
	    };
	
	    /**
	     * Make series positions.
	     * @param {number} seriesWidth - width of series area
	     * @returns {Array.<Array.<{left: number, top: number, startTop: number}>>} stackType positions
	     * @private
	     */
	
	
	    AreaChartSeries.prototype._makePositions = function _makePositions(seriesWidth) {
	        var groupPositions = this._makeBasicPositions(seriesWidth);
	
	        if (_predicate2['default'].isValidStackOption(this.options.stackType)) {
	            groupPositions = this._makeStackedPositions(groupPositions);
	        }
	
	        return groupPositions;
	    };
	
	    /**
	     * Make series data.
	     * @returns {object} series data
	     * @private
	     * @override
	     */
	
	
	    AreaChartSeries.prototype._makeSeriesData = function _makeSeriesData() {
	        var _layout3 = this.layout,
	            height = _layout3.dimension.height,
	            baseTop = _layout3.position.top;
	
	        var zeroTop = this._getLimitDistanceFromZeroPoint(height, this.limit).toMax + baseTop;
	        var groupPositions = this._makePositions();
	
	        return {
	            chartBackground: this.chartBackground,
	            groupPositions: groupPositions,
	            hasRangeData: this._getSeriesDataModel().hasRangeData(),
	            zeroTop: zeroTop,
	            isAvailable: function isAvailable() {
	                return groupPositions && groupPositions.length > 0;
	            }
	        };
	    };
	
	    /**
	     * Rerender.
	     * @param {object} data - data for rerendering
	     * @override
	     */
	
	
	    AreaChartSeries.prototype.rerender = function rerender(data) {
	        this._cancelMovingAnimation();
	
	        return _series2['default'].prototype.rerender.call(this, data);
	    };
	
	    return AreaChartSeries;
	}(_series2['default']);
	
	_lineTypeSeriesBase2['default'].mixin(AreaChartSeries);
	
	/**
	 * areaSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} areaChart series instanse
	 * @ignore
	 */
	function areaSeriesFactory(params) {
	    var chartTheme = params.chartTheme,
	        libType = params.chartOptions.libType;
	
	
	    params.libType = libType;
	    params.chartType = 'area';
	    params.chartBackground = chartTheme.chart.background;
	
	    return new AreaChartSeries(params);
	}
	
	areaSeriesFactory.componentType = 'series';
	areaSeriesFactory.AreaChartSeries = AreaChartSeries;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = bubbleSeriesFactory;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _coordinateTypeSeriesBase = __webpack_require__(417);
	
	var _coordinateTypeSeriesBase2 = _interopRequireDefault(_coordinateTypeSeriesBase);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Bubble chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var BubbleChartSeries = function (_Series) {
	    _inherits(BubbleChartSeries, _Series);
	
	    /**
	     * Bubble chart series component.
	     * @constructs BubbleChartSeries
	     * @private
	     * @extends Series
	     */
	    function BubbleChartSeries() {
	        _classCallCheck(this, BubbleChartSeries);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        /**
	         * previous clicked index.
	         * @type {?number}
	         */
	        var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
	
	        _this.prevClickedIndex = null;
	
	        /**
	         * max radius for rendering circle graph
	         * @type {null|number}
	         */
	        _this.maxRadius = null;
	
	        _this.drawingType = _const2['default'].COMPONENT_TYPE_RAPHAEL;
	        return _this;
	    }
	
	    /**
	     * Calculate step value for label axis.
	     * @returns {number}
	     * @private
	     */
	
	
	    BubbleChartSeries.prototype._calculateStep = function _calculateStep() {
	        var hasVerticalCategory = this.dataProcessor.isXCountGreaterThanYCount(this.chartType);
	        var step = 0;
	
	        if (this.dataProcessor.hasCategories(hasVerticalCategory)) {
	            var dimension = this.layout.dimension;
	
	            var len = this.dataProcessor.getCategoryCount(hasVerticalCategory);
	            var size = void 0;
	
	            if (hasVerticalCategory) {
	                size = dimension.height;
	            } else {
	                size = dimension.width;
	            }
	
	            step = size / len;
	        }
	
	        return step;
	    };
	
	    /**
	     * Make bound for bubble chart.
	     * @param {{x: number, y: number, r: number}} ratioMap - ratio map
	     * @param {number} positionByStep - position value by step
	     * @param {number} maxRadius - max radius
	     * @returns {{left: number, top: number, radius: number}}
	     * @private
	     */
	
	
	    BubbleChartSeries.prototype._makeBound = function _makeBound(ratioMap, positionByStep, maxRadius) {
	        var _layout = this.layout,
	            _layout$dimension = _layout.dimension,
	            width = _layout$dimension.width,
	            height = _layout$dimension.height,
	            position = _layout.position;
	
	        var left = _tuiCodeSnippet2['default'].isExisty(ratioMap.x) ? ratioMap.x * width : positionByStep;
	        var top = _tuiCodeSnippet2['default'].isExisty(ratioMap.y) ? ratioMap.y * height : positionByStep;
	
	        return {
	            left: position.left + left,
	            top: position.top + height - top,
	            radius: Math.max(maxRadius * ratioMap.r, 2)
	        };
	    };
	
	    /**
	     * Make bounds for bubble chart.
	     * @returns {Array.<Array.<{left: number, top: number, radius: number}>>} positions
	     * @private
	     */
	
	
	    BubbleChartSeries.prototype._makeBounds = function _makeBounds() {
	        var _this2 = this;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var maxRadius = this.maxRadius;
	
	        var step = this._calculateStep();
	        var start = step ? step / 2 : 0;
	
	        return seriesDataModel.map(function (seriesGroup, index) {
	            var positionByStep = start + step * index;
	
	            return seriesGroup.map(function (seriesItem) {
	                var hasRationMap = seriesItem && seriesItem.ratioMap;
	
	                return hasRationMap ? _this2._makeBound(seriesItem.ratioMap, positionByStep, maxRadius) : null;
	            });
	        });
	    };
	
	    /**
	     * Set data for rendering.
	     * @param {{
	     *      paper: ?object,
	     *      limit: {
	     *          min: number,
	     *          max: number
	     *      },
	     *      aligned: boolean,
	     *      layout: {
	     *          dimension: {width: number, height: number},
	     *          position: {left: number, top: number}
	     *      },
	     *      dimensionMap: object,
	     *      positionMap: object,
	     *      axisDataMap: object,
	     *      maxRadius: number
	     * }} data - data for rendering
	     * @private
	     */
	
	
	    BubbleChartSeries.prototype._setDataForRendering = function _setDataForRendering(data) {
	        this.maxRadius = data.maxRadius;
	        _series2['default'].prototype._setDataForRendering.call(this, data);
	    };
	
	    return BubbleChartSeries;
	}(_series2['default']);
	
	_coordinateTypeSeriesBase2['default'].mixin(BubbleChartSeries);
	
	/**
	 * bubbleSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} bubble series instanse
	 * @ignore
	 */
	function bubbleSeriesFactory(params) {
	    var libType = params.chartOptions.libType,
	        chartTheme = params.chartTheme;
	
	
	    params.libType = libType;
	    params.chartType = 'bubble';
	    params.chartBackground = chartTheme.chart.background;
	
	    return new BubbleChartSeries(params);
	}
	
	bubbleSeriesFactory.componentType = 'series';
	bubbleSeriesFactory.BubbleChartSeries = BubbleChartSeries;

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview CoordinateTypeSeriesBase is base class for coordinate type series.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var CoordinateTypeSeriesBase = function () {
	    function CoordinateTypeSeriesBase() {
	        _classCallCheck(this, CoordinateTypeSeriesBase);
	    }
	
	    /**
	     * Make series data.
	     * @returns {{
	     *      groupBounds: Array.<Array.<{left: number, top: number, radius: number}>>,
	     *      seriesDataModel: SeriesDataModel
	     * }} series data
	     * @private
	     * @override */
	    CoordinateTypeSeriesBase.prototype._makeSeriesData = function _makeSeriesData() {
	        var groupBounds = this._makeBounds();
	
	        return {
	            groupBounds: groupBounds,
	            seriesDataModel: this._getSeriesDataModel(),
	            isAvailable: function isAvailable() {
	                return groupBounds && groupBounds.length > 0;
	            }
	        };
	    };
	
	    /**
	     * showTooltip is callback of mouseover event to series element.
	     * @param {object} params parameters
	     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
	     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information
	     * @param {number} groupIndex group index
	     * @param {number} index index
	     * @param {{left: number, top: number}} mousePosition mouse position
	     */
	
	
	    CoordinateTypeSeriesBase.prototype.showTooltip = function showTooltip(params, bound, groupIndex, index, mousePosition) {
	        this.eventBus.fire('showTooltip', _tuiCodeSnippet2['default'].extend({
	            indexes: {
	                groupIndex: groupIndex,
	                index: index
	            },
	            mousePosition: mousePosition
	        }, params));
	    };
	
	    /**
	     * hideTooltip is callback of mouseout event to series element.
	     */
	
	
	    CoordinateTypeSeriesBase.prototype.hideTooltip = function hideTooltip() {
	        this.eventBus.fire('hideTooltip');
	    };
	
	    /**
	     * Render raphael graph.
	     * @param {{width: number, height: number}} dimension dimension
	     * @param {object} seriesData series data
	     * @param {object} paper paper object
	     * @private
	     * @override
	     */
	
	
	    CoordinateTypeSeriesBase.prototype._renderGraph = function _renderGraph(dimension, seriesData, paper) {
	        var showTooltip = this.showTooltip.bind(this, {
	            chartType: this.chartType
	        });
	        var callbacks = {
	            showTooltip: showTooltip,
	            hideTooltip: this.hideTooltip.bind(this)
	        };
	        var params = this._makeParamsForGraphRendering(dimension, seriesData);
	
	        return this.graphRenderer.render(paper, params, callbacks);
	    };
	
	    /**
	     * If click series, showing selected state.
	     * @param {{left: number, top: number}} position - mouse position
	     */
	
	
	    CoordinateTypeSeriesBase.prototype.onClickSeries = function onClickSeries(position) {
	        var indexes = this._executeGraphRenderer(position, 'findIndexes');
	        var prevIndexes = this.prevClickedIndexes;
	        var allowSelect = this.options.allowSelect,
	            chartType = this.chartType;
	
	
	        if (indexes && prevIndexes) {
	            this.onUnselectSeries({
	                chartType: chartType,
	                indexes: prevIndexes
	            });
	            this.prevClickedIndexes = null;
	        }
	
	        if (!indexes) {
	            return;
	        }
	
	        var shouldSelect = !prevIndexes || indexes.index !== prevIndexes.index || indexes.groupIndex !== prevIndexes.groupIndex;
	
	        if (allowSelect && shouldSelect) {
	            this.onSelectSeries({
	                chartType: chartType,
	                indexes: indexes
	            }, shouldSelect);
	            this.prevClickedIndexes = indexes;
	        }
	    };
	
	    /**
	     * If mouse move series, call 'moveMouseOnSeries' of graph render.
	     * @param {{left: number, top: number}} position mouse position
	     */
	
	
	    CoordinateTypeSeriesBase.prototype.onMoveSeries = function onMoveSeries(position) {
	        this._executeGraphRenderer(position, 'moveMouseOnSeries');
	    };
	
	    return CoordinateTypeSeriesBase;
	}();
	
	CoordinateTypeSeriesBase.mixin = function (func) {
	    Object.assign(func.prototype, CoordinateTypeSeriesBase.prototype);
	};
	
	exports['default'] = CoordinateTypeSeriesBase;

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = scatterSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _coordinateTypeSeriesBase = __webpack_require__(417);
	
	var _coordinateTypeSeriesBase2 = _interopRequireDefault(_coordinateTypeSeriesBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Scatter chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var ScatterChartSeries = function (_Series) {
	    _inherits(ScatterChartSeries, _Series);
	
	    /**
	     * Scatter chart series component.
	     * @constructs ScatterChartSeries
	     * @private
	     * @extends Series
	     */
	    function ScatterChartSeries() {
	        _classCallCheck(this, ScatterChartSeries);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        /**
	         * previous clicked index.
	         * @type {?number}
	         */
	        var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
	
	        _this.prevClickedIndex = null;
	        return _this;
	    }
	
	    /**
	     * Make bound for scatter chart.
	     * @param {{x: number, y: number, r: number}} ratioMap - ratio map
	     * @returns {{left: number, top: number, raius: number}}
	     * @private
	     */
	
	
	    ScatterChartSeries.prototype._makeBound = function _makeBound(ratioMap) {
	        var _layout = this.layout,
	            dimension = _layout.dimension,
	            basePosition = _layout.position;
	
	
	        return {
	            left: basePosition.left + ratioMap.x * dimension.width,
	            top: dimension.height - ratioMap.y * dimension.height + basePosition.top,
	            radius: _const2['default'].SCATTER_RADIUS
	        };
	    };
	
	    /**
	     * Make bounds for scatter chart.
	     * @returns {Array.<Array.<{left: number, top: number, radius: number}>>} positions
	     * @private
	     */
	
	
	    ScatterChartSeries.prototype._makeBounds = function _makeBounds() {
	        var _this2 = this;
	
	        var seriesDataModel = this._getSeriesDataModel();
	
	        return seriesDataModel.map(function (seriesGroup) {
	            return seriesGroup.map(function (seriesItem) {
	                var hasRatioMap = seriesItem && seriesItem.ratioMap;
	
	                return hasRatioMap ? _this2._makeBound(seriesItem.ratioMap) : null;
	            });
	        });
	    };
	
	    return ScatterChartSeries;
	}(_series2['default']);
	
	_coordinateTypeSeriesBase2['default'].mixin(ScatterChartSeries);
	
	/**
	 * scatterSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} scatter series instanse
	 * @ignore
	 */
	function scatterSeriesFactory(params) {
	    params.libType = params.chartOptions.libType;
	    params.chartType = 'scatter';
	    params.chartBackground = params.chartTheme.chart.background;
	
	    return new ScatterChartSeries(params);
	}
	
	scatterSeriesFactory.componentType = 'series';
	scatterSeriesFactory.ScatterChartSeries = ScatterChartSeries;

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = mapSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Map chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var browser = _tuiCodeSnippet2['default'].browser;
	
	var IS_LTE_IE8 = browser.msie && browser.version <= 8;
	var TOOLTIP_GAP = _const2['default'].TOOLTIP_GAP,
	    PUBLIC_EVENT_PREFIX = _const2['default'].PUBLIC_EVENT_PREFIX;
	
	var MapChartSeries = function (_Series) {
	    _inherits(MapChartSeries, _Series);
	
	    /**
	     * Map chart series component.
	     * @constructs MapChartSeries
	     * @private
	     * @extends Series
	     * @param {object} params parameters
	     *      @param {object} params.options series options
	     *      @param {object} params.theme series theme
	     *      @param {MapChartDataProcessor} params.dataProcessor data processor for map chart
	     */
	    function MapChartSeries(params) {
	        _classCallCheck(this, MapChartSeries);
	
	        /**
	         * Base position.
	         * @type {{left: number, top: number}}
	         */
	        var _this = _possibleConstructorReturn(this, _Series.call(this, params));
	
	        _this.basePosition = {
	            left: 0,
	            top: 0
	        };
	
	        /**
	         * Zoom magnification.
	         * @type {number}
	         */
	        _this.zoomMagn = 1;
	
	        /**
	         * Map ratio.
	         * @type {number}
	         */
	        _this.mapRatio = 1;
	
	        /**
	         * Graph dimension.
	         * @type {{}}
	         */
	        _this.graphDimension = {};
	
	        /**
	         * Limit position.
	         * @type {{}}
	         */
	        _this.limitPosition = {};
	
	        /**
	         * Map model.
	         * @type {MapChartMapModel}
	         */
	        _this.mapModel = params.mapModel;
	
	        /**
	         * Color spectrum
	         * @type {ColorSpectrum}
	         */
	        _this.colorSpectrum = params.colorSpectrum;
	
	        /**
	         * Previous mouse position.
	         * @type {?{left: number, top: number}}
	         */
	        _this.prevPosition = null;
	
	        /**
	         * Previous moved index.
	         * @type {?number}
	         */
	        _this.prevMovedIndex = null;
	
	        /**
	         * Whether drag or not.
	         * @type {boolean}
	         */
	        _this.isDrag = false;
	
	        /**
	         * Start position.
	         * @type {?{left: number, top: number}}
	         */
	        _this.startPosition = null;
	        return _this;
	    }
	
	    /**
	     * Attach to event bus.
	     * @private
	     */
	
	
	    MapChartSeries.prototype._attachToEventBus = function _attachToEventBus() {
	        _series2['default'].prototype._attachToEventBus.call(this);
	
	        if (!IS_LTE_IE8) {
	            this.eventBus.on({
	                dragStartMapSeries: this.onDragStartMapSeries,
	                dragMapSeries: this.onDragMapSeries,
	                dragEndMapSeries: this.onDragEndMapSeries,
	                zoomMap: this.onZoomMap
	            }, this);
	        }
	    };
	
	    /**
	     * Set map ratio.
	     * @param {object} [graphDimension] graph dimension
	     * @private
	     */
	
	
	    MapChartSeries.prototype._setMapRatio = function _setMapRatio(graphDimension) {
	        var seriesDimension = this.layout.dimension;
	        var mapDimension = graphDimension || this.mapModel.getMapDimension();
	        var widthRatio = seriesDimension.width / mapDimension.width;
	        var heightRatio = seriesDimension.height / mapDimension.height;
	
	        this.mapRatio = Math.min(widthRatio, heightRatio);
	    };
	
	    /**
	     * Set graph dimension.
	     * @private
	     */
	
	
	    MapChartSeries.prototype._setGraphDimension = function _setGraphDimension() {
	        var _layout$dimension = this.layout.dimension,
	            width = _layout$dimension.width,
	            height = _layout$dimension.height;
	
	
	        this.graphDimension = {
	            width: width * this.zoomMagn,
	            height: height * this.zoomMagn
	        };
	    };
	
	    /**
	     * Render series component.
	     * @param {object} data data for rendering
	     */
	
	
	    MapChartSeries.prototype.render = function render(data) {
	        _series2['default'].prototype.render.call(this, data);
	        this.seriesSet = this.graphRenderer.sectorSet;
	        this._setMapRatio();
	    };
	
	    /**
	     * Rerender series component.
	     * @param {object} data data for rendering
	     */
	
	
	    MapChartSeries.prototype.rerender = function rerender(data) {
	        _series2['default'].prototype.rerender.call(this, data);
	        this.seriesSet = this.graphRenderer.sectorSet;
	        this._setMapRatio();
	    };
	
	    /**
	     * Resize series component.
	     * @param {object} data data for rendering
	     */
	
	
	    MapChartSeries.prototype.resize = function resize(data) {
	        this.rerender(data);
	    };
	
	    /**
	     * Set limit position to move map.
	     * @private
	     */
	
	
	    MapChartSeries.prototype._setLimitPositionToMoveMap = function _setLimitPositionToMoveMap() {
	        var seriesDimension = this.layout.dimension;
	        var graphDimension = this.graphDimension;
	
	
	        this.limitPosition = {
	            left: seriesDimension.width - graphDimension.width,
	            top: seriesDimension.height - graphDimension.height
	        };
	    };
	
	    /**
	     * Render raphael graph.
	     * @private
	     * @override
	     */
	
	
	    MapChartSeries.prototype._renderGraph = function _renderGraph() {
	        this._setGraphDimension();
	
	        this._setLimitPositionToMoveMap();
	
	        this.graphRenderer.render(this.paper, {
	            colorSpectrum: this.colorSpectrum,
	            mapModel: this.mapModel,
	            layout: this.layout,
	            theme: this.theme
	        });
	    };
	
	    /**
	     * Render series label.
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    MapChartSeries.prototype._renderSeriesLabel = function _renderSeriesLabel() {
	        var labelData = this.mapModel.getLabelData(this.zoomMagn * this.mapRatio);
	
	        return this.graphRenderer.renderSeriesLabels(this.paper, labelData, this.theme.label);
	    };
	
	    /**
	     * Render series area.
	     * @param {HTMLElement} seriesContainer series area element
	     * @param {object} data data for rendering
	     * @param {function} funcRenderGraph function for graph rendering
	     * @private
	     */
	
	
	    MapChartSeries.prototype._renderSeriesArea = function _renderSeriesArea(seriesContainer, data, funcRenderGraph) {
	        _series2['default'].prototype._renderSeriesArea.call(this, seriesContainer, data, funcRenderGraph);
	    };
	
	    /**
	     * Adjust map position.
	     * @param {{left: number, top: number}} targetPosition target position
	     * @returns {{left: number, top: number}} adjusted position
	     * @private
	     */
	
	
	    MapChartSeries.prototype._adjustMapPosition = function _adjustMapPosition(targetPosition) {
	        return {
	            left: Math.max(Math.min(targetPosition.left, 0), this.limitPosition.left),
	            top: Math.max(Math.min(targetPosition.top, 0), this.limitPosition.top)
	        };
	    };
	
	    /**
	     * Update base position for zoom.
	     * @param {{width: number, height: number}} prevDimension previous dimension
	     * @param {{left: number, top: number}} prevLimitPosition previous limit position
	     * @param {number} changedRatio changed ratio
	     * @private
	     */
	
	
	    MapChartSeries.prototype._updateBasePositionForZoom = function _updateBasePositionForZoom(prevDimension, prevLimitPosition, changedRatio) {
	        var prevBasePosition = this.basePosition;
	        var prevLeft = prevBasePosition.left - prevLimitPosition.left / 2;
	        var prevTop = prevBasePosition.top - prevLimitPosition.top / 2;
	        var newBasePosition = {
	            left: prevLeft * changedRatio + this.limitPosition.left / 2,
	            top: prevTop * changedRatio + this.limitPosition.top / 2
	        };
	
	        this.basePosition = this._adjustMapPosition(newBasePosition);
	    };
	
	    /**
	     * Zoom.
	     * @param {number} changedRatio changed ratio
	     * @param {object} position position
	     * @private
	     */
	
	
	    MapChartSeries.prototype._zoom = function _zoom(changedRatio, position) {
	        var prevDimension = this.graphDimension;
	        var prevLimitPosition = this.limitPosition;
	
	        this._setGraphDimension();
	
	        this._setLimitPositionToMoveMap();
	        this._updateBasePositionForZoom(prevDimension, prevLimitPosition, changedRatio);
	
	        this._setMapRatio(this.graphDimension);
	
	        this.graphRenderer.scaleMapPaths(changedRatio, position, this.mapRatio, prevDimension, prevDimension);
	    };
	
	    /**
	     * Update positions to resize.
	     * @param {number} prevMapRatio previous ratio
	     * @private
	     */
	
	
	    MapChartSeries.prototype._updatePositionsToResize = function _updatePositionsToResize(prevMapRatio) {
	        var changedRatio = this.mapRatio / prevMapRatio;
	
	        this.basePosition.left *= changedRatio;
	        this.basePosition.top *= changedRatio;
	
	        this.limitPosition.left *= changedRatio;
	        this.limitPosition.top *= changedRatio;
	    };
	
	    /**
	     * If click series, showing selected state.
	     * @param {{left: number, top: number}} position - mouse position
	     */
	
	
	    MapChartSeries.prototype.onClickSeries = function onClickSeries(position) {
	        var foundIndex = this._executeGraphRenderer(position, 'findSectorIndex');
	
	        if (!_tuiCodeSnippet2['default'].isNull(foundIndex)) {
	            this.eventBus.fire('selectSeries', {
	                chartType: this.chartType,
	                index: foundIndex,
	                code: this.mapModel.getDatum(foundIndex).code
	            });
	        }
	    };
	
	    /**
	     * Whether changed position or not.
	     * @param {?{left: number, top: number}} prevPosition previous position
	     * @param {{left: number, top: number}} position position
	     * @returns {boolean} result boolean
	     * @private
	     */
	
	
	    MapChartSeries.prototype._isChangedPosition = function _isChangedPosition(prevPosition, position) {
	        return !prevPosition || prevPosition.left !== position.left || prevPosition.top !== position.top;
	    };
	
	    /**
	     * Show wedge of spectrum legend.
	     * @param {number} index map data index
	     * @private
	     */
	
	
	    MapChartSeries.prototype._showWedge = function _showWedge(index) {
	        var _mapModel$getDatum = this.mapModel.getDatum(index),
	            ratio = _mapModel$getDatum.ratio,
	            label = _mapModel$getDatum.label;
	
	        if (!_tuiCodeSnippet2['default'].isUndefined(ratio)) {
	            this.eventBus.fire('showWedge', ratio, label);
	        }
	    };
	
	    /**
	     * Show tooltip.
	     * @param {number} index map data index
	     * @param {{left: number, top: number}} mousePosition mouse position
	     * @private
	     */
	
	
	    MapChartSeries.prototype._showTooltip = function _showTooltip(index, _ref) {
	        var left = _ref.left,
	            top = _ref.top;
	
	        this.eventBus.fire('showTooltip', {
	            chartType: this.chartType,
	            indexes: {
	                index: index
	            },
	            mousePosition: {
	                left: left,
	                top: top - TOOLTIP_GAP
	            }
	        });
	    };
	
	    /**
	     * On move series.
	     * @param {{left: number, top: number}} position position
	     */
	
	
	    MapChartSeries.prototype.onMoveSeries = function onMoveSeries(position) {
	        var foundIndex = this._executeGraphRenderer(position, 'findSectorIndex');
	
	        if (!_tuiCodeSnippet2['default'].isNull(foundIndex)) {
	            if (this.prevMovedIndex !== foundIndex) {
	                if (!_tuiCodeSnippet2['default'].isNull(this.prevMovedIndex)) {
	                    this.graphRenderer.restoreColor(this.prevMovedIndex);
	                    this.eventBus.fire('hideTooltip');
	                }
	
	                this.graphRenderer.changeColor(foundIndex);
	            }
	
	            if (this._isChangedPosition(this.prevPosition, position)) {
	                this._showTooltip(foundIndex, {
	                    left: position.left,
	                    top: position.top
	                });
	                this.prevMovedIndex = foundIndex;
	            }
	
	            this._showWedge(foundIndex);
	        } else if (!_tuiCodeSnippet2['default'].isNull(this.prevMovedIndex)) {
	            this.graphRenderer.restoreColor(this.prevMovedIndex);
	            this.eventBus.fire('hideTooltip');
	            this.prevMovedIndex = null;
	        }
	        this.prevPosition = position;
	    };
	
	    /**
	     * On drag start series.
	     * @param {{left: number, top: number}} position position
	     */
	
	
	    MapChartSeries.prototype.onDragStartMapSeries = function onDragStartMapSeries(position) {
	        this.startPosition = {
	            left: position.left,
	            top: position.top
	        };
	    };
	
	    /**
	     * Move position.
	     * @param {{left: number, top: number}} startPosition start position
	     * @param {{left: number, top: number}} endPosition end position
	     * @private
	     */
	
	
	    MapChartSeries.prototype._movePosition = function _movePosition(startPosition, endPosition) {
	        var movementPosition = {
	            x: (endPosition.left - startPosition.left) * this.mapRatio,
	            y: (endPosition.top - startPosition.top) * this.mapRatio
	        };
	
	        this.graphRenderer.moveMapPaths(movementPosition, this.graphDimension);
	    };
	
	    /**
	     * On drag series.
	     * @param {{left: number, top: number}} position position
	     */
	
	
	    MapChartSeries.prototype.onDragMapSeries = function onDragMapSeries(position) {
	        this._movePosition(this.startPosition, position);
	
	        this.startPosition = position;
	
	        if (!this.isDrag) {
	            this.isDrag = true;
	            this.eventBus.fire('hideTooltip');
	        }
	    };
	
	    /**
	     * On drag end series.
	     */
	
	
	    MapChartSeries.prototype.onDragEndMapSeries = function onDragEndMapSeries() {
	        this.isDrag = false;
	    };
	
	    /**
	     * On zoom map.
	     * @param {number} newMagn new zoom magnification
	     * @param {?{left: number, top: number}} position mouse position
	     */
	
	
	    MapChartSeries.prototype.onZoomMap = function onZoomMap(newMagn, position) {
	        var changedRatio = newMagn / this.zoomMagn;
	        var _layout = this.layout,
	            _layout$position = _layout.position,
	            top = _layout$position.top,
	            left = _layout$position.left,
	            _layout$dimension2 = _layout.dimension,
	            width = _layout$dimension2.width,
	            height = _layout$dimension2.height;
	
	        var layerPosition = position ? position : {
	            left: width / 2,
	            top: height / 2
	        };
	
	        this.zoomMagn = newMagn;
	
	        this._zoom(changedRatio, {
	            left: layerPosition.left - left,
	            top: layerPosition.top - top
	        });
	
	        this.eventBus.fire(PUBLIC_EVENT_PREFIX + 'zoom', newMagn);
	    };
	
	    /**
	     * Make exportation data for public event of series type.
	     * @param {object} seriesData - series data
	     * @returns {{
	     *     chartType: string,
	     *     code: string,
	     *     index: number
	     *     }}
	     * @private
	     */
	
	
	    MapChartSeries.prototype._makeExportationSeriesData = function _makeExportationSeriesData(seriesData) {
	        return seriesData;
	    };
	
	    return MapChartSeries;
	}(_series2['default']);
	
	/**
	 * mapSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} mapChart series instanse
	 * @ignore
	 */
	
	
	function mapSeriesFactory(params) {
	    params.libType = params.chartOptions.libType;
	    params.chartType = 'map';
	
	    return new MapChartSeries(params);
	}
	
	mapSeriesFactory.componentType = 'series';
	mapSeriesFactory.MapChartSeries = MapChartSeries;

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports['default'] = pieSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Pie chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var COMPONENT_TYPE_RAPHAEL = _const2['default'].COMPONENT_TYPE_RAPHAEL,
	    ANGLE_360 = _const2['default'].ANGLE_360,
	    PIE_GRAPH_LEGEND_LABEL_INTERVAL = _const2['default'].PIE_GRAPH_LEGEND_LABEL_INTERVAL,
	    ANGLE_90 = _const2['default'].ANGLE_90,
	    PIE_GRAPH_SMALL_RATIO = _const2['default'].PIE_GRAPH_SMALL_RATIO,
	    PIE_GRAPH_DEFAULT_RATIO = _const2['default'].PIE_GRAPH_DEFAULT_RATIO,
	    RAD = _const2['default'].RAD,
	    PIE_GRAPH_LEGEND_LABEL_SIZE = _const2['default'].PIE_GRAPH_LEGEND_LABEL_SIZE,
	    SERIES_OUTER_LABEL_PADDING = _const2['default'].SERIES_OUTER_LABEL_PADDING,
	    SERIES_LABEL_PADDING = _const2['default'].SERIES_LABEL_PADDING;
	
	var COMBO_PIE1 = 'pie1';
	
	var PieChartSeries = function (_Series) {
	    _inherits(PieChartSeries, _Series);
	
	    /**
	     * Line chart series component.
	     * @constructs PieChartSeries
	     * @private
	     * @extends Series
	     * @param {object} params parameters
	     *      @param {object} params.model series model
	     *      @param {object} params.options series options
	     *      @param {object} params.theme series theme
	     */
	    function PieChartSeries(params) {
	        _classCallCheck(this, PieChartSeries);
	
	        var _this = _possibleConstructorReturn(this, _Series.call(this, params));
	
	        _this.isCombo = !!params.isCombo;
	
	        _this.isShowOuterLabel = _predicate2['default'].isShowOuterLabel(_this.options);
	
	        _this.isLabelAlignOuter = _predicate2['default'].isLabelAlignOuter(_this.options.labelAlign);
	
	        _this.legendMaxWidth = params.legendMaxWidth;
	
	        _this.drawingType = COMPONENT_TYPE_RAPHAEL;
	
	        /**
	         * range for quadrant.
	         * @type {?number}
	         */
	        _this.quadrantRange = null;
	
	        /**
	         * previous clicked index.
	         * @type {?number}
	         */
	        _this.prevClickedIndex = null;
	
	        /**
	         * series legend names
	         * @type {Array}
	         */
	        _this.legendLabels = [];
	
	        /**
	         * series values.
	         * @type {Array}
	         */
	        _this.valueLabels = [];
	
	        /**
	         * series ratio values.
	         * @type {Array}
	         */
	        _this.ratioValues = [];
	
	        /**
	         * max legend width
	         * @type {number}
	         */
	        _this.legendLongestWidth = 0;
	
	        /**
	         * labelTheme
	         * @type {object}
	         */
	        _this.labelTheme = _this.theme.label;
	
	        _this._setDefaultOptions();
	        return _this;
	    }
	
	    /**
	     * Make legendlabes
	     * @returns {Array.<string>}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._getLegendLabels = function _getLegendLabels() {
	        var _this2 = this;
	
	        var legendLabels = this.dataProcessor.getLegendLabels(this.seriesType);
	
	        return legendLabels.map(function (legendName) {
	            return _raphaelRenderUtil2['default'].getEllipsisText(legendName, _this2.legendMaxWidth, _this2.labelTheme);
	        });
	    };
	
	    /**
	     * Make valid angle.
	     * @param {number} angle - angle
	     * @param {number} defaultAngle - default angle
	     * @returns {number}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._makeValidAngle = function _makeValidAngle(angle, defaultAngle) {
	        if (_tuiCodeSnippet2['default'].isUndefined(angle)) {
	            angle = defaultAngle;
	        } else if (angle < 0) {
	            angle = ANGLE_360 - Math.abs(angle) % ANGLE_360;
	        } else if (angle > 0) {
	            angle = angle % ANGLE_360;
	        }
	
	        return angle;
	    };
	
	    /**
	     * Transform radius range.
	     * @param {Array.<number>} radiusRange - radius range
	     * @returns {Array}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._transformRadiusRange = function _transformRadiusRange() {
	        var radiusRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['0%', '100%'];
	
	        return radiusRange.map(function (percent) {
	            var ratio = parseInt(percent, 10) * 0.01;
	
	            return Math.max(Math.min(ratio, 1), 0);
	        });
	    };
	
	    /**
	     * Set default options for series of pie type chart.
	     * @private
	     */
	
	
	    PieChartSeries.prototype._setDefaultOptions = function _setDefaultOptions() {
	        var options = this.options;
	
	
	        options.startAngle = this._makeValidAngle(options.startAngle, 0);
	        options.endAngle = this._makeValidAngle(options.endAngle, options.startAngle);
	        options.radiusRange = this._transformRadiusRange(options.radiusRange);
	
	        if (options.radiusRange.length === 1) {
	            options.radiusRange.unshift(0);
	        }
	    };
	
	    /**
	     * Calculate angle for rendering.
	     * @returns {number}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._calculateAngleForRendering = function _calculateAngleForRendering() {
	        var _options = this.options,
	            startAngle = _options.startAngle,
	            endAngle = _options.endAngle;
	
	        var renderingAngle = void 0;
	
	        if (startAngle < endAngle) {
	            renderingAngle = endAngle - startAngle;
	        } else if (startAngle > endAngle) {
	            renderingAngle = ANGLE_360 - (startAngle - endAngle);
	        } else {
	            renderingAngle = ANGLE_360;
	        }
	
	        return renderingAngle;
	    };
	
	    /**
	     * Make sectors information.
	     * @param {{cx: number, cy: number, r: number}} circleBound circle bound
	     * @returns {Array.<object>} sectors information
	     * @private
	     */
	
	
	    PieChartSeries.prototype._makeSectorData = function _makeSectorData(circleBound) {
	        var _this3 = this;
	
	        var cx = circleBound.cx,
	            r = circleBound.r,
	            cy = circleBound.cy;
	
	        var _options$radiusRange = _slicedToArray(this.options.radiusRange, 1),
	            holeRatio = _options$radiusRange[0];
	
	        var angleForRendering = this._calculateAngleForRendering();
	        var seriesGroup = this._getSeriesDataModel().getFirstSeriesGroup();
	        var angle = this.options.startAngle;
	        var centerR = r * 0.5;
	
	        if (holeRatio) {
	            centerR += centerR * holeRatio;
	        }
	
	        if (!seriesGroup) {
	            return null;
	        }
	
	        var paths = seriesGroup.map(function (seriesItem) {
	            var ratio = seriesItem ? seriesItem.ratio : 0;
	            var currentAngle = angleForRendering * ratio;
	            var endAngle = angle + currentAngle;
	            var popupAngle = angle + currentAngle / 2;
	            var angles = {
	                start: {
	                    startAngle: angle,
	                    endAngle: angle
	                },
	                end: {
	                    startAngle: angle,
	                    endAngle: endAngle
	                }
	            };
	            var positionData = {
	                cx: cx,
	                cy: cy,
	                angle: popupAngle
	            };
	
	            angle = endAngle;
	
	            return {
	                ratio: ratio,
	                angles: angles,
	                centerPosition: _this3._getArcPosition(_tuiCodeSnippet2['default'].extend({
	                    r: centerR
	                }, positionData)),
	                outerPosition: _this3._getArcPosition(_tuiCodeSnippet2['default'].extend({
	                    r: r + _this3.legendLongestWidth / 2 + PIE_GRAPH_LEGEND_LABEL_INTERVAL
	                }, positionData))
	            };
	        });
	
	        return paths;
	    };
	
	    /**
	     * Make value labels
	     * @returns {Array.<string>}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._makeValueLabel = function _makeValueLabel() {
	        var seriesGroup = this._getSeriesDataModel().getFirstSeriesGroup();
	
	        return seriesGroup.map(function (seriesItem) {
	            return seriesItem.label;
	        });
	    };
	
	    /**
	     * Make ratio values
	     * @returns {Array.<number>}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._makeRatioValues = function _makeRatioValues() {
	        var seriesGroup = this._getSeriesDataModel().getFirstSeriesGroup();
	
	        return seriesGroup.map(function (seriesItem) {
	            return seriesItem.ratio;
	        });
	    };
	
	    /**
	     * Make series data.
	     * @returns {{
	     *      chartBackground: string,
	     *      circleBound: ({cx: number, cy: number, r: number}),
	     *      sectorData: Array.<object>
	     * }} add data for graph rendering
	     * @private
	     * @override
	     */
	
	
	    PieChartSeries.prototype._makeSeriesData = function _makeSeriesData() {
	        this.valueLabels = this._makeValueLabel();
	        this.legendLabels = this._getLegendLabels();
	        this.legendLongestWidth = this._getMaxLengthLegendWidth();
	        this.ratioValues = this._makeRatioValues();
	
	        var circleBound = this._makeCircleBound();
	        var sectorData = this._makeSectorData(circleBound);
	
	        return {
	            chartBackground: this.chartBackground,
	            circleBound: circleBound,
	            sectorData: sectorData,
	            isAvailable: function isAvailable() {
	                return sectorData && sectorData.length > 0;
	            }
	        };
	    };
	
	    /**
	     * Get quadrant from angle.
	     * @param {number} angle - angle
	     * @param {boolean} isEnd whether end quadrant
	     * @returns {number}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._getQuadrantFromAngle = function _getQuadrantFromAngle(angle, isEnd) {
	        var quadrant = parseInt(angle / ANGLE_90, 10) + 1;
	
	        if (isEnd && angle % ANGLE_90 === 0) {
	            quadrant += quadrant === 1 ? 3 : -1;
	        }
	
	        return quadrant;
	    };
	
	    /**
	     * Get range for quadrant.
	     * @returns {{start: number, end: number}}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._getRangeForQuadrant = function _getRangeForQuadrant() {
	        if (!this.quadrantRange) {
	            this.quadrantRange = {
	                start: this._getQuadrantFromAngle(this.options.startAngle),
	                end: this._getQuadrantFromAngle(this.options.endAngle, true)
	            };
	        }
	
	        return this.quadrantRange;
	    };
	
	    /**
	     * Whether in range for quadrant.
	     * @param {number} start - start quadrant
	     * @param {number} end - end quadrant
	     * @returns {boolean}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._isInQuadrantRange = function _isInQuadrantRange(start, end) {
	        var quadrantRange = this._getRangeForQuadrant();
	
	        return quadrantRange.start === start && quadrantRange.end === end;
	    };
	
	    /**
	     * Calculate base size.
	     * @returns {number}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._calculateBaseSize = function _calculateBaseSize() {
	        var dimension = this.layout.dimension;
	        var width = dimension.width,
	            height = dimension.height;
	
	
	        if (!this.isCombo) {
	            var quadrantRange = this._getRangeForQuadrant();
	            if (this._isInQuadrantRange(2, 3) || this._isInQuadrantRange(4, 1)) {
	                height *= 2;
	            } else if (this._isInQuadrantRange(1, 2) || this._isInQuadrantRange(3, 4)) {
	                width *= 2;
	            } else if (quadrantRange.start === quadrantRange.end) {
	                width *= 2;
	                height *= 2;
	            }
	        }
	
	        return Math.min(width, height);
	    };
	
	    /**
	     * Calculate radius.
	     * @returns {number}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._calculateRadius = function _calculateRadius() {
	        var isComboPie1 = this.isCombo && this.seriesType === COMBO_PIE1;
	        var baseSize = this._calculateBaseSize();
	        var radiusRatio = 0;
	        var isShowOuterLabel = this.isShowOuterLabel;
	
	
	        if (isComboPie1) {
	            isShowOuterLabel = this.dataProcessor.isComboDonutShowOuterLabel();
	        }
	
	        radiusRatio = isShowOuterLabel ? PIE_GRAPH_SMALL_RATIO : PIE_GRAPH_DEFAULT_RATIO;
	
	        return baseSize * radiusRatio * this.options.radiusRange[1] / 2;
	    };
	
	    /**
	     * Calculate center x, y.
	     * @param {number} radius - radius
	     * @returns {{cx: number, cy: number}}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._calculateCenterXY = function _calculateCenterXY(radius) {
	        var _layout = this.layout,
	            _layout$dimension = _layout.dimension,
	            width = _layout$dimension.width,
	            height = _layout$dimension.height,
	            _layout$position = _layout.position,
	            top = _layout$position.top,
	            left = _layout$position.left;
	
	        var halfRadius = radius / 2;
	        var cx = width / 2 + left;
	        var cy = height / 2 + top;
	
	        if (!this.isCombo) {
	            if (this._isInQuadrantRange(1, 1)) {
	                cx -= halfRadius;
	                cy += halfRadius;
	            } else if (this._isInQuadrantRange(1, 2)) {
	                cx -= halfRadius;
	            } else if (this._isInQuadrantRange(2, 2)) {
	                cx -= halfRadius;
	                cy -= halfRadius;
	            } else if (this._isInQuadrantRange(2, 3)) {
	                cy -= halfRadius;
	            } else if (this._isInQuadrantRange(3, 3)) {
	                cx += halfRadius;
	                cy -= halfRadius;
	            } else if (this._isInQuadrantRange(3, 4)) {
	                cx += halfRadius;
	            } else if (this._isInQuadrantRange(4, 1)) {
	                cy += halfRadius;
	            } else if (this._isInQuadrantRange(4, 4)) {
	                cx += halfRadius;
	                cy += halfRadius;
	            }
	        }
	
	        return {
	            cx: cx,
	            cy: cy
	        };
	    };
	
	    /**
	     * Make circle bound
	     * @returns {{cx: number, cy: number, r: number}} circle bounds
	     * @private
	     */
	
	
	    PieChartSeries.prototype._makeCircleBound = function _makeCircleBound() {
	        var radius = this._calculateRadius();
	        var centerXY = this._calculateCenterXY(radius);
	
	        return Object.assign({
	            r: radius
	        }, centerXY);
	    };
	
	    /**
	     * Get arc position.
	     * @param {object} params parameters
	     *      @param {number} params.cx center x
	     *      @param {number} params.cy center y
	     *      @param {number} params.r radius
	     *      @param {number} params.angle angle(degree)
	     * @returns {{left: number, top: number}} arc position
	     * @private
	     */
	
	
	    PieChartSeries.prototype._getArcPosition = function _getArcPosition(params) {
	        return {
	            left: params.cx + params.r * Math.sin(params.angle * RAD),
	            top: params.cy - params.r * Math.cos(params.angle * RAD)
	        };
	    };
	
	    /**
	     * Render raphael graph.
	     * @param {{width: number, height: number}} dimension dimension
	     * @param {object} seriesData series data
	     * @param {object} paper paper object
	     * @private
	     * @override
	     */
	
	
	    PieChartSeries.prototype._renderGraph = function _renderGraph(dimension, seriesData, paper) {
	        var showTooltip = this.showTooltip.bind(this, {
	            allowNegativeTooltip: !!this.allowNegativeTooltip,
	            seriesType: this.seriesType,
	            chartType: this.chartType
	        });
	
	        var callbacks = {
	            showTooltip: showTooltip,
	            hideTooltip: this.hideTooltip.bind(this)
	        };
	        var params = this._makeParamsForGraphRendering(dimension, seriesData);
	        var currentSeriesName = this.seriesType;
	        var seriesDataModelMap = this.dataProcessor.seriesDataModelMap;
	
	        var pastSeriesNames = [];
	        var pastIndex = 0;
	
	        (this.dataProcessor.seriesTypes || []).forEach(function (seriesType) {
	            var needNext = true;
	
	            if (seriesType !== currentSeriesName) {
	                pastSeriesNames.push(seriesType);
	            } else {
	                needNext = false;
	            }
	
	            return needNext;
	        });
	
	        pastSeriesNames.forEach(function (seriesType) {
	            pastIndex += seriesDataModelMap[seriesType].baseGroups.length;
	        });
	
	        params.additionalIndex = pastIndex;
	
	        return this.graphRenderer.render(paper, params, callbacks);
	    };
	
	    /**
	     * showTooltip is mouseover event callback on series graph.
	     * @param {object} params parameters
	     *      @param {boolean} params.allowNegativeTooltip whether allow negative tooltip or not
	     * @param {{top:number, left: number, width: number, height: number}} bound graph bound information
	     * @param {number} groupIndex group index
	     * @param {number} index index
	     * @param {{left: number, top: number}} mousePosition mouse position
	     */
	
	
	    PieChartSeries.prototype.showTooltip = function showTooltip(params, bound, groupIndex, index, mousePosition) {
	        this.eventBus.fire('showTooltip', _tuiCodeSnippet2['default'].extend({
	            indexes: {
	                groupIndex: groupIndex,
	                index: index
	            },
	            mousePosition: mousePosition
	        }, params));
	    };
	
	    /**
	     * hideTooltip is mouseout event callback on series graph.
	     */
	
	
	    PieChartSeries.prototype.hideTooltip = function hideTooltip() {
	        this.eventBus.fire('hideTooltip');
	    };
	
	    /**
	     * legendh max length width
	     * @returns {number} max width
	     * @private
	     */
	
	
	    PieChartSeries.prototype._getMaxLengthLegendWidth = function _getMaxLengthLegendWidth() {
	        var _this4 = this;
	
	        var lableWidths = this.legendLabels.map(function (label) {
	            return _raphaelRenderUtil2['default'].getRenderedTextSize(label, _this4.labelTheme.fontSize, _this4.labelTheme.fontFamily).width;
	        });
	
	        lableWidths.sort(function (prev, next) {
	            return prev - next;
	        });
	
	        return lableWidths[lableWidths.length - 1];
	    };
	
	    /**
	     * Make series data by selection.
	     * @param {number} index index
	     * @returns {{indexes: {index: number, groupIndex: number}}} series data
	     * @private
	     */
	
	
	    PieChartSeries.prototype._makeSeriesDataBySelection = function _makeSeriesDataBySelection(index) {
	        return {
	            indexes: {
	                index: index,
	                groupIndex: index
	            }
	        };
	    };
	
	    /**
	     * Pick poistions from sector data.
	     * @param {string} positionType position type
	     * @param {string} dataType legend or value label
	     * @returns {Array} positions
	     * @private
	     */
	
	
	    PieChartSeries.prototype._pickPositionsFromSectorData = function _pickPositionsFromSectorData(positionType, dataType) {
	        var _this5 = this;
	
	        var _options2 = this.options,
	            showLegend = _options2.showLegend,
	            showLabel = _options2.showLabel;
	
	        var legendLabelHeight = _raphaelRenderUtil2['default'].getRenderedTextSize(this.legendLabels[0], this.labelTheme.fontSize, this.labelTheme.fontFamily).height;
	
	        var valueLabelHeight = _raphaelRenderUtil2['default'].getRenderedTextSize(this.valueLabels[0], PIE_GRAPH_LEGEND_LABEL_SIZE, this.labelTheme.fontFamily).height;
	
	        return (this.seriesData.sectorData || []).map(function (datum) {
	            var position = datum.ratio ? Object.assign({}, datum[positionType]) : null;
	            var isReCalculatePosition = position && showLegend && showLabel && !_this5.isLabelAlignOuter;
	
	            if (isReCalculatePosition) {
	                if (dataType === 'value') {
	                    position.top -= valueLabelHeight / 2;
	                } else if (dataType === 'legend') {
	                    position.top += legendLabelHeight / 2;
	                }
	            }
	
	            return position;
	        });
	    };
	
	    /**
	     * Add end position.
	     * @param {number} centerLeft center left
	     * @param {Array.<object>} positions positions
	     * @private
	     */
	
	
	    PieChartSeries.prototype._addEndPosition = function _addEndPosition(centerLeft, positions) {
	        positions.forEach(function (position) {
	            if (!position) {
	                return;
	            }
	
	            var end = _tuiCodeSnippet2['default'].extend({}, position.middle);
	            if (end.left < centerLeft) {
	                end.left -= SERIES_OUTER_LABEL_PADDING;
	            } else {
	                end.left += SERIES_OUTER_LABEL_PADDING;
	            }
	            position.end = end;
	        });
	    };
	
	    /**
	     * Move to outer position.
	     * @param {number} centerLeft center left
	     * @param {object} position position
	     * @param {string} label label
	     * @returns {{left: number, top: number}} outer position
	     * @private
	     */
	
	
	    PieChartSeries.prototype._moveToOuterPosition = function _moveToOuterPosition(centerLeft, position, label) {
	        var positionEnd = position.end;
	        var left = positionEnd.left,
	            top = positionEnd.top;
	
	        var OffsetX = this.graphRenderer.getRenderedLabelWidth(label, this.labelTheme) / 2 + SERIES_LABEL_PADDING;
	
	        return {
	            left: left < centerLeft ? left - OffsetX : left + OffsetX,
	            top: top
	        };
	    };
	
	    /**
	     * set series position
	     * @param {object} params position infos
	     * @param {Array.<string>} labels labels array
	     * @returns {Array.<number>}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._setSeriesPosition = function _setSeriesPosition(params, labels) {
	        var positions = [];
	        if (params.funcMoveToPosition) {
	            positions = params.positions.map(function (position, index) {
	                if (position) {
	                    return params.funcMoveToPosition(position, labels[index]);
	                }
	
	                return null;
	            });
	        } else {
	            positions = params.positions;
	        }
	
	        return positions;
	    };
	
	    /**
	     * Render series label.
	     * @param {object} paper paper
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
	        var positions = [];
	        var renderOption = {};
	        var labelSet = paper.set();
	
	        var graphRenderLabel = function (dataType, labels) {
	            var colors = void 0;
	            var theme = Object.assign({}, this.theme.label);
	            var ratioValues = this.ratioValues;
	
	
	            if (this.isLabelAlignOuter && dataType === 'legend') {
	                colors = this.theme.colors;
	                theme.fontWeight = 'bold';
	            }
	
	            theme.fontSize = dataType === 'value' ? 16 : theme.fontSize;
	            positions = this._setSeriesPosition(renderOption, labels);
	
	            this.graphRenderer.renderLabels({
	                dataType: dataType,
	                paper: paper,
	                labelSet: labelSet,
	                positions: positions,
	                labels: labels,
	                ratioValues: ratioValues,
	                theme: theme,
	                colors: colors,
	                seriesNames: this.legendLabels,
	                labelFilter: this.options.labelFilter
	            });
	        }.bind(this);
	
	        if (this.options.showLabel) {
	            renderOption.positions = this._pickPositionsFromSectorData('centerPosition', 'value');
	            graphRenderLabel('value', this.decorateLabel(this.valueLabels));
	        }
	
	        if (this.options.showLegend) {
	            var legendLabelPosition = this.isLabelAlignOuter ? 'outerPosition' : 'centerPosition';
	            renderOption.positions = this._pickPositionsFromSectorData(legendLabelPosition, 'legend');
	            graphRenderLabel('legend', this.legendLabels);
	        }
	
	        return labelSet;
	    };
	
	    /**
	     * Whether detected label element or not.
	     * @param {{left: number, top: number}} position - mouse position
	     * @returns {boolean}
	     * @private
	     */
	
	
	    PieChartSeries.prototype._isDetectedLabel = function _isDetectedLabel(position) {
	        var labelElement = document.elementFromPoint(position.left, position.top);
	
	        return _tuiCodeSnippet2['default'].isString(labelElement.className);
	    };
	
	    /**
	     * On click series.
	     * @param {{left: number, top: number}} position mouse position
	     */
	
	
	    PieChartSeries.prototype.onClickSeries = function onClickSeries(position) {
	        var sectorInfo = this._executeGraphRenderer(position, 'findSectorInfo');
	        var prevIndex = this.prevClickedIndex;
	        var allowSelect = this.options.allowSelect;
	
	
	        if ((sectorInfo || this._isDetectedLabel(position)) && _tuiCodeSnippet2['default'].isExisty(prevIndex) && allowSelect) {
	            this.onUnselectSeries({
	                indexes: {
	                    index: prevIndex
	                }
	            });
	            this.prevClickedIndex = null;
	        }
	
	        if (!sectorInfo || sectorInfo.chartType !== this.seriesType) {
	            return;
	        }
	
	        var foundIndex = sectorInfo.index;
	        var shouldSelect = foundIndex > -1 && foundIndex !== prevIndex;
	
	        if (allowSelect && !shouldSelect) {
	            return;
	        }
	
	        this.onSelectSeries({
	            chartType: this.chartType,
	            indexes: {
	                index: foundIndex,
	                legendIndex: sectorInfo.legendIndex
	            }
	        }, shouldSelect);
	
	        if (allowSelect && foundIndex > -1) {
	            this.prevClickedIndex = foundIndex;
	        }
	    };
	
	    /**
	     * On move series.
	     * @param {{left: number, top: number}} position mouse position
	     */
	
	
	    PieChartSeries.prototype.onMoveSeries = function onMoveSeries(position) {
	        this._executeGraphRenderer(position, 'moveMouseOnSeries');
	    };
	
	    return PieChartSeries;
	}(_series2['default']);
	
	/**
	 * pieSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} pie series instanse
	 * @ignore
	 */
	
	
	function pieSeriesFactory(params) {
	    var _params$chartOptions = params.chartOptions,
	        libType = _params$chartOptions.libType,
	        chartType = _params$chartOptions.chartType,
	        legendOption = _params$chartOptions.legend;
	    var chartTheme = params.chartTheme;
	
	
	    params.libType = libType;
	    params.chartType = 'pie';
	
	    if (chartType === 'combo') {
	        var _params$name$split = params.name.split('Series');
	        // elias series mapping key is used as a seriesType(ex. pie1)
	        // It is now distinguished to follow current structure
	        // elias will not be needed after chart constructor is integrated
	
	
	        var _params$name$split2 = _slicedToArray(_params$name$split, 1);
	
	        params.seriesType = _params$name$split2[0];
	
	        params.isCombo = true;
	    }
	
	    if (legendOption) {
	        params.legendMaxWidth = legendOption.maxWidth;
	    }
	
	    params.chartBackground = chartTheme.chart.background;
	
	    return new PieChartSeries(params);
	}
	
	pieSeriesFactory.componentType = 'series';
	pieSeriesFactory.PieChartSeries = PieChartSeries;

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = heatmapChartSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _renderingLabelHelper = __webpack_require__(410);
	
	var _renderingLabelHelper2 = _interopRequireDefault(_renderingLabelHelper);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Series component for rendering graph of heatmap chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var HeatmapChartSeries = function (_Series) {
	    _inherits(HeatmapChartSeries, _Series);
	
	    /**
	     * Series component for rendering graph of heatmap chart.
	     * @constructs HeatmapChartSeries
	     * @private
	     * @param {object} params - parameters
	     * @extends Series
	     */
	    function HeatmapChartSeries(params) {
	        _classCallCheck(this, HeatmapChartSeries);
	
	        /**
	         * Color spectrum
	         * @type {ColorSpectrum}
	         */
	        var _this = _possibleConstructorReturn(this, _Series.call(this, params));
	
	        _this.colorSpectrum = params.colorSpectrum;
	        return _this;
	    }
	
	    /**
	     * Make series data for rendering graph and sending to mouse event detector.
	     * @returns {{
	     *      groupBounds: Array.<Array.<{left: number, top: number, radius: number}>>,
	     *      seriesDataModel: SeriesDataModel
	     * }} series data
	     * @private
	     * @override
	     */
	
	
	    HeatmapChartSeries.prototype._makeSeriesData = function _makeSeriesData() {
	        var groupBounds = this._makeBounds();
	        var seriesDataModel = this._getSeriesDataModel();
	
	        return {
	            colorSpectrum: this.colorSpectrum,
	            groupBounds: groupBounds,
	            seriesDataModel: seriesDataModel,
	            isAvailable: function isAvailable() {
	                return groupBounds && groupBounds.length > 0;
	            }
	        };
	    };
	
	    /**
	     * Make bound for graph rendering.
	     * @param {number} blockWidth - block width
	     * @param {number} blockHeight - block height
	     * @param {number} x - x index
	     * @param {number} y - y index
	     * @returns {{end: {left: number, top: number, width: number, height: number}}}
	     * @private
	     */
	
	
	    HeatmapChartSeries.prototype._makeBound = function _makeBound(blockWidth, blockHeight, x, y) {
	        var _layout = this.layout,
	            height = _layout.dimension.height,
	            _layout$position = _layout.position,
	            top = _layout$position.top,
	            left = _layout$position.left;
	
	
	        return {
	            end: {
	                left: left + blockWidth * x,
	                top: top + height - blockHeight * (y + 1),
	                width: blockWidth,
	                height: blockHeight
	            }
	        };
	    };
	
	    /**
	     * Make bounds for graph rendering.
	     * @returns {Array.<Array.<{left: number, top: number, radius: number}>>} positions
	     * @private
	     */
	
	
	    HeatmapChartSeries.prototype._makeBounds = function _makeBounds() {
	        var _this2 = this;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var _layout$dimension = this.layout.dimension,
	            width = _layout$dimension.width,
	            height = _layout$dimension.height;
	
	        var blockWidth = width / this.dataProcessor.getCategoryCount(false);
	        var blockHeight = height / this.dataProcessor.getCategoryCount(true);
	
	        return seriesDataModel.map(function (seriesGroup, x) {
	            return seriesGroup.map(function (seriesItem, y) {
	                return _this2._makeBound(blockWidth, blockHeight, x, y);
	            });
	        });
	    };
	
	    /**
	     * Call showWedge event of spectrum legend, when call showTooltip event.
	     * @param {{indexes: {groupIndex: number, index: number}}} params - parameters
	     */
	
	
	    HeatmapChartSeries.prototype.onShowTooltip = function onShowTooltip(_ref) {
	        var indexes = _ref.indexes;
	
	        var seriesDataModel = this._getSeriesDataModel();
	
	        var _seriesDataModel$getS = seriesDataModel.getSeriesItem(indexes.groupIndex, indexes.index),
	            ratio = _seriesDataModel$getS.ratio,
	            label = _seriesDataModel$getS.label;
	
	        this.eventBus.fire('showWedge', ratio, label);
	    };
	
	    /**
	     * Render series label.
	     * @param {object} paper - paper
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    HeatmapChartSeries.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
	        var _this3 = this;
	
	        var sdm = this._getSeriesDataModel();
	        var boundsSet = this.seriesData.groupBounds;
	        var labelTheme = this.theme.label;
	        var selectedIndex = this.selectedLegendIndex;
	        var positionsSet = _renderingLabelHelper2['default'].boundsToLabelPositions(sdm, boundsSet, labelTheme);
	        var labels = sdm.map(function (datum) {
	            return _this3.decorateLabel(datum.valuesMap.value);
	        });
	
	        return this.graphRenderer.renderSeriesLabel(paper, positionsSet, labels, labelTheme, selectedIndex);
	    };
	
	    /**
	     * Resize.
	     * @override
	     */
	
	
	    HeatmapChartSeries.prototype.resize = function resize() {
	        this.boundMap = null;
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        _series2['default'].prototype.resize.apply(this, args);
	    };
	
	    /**
	     * Make exportation data for public event of series type.
	     * @param {object} seriesData - series data
	     * @returns {{x: number, y: number}}
	     * @private
	     */
	
	
	    HeatmapChartSeries.prototype._makeExportationSeriesData = function _makeExportationSeriesData(_ref2) {
	        var indexes = _ref2.indexes;
	
	        return {
	            x: indexes.groupIndex,
	            y: indexes.index
	        };
	    };
	
	    return HeatmapChartSeries;
	}(_series2['default']);
	
	/**
	 * heatmapChartSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} heatmapChart series instanse
	 * @ignore
	 */
	
	
	function heatmapChartSeriesFactory(params) {
	    params.libType = params.chartOptions.libType;
	    params.chartType = 'heatmap';
	
	    return new HeatmapChartSeries(params);
	}
	
	heatmapChartSeriesFactory.componentType = 'series';
	heatmapChartSeriesFactory.HeatmapChartSeries = HeatmapChartSeries;

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = treemapChartSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _squarifier = __webpack_require__(423);
	
	var _squarifier2 = _interopRequireDefault(_squarifier);
	
	var _renderingLabelHelper = __webpack_require__(410);
	
	var _renderingLabelHelper2 = _interopRequireDefault(_renderingLabelHelper);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Series component for rendering graph of treemap chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	var TreemapChartSeries = function (_Series) {
	    _inherits(TreemapChartSeries, _Series);
	
	    /**
	     * Series component for rendering graph of treemap chart.
	     * @constructs TreemapChartSeries
	     * @private
	     * @param {object} params - parameters
	     * @extends Series
	     */
	    function TreemapChartSeries(params) {
	        _classCallCheck(this, TreemapChartSeries);
	
	        var _this = _possibleConstructorReturn(this, _Series.call(this, params));
	
	        _this.theme.borderColor = _this.theme.borderColor || _const2['default'].TREEMAP_DEFAULT_BORDER;
	        _this.theme.label.color = _this.options.useColorValue ? '#000' : '#fff';
	
	        /**
	         * root id
	         * @type {string}
	         */
	        _this.rootId = _const2['default'].TREEMAP_ROOT_ID;
	
	        /**
	         * start depth of seriesItem for rendering graph
	         * @type {number}
	         */
	        _this.startDepth = 1;
	
	        /**
	         * selected group
	         * @type {null | number}
	         */
	        _this.selectedGroup = null;
	
	        /**
	         * bound map
	         * @type {null|object.<string, object>}
	         */
	        _this.boundMap = null;
	
	        /**
	         * color spectrum
	         * @type {ColorSpectrum}
	         */
	        _this.colorSpectrum = params.colorSpectrum;
	
	        _this._initOptions();
	        return _this;
	    }
	
	    /**
	     * Initialize options.
	     * @private
	     */
	
	
	    TreemapChartSeries.prototype._initOptions = function _initOptions() {
	        this.options.useColorValue = !!this.options.useColorValue;
	
	        if (_tuiCodeSnippet2['default'].isUndefined(this.options.zoomable)) {
	            this.options.zoomable = !this.options.useColorValue;
	        }
	
	        if (_tuiCodeSnippet2['default'].isUndefined(this.options.useLeafLabel)) {
	            this.options.useLeafLabel = !this.options.zoomable;
	        }
	    };
	
	    /**
	     * Make series data.
	     * @returns {{
	     *      groupBounds: object.<string, {left: number, top: number, width: number, height: number}>,
	     *      seriesDataModel: SeriesDataModel
	     * }}
	     * @private
	     * @override
	     */
	
	
	    TreemapChartSeries.prototype._makeSeriesData = function _makeSeriesData() {
	        var boundMap = this._getBoundMap();
	        var groupBounds = this._makeBounds(boundMap);
	
	        return {
	            boundMap: boundMap,
	            groupBounds: groupBounds,
	            seriesDataModel: this._getSeriesDataModel(),
	            startDepth: this.startDepth,
	            isPivot: true,
	            colorSpectrum: this.options.useColorValue ? this.colorSpectrum : null,
	            chartBackground: this.chartBackground,
	            zoomable: this.options.zoomable,
	            isAvailable: function isAvailable() {
	                return groupBounds && groupBounds.length > 0;
	            }
	        };
	    };
	
	    /**
	     * Make bound map by dimension.
	     * @param {string | number} parent - parent id
	     * @param {object.<string, {left: number, top: number, width: number, height: number}>} boundMap - bound map
	     * @param {object} layout - layout
	     * @returns {object.<string, {left: number, top: number, width: number, height: number}>}
	     * @private
	     */
	
	
	    TreemapChartSeries.prototype._makeBoundMap = function _makeBoundMap(parent, boundMap, layout) {
	        var _this2 = this;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var defaultLayout = _tuiCodeSnippet2['default'].extend({}, this.layout.dimension, this.layout.position);
	        var seriesItems = seriesDataModel.findSeriesItemsByParent(parent);
	
	        layout = layout || defaultLayout;
	        boundMap = _tuiCodeSnippet2['default'].extend(boundMap || {}, _squarifier2['default'].squarify(layout, seriesItems));
	
	        seriesItems.forEach(function (seriesItem) {
	            boundMap = _this2._makeBoundMap(seriesItem.id, boundMap, boundMap[seriesItem.id]);
	        });
	
	        return boundMap;
	    };
	
	    /**
	     * Make bounds for rendering graph.
	     * @param {object.<string, {left: number, top: number, width: number, height: number}>} boundMap - bound map
	     * @returns {Array.<Array.<{left: number, top: number, width: number, height: number}>>}
	     * @private
	     */
	
	
	    TreemapChartSeries.prototype._makeBounds = function _makeBounds(boundMap) {
	        var startDepth = this.startDepth;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var isValid = void 0;
	
	        if (this.options.zoomable) {
	            isValid = function isValid(seriesItem) {
	                return seriesItem.depth === startDepth;
	            };
	        } else {
	            isValid = function isValid(seriesItem) {
	                return !seriesItem.hasChild;
	            };
	        }
	
	        return seriesDataModel.map(function (seriesGroup) {
	            return seriesGroup.map(function (seriesItem) {
	                var bound = boundMap[seriesItem.id];
	                var result = null;
	
	                if (bound && isValid(seriesItem)) {
	                    result = {
	                        end: bound
	                    };
	                }
	
	                return result;
	            }, true);
	        }, true);
	    };
	
	    /**
	     * Get bound map for rendering graph.
	     * @returns {object.<string, {left: number, top: number, width: number, height: number}>}
	     * @private
	     */
	
	
	    TreemapChartSeries.prototype._getBoundMap = function _getBoundMap() {
	        if (!this.boundMap) {
	            this.boundMap = this._makeBoundMap(this.rootId);
	        }
	
	        return this.boundMap;
	    };
	
	    /**
	     * Whether should dimmed or not.
	     * @param {SeriesDataModel} seriesDataModel - SeriesDataModel for treemap
	     * @param {SeriesItem} hoverSeriesItem - hover SeriesItem
	     * @param {SeriesItem} seriesItem - target SeriesItem
	     * @returns {boolean}
	     * @private
	     */
	
	
	    TreemapChartSeries.prototype._shouldDimmed = function _shouldDimmed(seriesDataModel, hoverSeriesItem, seriesItem) {
	        var shouldTransparent = false;
	
	        if (hoverSeriesItem && seriesItem.id !== hoverSeriesItem.id && seriesItem.group === hoverSeriesItem.group) {
	            var parent = seriesDataModel.findParentByDepth(seriesItem.id, hoverSeriesItem.depth + 1);
	
	            if (parent && parent.parent === hoverSeriesItem.id) {
	                shouldTransparent = true;
	            }
	        }
	
	        return shouldTransparent;
	    };
	
	    /**
	     * Render series label.
	     * @param {object} paper - paper
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    TreemapChartSeries.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
	        var _this3 = this;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var boundMap = this._getBoundMap();
	        var labelTheme = this.theme.label;
	        var labelTemplate = this.options.labelTemplate;
	
	        var seriesItems = void 0;
	
	        if (this.options.useLeafLabel) {
	            seriesItems = seriesDataModel.findLeafSeriesItems(this.selectedGroup);
	        } else {
	            seriesItems = seriesDataModel.findSeriesItemsByDepth(this.startDepth, this.selectedGroup);
	        }
	
	        var labels = seriesItems.map(function (seriesItem) {
	            var labelText = labelTemplate ? labelTemplate(seriesItem.pickLabelTemplateData()) : seriesItem.label;
	
	            return _this3.decorateLabel(labelText);
	        });
	
	        var positions = _renderingLabelHelper2['default'].boundsToLabelPostionsForTreemap(seriesItems, boundMap, labelTheme);
	
	        return this.graphRenderer.renderSeriesLabelForTreemap(paper, positions, labels, labelTheme);
	    };
	
	    /**
	     * Resize.
	     * @override
	     */
	
	
	    TreemapChartSeries.prototype.resize = function resize() {
	        this.boundMap = null;
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        _series2['default'].prototype.resize.apply(this, args);
	    };
	
	    /**
	     * Zoom.
	     * @param {string | number} rootId - root id
	     * @param {number} startDepth - start depth
	     * @param {number} group - group
	     * @private
	     */
	
	
	    TreemapChartSeries.prototype._zoom = function _zoom(rootId, startDepth, group) {
	        this._clearSeriesContainer();
	        this.boundMap = null;
	        this.rootId = rootId;
	        this.startDepth = startDepth;
	        this.selectedGroup = group;
	        this._renderSeriesArea(this.paper, _tuiCodeSnippet2['default'].bind(this._renderGraph, this));
	        this.animateComponent(true);
	    };
	
	    /**
	     * Zoom
	     * @param {{index: number}} data - data for zoom
	     */
	
	
	    TreemapChartSeries.prototype.zoom = function zoom(data) {
	        var detectedIndex = data.index;
	
	        this.labelSet.remove();
	
	        if (detectedIndex === -1) {
	            this._zoom(_const2['default'].TREEMAP_ROOT_ID, 1, null);
	
	            return;
	        }
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var seriesItem = seriesDataModel.getSeriesItem(0, detectedIndex, true);
	
	        if (!seriesItem || !seriesItem.hasChild) {
	            return;
	        }
	
	        this._zoom(seriesItem.id, seriesItem.depth + 1, seriesItem.group);
	        this.eventBus.fire('afterZoom', detectedIndex);
	    };
	
	    /**
	     * Make exportation data for public event of series type.
	     * @param {object} seriesData series data
	     * @returns {{chartType: string, legend: string, legendIndex: number, index: number}} export data
	     * @private
	     */
	
	
	    TreemapChartSeries.prototype._makeExportationSeriesData = function _makeExportationSeriesData(seriesData) {
	        var indexes = seriesData.indexes;
	
	        var seriesItem = this._getSeriesDataModel().getSeriesItem(indexes.groupIndex, indexes.index, true);
	
	        return _tuiCodeSnippet2['default'].extend({
	            chartType: this.chartType,
	            indexes: seriesItem.indexes
	        });
	    };
	
	    /**
	     * To call showAnimation function of graphRenderer.
	     * @param {{groupIndex: number, index: number}} indexes - indexes
	     */
	
	
	    TreemapChartSeries.prototype.onHoverSeries = function onHoverSeries(indexes) {
	        if (!_predicate2['default'].isShowLabel(this.options)) {
	            return;
	        }
	
	        var item = this._getSeriesDataModel().getSeriesItem(indexes.groupIndex, indexes.index, true);
	        var ratio = item.colorRatio;
	
	        this.graphRenderer.showAnimation(indexes, this.options.useColorValue, 0.6);
	
	        if (ratio > -1) {
	            this.eventBus.fire('showWedge', ratio, item.colorValue);
	        }
	    };
	
	    /**
	     * To call hideAnimation function of graphRenderer.
	     * @param {{groupIndex: number, index: number}} indexes - indexes
	     */
	
	
	    TreemapChartSeries.prototype.onHoverOffSeries = function onHoverOffSeries(indexes) {
	        if (!_predicate2['default'].isShowLabel(this.options) || !indexes) {
	            return;
	        }
	
	        this.graphRenderer.hideAnimation(indexes, this.options.useColorValue);
	    };
	
	    return TreemapChartSeries;
	}(_series2['default']);
	
	/**
	 * treemapChartSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} treemap series instanse
	 * @ignore
	 */
	
	
	function treemapChartSeriesFactory(params) {
	    params.libType = params.chartOptions.libType;
	    params.chartType = 'treemap';
	    params.chartBackground = params.chartTheme.chart.background;
	
	    return new TreemapChartSeries(params);
	}
	
	treemapChartSeriesFactory.componentType = 'series';
	treemapChartSeriesFactory.TreemapChartSeries = TreemapChartSeries;

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	exports['default'] = {
	    /**
	     * bound map
	     * @type {object.<string, {width: number, height: number, left: number, top: number}>}
	     */
	    boundMap: {},
	
	    /**
	     * Make base bound for calculating bounds.
	      * @param {{width: number, height: number, left: number, top: number}} layout - layout
	     * @returns {{width: number, height: number, left: number, top: number}}
	     * @private
	     */
	    _makeBaseBound: function _makeBaseBound(layout) {
	        return _tuiCodeSnippet2['default'].extend({}, layout);
	    },
	
	
	    /**
	     * Calculate scale for calculating weight.
	     * @param {Array.<number>} values - values
	     * @param {number} width - width of series area
	     * @param {number} height - height of series area
	     * @returns {number}
	     * @private
	     */
	    _calculateScale: function _calculateScale(values, width, height) {
	        return width * height / _calculator2['default'].sum(values);
	    },
	
	
	    /**
	     * Make base data for creating squarified bounds.
	     * @param {Array.<SeriesItem>} seriesItems - SeriesItems
	     * @param {number} width - width of series area
	     * @param {number} height - height of series area
	     * @returns {Array.<{itme: SeriesItem, weight: number}>}
	     * @private
	     */
	    _makeBaseData: function _makeBaseData(seriesItems, width, height) {
	        var scale = this._calculateScale(_tuiCodeSnippet2['default'].pluck(seriesItems, 'value'), width, height);
	        var data = seriesItems.map(function (seriesItem) {
	            return {
	                id: seriesItem.id,
	                weight: seriesItem.value * scale
	            };
	        }).sort(function (a, b) {
	            return b.weight - a.weight;
	        });
	
	        return data;
	    },
	
	
	    /**
	     * Calculate worst aspect ratio.
	     * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf
	     * @param {number} sum - sum for weights
	     * @param {number} min - minimum weight
	     * @param {number} max - maximum weight
	     * @param {number} baseSize - base size (width or height)
	     * @returns {number}
	     * @private
	     */
	    _worst: function _worst(sum, min, max, baseSize) {
	        var sumSquare = sum * sum;
	        var sizeSquare = baseSize * baseSize;
	
	        return Math.max(sizeSquare * max / sumSquare, sumSquare / (sizeSquare * min));
	    },
	
	
	    /**
	     * Whether changed stack direction or not.
	     * @param {number} sum - sum for weights
	     * @param {Array.<number>} weights - weights
	     * @param {number} baseSize - base size
	     * @param {number} newWeight - new weight
	     * @returns {boolean}
	     * @private
	     */
	    _changedStackDirection: function _changedStackDirection(sum, weights, baseSize, newWeight) {
	        var min = _arrayUtil2['default'].min(weights);
	        var max = _arrayUtil2['default'].max(weights);
	        var beforeWorst = this._worst(sum, min, max, baseSize);
	        var newWorst = this._worst(sum + newWeight, Math.min(min, newWeight), Math.max(max, newWeight), baseSize);
	
	        return newWorst >= beforeWorst;
	    },
	
	
	    /**
	     * Whether type of vertical stack or not.
	     * @param {{width: number, height: number}} baseBound - base bound
	     * @returns {boolean}
	     * @private
	     */
	    _isVerticalStack: function _isVerticalStack(baseBound) {
	        return baseBound.height < baseBound.width;
	    },
	
	
	    /**
	     * Select base size from baseBound.
	     * @param {{width: number, height: number}} baseBound - base bound
	     * @returns {number}
	     * @private
	     */
	    _selectBaseSize: function _selectBaseSize(baseBound) {
	        return this._isVerticalStack(baseBound) ? baseBound.height : baseBound.width;
	    },
	
	
	    /**
	     * Calculate fixed size.
	     * @param {number} baseSize - base size
	     * @param {number} sum - sum for weights
	     * @param {Array.<{weight: number}>} row - row
	     * @returns {number}
	     * @private
	     */
	    _calculateFixedSize: function _calculateFixedSize(baseSize, sum, row) {
	        if (!sum) {
	            var weights = _tuiCodeSnippet2['default'].pluck(row, 'weight');
	            sum = _calculator2['default'].sum(weights);
	        }
	
	        return sum / baseSize;
	    },
	
	
	    /**
	     * Add bounds.
	     * @param {number} startPosition - start position
	     * @param {Array.<{weight: number}>} row - row
	     * @param {number} fixedSize - fixed size
	     * @param {function} callback - callback function
	     * @private
	     */
	    _addBounds: function _addBounds(startPosition, row, fixedSize, callback) {
	        [startPosition].concat(row).reduce(function (storedPosition, rowDatum) {
	            var dynamicSize = rowDatum.weight / fixedSize;
	
	            callback(dynamicSize, storedPosition, rowDatum.id);
	
	            return storedPosition + dynamicSize;
	        });
	    },
	
	
	    /**
	     * Add bound.
	     * @param {number} left - left position
	     * @param {number} top - top position
	     * @param {number} width - width
	     * @param {number} height - height
	     * @param {string | number} id - id of seriesItem
	     * @private
	     */
	    _addBound: function _addBound(left, top, width, height, id) {
	        this.boundMap[id] = {
	            left: left,
	            top: top,
	            width: width,
	            height: height
	        };
	    },
	
	
	    /**
	     * Add bounds for type of vertical stack.
	     * @param {Array.<{weight: number}>} row - row
	     * @param {{left: number, top: number, width: number, height: number}} baseBound - base bound
	     * @param {number} baseSize - base size
	     * @param {number} sum - sum for weights of row
	     * @private
	     */
	    _addBoundsForVerticalStack: function _addBoundsForVerticalStack(row, baseBound, baseSize, sum) {
	        var _this = this;
	
	        var fixedWidth = this._calculateFixedSize(baseSize, sum, row);
	
	        this._addBounds(baseBound.top, row, fixedWidth, function (dynamicHeight, storedTop, id) {
	            _this._addBound(baseBound.left, storedTop, fixedWidth, dynamicHeight, id);
	        });
	
	        baseBound.left += fixedWidth;
	        baseBound.width -= fixedWidth;
	    },
	
	
	    /**
	     * Add bounds for type of horizontal stack.
	     * @param {Array.<{weight: number}>} row - row
	     * @param {{left: number, top: number, width: number, height: number}} baseBound - base bound
	     * @param {number} baseSize - base size
	     * @param {number} sum - sum for weights of row
	     * @private
	     */
	    _addBoundsForHorizontalStack: function _addBoundsForHorizontalStack(row, baseBound, baseSize, sum) {
	        var _this2 = this;
	
	        var fixedHeight = this._calculateFixedSize(baseSize, sum, row);
	
	        this._addBounds(baseBound.left, row, fixedHeight, function (dynamicWidth, storedLeft, id) {
	            _this2._addBound(storedLeft, baseBound.top, dynamicWidth, fixedHeight, id);
	        });
	
	        baseBound.top += fixedHeight;
	        baseBound.height -= fixedHeight;
	    },
	
	
	    /**
	     * Get adding bounds function.
	     * @param {{width: number, height: number}} baseBound - base bound
	     * @returns {*}
	     * @private
	     */
	    _getAddingBoundsFunction: function _getAddingBoundsFunction(baseBound) {
	        if (this._isVerticalStack(baseBound)) {
	            return _tuiCodeSnippet2['default'].bind(this._addBoundsForVerticalStack, this);
	        }
	
	        return this._addBoundsForHorizontalStack.bind(this);
	    },
	
	
	    /**
	     * Create squarified bound map for graph rendering.
	     * @param {object} layout - series area layout
	     * @param {Array.<SeriesItem>} seriesItems - seriesItems
	     * @returns {object.<string, {width: number, height: number, left: number, top: number}>}
	     */
	    squarify: function squarify(layout, seriesItems) {
	        var _this3 = this;
	
	        var baseBound = this._makeBaseBound(layout);
	        var baseData = this._makeBaseData(seriesItems, baseBound.width, baseBound.height);
	        var row = [];
	        var baseSize = void 0,
	            addBounds = void 0;
	
	        this.boundMap = {};
	
	        baseData.forEach(function (datum) {
	            var weights = _tuiCodeSnippet2['default'].pluck(row, 'weight');
	            var sum = _calculator2['default'].sum(weights);
	
	            if (row.length && _this3._changedStackDirection(sum, weights, baseSize, datum.weight)) {
	                addBounds(row, baseBound, baseSize, sum);
	                row = [];
	            }
	
	            if (!row.length) {
	                baseSize = _this3._selectBaseSize(baseBound);
	                addBounds = _this3._getAddingBoundsFunction(baseBound);
	            }
	
	            row.push(datum);
	        });
	
	        if (row.length) {
	            addBounds(row, baseBound, baseSize);
	        }
	
	        return this.boundMap;
	    }
	}; /**
	    * @fileoverview squarifier create squarified bounds for rendering graph of treemap chart.
	    * @author NHN.
	    *         FE Development Lab <dl_javascript@nhn.com>
	    */

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = boxplotSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _barTypeSeriesBase = __webpack_require__(409);
	
	var _barTypeSeriesBase2 = _interopRequireDefault(_barTypeSeriesBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Boxplot chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var SERIES_EXPAND_SIZE = _const2['default'].SERIES_EXPAND_SIZE,
	    TEXT_PADDING = _const2['default'].TEXT_PADDING;
	
	var BoxplotChartSeries = function (_Series) {
	    _inherits(BoxplotChartSeries, _Series);
	
	    /**
	     * Boxplot chart series component.
	     * @constructs BoxplotChartSeries
	     * @private
	     * @extends Series
	     * @param {object} params parameters
	     *      @param {object} params.model series model
	     *      @param {object} params.options series options
	     *      @param {object} params.theme series theme
	     */
	    function BoxplotChartSeries() {
	        _classCallCheck(this, BoxplotChartSeries);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        /**
	         * whether series label is supported
	         * @type {boolean}
	         */
	        var _this = _possibleConstructorReturn(this, _Series.call.apply(_Series, [this].concat(args)));
	
	        _this.supportSeriesLable = false;
	        return _this;
	    }
	
	    /**
	     * Make boxplot chart bound.
	     * @param {{
	     *      baseBarSize: number,
	     *      groupSize: number,
	     *      barSize: number,
	     *      pointInterval: number,
	     *      firstAdditionalPosition: number,
	     *      basePosition: number
	     * }} baseData base data for making bound
	     * @param {{
	     *      baseLeft: number,
	     *      left: number,
	     *      plusTop: number,
	     *      minusTop: number,
	     *      prevStack: ?string
	     * }} iterationData iteration data
	     * @param {?boolean} isStackType whether stackType option or not.
	     * @param {SeriesItem} seriesItem series item
	     * @param {number} index index
	     * @returns {{
	     *      start: {left: number, top: number, width: number, height: number},
	     *      end: {left: number, top: number, width: number, height: number}
	     * }}
	     * @private
	     */
	
	
	    BoxplotChartSeries.prototype._makeBoxplotChartBound = function _makeBoxplotChartBound(baseData, iterationData, isStackType, seriesItem, index) {
	        var pointInterval = baseData.pointInterval,
	            barSize = baseData.barSize,
	            baseBarSize = baseData.baseBarSize,
	            basePosition = baseData.basePosition;
	
	        var boxHeight = Math.abs(baseBarSize * seriesItem.ratioDistance);
	        var boxStartTop = baseBarSize * (1 - seriesItem.lqRatio);
	        var startTop = basePosition + boxStartTop + SERIES_EXPAND_SIZE;
	        var baseTopPosition = basePosition + SERIES_EXPAND_SIZE;
	        var pointCount = index;
	        var endTop = void 0;
	
	        iterationData.left = iterationData.baseLeft + pointInterval * pointCount;
	        iterationData.plusTop = 0;
	        iterationData.minusTop = 0;
	
	        if (seriesItem.value >= 0) {
	            iterationData.plusTop -= boxHeight;
	            endTop = startTop + iterationData.plusTop;
	        } else {
	            endTop = startTop + iterationData.minusTop;
	            iterationData.minusTop += boxHeight;
	        }
	
	        var boundLeft = iterationData.left + pointInterval - barSize / 2;
	        var outliers = (seriesItem.outliers || []).map(function (outlier) {
	            return {
	                top: baseBarSize * (1 - outlier.ratio) + baseTopPosition,
	                left: boundLeft + barSize / 2
	            };
	        });
	
	        return {
	            start: {
	                top: startTop,
	                left: boundLeft,
	                width: barSize,
	                height: 0
	            },
	            end: {
	                top: endTop,
	                left: boundLeft,
	                width: barSize,
	                height: boxHeight
	            },
	            min: {
	                top: baseBarSize * (1 - seriesItem.minRatio) + baseTopPosition,
	                left: boundLeft,
	                width: barSize,
	                height: 0
	            },
	            max: {
	                top: baseBarSize * (1 - seriesItem.maxRatio) + baseTopPosition,
	                left: boundLeft,
	                width: barSize,
	                height: 0
	            },
	            median: {
	                top: baseBarSize * (1 - seriesItem.medianRatio) + baseTopPosition,
	                left: boundLeft,
	                width: barSize,
	                height: 0
	            },
	            outliers: outliers
	        };
	    };
	
	    /**
	     * Make bounds of boxplot chart.
	     * @returns {Array.<Array.<object>>} bounds
	     * @private
	     */
	
	
	    BoxplotChartSeries.prototype._makeBounds = function _makeBounds() {
	        var _this2 = this;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var isStackType = _predicate2['default'].isValidStackOption(this.options.stackType);
	        var _layout$dimension = this.layout.dimension,
	            width = _layout$dimension.width,
	            height = _layout$dimension.height;
	
	        var baseData = this._makeBaseDataForMakingBound(width, height);
	
	        return seriesDataModel.map(function (seriesGroup, groupIndex) {
	            var baseLeft = groupIndex * baseData.groupSize + _this2.layout.position.left;
	            var iterationData = {
	                baseLeft: baseLeft,
	                left: baseLeft,
	                plusTop: 0,
	                minusTop: 0,
	                prevStack: null
	            };
	            var iteratee = _this2._makeBoxplotChartBound.bind(_this2, baseData, iterationData, isStackType);
	
	            return seriesGroup.map(iteratee);
	        });
	    };
	
	    /**
	     * Calculate left position of sum label.
	     * @param {{left: number, top: number}} bound bound
	     * @param {string} formattedSum formatted sum.
	     * @returns {number} left position value
	     * @private
	     */
	
	
	    BoxplotChartSeries.prototype._calculateLeftPositionOfSumLabel = function _calculateLeftPositionOfSumLabel(_ref, formattedSum) {
	        var left = _ref.left,
	            width = _ref.width;
	
	        var labelWidth = _renderUtil2['default'].getRenderedLabelWidth(formattedSum, this.theme.label);
	
	        return left + (width - labelWidth + TEXT_PADDING) / 2;
	    };
	
	    return BoxplotChartSeries;
	}(_series2['default']);
	
	_barTypeSeriesBase2['default'].mixin(BoxplotChartSeries);
	
	/**
	 * boxplotSeriesFactory
	 * @param {object} params chart options
	 * @returns {object} boxplot series instanse
	 * @ignore
	 */
	function boxplotSeriesFactory(params) {
	    var libType = params.chartOptions.libType,
	        chartTheme = params.chartTheme;
	
	
	    params.libType = libType;
	    params.chartType = 'boxplot';
	    params.chartBackground = chartTheme.chart.background;
	
	    return new BoxplotChartSeries(params);
	}
	
	boxplotSeriesFactory.componentType = 'series';
	boxplotSeriesFactory.BoxplotChartSeries = BoxplotChartSeries;

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = bulletSeriesFactory;
	
	var _series = __webpack_require__(408);
	
	var _series2 = _interopRequireDefault(_series);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Bullet chart series component.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var BULLET_TYPE_ACTUAL = _const2['default'].BULLET_TYPE_ACTUAL,
	    BULLET_ACTUAL_HEIGHT_RATIO = _const2['default'].BULLET_ACTUAL_HEIGHT_RATIO,
	    BULLET_TYPE_RANGE = _const2['default'].BULLET_TYPE_RANGE,
	    BULLET_RANGES_HEIGHT_RATIO = _const2['default'].BULLET_RANGES_HEIGHT_RATIO,
	    BULLET_TYPE_MARKER = _const2['default'].BULLET_TYPE_MARKER,
	    BULLET_MARKERS_HEIGHT_RATIO = _const2['default'].BULLET_MARKERS_HEIGHT_RATIO,
	    BULLET_MARKER_DETECT_PADDING = _const2['default'].BULLET_MARKER_DETECT_PADDING,
	    MAX_HEIGHT_WORD = _const2['default'].MAX_HEIGHT_WORD;
	
	var BulletChartSeries = function (_Series) {
	    _inherits(BulletChartSeries, _Series);
	
	    /**
	     * Bullet chart series component.
	     * @constructs BulletChartSeries
	     * @private
	     * @extends Series
	     * @param {object} params series initialization data
	     */
	    function BulletChartSeries(params) {
	        _classCallCheck(this, BulletChartSeries);
	
	        /**
	         * true if graph stratches vertically
	         * false if graph stratches horizontally
	         * @type {boolean}
	         */
	        var _this = _possibleConstructorReturn(this, _Series.call(this, params));
	
	        _this.isVertical = params.isVertical;
	        return _this;
	    }
	
	    /**
	     * Create data for rendering series
	     * @returns {object} - data for rendering series
	     * @override
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._makeSeriesData = function _makeSeriesData() {
	        var groupBounds = this._makeBounds();
	
	        return {
	            groupBounds: groupBounds,
	            seriesDataModel: this._getSeriesDataModel(),
	            isVertical: this.isVertical,
	            isAvailable: function isAvailable() {
	                return groupBounds && groupBounds.length > 0;
	            }
	        };
	    };
	
	    /**
	     * Create bounds data
	     * @returns {Array.<Bound>} - bound data of bullet graph components
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._makeBounds = function _makeBounds() {
	        var _this2 = this;
	
	        var seriesDataModel = this._getSeriesDataModel();
	        var baseData = this._makeBaseDataForMakingBound();
	        var iterationData = {
	            renderedItemCount: 0,
	            top: baseData.categoryAxisTop,
	            left: baseData.categoryAxisLeft
	        };
	
	        return seriesDataModel.map(function (seriesGroup) {
	            var iteratee = _this2._makeBulletChartBound.bind(_this2, baseData, iterationData);
	            var bounds = seriesGroup.map(iteratee);
	
	            _this2._updateIterationData(iterationData, baseData.itemWidth);
	
	            return bounds;
	        });
	    };
	
	    /**
	     * prepare a base data before making a bound
	     * @returns {object} - base data
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._makeBaseDataForMakingBound = function _makeBaseDataForMakingBound() {
	        var groupCount = this._getSeriesDataModel().getGroupCount();
	        var _layout = this.layout,
	            _layout$dimension = _layout.dimension,
	            width = _layout$dimension.width,
	            height = _layout$dimension.height,
	            position = _layout.position;
	
	        var categoryAxisLeft = position.left;
	        var categoryAxisTop = position.top;
	        var categoryAxisWidth = void 0,
	            valueAxisWidth = void 0;
	
	        if (this.isVertical) {
	            categoryAxisTop += height;
	            categoryAxisWidth = width;
	            valueAxisWidth = height;
	        } else {
	            categoryAxisWidth = height;
	            valueAxisWidth = width;
	        }
	
	        var itemWidth = categoryAxisWidth / groupCount;
	
	        return {
	            categoryAxisTop: categoryAxisTop,
	            categoryAxisLeft: categoryAxisLeft,
	            categoryAxisWidth: categoryAxisWidth,
	            valueAxisWidth: valueAxisWidth,
	            itemWidth: itemWidth
	        };
	    };
	
	    /**
	     * Create a bullet chart bound before making a base data
	     * @param {object} baseData - base data for making a tooltip
	     * @param {object} iterationData - increasing data while generating a graph data: index of item, graph position
	     * @param {object} item - series item
	     * @returns {Bound} - bullet graph bound
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._makeBulletChartBound = function _makeBulletChartBound(baseData, iterationData, item) {
	        var type = item.type;
	
	        var bound = void 0;
	
	        if (type === BULLET_TYPE_ACTUAL) {
	            bound = this._makeBarBound(item, BULLET_ACTUAL_HEIGHT_RATIO, baseData, iterationData);
	        } else if (type === BULLET_TYPE_RANGE) {
	            bound = this._makeBarBound(item, BULLET_RANGES_HEIGHT_RATIO, baseData, iterationData);
	        } else if (type === BULLET_TYPE_MARKER) {
	            bound = this._makeLineBound(item, BULLET_MARKERS_HEIGHT_RATIO, baseData, iterationData);
	        }
	
	        bound.type = type;
	
	        return bound;
	    };
	
	    /**
	     * Create bar type bound data
	     * @param {object} model - series item data
	     * @param {number} widthRatio - thickness compare to graph area
	     * @param {object} baseData - base data needed for making a bar bound
	     * @param {object} iterationData - data for setting up position
	     * @returns {object} - bar type bound data
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._makeBarBound = function _makeBarBound(_ref, widthRatio, baseData, iterationData) {
	        var ratioDistance = _ref.ratioDistance,
	            endRatio = _ref.endRatio;
	
	        var barWidth = baseData.itemWidth * widthRatio;
	        var barHeight = baseData.valueAxisWidth * ratioDistance;
	        var barEndHeight = baseData.valueAxisWidth * endRatio;
	        var bound = void 0;
	
	        if (this.isVertical) {
	            bound = this._makeVerticalBarBound(iterationData, baseData, barWidth, barHeight, barEndHeight);
	        } else {
	            bound = this._makeHorizontalBarBound(iterationData, baseData, barWidth, barHeight, barEndHeight);
	        }
	
	        return bound;
	    };
	
	    /**
	     * create a bound of bar type component, when it is virtical chart
	     * @param {object} iterationData - increasing data while generating a graph data: graph position
	     * @param {object} baseData - base data
	     * @param {number} barWidth - width of bar
	     * @param {number} barHeight - bar size from start position to end position
	     * @param {number} barEndHeight - bar size from axis start point to end position
	     * @returns {object} - bound data
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._makeVerticalBarBound = function _makeVerticalBarBound(iterationData, baseData, barWidth, barHeight, barEndHeight) {
	        return {
	            top: iterationData.top - barEndHeight,
	            left: iterationData.left + (baseData.itemWidth - barWidth) / 2,
	            width: barWidth,
	            height: barHeight
	        };
	    };
	
	    /**
	     * create a bound of bar type component, when it is a horizontal chart
	     * @param {object} iterationData - increasing data while generating a graph data: graph position
	     * @param {object} baseData - base data
	     * @param {number} barWidth - width of bar
	     * @param {number} barHeight - bar size from start position to end position
	     * @param {number} barEndHeight - bar size from axis start point to end position
	     * @returns {object} - bound data
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._makeHorizontalBarBound = function _makeHorizontalBarBound(iterationData, baseData, barWidth, barHeight, barEndHeight) {
	        return {
	            top: iterationData.top + (baseData.itemWidth - barWidth) / 2,
	            left: iterationData.left + barEndHeight - barHeight,
	            width: barHeight,
	            height: barWidth
	        };
	    };
	
	    /**
	     * Create line type bound data
	     * @param {object} model - series item data
	     * @param {number} widthRatio - graph thickness compare to graph area
	     * @param {object} baseData - base data needed for making a line bound
	     * @param {object} iterationData - data for setting up position
	     * @returns {object} - line type bound data
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._makeLineBound = function _makeLineBound(model, widthRatio, baseData, iterationData) {
	        var itemWidth = baseData.itemWidth,
	            valueAxisWidth = baseData.valueAxisWidth;
	
	        var lineWidth = itemWidth * widthRatio;
	        var endHeight = valueAxisWidth * model.endRatio;
	        var height = BULLET_MARKER_DETECT_PADDING;
	        var width = BULLET_MARKER_DETECT_PADDING;
	        var top = void 0,
	            left = void 0;
	
	        if (this.isVertical) {
	            top = iterationData.top - endHeight;
	            left = iterationData.left + (itemWidth - lineWidth) / 2;
	            width = lineWidth;
	        } else {
	            top = iterationData.top + (itemWidth - lineWidth) / 2;
	            left = iterationData.left + endHeight;
	            height = lineWidth;
	        }
	
	        return {
	            top: top,
	            left: left,
	            width: width,
	            height: height,
	            length: lineWidth
	        };
	    };
	
	    /**
	     * update iterationData after making a graph bound
	     * @param {object} iterationData - iteration data
	     * @param {number} itemWidth - size of category axis area
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._updateIterationData = function _updateIterationData(iterationData, itemWidth) {
	        iterationData.renderedItemCount += 1;
	
	        if (this.isVertical) {
	            iterationData.left += itemWidth;
	        } else {
	            iterationData.top += itemWidth;
	        }
	    };
	
	    /**
	    * Render series area.
	    * @param {object} paper - raphael object
	    * @param {function} funcRenderGraph - function for graph rendering
	    * @private
	    */
	
	
	    BulletChartSeries.prototype._renderSeriesArea = function _renderSeriesArea(paper, funcRenderGraph) {
	        _series2['default'].prototype._renderSeriesArea.call(this, paper, funcRenderGraph);
	
	        this.dataProcessor.setGraphColors(this.graphRenderer.getGraphColors());
	    };
	
	    /**
	     * Render series labels
	     * Series labels are shown only when `options.series.showLabel` is enabled
	     * @param {object} paper paper
	     * @returns {Array.<SVGElement>} - svg label sets
	     * @override
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._renderSeriesLabel = function _renderSeriesLabel(paper) {
	        var theme = this.theme.label;
	        var seriesDataModel = this._getSeriesDataModel();
	        var groupLabels = this._getLabelTexts(seriesDataModel);
	        var positionsSet = this._calculateLabelPositions(seriesDataModel, theme);
	
	        return this.graphRenderer.renderSeriesLabel(paper, positionsSet, groupLabels, theme);
	    };
	
	    /**
	     * Get label texts needed for enabling `options.series.showLabel` option
	     * @param {object} seriesDataModel - seriesDataModel
	     * @returns {Array.<string>} - actual data and marker data label
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._getLabelTexts = function _getLabelTexts(seriesDataModel) {
	        var _this3 = this;
	
	        return seriesDataModel.map(function (seriesGroup) {
	            var seriesLabels = [];
	
	            seriesGroup.each(function (seriesDatum) {
	                if (seriesDatum.type !== BULLET_TYPE_RANGE) {
	                    seriesLabels.push(_this3.decorateLabel(seriesDatum.endLabel));
	                }
	            });
	
	            return seriesLabels;
	        });
	    };
	
	    /**
	     * calculate a label position
	     * @param {object} seriesDataModel - bullet chart's series data model
	     * @param {object} theme - style needed to calculate the size of the text
	     * @returns {Array.<object>} - position of label text
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._calculateLabelPositions = function _calculateLabelPositions(seriesDataModel, theme) {
	        var _this4 = this;
	
	        var serieses = this.seriesData.groupBounds;
	        var labelHeight = _renderUtil2['default'].getRenderedLabelHeight(MAX_HEIGHT_WORD, theme);
	
	        return serieses.map(function (series) {
	            var bounds = [];
	
	            series.forEach(function (item) {
	                if (item.type !== BULLET_TYPE_RANGE) {
	                    bounds.push(_this4._makePositionByBound(item, labelHeight));
	                }
	            });
	
	            return bounds;
	        });
	    };
	
	    /**
	     * make position top, left data using bound data and label height
	     * @param {object} bound - bound data
	     * @param {number} labelHeight - label's height
	     * @returns {object} - position top, left
	     * @private
	     */
	
	
	    BulletChartSeries.prototype._makePositionByBound = function _makePositionByBound(bound, labelHeight) {
	        var boundTop = bound.top;
	        var boundLeft = bound.left;
	        var position = {};
	
	        if (this.isVertical) {
	            var width = bound.width || bound.length;
	            position.top = boundTop - labelHeight;
	            position.left = boundLeft + width / 2;
	        } else {
	            var _width = bound.width || 0;
	            var height = bound.height || bound.length;
	            position.top = boundTop + height / 2;
	            position.left = boundLeft + 5 + (_width || 0);
	        }
	
	        return position;
	    };
	
	    return BulletChartSeries;
	}(_series2['default']);
	
	/**
	 * BulletChartSeries factory function
	 * @param {object} params - series initialization data
	 * @returns {BulletChartSeries} - bullet chart series
	 * private
	 */
	
	
	function bulletSeriesFactory(params) {
	    params.chartType = 'bullet';
	    params.libType = params.chartOptions.libType;
	    params.chartBackground = params.chartTheme.chart.background;
	
	    return new BulletChartSeries(params);
	}
	
	bulletSeriesFactory.componentType = 'series';
	bulletSeriesFactory.BulletChartSeries = BulletChartSeries;

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = zoomFactory;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	var _seriesTemplate = __webpack_require__(427);
	
	var _seriesTemplate2 = _interopRequireDefault(_seriesTemplate);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _domHandler = __webpack_require__(336);
	
	var _domHandler2 = _interopRequireDefault(_domHandler);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _eventListener = __webpack_require__(382);
	
	var _eventListener2 = _interopRequireDefault(_eventListener);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Zoom component.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var COMPONENT_TYPE_DOM = _const2['default'].COMPONENT_TYPE_DOM,
	    MAP_CHART_ZOOM_AREA_HEIGHT = _const2['default'].MAP_CHART_ZOOM_AREA_HEIGHT,
	    MAP_CHART_ZOOM_AREA_WIDTH = _const2['default'].MAP_CHART_ZOOM_AREA_WIDTH,
	    CHART_PADDING = _const2['default'].CHART_PADDING;
	
	
	var IS_MSIE_VERSION_LTE_THAN_8 = _tuiCodeSnippet2['default'].browser.msie && _tuiCodeSnippet2['default'].browser.version <= 8;
	
	var Zoom = function () {
	    /**
	     * Zoom component.
	     * @param {{eventBus: object}} params - parameters
	     * @constructs Zoom
	     * @private
	     */
	    function Zoom(params) {
	        _classCallCheck(this, Zoom);
	
	        /**
	         * zoom component className
	         * @type {string}
	         */
	        this.className = 'tui-chart-zoom-area';
	
	        var seriesTypes = params.seriesTypes;
	
	        var isMapChart = seriesTypes && seriesTypes.length ? _predicate2['default'].isMapChart(seriesTypes[0]) : false;
	        var legendOption = params.dataProcessor.options.legend;
	        var isLegendTop = _predicate2['default'].isLegendAlignTop(legendOption.align);
	        var isLegendVisible = legendOption.visible !== false;
	
	        this.isMapLegendTop = isMapChart && isLegendTop && isLegendVisible;
	
	        /**
	         * event bus for transmitting message
	         * @type {object}
	         */
	        this.eventBus = params.eventBus;
	
	        /**
	         * Magnification.
	         * @type {number}
	         */
	        this.magn = 1;
	
	        /**
	         * Stacked wheelDelta.
	         * @type {number}
	         */
	        this.stackedWheelDelta = 0;
	
	        this.drawingType = COMPONENT_TYPE_DOM;
	
	        this._attachToEventBus();
	    }
	
	    /**
	     * Attach to event bus.
	     * @private
	     */
	
	
	    Zoom.prototype._attachToEventBus = function _attachToEventBus() {
	        this.eventBus.on('wheel', this.onWheel, this);
	    };
	
	    /**
	     * Render.
	     * @param {{positionMap: {series: {left: number, top: number}}}} data - data for rendering
	     * @returns {HTMLElement} zoom container
	     */
	
	
	    Zoom.prototype.render = function render(data) {
	        var container = void 0;
	
	        if (!IS_MSIE_VERSION_LTE_THAN_8) {
	            var positionTop = _calculator2['default'].sum([data.positionMap.series.top, -MAP_CHART_ZOOM_AREA_HEIGHT, MAP_CHART_ZOOM_AREA_WIDTH]);
	
	            if (this.isMapLegendTop) {
	                positionTop = data.positionMap.legend.top - MAP_CHART_ZOOM_AREA_WIDTH;
	            }
	
	            var position = {
	                top: positionTop,
	                right: CHART_PADDING
	            };
	
	            container = _domHandler2['default'].create('DIV', this.className);
	
	            container.innerHTML += _seriesTemplate2['default'].ZOOM_BUTTONS;
	            _renderUtil2['default'].renderPosition(container, position);
	            this._attachEvent(container);
	        }
	
	        return container;
	    };
	
	    /**
	     * Find button element.
	     * @param {HTMLElement} target target element.
	     * @returns {?HTMLElement} button element
	     * @private
	     */
	
	
	    Zoom.prototype._findBtnElement = function _findBtnElement(target) {
	        var btnClassName = 'tui-chart-zoom-btn';
	        var btnElement = target;
	
	        if (!_domHandler2['default'].hasClass(target, btnClassName)) {
	            btnElement = _domHandler2['default'].findParentByClass(target, btnClassName);
	        }
	
	        return btnElement;
	    };
	
	    /**
	     * Zoom
	     * @param {number} magn magnification
	     * @param {?{left: number, top: number}} position mouse position
	     * @private
	     */
	
	
	    Zoom.prototype._zoom = function _zoom(magn, position) {
	        this.eventBus.fire('zoomMap', magn, position);
	    };
	
	    /**
	     * On click.
	     * @param {MouseEvent} e mouse event
	     * @returns {?boolean} prevent default for ie
	     * @private
	     */
	
	
	    Zoom.prototype._onClick = function _onClick(e) {
	        var target = e.target || e.srcElement;
	        var btnElement = this._findBtnElement(target);
	        var zoomDirection = btnElement.getAttribute('data-magn');
	        var magn = this._calculateMagn(zoomDirection);
	
	        if (magn > 5) {
	            this.magn = 5;
	        } else if (magn < 1) {
	            this.magn = 1;
	        } else if (magn >= 1) {
	            this._zoom(magn);
	        }
	
	        if (e.preventDefault) {
	            e.preventDefault();
	        }
	
	        return false;
	    };
	
	    /**
	     * Attach event.
	     * @param {HTMLElement} target target element
	     * @private
	     */
	
	
	    Zoom.prototype._attachEvent = function _attachEvent(target) {
	        _eventListener2['default'].on(target, 'click', this._onClick, this);
	    };
	
	    /**
	     * Calculate magnification from zoomDirection.
	     * @param {number} zoomDirection zoomDirection (positive is zoomIn)
	     * @returns {number} magnification
	     * @private
	     */
	
	
	    Zoom.prototype._calculateMagn = function _calculateMagn(zoomDirection) {
	        if (zoomDirection > 0) {
	            this.magn += 0.1;
	        } else if (zoomDirection < 0) {
	            this.magn -= 0.1;
	        }
	
	        return this.magn;
	    };
	
	    /**
	     * On wheel.
	     * @param {number} wheelDelta wheelDelta
	     * @param {{left: number, top: number}} position mouse position
	     */
	
	
	    Zoom.prototype.onWheel = function onWheel(wheelDelta, position) {
	        var magn = this._calculateMagn(wheelDelta);
	
	        if (magn > 5) {
	            this.magn = 5;
	        } else if (magn < 1) {
	            this.magn = 1;
	        } else if (magn >= 1) {
	            this._zoom(magn, position);
	        }
	    };
	
	    return Zoom;
	}();
	
	/**
	 * zoomFactory
	 * @param {object} params chart options
	 * @returns {object} zoom instanse
	 * @ignore
	 */
	
	
	function zoomFactory(params) {
	    return new Zoom(params);
	}
	
	zoomFactory.componentType = 'zoom';

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _templateMaker = __webpack_require__(392);
	
	var _templateMaker2 = _interopRequireDefault(_templateMaker);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var htmls = {
	    HTML_SERIES_LABEL: '<div class="tui-chart-series-label" style="{{ cssText }}"{{ rangeLabelAttribute }}>' + '{{ label }}</div>',
	    TEXT_CSS_TEXT: 'left:{{ left }}px;top:{{ top }}px;font-family:{{ fontFamily }};' + 'font-size:{{ fontSize }}px;font-weight:{{ fontWeight }}{{opacity}}',
	    TEXT_CSS_TEXT_FOR_LINE_TYPE: 'left:{{ left }}%;top:{{ top }}%;font-family:{{ fontFamily }};' + 'font-size:{{ fontSize }}px;font-weight:{{ fontWeight }}{{opacity}}',
	    HTML_ZOOM_BUTTONS: '<a class="tui-chart-zoom-btn zoom-in" href="#" data-magn="1"></a>' + '<a class="tui-chart-zoom-btn zoom-out" href="#" data-magn="-1"></a>',
	    HTML_SERIES_BLOCK: '<div class="tui-chart-series-block" style="{{ cssText }}">{{ label }}</div>'
	}; /**
	    * @fileoverview This is templates of series.
	    * @author NHN.
	    *         FE Development Lab <dl_javascript@nhn.com>
	    */
	exports['default'] = {
	    tplSeriesLabel: _templateMaker2['default'].template(htmls.HTML_SERIES_LABEL),
	    tplCssText: _templateMaker2['default'].template(htmls.TEXT_CSS_TEXT),
	    tplCssTextForLineType: _templateMaker2['default'].template(htmls.TEXT_CSS_TEXT_FOR_LINE_TYPE),
	    ZOOM_BUTTONS: htmls.HTML_ZOOM_BUTTONS,
	    tplSeriesBlock: _templateMaker2['default'].template(htmls.HTML_SERIES_BLOCK)
	};

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _dataProcessorBase = __webpack_require__(429);
	
	var _dataProcessorBase2 = _interopRequireDefault(_dataProcessorBase);
	
	var _seriesDataModel = __webpack_require__(430);
	
	var _seriesDataModel2 = _interopRequireDefault(_seriesDataModel);
	
	var _seriesDataModelForBoxplot = __webpack_require__(434);
	
	var _seriesDataModelForBoxplot2 = _interopRequireDefault(_seriesDataModelForBoxplot);
	
	var _seriesDataModelForBullet = __webpack_require__(436);
	
	var _seriesDataModelForBullet2 = _interopRequireDefault(_seriesDataModelForBullet);
	
	var _seriesDataModelForTreemap = __webpack_require__(437);
	
	var _seriesDataModelForTreemap2 = _interopRequireDefault(_seriesDataModelForTreemap);
	
	var _seriesGroup = __webpack_require__(431);
	
	var _seriesGroup2 = _interopRequireDefault(_seriesGroup);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _objectUtil = __webpack_require__(364);
	
	var _objectUtil2 = _interopRequireDefault(_objectUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview DataProcessor process rawData.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * rawData.categories --> categories
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * rawData.series --> SeriesDataModel, legendLabels, legendData
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var isUndefined = _tuiCodeSnippet2['default'].isUndefined;
	
	/*
	 * Raw series datum.
	 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
	 */
	
	/*
	 * Raw series data.
	 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
	 */
	
	/*
	 * Raw data by user.
	 * @typedef {{
	 *      categories: ?Array.<string>,
	 *      series: (rawSeriesData|{line: ?rawSeriesData, column: ?rawSeriesData})
	 * }} rawData
	 */
	
	/*
	 * SeriesDataModel is base model for drawing graph of chart series area,
	 *      and create from rawSeriesData by user,
	 * SeriesDataModel.groups has SeriesGroups.
	 */
	
	/*
	 * SeriesGroup is a element of SeriesDataModel.groups.
	 * SeriesGroup.items has SeriesItem.
	 */
	
	var DataProcessor = function (_DataProcessorBase) {
	    _inherits(DataProcessor, _DataProcessorBase);
	
	    /**
	     * Data processor.
	     * @constructs DataProcessor
	     * @private
	     * @param {rawData} rawData raw data
	     * @param {string} chartType chart type
	     * @param {object} options options
	     * @param {Array.<string>} seriesTypes chart types
	     */
	    function DataProcessor(rawData, chartType, options, seriesTypes) {
	        _classCallCheck(this, DataProcessor);
	
	        /**
	         * original raw data.
	         * @type {{categories: ?Array.<string>, series: Array.<object>}}
	         */
	        var _this = _possibleConstructorReturn(this, _DataProcessorBase.call(this));
	
	        _this.originalRawData = _objectUtil2['default'].deepCopy(rawData);
	
	        /**
	         * chart type
	         * @type {string}
	         */
	        _this.chartType = chartType;
	
	        /**
	         * chart options
	         * @type {Object}
	         */
	        _this.options = options;
	
	        /**
	         * seriesTypes is sorted chart types for rendering series area of combo chart.
	         * @type {Array.<string>}
	         */
	        _this.seriesTypes = seriesTypes;
	
	        /**
	         * legend data for rendering legend of group tooltip
	         * @type {Array.<{chartType: string, label: string}>}
	         */
	        _this.originalLegendData = null;
	
	        /**
	         * select legend index
	         * @type {number}
	         */
	        _this.selectLegendIndex = null;
	
	        /**
	         * dynamic data array for adding data.
	         * @type {Array.<{category: string | number, values: Array.<number>}>}
	         */
	        _this.dynamicData = [];
	
	        _this.defaultValues = [0, 500];
	
	        _this.initData(rawData);
	        _this.initZoomedRawData();
	        _this.baseInit();
	
	        if (_this.isLineCoordinateType()) {
	            _this.integratedXAxisData = _this._integrateXAxisData();
	        }
	        return _this;
	    }
	
	    /**
	     * make integrated X Axis Data for coordinate chart
	     * @returns {array} integratedXAxisData
	     */
	
	
	    DataProcessor.prototype._integrateXAxisData = function _integrateXAxisData() {
	        var seriesData = this.rawData.series.line;
	        var options = this.options.xAxis || {};
	        var integratedXAxisData = [];
	        var isDateTime = false;
	
	        if (_tuiCodeSnippet2['default'].isArray(options)) {
	            isDateTime = options.filter(function (option) {
	                return option.type && _predicate2['default'].isDatetimeType(option.type);
	            });
	        } else {
	            isDateTime = options.type && _predicate2['default'].isDatetimeType(options.type);
	        }
	
	        seriesData.forEach(function (seriesDatum) {
	            seriesDatum.data.forEach(function (data) {
	                integratedXAxisData.push(data[0]);
	            });
	        });
	
	        integratedXAxisData = [].concat(_toConsumableArray(new Set(integratedXAxisData)));
	
	        if (isDateTime) {
	            integratedXAxisData = integratedXAxisData.map(function (data) {
	                return new Date(data);
	            });
	        }
	
	        return integratedXAxisData.sort(function (a, b) {
	            return a - b;
	        });
	    };
	
	    /**
	     * Get original raw data.
	     * @returns {rawData} raw data
	     */
	
	
	    DataProcessor.prototype.getOriginalRawData = function getOriginalRawData() {
	        return _objectUtil2['default'].deepCopy(this.originalRawData);
	    };
	
	    /**
	     * Get current data.
	     * @returns {*|null}
	     */
	
	
	    DataProcessor.prototype.getCurrentData = function getCurrentData() {
	        var zoomedRawData = this.zoomedRawData;
	
	
	        if (zoomedRawData) {
	            zoomedRawData = _objectUtil2['default'].deepCopy(zoomedRawData);
	        } else {
	            zoomedRawData = this.getOriginalRawData();
	        }
	
	        return zoomedRawData;
	    };
	
	    /**
	     * Filter seriesData by index range.
	     * @param {Array.<{data: Array}>} seriesData - series data
	     * @param {number} startIndex - start index
	     * @param {number} endIndex - end index
	     * @returns {Array.<Array.<object>>}
	     * @private
	     */
	
	
	    DataProcessor.prototype._filterSeriesDataByIndexRange = function _filterSeriesDataByIndexRange(seriesData, startIndex, endIndex) {
	        var series = [].concat(_toConsumableArray(seriesData));
	
	        series.forEach(function (seriesDatum) {
	            seriesDatum.data = seriesDatum.data.slice(startIndex, endIndex + 1);
	        });
	
	        return series;
	    };
	
	    /**
	     * Filter raw data by index range.
	     * @param {{series: Array.<object>, categories: Array.<string>}} rawData - raw data
	     * @param {Array.<number>} indexRange - index range for zoom
	     * @returns {*}
	     * @private
	     */
	
	
	    DataProcessor.prototype._filterRawDataByIndexRange = function _filterRawDataByIndexRange(rawData, indexRange) {
	        var _this2 = this;
	
	        var _indexRange = _slicedToArray(indexRange, 2),
	            startIndex = _indexRange[0],
	            endIndex = _indexRange[1];
	
	        var data = Object.assign({}, rawData);
	
	        Object.entries(data.series).forEach(function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2),
	                seriesType = _ref2[0],
	                seriesDataSet = _ref2[1];
	
	            data.series[seriesType] = _this2._filterSeriesDataByIndexRange(seriesDataSet, startIndex, endIndex);
	        });
	
	        if (data.categories) {
	            data.categories = data.categories.slice(startIndex, endIndex + 1);
	        }
	
	        return data;
	    };
	
	    /**
	     * Filter seriesData by value.
	     * @param {Array.<{data: Array}>} seriesData - series data
	     * @param {number} minValue - minimum value
	     * @param {number} maxValue - maximum value
	     * @returns {Array.<Array.<object>>}
	     * @private
	     */
	
	
	    DataProcessor.prototype._filterSeriesDataByValue = function _filterSeriesDataByValue(seriesData, minValue, maxValue) {
	        var isDatetime = _predicate2['default'].isDatetimeType(this.options.xAxis.type);
	        var series = [].concat(_toConsumableArray(seriesData));
	
	        series.forEach(function (seriesDatum) {
	            seriesDatum.data = seriesDatum.data.filter(function (data) {
	                var xAxisValue = isDatetime ? new Date(data[0]) : data[0];
	
	                return xAxisValue >= minValue && xAxisValue <= maxValue;
	            });
	        });
	
	        return series;
	    };
	
	    /**
	     * Filter raw data by value.
	     * @param {{series: Array.<object>, categories: Array.<string>}} rawData - raw data
	     * @param {Array.<number>} valueRange - value range for zoom
	     * @returns {*}
	     * @private
	     */
	
	
	    DataProcessor.prototype._filterRawDataByValue = function _filterRawDataByValue(rawData, valueRange) {
	        var _this3 = this;
	
	        var _valueRange = _slicedToArray(valueRange, 2),
	            minValue = _valueRange[0],
	            maxValue = _valueRange[1];
	
	        var data = Object.assign({}, rawData);
	
	        Object.entries(data.series).forEach(function (_ref3) {
	            var _ref4 = _slicedToArray(_ref3, 2),
	                seriesType = _ref4[0],
	                seriesDataSet = _ref4[1];
	
	            data.series[seriesType] = _this3._filterSeriesDataByValue(seriesDataSet, minValue, maxValue);
	        });
	
	        return data;
	    };
	
	    /**
	     * Update raw data for zoom
	     * @param {Array.<number>} range - index or value range for zoom
	     */
	
	
	    DataProcessor.prototype.updateRawDataForZoom = function updateRawDataForZoom(range) {
	        var currentData = this.getCurrentData();
	        var rawData = this.getRawData();
	
	        var getZoomedRawData = this.isLineCoordinateType() ? this._filterRawDataByValue.bind(this) : this._filterRawDataByIndexRange.bind(this);
	
	        this.zoomedRawData = getZoomedRawData(currentData, range);
	        rawData = getZoomedRawData(rawData, range);
	
	        this.initData(rawData);
	    };
	
	    /**
	     * Init zoomed raw data.
	     */
	
	
	    DataProcessor.prototype.initZoomedRawData = function initZoomedRawData() {
	        this.zoomedRawData = null;
	    };
	
	    /**
	     * Initialize data.
	     * @param {rawData} rawData raw data
	     * @param {boolean} originalChange whether the original has changed
	     */
	
	
	    DataProcessor.prototype.initData = function initData(rawData) {
	        var originalChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	        /**
	         * raw data
	         * @type {rawData}
	         */
	        this.rawData = rawData;
	
	        if (originalChange) {
	            this.originalRawData = _objectUtil2['default'].deepCopy(rawData);
	            this.originalLegendData = null;
	        }
	
	        /**
	         * categoriesMap
	         * @type {null|object}
	         */
	        this.categoriesMap = null;
	
	        /**
	         * categories isDatetype true or false
	         * @type {null|object}
	         */
	        this.categoriesIsDateTime = {};
	
	        /**
	         * stacks
	         * @type {Array.<number>}
	         */
	        this.stacks = null;
	
	        /**
	         * seriesDataModel map
	         * @type {object.<string, SeriesDataModel>}
	         */
	        this.seriesDataModelMap = {};
	
	        /**
	         * legendVisiblities
	         * @type {{column: Array.<string>, line: Array.<string> | Array.<string>}}
	         */
	        this.legendVisibilities = null;
	
	        /**
	         * zoomed raw data
	         * @type {object} zoomed raw data
	         */
	        this.zoomedRawData = null;
	
	        /**
	         * SeriesGroups
	         * @type {Array.<SeriesGroup>}
	         */
	        this.seriesGroups = null;
	
	        /**
	         * map of values of SeriesItems
	         * @type {Object.<string, Array.<number>>}
	         */
	        this.valuesMap = {};
	
	        /**
	         * legend labels for rendering legend area
	         * @type {{column: Array.<string>, line: Array.<string> | Array.<string>}}
	         */
	        this.legendLabels = null;
	
	        /**
	         * legend data for rendering legend
	         * @type {Array.<{chartType: string, label: string}>}
	         */
	        this.legendData = null;
	
	        /**
	         * multiline categories
	         * @type {Array.<string>}
	         */
	        this.multilineCategories = null;
	
	        /**
	         * whether coordinate type data or not
	         * @type {null|boolean}
	         */
	        this.coordinateType = null;
	
	        /**
	         * whether line chart with coordinate data or not
	         * @type {null|boolean}
	         */
	        this.lineCoordinateType = null;
	    };
	
	    /**
	     * Get raw data.
	     * @returns {rawData}
	     */
	
	
	    DataProcessor.prototype.getRawData = function getRawData() {
	        return this.rawData;
	    };
	
	    /**
	     * Find chart type from series name.
	     * @param {string} seriesType - series name
	     * @returns {*}
	     */
	
	
	    DataProcessor.prototype.findChartType = function findChartType(seriesType) {
	        return _rawDataHandler2['default'].findChartType(this.rawData.seriesAlias, seriesType);
	    };
	
	    /**
	     * Escape categories.
	     * @param {Array.<string, number>} categories - cetegories
	     * @returns {*|Array.<Object>|Array}
	     * @private
	     */
	
	
	    DataProcessor.prototype._escapeCategories = function _escapeCategories(categories) {
	        return categories.map(function (category) {
	            return _tuiCodeSnippet2['default'].encodeHTMLEntity(String(category));
	        });
	    };
	
	    /**
	     * Map categories.
	     * @param {Array.<string | number>} categories - categories
	     * @param {string} [axisName] - axis name like 'x' or 'y'
	     * @returns {Array.<string | number>}
	     * @private
	     */
	
	
	    DataProcessor.prototype._mapCategories = function _mapCategories(categories, axisName) {
	        var _this4 = this;
	
	        var axisType = axisName + 'Axis';
	        var options = this.options[axisType] || {};
	        var isDateTime = false;
	
	        if (_tuiCodeSnippet2['default'].isArray(options)) {
	            isDateTime = options.filter(function (option) {
	                return option.type && _predicate2['default'].isDatetimeType(option.type);
	            });
	        } else {
	            isDateTime = options.type && _predicate2['default'].isDatetimeType(options.type);
	        }
	        if (isDateTime) {
	            categories = categories.map(function (value) {
	                return _this4.chageDatetypeToTimestamp(value);
	            });
	        } else {
	            categories = this._escapeCategories(categories);
	        }
	        this.categoriesIsDateTime[axisName] = isDateTime;
	
	        return categories;
	    };
	
	    /**
	     * Process categories.
	     * @param {string} type - category type (x or y)
	     * @returns {null | Array.<string>} processed categories
	     * @private
	     */
	
	
	    DataProcessor.prototype._processCategories = function _processCategories(type) {
	        var rawCategories = this.rawData.categories;
	        var categoriesMap = {};
	
	        if (_tuiCodeSnippet2['default'].isArray(rawCategories)) {
	            categoriesMap[type] = this._mapCategories(rawCategories, type);
	        } else if (rawCategories) {
	            if (rawCategories.x) {
	                categoriesMap.x = this._mapCategories(rawCategories.x, 'x');
	            }
	
	            if (rawCategories.y) {
	                categoriesMap.y = this._mapCategories(rawCategories.y, 'y').reverse();
	            }
	        }
	
	        return categoriesMap;
	    };
	
	    /**
	     * Get Categories
	     * @param {boolean} isVertical - whether vertical or not
	     * @returns {Array.<string>}}
	     */
	
	
	    DataProcessor.prototype.getCategories = function getCategories(isVertical) {
	        var type = isVertical ? 'y' : 'x';
	        var foundCategories = [];
	
	        if (!this.categoriesMap) {
	            this.categoriesMap = this._processCategories(type);
	        }
	
	        if (_tuiCodeSnippet2['default'].isExisty(isVertical)) {
	            foundCategories = this.categoriesMap[type] || [];
	        } else {
	            Object.values(this.categoriesMap).every(function (categories) {
	                foundCategories = categories;
	
	                return false;
	            });
	        }
	
	        return foundCategories;
	    };
	
	    /**
	     * Get Category date type
	     * @param {boolean} isVertical - whether vertical or not
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.getCategorieDateType = function getCategorieDateType(isVertical) {
	        var type = isVertical ? 'y' : 'x';
	
	        return this.categoriesIsDateTime[type];
	    };
	
	    /**
	     * value to timestamp of datetype category
	     * @param {string} dateTypeValue - datetype category value
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.chageDatetypeToTimestamp = function chageDatetypeToTimestamp(dateTypeValue) {
	        var date = new Date(dateTypeValue);
	        if (!(date.getTime() > 0)) {
	            date = new Date(parseInt(dateTypeValue, 10));
	        }
	
	        return date.getTime() || dateTypeValue;
	    };
	
	    /**
	     * Get category count.
	     * @param {boolean} isVertical - whether vertical or not
	     * @returns {*}
	     */
	
	
	    DataProcessor.prototype.getCategoryCount = function getCategoryCount(isVertical) {
	        var categories = this.getCategories(isVertical);
	
	        return categories ? categories.length : 0;
	    };
	
	    /**
	     * Whether has categories or not.
	     * @param {boolean} isVertical - whether vertical or not
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.hasCategories = function hasCategories(isVertical) {
	        return !!this.getCategoryCount(isVertical);
	    };
	
	    /**
	     * Whether count of x data grater than count of y data.
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.isXCountGreaterThanYCount = function isXCountGreaterThanYCount(chartType) {
	        var seriesDataModel = this.getSeriesDataModel(chartType);
	
	        return seriesDataModel.isXCountGreaterThanYCount();
	    };
	
	    /**
	     * Whether has x value or not.
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.hasXValue = function hasXValue(chartType) {
	        var hasVerticalCategory = this.isXCountGreaterThanYCount(chartType);
	
	        return !this.hasCategories(hasVerticalCategory) || hasVerticalCategory;
	    };
	
	    /**
	     * Whether has y value or not.
	     * @param {string} chartType - chart type
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.hasYValue = function hasYValue(chartType) {
	        var hasVerticalCategory = this.isXCountGreaterThanYCount(chartType);
	
	        return !this.hasCategories(hasVerticalCategory) || !hasVerticalCategory;
	    };
	
	    /**
	     * Get category.
	     * @param {number} index index
	     * @param {boolean} isVertical - whether vertical or not
	     * @returns {string} category
	     */
	
	
	    DataProcessor.prototype.getCategory = function getCategory(index, isVertical) {
	        return this.getCategories(isVertical)[index];
	    };
	
	    /**
	     * Find category index by value
	     * @param {string} value - category value
	     * @returns {null|number}
	     */
	
	
	    DataProcessor.prototype.findCategoryIndex = function findCategoryIndex(value) {
	        var _this5 = this;
	
	        var categories = this.getCategories();
	        var isDateType = this.getCategorieDateType();
	        var foundIndex = null;
	
	        categories.forEach(function (category, index) {
	            if (isDateType) {
	                value = _this5.chageDatetypeToTimestamp(value);
	            }
	
	            if (category === value) {
	                foundIndex = index;
	            }
	
	            return _tuiCodeSnippet2['default'].isNull(foundIndex);
	        });
	
	        return foundIndex;
	    };
	
	    /**
	     * @param {string} value - category
	     * @returns {number} - found: category index, not found: -1
	     */
	
	
	    DataProcessor.prototype.findAbsoluteCategoryIndex = function findAbsoluteCategoryIndex(value) {
	        var originalCategories = this.originalRawData ? this.originalRawData.categories : null;
	        var index = -1;
	
	        if (!originalCategories) {
	            return index;
	        }
	
	        originalCategories.forEach(function (category, categoryIndex) {
	            var found = category === value;
	            if (found) {
	                index = categoryIndex;
	            }
	
	            return !found;
	        });
	
	        return index;
	    };
	
	    /**
	     * Get tooltip category.
	     * @param {number} categoryIndex - category index
	     * @param {boolean} isVertical - whether vertical category or not
	     * @returns {string}
	     * @private
	     */
	
	
	    DataProcessor.prototype._getTooltipCategory = function _getTooltipCategory(categoryIndex, isVertical) {
	        var category = this.getCategory(categoryIndex, isVertical);
	        var axisType = isVertical ? 'yAxis' : 'xAxis';
	        var axisOption = this.options[axisType] || {};
	        var tooltipOption = this.options.tooltip || {};
	
	        if (_predicate2['default'].isDatetimeType(tooltipOption.type)) {
	            category = _renderUtil2['default'].formatDate(category, tooltipOption.dateFormat);
	        } else if (_predicate2['default'].isDatetimeType(axisOption.type)) {
	            category = _renderUtil2['default'].formatDate(category, axisOption.dateFormat);
	        }
	
	        return category;
	    };
	
	    /**
	     * Make category for tooltip.
	     * @param {number} categoryIndex - category index
	     * @param {number} oppositeIndex - opposite index
	     * @param {boolean} isVerticalChart - whether vertical chart or not
	     * @returns {string}
	     */
	
	
	    DataProcessor.prototype.makeTooltipCategory = function makeTooltipCategory(categoryIndex, oppositeIndex, isVerticalChart) {
	        var isVertical = !isVerticalChart;
	        var category = this._getTooltipCategory(categoryIndex, isVertical);
	        var categoryCount = this.getCategoryCount(!isVertical);
	
	        if (categoryCount) {
	            category += ', ' + this._getTooltipCategory(categoryCount - oppositeIndex - 1, !isVertical);
	        }
	
	        return category;
	    };
	
	    /**
	     * Get stacks from raw series data.
	     * @param {string} seriesType seriesType to count stacks
	     * @returns {Array.<string>}
	     */
	
	
	    DataProcessor.prototype.getStacks = function getStacks(seriesType) {
	        if (!this.stacks) {
	            this.stacks = _rawDataHandler2['default'].pickStacks(this.rawData.series[seriesType]);
	        }
	
	        return this.stacks;
	    };
	
	    /**
	     * Get stack count.
	     * @param {string} seriesType - series type
	     * @returns {Number}
	     */
	
	
	    DataProcessor.prototype.getStackCount = function getStackCount(seriesType) {
	        return this.getStacks(seriesType).length;
	    };
	
	    /**
	     * Find stack index from stack list by stack value.
	     * @param {string} stack stack
	     * @returns {number}
	     */
	
	
	    DataProcessor.prototype.findStackIndex = function findStackIndex(stack) {
	        return _tuiCodeSnippet2['default'].inArray(stack, this.getStacks());
	    };
	
	    /**
	     * Whether line chart with coordinate data or not.
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.isLineCoordinateType = function isLineCoordinateType() {
	        var lineCoordinateType = this.lineCoordinateType;
	
	
	        if (!_tuiCodeSnippet2['default'].isExisty(lineCoordinateType)) {
	            var chartType = this.chartType;
	
	            lineCoordinateType = _predicate2['default'].isLineTypeChart(chartType) && !this.hasCategories();
	            this.lineCoordinateType = lineCoordinateType;
	        }
	
	        return lineCoordinateType;
	    };
	
	    /**
	     * Whether coordinate type or not.
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.isCoordinateType = function isCoordinateType() {
	        var coordinateType = this.coordinateType;
	
	
	        if (!_tuiCodeSnippet2['default'].isExisty(coordinateType)) {
	            var chartType = this.chartType;
	
	
	            coordinateType = _predicate2['default'].isCoordinateTypeChart(chartType);
	            coordinateType = coordinateType || _predicate2['default'].isLineScatterComboChart(chartType, this.seriesTypes);
	            coordinateType = coordinateType || _predicate2['default'].isLineTypeChart(chartType) && !this.hasCategories();
	            this.coordinateType = coordinateType;
	        }
	
	        return coordinateType;
	    };
	
	    /**
	     * Get SeriesDataModel.
	     * @param {string} seriesType - series name
	     * @returns {SeriesDataModel}
	     */
	
	
	    DataProcessor.prototype.getSeriesDataModel = function getSeriesDataModel(seriesType) {
	        if (!this.seriesDataModelMap[seriesType]) {
	            var chartType = this.findChartType(seriesType);
	            var rawSeriesData = this.rawData.series[seriesType];
	            var SeriesDataModelClass = void 0;
	
	            if (_predicate2['default'].isBoxplotChart(this.chartType)) {
	                SeriesDataModelClass = _seriesDataModelForBoxplot2['default'];
	            } else if (_predicate2['default'].isTreemapChart(this.chartType)) {
	                SeriesDataModelClass = _seriesDataModelForTreemap2['default'];
	            } else if (_predicate2['default'].isBulletChart(this.chartType)) {
	                SeriesDataModelClass = _seriesDataModelForBullet2['default'];
	            } else {
	                SeriesDataModelClass = _seriesDataModel2['default'];
	            }
	
	            this.seriesDataModelMap[seriesType] = new SeriesDataModelClass(rawSeriesData, chartType, this.options, this.getFormatFunctions(), this.isCoordinateType());
	        }
	
	        return this.seriesDataModelMap[seriesType];
	    };
	
	    /**
	     * Get chart option
	     * @param {string} optionType option category
	     * @returns {object}
	     */
	
	
	    DataProcessor.prototype.getOption = function getOption(optionType) {
	        return this.options[optionType];
	    };
	
	    /**
	     * Get group count.
	     * @param {string} chartType chart type
	     * @returns {number}
	     */
	
	
	    DataProcessor.prototype.getGroupCount = function getGroupCount(chartType) {
	        return this.getSeriesDataModel(chartType).getGroupCount();
	    };
	
	    /**
	     * Push category.
	     * @param {string} category - category
	     * @private
	     */
	
	
	    DataProcessor.prototype._pushCategory = function _pushCategory(category) {
	        if (this.rawData.categories) {
	            this.rawData.categories.push(category);
	            this.originalRawData.categories.push(category);
	        }
	    };
	
	    /**
	     * Shift category.
	     * @private
	     */
	
	
	    DataProcessor.prototype._shiftCategory = function _shiftCategory() {
	        if (this.rawData.categories) {
	            this.rawData.categories.shift();
	            this.originalRawData.categories.shift();
	        }
	    };
	
	    /**
	     * Find raw series datum by name.
	     * @param {string} name - legend name
	     * @param {string} [seriesType] - series name
	     * @returns {object}
	     * @private
	     */
	
	
	    DataProcessor.prototype._findRawSeriesDatumByName = function _findRawSeriesDatumByName(name, seriesType) {
	        var seriesData = this.rawData.series[seriesType];
	        var foundSeriesDatum = null;
	
	        seriesData.forEach(function (seriesDatum) {
	            var isEqual = seriesDatum.name === name;
	            if (isEqual) {
	                foundSeriesDatum = seriesDatum;
	            }
	
	            return !isEqual;
	        });
	
	        return foundSeriesDatum;
	    };
	
	    /**
	     * Push value to data property of series.
	     * @param {{name: string, data: Array}} seriesDatum - series datum
	     * @param {Array.<number>|{x: number, y: number, r: number}|number} value - value
	     * @param {string} seriesType - sereis name
	     * @private
	     */
	
	
	    DataProcessor.prototype._pushValue = function _pushValue(seriesDatum, value, seriesType) {
	        var rawSeriesDatum = this._findRawSeriesDatumByName(seriesDatum.name, seriesType);
	
	        seriesDatum.data.push(value);
	
	        if (rawSeriesDatum) {
	            rawSeriesDatum.data.push(value);
	        }
	    };
	
	    /**
	     * Push values to series of originalRawData and series of rawData.
	     * @param {Array.<{name: string, data: Array}>} seriesData - series data
	     * @param {Array} values - values
	     * @param {string} [seriesType] - series name
	     * @private
	     */
	
	
	    DataProcessor.prototype._pushValues = function _pushValues(seriesData, values, seriesType) {
	        var _this6 = this;
	
	        seriesData.forEach(function (seriesDatum, index) {
	            _this6._pushValue(seriesDatum, values[index], seriesType);
	        });
	    };
	
	    /**
	     * Push series data.
	     * @param {Array.<number>} values - values
	     * @private
	     */
	
	
	    DataProcessor.prototype._pushSeriesData = function _pushSeriesData(values) {
	        var _this7 = this;
	
	        if (this.chartType !== 'combo' && _tuiCodeSnippet2['default'].isArray(values)) {
	            var temp = values;
	            values = {};
	            values[this.chartType] = temp;
	        }
	
	        Object.entries(this.originalRawData.series).forEach(function (_ref5) {
	            var _ref6 = _slicedToArray(_ref5, 2),
	                seriesType = _ref6[0],
	                seriesData = _ref6[1];
	
	            _this7._pushValues(seriesData, values[seriesType], seriesType);
	        });
	    };
	
	    /**
	     * Shift values.
	     * @param {Array.<{name: string, data: Array}>} seriesData - series data
	     * @param {string} seriesType - series name
	     * @private
	     */
	
	
	    DataProcessor.prototype._shiftValues = function _shiftValues(seriesData, seriesType) {
	        var _this8 = this;
	
	        seriesData.forEach(function (seriesDatum) {
	            var rawSeriesDatum = _this8._findRawSeriesDatumByName(seriesDatum.name, seriesType);
	
	            seriesDatum.data.shift();
	            if (rawSeriesDatum) {
	                rawSeriesDatum.data.shift();
	            }
	        });
	    };
	
	    /**
	     * Shift series data.
	     * @private
	     */
	
	
	    DataProcessor.prototype._shiftSeriesData = function _shiftSeriesData() {
	        var _this9 = this;
	
	        Object.entries(this.originalRawData.series).forEach(function (_ref7) {
	            var _ref8 = _slicedToArray(_ref7, 2),
	                seriesType = _ref8[0],
	                seriesData = _ref8[1];
	
	            _this9._shiftValues(seriesData, seriesType);
	        });
	    };
	
	    /**
	     * Add dynamic data.
	     * @param {string} category - category
	     * @param {Array.<number>} values - values
	     */
	
	
	    DataProcessor.prototype.addDynamicData = function addDynamicData(category, values) {
	        this.dynamicData.push({
	            category: category,
	            values: values
	        });
	    };
	
	    /**
	     * Push dynamic data.
	     * @param {{category: string, values: Array.<number>}} data - adding data
	     * @private
	     */
	
	
	    DataProcessor.prototype._pushDynamicData = function _pushDynamicData(data) {
	        this._pushCategory(data.category);
	        this._pushSeriesData(data.values);
	    };
	
	    /**
	     * Push dynamic data for coordinate type.
	     * @param {object.<string, Array.<number>|object.<string, number>>} data - adding data
	     * @private
	     */
	
	
	    DataProcessor.prototype._pushDynamicDataForCoordinateType = function _pushDynamicDataForCoordinateType(data) {
	        var _this10 = this;
	
	        Object.values(this.originalRawData.series).forEach(function (seriesDatum) {
	            _this10._pushValue(seriesDatum, data[seriesDatum.name]);
	        });
	    };
	
	    /**
	     * Add data from dynamic data.
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.addDataFromDynamicData = function addDataFromDynamicData() {
	        var datum = this.dynamicData.shift();
	
	        if (datum) {
	            if (this.isCoordinateType()) {
	                this._pushDynamicDataForCoordinateType(datum.values);
	            } else {
	                this._pushDynamicData(datum);
	            }
	
	            this.initData(this.rawData);
	        }
	
	        return !!datum;
	    };
	
	    /**
	     * Shift data.
	     */
	
	
	    DataProcessor.prototype.shiftData = function shiftData() {
	        this._shiftCategory();
	        this._shiftSeriesData();
	
	        this.initData(this.rawData);
	    };
	
	    /**
	     * Add data from remain dynamic data.
	     * @param {boolean} shiftingOption - whether has shifting option or not.
	     */
	
	
	    DataProcessor.prototype.addDataFromRemainDynamicData = function addDataFromRemainDynamicData(shiftingOption) {
	        var _this11 = this;
	
	        var dynamicData = this.dynamicData;
	
	        this.dynamicData = [];
	
	        dynamicData.forEach(function (datum) {
	            _this11._pushCategory(datum.category);
	            _this11._pushSeriesData(datum.values);
	            if (shiftingOption) {
	                _this11._shiftCategory();
	                _this11._shiftSeriesData();
	            }
	        });
	
	        this.initData(this.rawData);
	    };
	
	    /**
	     * Traverse all SeriesDataModel by seriesTypes, and executes iteratee function.
	     * @param {function} iteratee iteratee function
	     * @private
	     */
	
	
	    DataProcessor.prototype._eachByAllSeriesDataModel = function _eachByAllSeriesDataModel(iteratee) {
	        var _this12 = this;
	
	        var seriesTypes = this.seriesTypes || [this.chartType];
	
	        seriesTypes.forEach(function (chartType) {
	            return iteratee(_this12.getSeriesDataModel(chartType), chartType);
	        });
	    };
	
	    /**
	     * Whether valid all SeriesDataModel or not.
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.isValidAllSeriesDataModel = function isValidAllSeriesDataModel() {
	        var isValid = true;
	
	        this._eachByAllSeriesDataModel(function (seriesDataModel) {
	            isValid = !!seriesDataModel.getGroupCount();
	        });
	
	        return isValid;
	    };
	
	    /**
	     * Make SeriesGroups.
	     * @returns {Array.<SeriesGroup>}
	     * @private
	     */
	
	
	    DataProcessor.prototype._makeSeriesGroups = function _makeSeriesGroups() {
	        var joinedGroups = [];
	
	        this._eachByAllSeriesDataModel(function (seriesDataModel) {
	            seriesDataModel.each(function (seriesGroup, index) {
	                if (!joinedGroups[index]) {
	                    joinedGroups[index] = [];
	                }
	                joinedGroups[index] = joinedGroups[index].concat(seriesGroup.items);
	            });
	        });
	
	        var seriesGroups = joinedGroups.map(function (items) {
	            return new _seriesGroup2['default'](items);
	        });
	
	        return seriesGroups;
	    };
	
	    /**
	     * Get SeriesGroups.
	     * @returns {Array.<SeriesGroup>}
	     */
	
	
	    DataProcessor.prototype.getSeriesGroups = function getSeriesGroups() {
	        if (!this.seriesGroups) {
	            this.seriesGroups = this._makeSeriesGroups();
	        }
	
	        return this.seriesGroups;
	    };
	
	    /**
	     * Get value.
	     * @param {number} groupIndex group index
	     * @param {number} index index
	     * @param {?string} chartType chart type
	     * @returns {number} value
	     */
	
	
	    DataProcessor.prototype.getValue = function getValue(groupIndex, index, chartType) {
	        return this.getSeriesDataModel(chartType).getValue(groupIndex, index);
	    };
	
	    /**
	     * Get fallback datetime values
	     * @returns {number[]} milliseconds
	     */
	
	
	    DataProcessor.prototype.getDefaultDatetimeValues = function getDefaultDatetimeValues() {
	        var hour = 60 * 60 * 1000;
	        var now = Date.now();
	
	        return [now - hour, now];
	    };
	
	    /**
	     * Return boolean value of whether seriesData empty or not
	     * @param {string} chartType Type string of chart
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.isSeriesDataEmpty = function isSeriesDataEmpty(chartType) {
	        var rawData = this.rawData;
	
	        var seriesNotExist = rawData && !rawData.series;
	
	        return !rawData || seriesNotExist || !rawData.series[chartType] || rawData.series[chartType] && !rawData.series[chartType].length;
	    };
	
	    /**
	     * Return boolean value of whether axis limit option empty or not
	     * @param {string} axisType Type string of axis
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.isLimitOptionsEmpty = function isLimitOptionsEmpty(axisType) {
	        var axisOption = this.options[axisType] || {};
	
	        return isUndefined(axisOption.min) && isUndefined(axisOption.max);
	    };
	
	    /**
	     * Return boolean value of whether axis limit option empty or not
	     * @param {string} axisType Type string of axis
	     * @returns {boolean}
	     */
	
	
	    DataProcessor.prototype.isLimitOptionsInsufficient = function isLimitOptionsInsufficient(axisType) {
	        var axisOption = this.options[axisType] || {};
	
	        return isUndefined(axisOption.min) || isUndefined(axisOption.max);
	    };
	
	    /**
	     * Create values that picked value from SeriesItems of specific SeriesDataModel.
	     * @param {?string} chartType - type of chart
	     * @param {?string} valueType - type of value like value, x, y, r.
	     * @param {?string} axisName - name of axis value 'xAxis' 'yAxis'
	     * @returns {Array.<number>}
	     * @private
	     */
	
	
	    DataProcessor.prototype._createValues = function _createValues(chartType, valueType, axisName) {
	        var values = void 0;
	        var options = this.options;
	
	        var plotOptions = options.plot;
	        var axisOption = options[axisName] || {};
	        var type = axisOption.type;
	
	        var isEmptyRawData = this.isSeriesDataEmpty(chartType);
	        var isEmptyLimitOptions = this.isLimitOptionsEmpty(axisName);
	        var isInsufficientLimitOptions = this.isLimitOptionsInsufficient(axisName);
	        var isLineOrAreaChart = _predicate2['default'].isLineChart(chartType) || _predicate2['default'].isAreaChart(chartType) || _predicate2['default'].isLineAreaComboChart(chartType, this.seriesTypes);
	        var valueCandidate = this.defaultValues;
	
	        if (_predicate2['default'].isComboChart(chartType)) {
	            values = [];
	            this._eachByAllSeriesDataModel(function (seriesDataModel) {
	                values = values.concat(seriesDataModel.getValues(valueType));
	            });
	        } else if (isEmptyRawData && isInsufficientLimitOptions) {
	            if (!isEmptyLimitOptions && isInsufficientLimitOptions) {
	                valueCandidate = valueCandidate.concat([axisOption.min || axisOption.max]);
	            }
	
	            if (valueType === 'x' && type === 'datetime') {
	                values = this.getDefaultDatetimeValues();
	
	                if (isLineOrAreaChart && plotOptions) {
	                    var plotValues = this.getValuesFromPlotOptions(plotOptions, type);
	                    values = values.concat(plotValues);
	                }
	            } else {
	                values = valueCandidate;
	            }
	        } else {
	            values = this.getSeriesDataModel(chartType).getValues(valueType);
	        }
	
	        return values;
	    };
	
	    /**
	     * Get values of plot lines, and bands if it exist
	     * @param {{lines: Array.<object>, bands: Array.<object>}} plotOptions plot options
	     * @param {string} [axisType] axis value type 'value' 'datetime'
	     * @returns {Array.<number>}
	     */
	
	
	    DataProcessor.prototype.getValuesFromPlotOptions = function getValuesFromPlotOptions(plotOptions, axisType) {
	        var values = [];
	
	        if (plotOptions.lines) {
	            plotOptions.lines.forEach(function (line) {
	                values.push(axisType !== 'datetime' ? line.value : new Date(line.value));
	            });
	        }
	
	        if (plotOptions.bands) {
	            plotOptions.bands.forEach(function (line) {
	                var ranges = line.range.map(function (range) {
	                    return axisType !== 'datetime' ? range : new Date(range);
	                });
	
	                values = values.concat(ranges);
	            });
	        }
	
	        return values;
	    };
	
	    /**
	     * Get values from valuesMap.
	     * @param {?string} chartType - type of chart
	     * @param {?string} valueType - type of value like value, x, y, r.
	     * @param {?string} axisType - type of axis value 'value', 'datetime'
	     * @returns {Array.<number>}
	     */
	
	
	    DataProcessor.prototype.getValues = function getValues(chartType, valueType, axisType) {
	        var mapKey = chartType + valueType;
	
	        if (!this.valuesMap[mapKey]) {
	            this.valuesMap[mapKey] = this._createValues(chartType, valueType, axisType);
	        }
	
	        return this.valuesMap[mapKey];
	    };
	
	    /**
	     * Traverse SeriesGroup of all SeriesDataModel, and executes iteratee function.
	     * @param {function} iteratee iteratee function
	     * @param {boolean} [isPivot] - whether pivot or not
	     */
	
	
	    DataProcessor.prototype.eachBySeriesGroup = function eachBySeriesGroup(iteratee, isPivot) {
	        this._eachByAllSeriesDataModel(function (seriesDataModel, chartType) {
	            seriesDataModel.each(function (seriesGroup, groupIndex) {
	                iteratee(seriesGroup, groupIndex, chartType);
	            }, isPivot);
	        });
	    };
	
	    /**
	     * Pick legend label.
	     * @param {object} item item
	     * @returns {string} label
	     * @private
	     */
	
	
	    DataProcessor.prototype._pickLegendLabel = function _pickLegendLabel(item) {
	        return item.name ? _tuiCodeSnippet2['default'].encodeHTMLEntity(item.name) : null;
	    };
	
	    /**
	     * Pick legend visibility.
	     * @param {object} item item
	     * @returns {boolean}
	     * @private
	     */
	
	
	    DataProcessor.prototype._isVisibleLegend = function _isVisibleLegend(item) {
	        var visibility = true;
	        if (_tuiCodeSnippet2['default'].isExisty(item.visible) && item.visible === false) {
	            visibility = false;
	        }
	
	        return visibility;
	    };
	
	    /**
	     * Pick legend labels or visibilities from raw data.
	     * @param {string} dataType data type of picking values
	     * @returns {string[]|boolean[]} labels or visibilities
	     * @private
	     */
	
	
	    DataProcessor.prototype._pickLegendData = function _pickLegendData(dataType) {
	        var seriesData = this.rawData.series;
	        var result = {};
	        var pickerMethod = void 0;
	
	        if (dataType === 'visibility') {
	            pickerMethod = this._isVisibleLegend;
	        } else if (dataType === 'label') {
	            pickerMethod = this._pickLegendLabel;
	        }
	
	        if (pickerMethod) {
	            Object.entries(seriesData).forEach(function (_ref9) {
	                var _ref10 = _slicedToArray(_ref9, 2),
	                    seriesType = _ref10[0],
	                    seriesDatum = _ref10[1];
	
	                result[seriesType] = seriesDatum.map(pickerMethod);
	            });
	
	            result = _tuiCodeSnippet2['default'].filter(result, _tuiCodeSnippet2['default'].isExisty);
	        }
	
	        return result;
	    };
	
	    /**
	     * Get legend labels.
	     * @param {?string} chartType chart type
	     * @returns {Array.<string> | {column: ?Array.<string>, line: ?Array.<string>}} legend labels
	     */
	
	
	    DataProcessor.prototype.getLegendLabels = function getLegendLabels(chartType) {
	        if (!this.legendLabels) {
	            this.legendLabels = this._pickLegendData('label');
	        }
	
	        return this.legendLabels[chartType] || this.legendLabels;
	    };
	
	    /**
	     * Get legend visibility.
	     * @param {?string} chartType chart type
	     * @returns {Array.<string> | {column: ?Array.<string>, line: ?Array.<string>}} legend labels
	     */
	
	
	    DataProcessor.prototype.getLegendVisibility = function getLegendVisibility(chartType) {
	        if (!this.legendVisibilities) {
	            this.legendVisibilities = this._pickLegendData('visibility');
	        }
	
	        return this.legendVisibilities[chartType] || this.legendVisibilities;
	    };
	
	    /**
	     * Make legend data.
	     * @returns {Array} labels
	     * @private
	     */
	
	
	    DataProcessor.prototype._makeLegendData = function _makeLegendData() {
	        var _ref11;
	
	        var legendLabels = this.getLegendLabels(this.chartType);
	        var legendVisibilities = this.getLegendVisibility();
	        var seriesTypes = this.seriesTypes || [this.chartType];
	        var legendLabelsMap = void 0;
	
	        if (_tuiCodeSnippet2['default'].isArray(legendLabels)) {
	            legendLabelsMap = [this.chartType];
	            legendLabelsMap[this.chartType] = legendLabels;
	        } else {
	            seriesTypes = this.seriesTypes;
	            legendLabelsMap = legendLabels;
	        }
	
	        var legendData = seriesTypes.map(function (chartType) {
	            return legendLabelsMap[chartType].map(function (label, index) {
	                var is2DArray = _tuiCodeSnippet2['default'].isArray(legendVisibilities[chartType]);
	
	                return {
	                    chartType: chartType,
	                    label: label,
	                    visible: is2DArray ? legendVisibilities[chartType][index] : legendVisibilities[index]
	                };
	            });
	        });
	
	        return (_ref11 = []).concat.apply(_ref11, _toConsumableArray(legendData));
	    };
	
	    /**
	     * Get legend data.
	     * @returns {Array.<{chartType: string, label: string}>} legend data
	     */
	
	
	    DataProcessor.prototype.getLegendData = function getLegendData() {
	        if (!this.legendData) {
	            this.legendData = this._makeLegendData();
	        }
	
	        if (!this.originalLegendData) {
	            this.originalLegendData = this.legendData;
	        }
	
	        return this.legendData;
	    };
	
	    /**
	     * get original legend data.
	     * @returns {Array.<{chartType: string, label: string}>}
	     */
	
	
	    DataProcessor.prototype.getOriginalLegendData = function getOriginalLegendData() {
	        return this.originalLegendData;
	    };
	
	    /**
	     * Get legend item.
	     * @param {number} index index
	     * @returns {{chartType: string, label: string}} legend data
	     */
	
	
	    DataProcessor.prototype.getLegendItem = function getLegendItem(index) {
	        return this.getLegendData()[index];
	    };
	
	    /**
	     * Get first label of SeriesItem.
	     * @param {?string} chartType chartType
	     * @returns {string} formatted value
	     */
	
	
	    DataProcessor.prototype.getFirstItemLabel = function getFirstItemLabel(chartType) {
	        return this.getSeriesDataModel(chartType).getFirstItemLabel();
	    };
	
	    /**
	     * Add data ratios of pie chart.
	     * @param {string} chartType - type of chart.
	     */
	
	
	    DataProcessor.prototype.addDataRatiosOfPieChart = function addDataRatiosOfPieChart(chartType) {
	        this.getSeriesDataModel(chartType).addDataRatiosOfPieChart();
	    };
	
	    /**
	     * Add data ratios for chart of coordinate type.
	     * @param {string} chartType - type of chart.
	     * @param {{x: {min: number, max: number}, y: {min: number, max: number}}} limitMap - limit map
	     * @param {boolean} [hasRadius] - whether has radius or not
	     */
	
	
	    DataProcessor.prototype.addDataRatiosForCoordinateType = function addDataRatiosForCoordinateType(chartType, limitMap, hasRadius) {
	        if (_predicate2['default'].isLineTypeChart(chartType)) {
	            this._addStartValueToAllSeriesItem(limitMap.yAxis, chartType);
	        }
	        this.getSeriesDataModel(chartType).addDataRatiosForCoordinateType(limitMap, hasRadius);
	    };
	
	    /**
	     * Add start value to all series item.
	     * @param {{min: number, max: number}} limit - limit
	     * @param {string} chartType - chart type
	     * @private
	     */
	
	
	    DataProcessor.prototype._addStartValueToAllSeriesItem = function _addStartValueToAllSeriesItem(limit, chartType) {
	        var start = 0;
	
	        if (limit.min >= 0) {
	            start = limit.min;
	        } else if (limit.max <= 0) {
	            start = limit.max;
	        }
	
	        this.getSeriesDataModel(chartType).addStartValueToAllSeriesItem(start);
	    };
	
	    /**
	     * Register percent values.
	     * @param {{min: number, max: number}} limit axis limit
	     * @param {string} stackType stackType option
	     * @param {string} chartType chart type
	     */
	
	
	    DataProcessor.prototype.addDataRatios = function addDataRatios(limit, stackType, chartType) {
	        var seriesDataModel = this.getSeriesDataModel(chartType);
	
	        this._addStartValueToAllSeriesItem(limit, chartType);
	        seriesDataModel.addDataRatios(limit, stackType);
	    };
	
	    /**
	     * Add data ratios for treemap chart.
	     * @param {{min: number, max: number}} limit - limit
	     * @param {string} chartType - chart type
	     */
	
	
	    DataProcessor.prototype.addDataRatiosForTreemapChart = function addDataRatiosForTreemapChart(limit, chartType) {
	        this.getSeriesDataModel(chartType).addDataRatios(limit);
	    };
	
	    /**
	     * Create base values for normal stackType chart.
	     * @param {string} chartType - chart type
	     * @returns {Array.<number>}
	     * @private
	     */
	
	
	    DataProcessor.prototype._createBaseValuesForNormalStackedChart = function _createBaseValuesForNormalStackedChart(chartType) {
	        var seriesDataModel = this.getSeriesDataModel(chartType);
	        var baseValues = [];
	
	        seriesDataModel.each(function (seriesGroup) {
	            var valuesMap = seriesGroup._makeValuesMapPerStack();
	
	            Object.values(valuesMap).forEach(function (values) {
	                var plusSum = _calculator2['default'].sumPlusValues(values);
	                var minusSum = _calculator2['default'].sumMinusValues(values);
	                baseValues = baseValues.concat([plusSum, minusSum]);
	            });
	        });
	
	        return baseValues;
	    };
	
	    /**
	     * Create base values for calculating limit
	     * @param {string} chartType - chart type
	     * @param {boolean} isSingleYAxis = whether single y axis or not
	     * @param {string} stackType - stack type
	     * @param {string} valueType - value type
	     * @param {string} axisType - value type
	     * @returns {Array.<number>}
	     */
	
	
	    DataProcessor.prototype.createBaseValuesForLimit = function createBaseValuesForLimit(chartType, isSingleYAxis, stackType, valueType, axisType) {
	        var baseValues = void 0;
	
	        if (_predicate2['default'].isComboChart(this.chartType) && isSingleYAxis) {
	            baseValues = this.getValues(this.chartType, valueType);
	            if (_predicate2['default'].isNormalStackChart(chartType, stackType)) {
	                baseValues = baseValues.concat(this._createBaseValuesForNormalStackedChart(chartType));
	            }
	        } else if (_predicate2['default'].isTreemapChart(chartType)) {
	            baseValues = this.getValues(chartType, 'colorValue');
	        } else if (_predicate2['default'].isNormalStackChart(chartType, stackType)) {
	            baseValues = this._createBaseValuesForNormalStackedChart(chartType);
	        } else {
	            baseValues = this.getValues(chartType, valueType, axisType);
	        }
	
	        return baseValues;
	    };
	
	    /**
	     * Find overflow item than graph area
	     * @param {string} chartType - chart type
	     * @param {string} valueType - value type
	     * @returns {{minItem: SeriesItem, maxItem: SeriesItem}}
	     */
	
	
	    DataProcessor.prototype.findOverflowItem = function findOverflowItem(chartType, valueType) {
	        var seriesDataModel = this.getSeriesDataModel(chartType);
	        var maxRadiusValue = seriesDataModel.getMaxValue('r');
	        var isBiggerRatioThanHalfRatio = function isBiggerRatioThanHalfRatio(seriesItem) {
	            return seriesItem.r / maxRadiusValue > _const2['default'].HALF_RATIO;
	        };
	
	        return {
	            minItem: seriesDataModel.findMinSeriesItem(valueType, isBiggerRatioThanHalfRatio),
	            maxItem: seriesDataModel.findMaxSeriesItem(valueType, isBiggerRatioThanHalfRatio)
	        };
	    };
	
	    /**
	     * Register color and opacity data of tooltip icon
	     * @param {Array.<Array.<object>>} colors - color and opacities setGraphColors
	     * @ignore
	     */
	
	
	    DataProcessor.prototype.setGraphColors = function setGraphColors(colors) {
	        this.graphColors = colors;
	    };
	
	    /**
	     * Get color and opacity data of tooltip data
	     * @returns {Array.<Array.<object>>} - color and opacities set
	     * @ignore
	     */
	
	
	    DataProcessor.prototype.getGraphColors = function getGraphColors() {
	        return this.graphColors;
	    };
	
	    /**
	     * Check The donut chart on pie donut combo chart has outer label align option
	     * @returns {boolean} - whether donut chart has outer label align option or not
	     * @ignore
	     */
	
	
	    DataProcessor.prototype.isComboDonutShowOuterLabel = function isComboDonutShowOuterLabel() {
	        var seriesOptions = this.options.series;
	
	        return seriesOptions && seriesOptions.pie2 && seriesOptions.pie2.labelAlign === 'outer';
	    };
	
	    return DataProcessor;
	}(_dataProcessorBase2['default']);
	
	exports['default'] = DataProcessor;

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview data processor base.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	/**
	 * @classdesc data processor base.
	 * @class DataProcessorBase
	 * @private
	 */
	var DataProcessorBase = function () {
	    function DataProcessorBase() {
	        _classCallCheck(this, DataProcessorBase);
	    }
	
	    /**
	     * Initialize.
	     */
	    DataProcessorBase.prototype.baseInit = function baseInit() {
	        /**
	         * functions for formatting
	         * @type {Array.<function>}
	         */
	        this.formatFunctions = null;
	    };
	
	    /**
	     * Get values.
	     * @abstract
	     * @returns {Array}
	     */
	
	
	    DataProcessorBase.prototype.getValues = function getValues() {};
	
	    /**
	     * Get current  Data.
	     * @abstract
	     * @returns {Array}
	     */
	
	
	    DataProcessorBase.prototype.getCurrentData = function getCurrentData() {};
	
	    /**
	     * Get max value.
	     * @param {?string} chartType - type of chart
	     * @param {?string} valueType - type of value like value, x, y, r
	     * @returns {number}
	     */
	
	
	    DataProcessorBase.prototype.getMaxValue = function getMaxValue(chartType, valueType) {
	        return _arrayUtil2['default'].max(this.getValues(chartType, valueType));
	    };
	
	    /**
	     * Get max value.
	     * @param {?string} chartType - type of chart
	     * @param {?string} valueType - type of value like value, x, y, r
	     * @returns {number}
	     */
	
	
	    DataProcessorBase.prototype.getMinValue = function getMinValue(chartType, valueType) {
	        return _arrayUtil2['default'].min(this.getValues(chartType, valueType));
	    };
	
	    /**
	     * Get formatted max value.
	     * @param {?string} chartType - type of chart
	     * @param {?string} areaType - type of area like circleLegend
	     * @param {?string} valueType - type of value like value, x, y, r
	     * @returns {string | number}
	     */
	
	
	    DataProcessorBase.prototype.getFormattedMaxValue = function getFormattedMaxValue(chartType, areaType, valueType) {
	        var maxValue = this.getMaxValue(chartType, valueType);
	        var formatFunctions = this.getFormatFunctions();
	
	        return _renderUtil2['default'].formatValue({
	            value: maxValue,
	            formatFunctions: formatFunctions,
	            chartType: chartType,
	            areaType: areaType,
	            valueType: valueType
	        });
	    };
	
	    /**
	     * Get formatted max value.
	     * @param {?string} chartType - type of chart
	     * @param {?string} areaType - type of area like circleLegend
	     * @param {?string} valueType - type of value like value, x, y, r
	     * @returns {string | number}
	     */
	
	
	    DataProcessorBase.prototype.getFormattedMinValue = function getFormattedMinValue(chartType, areaType, valueType) {
	        var maxValue = this.getMinValue(chartType, valueType);
	        var formatFunctions = this.getFormatFunctions();
	
	        return _renderUtil2['default'].formatValue({
	            value: maxValue,
	            formatFunctions: formatFunctions,
	            chartType: chartType,
	            areaType: areaType,
	            valueType: valueType
	        });
	    };
	
	    /**
	     * Pick max length under point.
	     * @param {string[]} values chart values
	     * @returns {number} max length under point
	     * @private
	     */
	
	
	    DataProcessorBase.prototype._pickMaxLenUnderPoint = function _pickMaxLenUnderPoint(values) {
	        var max = 0;
	
	        values.forEach(function (value) {
	            var len = _calculator2['default'].getDecimalLength(value);
	            if (len > max) {
	                max = len;
	            }
	        });
	
	        return max;
	    };
	
	    /**
	     * Whether zero fill format or not.
	     * @param {string} format format
	     * @returns {boolean} result boolean
	     * @private
	     */
	
	
	    DataProcessorBase.prototype._isZeroFill = function _isZeroFill(format) {
	        return format.length > 2 && format.charAt(0) === '0';
	    };
	
	    /**
	     * Whether decimal format or not.
	     * @param {string} format format
	     * @returns {boolean} result boolean
	     * @private
	     */
	
	
	    DataProcessorBase.prototype._isDecimal = function _isDecimal(format) {
	        var indexOf = format.indexOf('.');
	
	        return indexOf > -1 && indexOf < format.length - 1;
	    };
	
	    /**
	     * Whether comma format or not.
	     * @param {string} format format
	     * @returns {boolean} result boolean
	     * @private
	     */
	
	
	    DataProcessorBase.prototype._isComma = function _isComma(format) {
	        return format.indexOf(',') > -1;
	    };
	
	    /**
	     * Format to zero fill.
	     * @param {number} len length of result
	     * @param {string} value target value
	     * @returns {string} formatted value
	     * @private
	     */
	
	
	    DataProcessorBase.prototype._formatToZeroFill = function _formatToZeroFill(len, value) {
	        var isMinus = value < 0;
	
	        value = _renderUtil2['default'].formatToZeroFill(Math.abs(value), len);
	
	        return (isMinus ? '-' : '') + value;
	    };
	
	    /**
	     * Format to Decimal.
	     * @param {number} len length of under decimal point
	     * @param {string} value target value
	     * @returns {string} formatted value
	     * @private
	     */
	
	
	    DataProcessorBase.prototype._formatToDecimal = function _formatToDecimal(len, value) {
	        return _renderUtil2['default'].formatToDecimal(value, len);
	    };
	
	    /**
	     * Find simple type format functions.
	     * @param {string} format - simple format
	     * @returns {Array.<function>}
	     * @private
	     */
	
	
	    DataProcessorBase.prototype._findSimpleTypeFormatFunctions = function _findSimpleTypeFormatFunctions(format) {
	        var funcs = [];
	        var len = void 0;
	
	        if (this._isDecimal(format)) {
	            len = this._pickMaxLenUnderPoint([format]);
	            funcs = [_tuiCodeSnippet2['default'].bind(this._formatToDecimal, this, len)];
	        } else if (this._isZeroFill(format)) {
	            len = format.length;
	            funcs = [_tuiCodeSnippet2['default'].bind(this._formatToZeroFill, this, len)];
	
	            return funcs;
	        }
	
	        if (this._isComma(format)) {
	            funcs.push(_renderUtil2['default'].formatToComma);
	        }
	
	        return funcs;
	    };
	
	    /**
	     * Find format functions.
	     * @returns {function[]} functions
	     * @private
	     */
	
	
	    DataProcessorBase.prototype._findFormatFunctions = function _findFormatFunctions() {
	        var format = _tuiCodeSnippet2['default'].pick(this.options, 'chart', 'format');
	        var funcs = [];
	
	        if (_tuiCodeSnippet2['default'].isFunction(format)) {
	            funcs = [format];
	        } else if (_tuiCodeSnippet2['default'].isString(format)) {
	            funcs = this._findSimpleTypeFormatFunctions(format);
	        }
	
	        return funcs;
	    };
	
	    /**
	     * Get format functions.
	     * @returns {Array.<function>} functions
	     */
	
	
	    DataProcessorBase.prototype.getFormatFunctions = function getFormatFunctions() {
	        if (!this.formatFunctions) {
	            this.formatFunctions = this._findFormatFunctions();
	        }
	
	        return this.formatFunctions;
	    };
	
	    return DataProcessorBase;
	}();
	
	exports['default'] = DataProcessorBase;

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _seriesGroup = __webpack_require__(431);
	
	var _seriesGroup2 = _interopRequireDefault(_seriesGroup);
	
	var _seriesItem = __webpack_require__(432);
	
	var _seriesItem2 = _interopRequireDefault(_seriesItem);
	
	var _seriesItemForCoordinateType = __webpack_require__(433);
	
	var _seriesItemForCoordinateType2 = _interopRequireDefault(_seriesItemForCoordinateType);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview SeriesDataModel is base model for drawing graph of chart series area,
	                                                                                                                                                           *                  and create from rawSeriesData by user,
	                                                                                                                                                           * SeriesDataModel.groups has SeriesGroups.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	/*
	 * Raw series datum.
	 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
	 */
	
	/*
	 * Raw series data.
	 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
	 */
	
	/*
	 * Groups.
	 * @typedef {Array.<SeriesGroup>} groups
	 */
	
	/*
	 * SeriesGroup is a element of SeriesDataModel.groups.
	 * SeriesGroup.items has SeriesItem.
	 */
	
	/*
	 * SeriesItem is a element of SeriesGroup.items.
	 * SeriesItem has processed terminal data like value, ratio, etc.
	 */
	
	var concat = Array.prototype.concat;
	
	var SeriesDataModel = function () {
	    /**
	     * SeriesDataModel is base model for drawing graph of chart series area,
	     *      and create from rawSeriesData by user.
	     * SeriesDataModel.groups has SeriesGroups.
	     * @constructs SeriesDataModel
	     * @private
	     * @param {rawSeriesData} rawSeriesData - raw series data
	     * @param {string} chartType - chart type
	     * @param {object} options - options
	     * @param {Array.<function>} formatFunctions - format functions
	     * @param {boolean} isCoordinateType - whether coordinate type or not
	     * @private
	     */
	    function SeriesDataModel(rawSeriesData, chartType, options, formatFunctions, isCoordinateType) {
	        _classCallCheck(this, SeriesDataModel);
	
	        /**
	         * chart type
	         * @type {string}
	         */
	        this.chartType = chartType;
	
	        /**
	         * chart options
	         * @type {Object}
	         */
	        this.options = options || {};
	
	        /**
	         * functions for formatting
	         * @type {Array.<function>}
	         */
	        this.formatFunctions = formatFunctions;
	
	        /**
	         * rawData.series
	         * @type {rawSeriesData}
	         */
	        this.rawSeriesData = rawSeriesData || [];
	
	        /**
	         * whether coordinate type or not
	         * @type {boolean}
	         */
	        this.isCoordinateType = isCoordinateType;
	
	        /**
	         * baseGroups is base data for making SeriesGroups.
	         * SeriesGroups is made by pivoted baseGroups, lf line type chart.
	         * @type {Array.Array<SeriesItem>}
	         */
	        this.baseGroups = null;
	
	        /**
	         * groups has SeriesGroups.
	         * @type {Array.<SeriesGroup>}
	         */
	        this.groups = null;
	
	        this.options.series = this.options.series || {};
	
	        /**
	         * whether diverging chart or not.
	         * @type {boolean}
	         */
	        this.isDivergingChart = _predicate2['default'].isDivergingChart(chartType, this.options.series.diverging);
	
	        /**
	         * map of values by value type like value, x, y, r.
	         * @type {object.<string, Array.<number>>}
	         */
	        this.valuesMap = {};
	
	        this._removeRangeValue();
	    }
	
	    /**
	     * Remove range value of item, if has stackType option.
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._removeRangeValue = function _removeRangeValue() {
	        var seriesOption = _tuiCodeSnippet2['default'].pick(this.options, 'series') || {};
	        var allowRange = _predicate2['default'].isAllowRangeData(this.chartType) && !_predicate2['default'].isValidStackOption(seriesOption.stackType) && !seriesOption.spline;
	
	        if (allowRange || this.isCoordinateType) {
	            return;
	        }
	
	        Object.values(this.rawSeriesData).forEach(function (rawItem) {
	            if (!_tuiCodeSnippet2['default'].isArray(rawItem.data)) {
	                return;
	            }
	            rawItem.data.forEach(function (value, index) {
	                if (_tuiCodeSnippet2['default'].isExisty(value)) {
	                    var _concat$apply = concat.apply(value);
	
	                    var _concat$apply2 = _slicedToArray(_concat$apply, 1);
	
	                    rawItem.data[index] = _concat$apply2[0];
	                }
	            });
	        });
	    };
	
	    /**
	     * Create base groups.
	     * Base groups is two-dimensional array by seriesItems.
	     * @returns {Array.<Array.<(SeriesItem | SeriesItemForCoordinateType)>>}
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._createBaseGroups = function _createBaseGroups() {
	        var chartType = this.chartType,
	            formatFunctions = this.formatFunctions,
	            isDivergingChart = this.isDivergingChart,
	            isCoordinateType = this.isCoordinateType;
	
	        var xAxisOption = this.options.xAxis;
	        var isPieChart = _predicate2['default'].isPieChart(this.chartType);
	        var hasRawDatumAsArray = _predicate2['default'].isHeatmapChart(this.chartType) || _predicate2['default'].isTreemapChart(this.chartType);
	        var sortValues = void 0,
	            SeriesItemClass = void 0;
	
	        if (isCoordinateType) {
	            SeriesItemClass = _seriesItemForCoordinateType2['default'];
	            sortValues = function sortValues(items) {
	                items.sort(function (a, b) {
	                    return a.x - b.x;
	                });
	            };
	        } else {
	            SeriesItemClass = _seriesItem2['default'];
	            sortValues = function sortValues() {};
	        }
	
	        return this.rawSeriesData.map(function (rawDatum) {
	            var stack = void 0,
	                data = void 0,
	                legendName = void 0;
	
	            data = _tuiCodeSnippet2['default'].isArray(rawDatum) ? rawDatum : [].concat(rawDatum.data);
	
	            if (!hasRawDatumAsArray) {
	                stack = rawDatum.stack;
	            }
	            if (rawDatum.name) {
	                legendName = rawDatum.name;
	            }
	
	            if (isCoordinateType || isPieChart) {
	                data = _tuiCodeSnippet2['default'].filter(data, _tuiCodeSnippet2['default'].isExisty);
	            }
	
	            var items = data.map(function (datum, index) {
	                return new SeriesItemClass({
	                    datum: datum,
	                    chartType: chartType,
	                    formatFunctions: formatFunctions,
	                    index: index,
	                    legendName: legendName,
	                    stack: stack,
	                    isDivergingChart: isDivergingChart,
	                    xAxisType: xAxisOption.type,
	                    dateFormat: xAxisOption.dateFormat
	                });
	            });
	            sortValues(items);
	
	            return items;
	        });
	    };
	
	    /**
	     * Get base groups.
	     * @returns {Array.Array.<SeriesItem>}
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._getBaseGroups = function _getBaseGroups() {
	        if (!this.baseGroups) {
	            this.baseGroups = this._createBaseGroups();
	        }
	
	        return this.baseGroups;
	    };
	
	    /**
	     * Create SeriesGroups from rawData.series.
	     * @param {boolean} isPivot - whether pivot or not.
	     * @returns {Array.<SeriesGroup>}
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._createSeriesGroupsFromRawData = function _createSeriesGroupsFromRawData(isPivot) {
	        var baseGroups = this._getBaseGroups();
	
	        if (isPivot) {
	            baseGroups = _arrayUtil2['default'].pivot(baseGroups);
	        }
	
	        return baseGroups.map(function (items) {
	            return new _seriesGroup2['default'](items);
	        });
	    };
	
	    /**
	     * Get SeriesGroups.
	     * @returns {(Array.<SeriesGroup>|object)}
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._getSeriesGroups = function _getSeriesGroups() {
	        if (!this.groups) {
	            this.groups = this._createSeriesGroupsFromRawData(true);
	        }
	
	        return this.groups;
	    };
	
	    /**
	     * Get group count.
	     * @returns {Number}
	     */
	
	
	    SeriesDataModel.prototype.getGroupCount = function getGroupCount() {
	        return this._getSeriesGroups().length;
	    };
	
	    /**
	     * Get pivot groups.
	     * @returns {(Array.<SeriesGroup>|object)}
	     */
	
	
	    SeriesDataModel.prototype._getPivotGroups = function _getPivotGroups() {
	        if (!this.pivotGroups) {
	            this.pivotGroups = this._createSeriesGroupsFromRawData();
	        }
	
	        return this.pivotGroups;
	    };
	
	    /**
	     * Get SeriesGroup.
	     * @param {number} index - index
	     * @param {boolean} [isPivot] - whether pivot or not
	     * @returns {SeriesGroup}
	     */
	
	
	    SeriesDataModel.prototype.getSeriesGroup = function getSeriesGroup(index, isPivot) {
	        return isPivot ? this._getPivotGroups()[index] : this._getSeriesGroups()[index];
	    };
	
	    /**
	     * Get first SeriesGroup.
	     * @param {boolean} [isPivot] - whether pivot or not
	     * @returns {SeriesGroup}
	     */
	
	
	    SeriesDataModel.prototype.getFirstSeriesGroup = function getFirstSeriesGroup(isPivot) {
	        return this.getSeriesGroup(0, isPivot);
	    };
	
	    /**
	     * Get first label of SeriesItem.
	     * @returns {string} formatted value
	     */
	
	
	    SeriesDataModel.prototype.getFirstItemLabel = function getFirstItemLabel() {
	        return this.getFirstSeriesGroup().getFirstSeriesItem().label;
	    };
	
	    /**
	     * Get series item.
	     * @param {number} groupIndex - index of series groups
	     * @param {number} index - index of series items
	     * @param {boolean} [isPivot] - whether pivot or not
	     * @returns {SeriesItem}
	     */
	
	
	    SeriesDataModel.prototype.getSeriesItem = function getSeriesItem(groupIndex, index, isPivot) {
	        return this.getSeriesGroup(groupIndex, isPivot).getSeriesItem(index);
	    };
	
	    /**
	     * Get first series item.
	     * @returns {SeriesItem}
	     */
	
	
	    SeriesDataModel.prototype.getFirstSeriesItem = function getFirstSeriesItem() {
	        return this.getSeriesItem(0, 0);
	    };
	
	    /**
	     * Get value.
	     * @param {number} groupIndex - index of series groups
	     * @param {number} index - index of series items
	     * @returns {number} value
	     */
	
	
	    SeriesDataModel.prototype.getValue = function getValue(groupIndex, index) {
	        return this.getSeriesItem(groupIndex, index).value;
	    };
	
	    /**
	     * Get minimum value.
	     * @param {string} valueType - value type like value, x, y, r.
	     * @returns {number}
	     */
	
	
	    SeriesDataModel.prototype.getMinValue = function getMinValue(valueType) {
	        return _arrayUtil2['default'].min(this.getValues(valueType));
	    };
	
	    /**
	     * Get maximum value.
	     * @param {string} valueType - value type like value, x, y, r.
	     * @returns {number}
	     */
	
	
	    SeriesDataModel.prototype.getMaxValue = function getMaxValue(valueType) {
	        return _arrayUtil2['default'].max(this.getValues(valueType));
	    };
	
	    /**
	     * Traverse seriesGroups, and returns to found SeriesItem by result of execution seriesGroup.find with condition.
	     * @param {function} condition - condition function
	     * @returns {SeriesItem}
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._findSeriesItem = function _findSeriesItem(condition) {
	        var foundItem = void 0;
	
	        this.each(function (seriesGroup) {
	            foundItem = seriesGroup.find(condition);
	
	            return !foundItem;
	        });
	
	        return foundItem;
	    };
	
	    /**
	     * Find SeriesItem by value.
	     * @param {string} valueType - value type like value, x, y, r.
	     * @param {number} value - comparing value
	     * @param {function} condition - condition function
	     * @returns {SeriesItem}
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._findSeriesItemByValue = function _findSeriesItemByValue(valueType, value, condition) {
	        condition = condition || function () {
	            return null;
	        };
	
	        return this._findSeriesItem(function (seriesItem) {
	            return seriesItem && seriesItem[valueType] === value && condition(seriesItem);
	        });
	    };
	
	    /**
	     * Find minimum SeriesItem.
	     * @param {string} valueType - value type like value, x, y, r.
	     * @param {function} condition - condition function
	     * @returns {SeriesItem}
	     */
	
	
	    SeriesDataModel.prototype.findMinSeriesItem = function findMinSeriesItem(valueType, condition) {
	        var minValue = this.getMinValue(valueType);
	
	        return this._findSeriesItemByValue(valueType, minValue, condition);
	    };
	
	    /**
	     * Find maximum SeriesItem.
	     * @param {string} valueType - value type like value, x, y, r.
	     * @param {function} condition - condition function
	     * @returns {*|SeriesItem}
	     */
	
	
	    SeriesDataModel.prototype.findMaxSeriesItem = function findMaxSeriesItem(valueType, condition) {
	        var maxValue = this.getMaxValue(valueType);
	
	        return this._findSeriesItemByValue(valueType, maxValue, condition);
	    };
	
	    /**
	     * Create values that picked value from SeriesItems of SeriesGroups.
	     * @param {?string} valueType - type of value
	     * @returns {Array.<number>}
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._createValues = function _createValues(valueType) {
	        var _ref;
	
	        var values = this.map(function (seriesGroup) {
	            return seriesGroup.getValues(valueType);
	        });
	
	        values = (_ref = []).concat.apply(_ref, _toConsumableArray(values));
	
	        return values.filter(function (value) {
	            return !isNaN(value);
	        });
	    };
	
	    /**
	     * Get values form valuesMap.
	     * @param {?string} valueType - type of value
	     * @returns {Array.<number>}
	     */
	
	
	    SeriesDataModel.prototype.getValues = function getValues() {
	        var valueType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'value';
	
	        if (!this.valuesMap[valueType]) {
	            this.valuesMap[valueType] = this._createValues(valueType);
	        }
	
	        return this.valuesMap[valueType];
	    };
	
	    /**
	     * Whether count of x values greater than count of y values.
	     * @returns {boolean}
	     */
	
	
	    SeriesDataModel.prototype.isXCountGreaterThanYCount = function isXCountGreaterThanYCount() {
	        return this.getValues('x').length > this.getValues('y').length;
	    };
	
	    /**
	     * Add ratios, when has normal stackType option.
	     * @param {{min: number, max: number}} limit - axis limit
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._addRatiosWhenNormalStacked = function _addRatiosWhenNormalStacked(limit) {
	        var distance = Math.abs(limit.max - limit.min);
	
	        this.each(function (seriesGroup) {
	            seriesGroup.addRatios(distance);
	        });
	    };
	
	    /**
	     * Calculate base ratio for calculating ratio of item.
	     * @returns {number}
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._calculateBaseRatio = function _calculateBaseRatio() {
	        var values = this.getValues();
	        var plusSum = _calculator2['default'].sumPlusValues(values);
	        var minusSum = Math.abs(_calculator2['default'].sumMinusValues(values));
	        var ratio = plusSum > 0 && minusSum > 0 ? 0.5 : 1;
	
	        return ratio;
	    };
	
	    /**
	     * Add ratios, when has percent stackType option.
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._addRatiosWhenPercentStacked = function _addRatiosWhenPercentStacked() {
	        var baseRatio = this._calculateBaseRatio();
	
	        this.each(function (seriesGroup) {
	            seriesGroup.addRatiosWhenPercentStacked(baseRatio);
	        });
	    };
	
	    /**
	     * Add ratios, when has diverging stackType option.
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._addRatiosWhenDivergingStacked = function _addRatiosWhenDivergingStacked() {
	        this.each(function (seriesGroup) {
	            var values = seriesGroup.pluck('value');
	            var plusSum = _calculator2['default'].sumPlusValues(values);
	            var minusSum = Math.abs(_calculator2['default'].sumMinusValues(values));
	
	            seriesGroup.addRatiosWhenDivergingStacked(plusSum, minusSum);
	        });
	    };
	
	    /**
	     * Make subtraction value for making ratio of no option chart.
	     * @param {{min: number, max: number}} limit - limit
	     * @returns {number}
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._makeSubtractionValue = function _makeSubtractionValue(limit) {
	        var allowMinusPointRender = _predicate2['default'].allowMinusPointRender(this.chartType);
	        var subValue = 0;
	
	        if (!allowMinusPointRender && _predicate2['default'].isMinusLimit(limit)) {
	            subValue = limit.max;
	        } else if (allowMinusPointRender || limit.min >= 0) {
	            subValue = limit.min;
	        }
	
	        return subValue;
	    };
	
	    /**
	     * Add ratios, when has not option.
	     * @param {{min: number, max: number}} limit - axis limit
	     * @private
	     */
	
	
	    SeriesDataModel.prototype._addRatios = function _addRatios(limit) {
	        var distance = Math.abs(limit.max - limit.min);
	        var subValue = this._makeSubtractionValue(limit);
	
	        this.each(function (seriesGroup) {
	            seriesGroup.addRatios(distance, subValue);
	        });
	    };
	
	    /**
	     * Add data ratios.
	     * @param {{min: number, max: number}} limit - axis limit
	     * @param {string} stackType - stackType option
	     * @private
	     */
	
	
	    SeriesDataModel.prototype.addDataRatios = function addDataRatios(limit, stackType) {
	        var isAllowedStackOption = _predicate2['default'].isAllowedStackOption(this.chartType);
	
	        if (isAllowedStackOption && _predicate2['default'].isNormalStack(stackType)) {
	            this._addRatiosWhenNormalStacked(limit);
	        } else if (isAllowedStackOption && _predicate2['default'].isPercentStack(stackType)) {
	            if (this.isDivergingChart) {
	                this._addRatiosWhenDivergingStacked();
	            } else {
	                this._addRatiosWhenPercentStacked();
	            }
	        } else {
	            this._addRatios(limit);
	        }
	    };
	
	    /**
	     * Add data ratios of pie chart.
	     */
	
	
	    SeriesDataModel.prototype.addDataRatiosOfPieChart = function addDataRatiosOfPieChart() {
	        this.each(function (seriesGroup) {
	            var sum = _calculator2['default'].sum(seriesGroup.pluck('value'));
	
	            seriesGroup.addRatios(sum);
	        });
	    };
	
	    /**
	     * Add ratios of data for chart of coordinate type.
	     * @param {{x: {min: number, max: number}, y: {min: number, max: number}}} limitMap - limit map
	     * @param {boolean} [hasRadius] - whether has radius or not
	     */
	
	
	    SeriesDataModel.prototype.addDataRatiosForCoordinateType = function addDataRatiosForCoordinateType(limitMap, hasRadius) {
	        var xLimit = limitMap.xAxis;
	        var yLimit = limitMap.yAxis;
	        var maxRadius = hasRadius ? _arrayUtil2['default'].max(this.getValues('r')) : 0;
	        var xDistance = void 0,
	            xSubValue = void 0,
	            yDistance = void 0,
	            ySubValue = void 0;
	
	        if (xLimit) {
	            xDistance = Math.abs(xLimit.max - xLimit.min);
	            xSubValue = this._makeSubtractionValue(xLimit);
	        }
	
	        if (yLimit) {
	            yDistance = Math.abs(yLimit.max - yLimit.min);
	            ySubValue = this._makeSubtractionValue(yLimit);
	        }
	
	        this.each(function (seriesGroup) {
	            seriesGroup.each(function (item) {
	                if (!item) {
	                    return;
	                }
	
	                item.addRatio('x', xDistance, xSubValue);
	                item.addRatio('y', yDistance, ySubValue);
	                item.addRatio('r', maxRadius, 0);
	
	                if (_tuiCodeSnippet2['default'].isExisty(item.start)) {
	                    item.addRatio('start', yDistance, ySubValue);
	                }
	            });
	        });
	    };
	
	    /**
	     * Add start to all series item.
	     * @param {number} start - start value
	     */
	
	
	    SeriesDataModel.prototype.addStartValueToAllSeriesItem = function addStartValueToAllSeriesItem(start) {
	        this.each(function (seriesGroup) {
	            seriesGroup.addStartValueToAllSeriesItem(start);
	        });
	    };
	
	    /**
	     * Whether has range data or not.
	     * @returns {boolean}
	     */
	
	
	    SeriesDataModel.prototype.hasRangeData = function hasRangeData() {
	        var hasRangeData = false;
	
	        this.each(function (seriesGroup) {
	            hasRangeData = seriesGroup.hasRangeData();
	
	            return !hasRangeData;
	        });
	
	        return hasRangeData;
	    };
	
	    /**
	     * Traverse groups, and executes iteratee function.
	     * @param {function} iteratee - iteratee function
	     * @param {boolean} isPivot - whether pivot or not
	     */
	
	
	    SeriesDataModel.prototype.each = function each(iteratee, isPivot) {
	        var groups = isPivot ? this._getPivotGroups() : this._getSeriesGroups();
	
	        groups.forEach(function (seriesGroup, index) {
	            return iteratee(seriesGroup, index);
	        });
	    };
	
	    /**
	     * Traverse groups, and returns to result of execution about iteratee function.
	     * @param {function} iteratee - iteratee function
	     * @param {boolean} isPivot - whether pivot or not
	     * @returns {Array}
	     */
	
	
	    SeriesDataModel.prototype.map = function map(iteratee, isPivot) {
	        var results = [];
	
	        this.each(function (seriesGroup, index) {
	            results.push(iteratee(seriesGroup, index));
	        }, isPivot);
	
	        return results;
	    };
	
	    return SeriesDataModel;
	}();
	
	exports['default'] = SeriesDataModel;

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview SeriesGroup is a element of SeriesDataModel.groups.
	                                                                                                                                                           * SeriesGroup.items has SeriesItem.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var SeriesGroup = function () {
	    /**
	     * SeriesGroup is a element of SeriesDataModel.groups.
	     * SeriesGroup.items has SeriesItem.
	     * @constructs SeriesGroup
	     * @private
	     * @param {Array.<SeriesItem>} seriesItems - series items
	     */
	    function SeriesGroup(seriesItems) {
	        _classCallCheck(this, SeriesGroup);
	
	        /**
	         * items has SeriesItem
	         * @type {Array.<SeriesItem>}
	         */
	        this.items = seriesItems;
	
	        /**
	         * map of values by value type like value, x, y, r.
	         * @type {Array.<number>}
	         */
	        this.valuesMap = {};
	
	        this.valuesMapPerStack = null;
	    }
	
	    /**
	     * Get series item count.
	     * @returns {number}
	     */
	
	
	    SeriesGroup.prototype.getSeriesItemCount = function getSeriesItemCount() {
	        return this.items.length;
	    };
	
	    /**
	     * Get series item.
	     * @param {number} index - index of items
	     * @returns {SeriesItem}
	     */
	
	
	    SeriesGroup.prototype.getSeriesItem = function getSeriesItem(index) {
	        return this.items[index];
	    };
	
	    /**
	     * Get first SeriesItem.
	     * @returns {SeriesItem}
	     */
	
	
	    SeriesGroup.prototype.getFirstSeriesItem = function getFirstSeriesItem() {
	        return this.getSeriesItem(0);
	    };
	
	    /**
	     * Create values that picked value from SeriesItems.
	     * @param {?string} valueType - type of value
	     * @returns {Array.<number>}
	     * @private
	     */
	
	
	    SeriesGroup.prototype._createValues = function _createValues(valueType) {
	        var values = [];
	
	        this.each(function (item) {
	            if (!item) {
	                return;
	            }
	
	            if (_tuiCodeSnippet2['default'].isExisty(item[valueType])) {
	                values.push(item[valueType]);
	            }
	            if (_tuiCodeSnippet2['default'].isExisty(item.start)) {
	                values.push(item.start);
	            }
	        });
	
	        return values;
	    };
	
	    /**
	     * Get values from valuesMap.
	     * @param {?string} valueType - type of value
	     * @returns {Array}
	     */
	
	
	    SeriesGroup.prototype.getValues = function getValues(valueType) {
	        valueType = valueType || 'value';
	
	        if (!this.valuesMap[valueType]) {
	            this.valuesMap[valueType] = this._createValues(valueType);
	        }
	
	        return this.valuesMap[valueType];
	    };
	
	    /**
	     * Make values map per stack.
	     * @returns {object}
	     * @private
	     */
	
	
	    SeriesGroup.prototype._makeValuesMapPerStack = function _makeValuesMapPerStack() {
	        var valuesMap = {};
	
	        this.each(function (item) {
	            if (!valuesMap[item.stack]) {
	                valuesMap[item.stack] = [];
	            }
	            valuesMap[item.stack].push(item.value);
	        });
	
	        return valuesMap;
	    };
	
	    /**
	     * Get values map per stack.
	     * @returns {*|Object}
	     */
	
	
	    SeriesGroup.prototype.getValuesMapPerStack = function getValuesMapPerStack() {
	        if (!this.valuesMapPerStack) {
	            this.valuesMapPerStack = this._makeValuesMapPerStack();
	        }
	
	        return this.valuesMapPerStack;
	    };
	
	    /**
	     * Make sum map per stack.
	     * @returns {object} sum map
	     * @private
	     */
	
	
	    SeriesGroup.prototype._makeSumMapPerStack = function _makeSumMapPerStack() {
	        var valuesMap = this.getValuesMapPerStack();
	        var sumMap = {};
	
	        Object.entries(valuesMap).forEach(function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2),
	                key = _ref2[0],
	                values = _ref2[1];
	
	            sumMap[key] = _calculator2['default'].sum(values.map(function (value) {
	                return Math.abs(value);
	            }));
	        });
	
	        return sumMap;
	    };
	
	    /**
	     * Add start value to all series item.
	     * @param {number} start start value
	     */
	
	
	    SeriesGroup.prototype.addStartValueToAllSeriesItem = function addStartValueToAllSeriesItem(start) {
	        this.each(function (item) {
	            if (!item) {
	                return;
	            }
	            item.addStart(start);
	        });
	    };
	
	    /**
	     * Add ratios when percent stackType.
	     * @param {number} baseRatio - base ratio
	     */
	
	
	    SeriesGroup.prototype.addRatiosWhenPercentStacked = function addRatiosWhenPercentStacked(baseRatio) {
	        var sumMap = this._makeSumMapPerStack();
	
	        this.each(function (item) {
	            var dividingNumber = sumMap[item.stack];
	
	            item.addRatio(dividingNumber, 0, baseRatio);
	        });
	    };
	
	    /**
	     * Add ratios when diverging stacked.
	     * @param {number} plusSum - sum of plus number
	     * @param {number} minusSum - sum of minus number
	     */
	
	
	    SeriesGroup.prototype.addRatiosWhenDivergingStacked = function addRatiosWhenDivergingStacked(plusSum, minusSum) {
	        this.each(function (item) {
	            var dividingNumber = item.value >= 0 ? plusSum : minusSum;
	
	            item.addRatio(dividingNumber, 0, 0.5);
	        });
	    };
	
	    /**
	     * Add ratios.
	     * @param {number} divNumber dividing number
	     * @param {number} subValue subtraction value
	     */
	
	
	    SeriesGroup.prototype.addRatios = function addRatios(divNumber, subValue) {
	        this.each(function (item) {
	            if (!item) {
	                return;
	            }
	            item.addRatio(divNumber, subValue);
	        });
	    };
	
	    /**
	     * Whether has range data or not.
	     * @returns {boolean}
	     */
	
	
	    SeriesGroup.prototype.hasRangeData = function hasRangeData() {
	        var hasRangeData = false;
	
	        this.each(function (seriesItem) {
	            hasRangeData = seriesItem && seriesItem.isRange;
	
	            return !hasRangeData;
	        });
	
	        return hasRangeData;
	    };
	
	    /**
	     * Traverse items, and executes iteratee function.
	     * @param {function} iteratee - iteratee function
	     */
	
	
	    SeriesGroup.prototype.each = function each(iteratee) {
	        this.items.forEach(iteratee);
	    };
	
	    /**
	     * Traverse items, and returns to results of execution about iteratee function.
	     * @param {function} iteratee - iteratee function
	     * @returns {Array}
	     */
	
	
	    SeriesGroup.prototype.map = function map(iteratee) {
	        return this.items.map(iteratee);
	    };
	
	    /**
	     * Traverse items, and returns to picked result at item.
	     * @param {string} key key for pick
	     * @returns {Array}
	     */
	
	
	    SeriesGroup.prototype.pluck = function pluck(key) {
	        var items = this.items.filter(_tuiCodeSnippet2['default'].isExisty);
	
	        return _tuiCodeSnippet2['default'].pluck(items, key);
	    };
	
	    /**
	     * Traverse items, and returns to found SeriesItem by condition function.
	     * @param {function} condition - condition function
	     * @returns {SeriesItem|null}
	     */
	
	
	    SeriesGroup.prototype.find = function find(condition) {
	        var foundItem = void 0;
	
	        this.each(function (seriesItem) {
	            if (condition(seriesItem)) {
	                foundItem = seriesItem;
	            }
	
	            return !foundItem;
	        });
	
	        return foundItem || null;
	    };
	
	    /**
	     * Traverse items, and returns to filter SeriesItems by condition function.
	     * @param {function} condition - condition function
	     * @returns {Array}
	     */
	
	
	    SeriesGroup.prototype.filter = function filter(condition) {
	        return this.items.filter(condition);
	    };
	
	    return SeriesGroup;
	}();
	
	exports['default'] = SeriesGroup;

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview SeriesItem is a element of SeriesGroup.items.
	                                                                                                                                                           * SeriesItem has processed terminal data like value, ratio, etc.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var SeriesItem = function () {
	  /**
	   * SeriesItem is a element of SeriesGroup.items.
	   * SeriesItem has processed terminal data like value, ratio, etc.
	   * @constructs SeriesItem
	   * @private
	   * @param {object} params - parameters
	   *      @param {number} params.datum - value
	   *      @param {string} params.chartType - type of chart
	   *      @param {?Array.<function>} params.formatFunctions - format functions
	   *      @param {number} params.index - raw data index
	   *      @param {?string} params.stack - stack
	   */
	  function SeriesItem(params) {
	    _classCallCheck(this, SeriesItem);
	
	    /**
	     * type of chart
	     * @type {string}
	     */
	    this.chartType = params.chartType;
	
	    /**
	     * for group stack option.
	     * @type {string}
	     */
	    this.stack = params.stack || _const2['default'].DEFAULT_STACK;
	
	    /**
	     * whether diverging chart or not
	     * @type {boolean}
	     */
	    this.isDivergingChart = params.isDivergingChart;
	
	    /**
	     * format functions
	     * @type {Array.<function>}
	     */
	    this.formatFunctions = params.formatFunctions;
	
	    /**
	     * whether range item or not
	     * @type {boolean}
	     */
	    this.isRange = false;
	
	    /**
	     * value of item
	     * @type {number}
	     */
	    this.value = null;
	
	    /**
	     * label
	     * @type {string}
	     */
	    this.label = null;
	
	    /**
	     * tooltip label
	     * @type {string}
	     */
	    this.tooltipLabel = null;
	
	    /**
	     * ratio of value about distance of limit
	     * @type {number}
	     */
	    this.ratio = null;
	
	    /**
	     * end value of item.
	     * @type {number}
	     */
	    this.end = null;
	
	    /**
	     * end label
	     * @type {number}
	     */
	    this.endLabel = null;
	
	    /**
	     * ratio of end value
	     * @type {number}
	     */
	    this.endRatio = null;
	
	    /**
	     * start value of item.
	     * @type {number}
	     */
	    this.start = null;
	
	    /**
	     * start label
	     * @type {number}
	     */
	    this.startLabel = null;
	
	    /**
	     * ratio of start value
	     * @type {number}
	     */
	
	    this.startRatio = null;
	
	    /**
	     * distance of start ratio and end ratio
	     * @type {null}
	     */
	    this.ratioDistance = null;
	
	    if (_predicate2['default'].isBulletChart(this.chartType)) {
	      /**
	       * @type {string}
	       */
	      this.type = params.type;
	    }
	
	    /**
	     * series legend name
	     * @type {string}
	     */
	    this.legendName = params.legendName;
	
	    this._initValues(params.datum, params.index);
	  }
	
	  /**
	   * Initialize values of item.
	   * @param {number|Array.<number>} rawValue - raw value
	   * @param {number} index - raw data index
	   * @private
	   */
	
	
	  SeriesItem.prototype._initValues = function _initValues(rawValue, index) {
	    var _this = this;
	
	    var values = this._createValues(rawValue);
	    var hasStart = values.length > 1;
	
	    var _values = _slicedToArray(values, 1),
	        value = _values[0];
	
	    this.value = this.end = value;
	    this.index = index;
	
	    if (this.isDivergingChart) {
	      value = Math.abs(value);
	    }
	
	    if (_tuiCodeSnippet2['default'].isNull(value)) {
	      this._setLabel('');
	    } else {
	      ['label', 'tooltipLabel'].forEach(function (labelType) {
	        _this[labelType] = _renderUtil2['default'].formatValue({
	          value: value,
	          formatFunctions: _this.formatFunctions,
	          chartType: _this.chartType,
	          areaType: labelType === 'tooltipLabel' ? 'makingTooltipLabel' : 'makingSeriesLabel',
	          legendName: _this.legendName
	        });
	      });
	    }
	
	    this.endLabel = this.label;
	
	    if (hasStart) {
	      this.addStart(values[1], true);
	      this._updateFormattedValueforRange();
	      this.isRange = true;
	    }
	  };
	
	  /**
	   * set label property
	   * @param {string} value set value
	   * @private
	   */
	
	
	  SeriesItem.prototype._setLabel = function _setLabel(value) {
	    this.label = value;
	    this.tooltipLabel = value;
	  };
	
	  /**
	   * Crete sorted values.
	   * @param {Array.<number>|number} value value
	   * @returns {Array.<number>}
	   * @private
	   */
	
	
	  SeriesItem.prototype._createValues = function _createValues(value) {
	    var values = [].concat(value).map(function (newValue) {
	      return _tuiCodeSnippet2['default'].isNull(newValue) ? null : parseFloat(newValue);
	    });
	
	    values = values.sort(function (a, b) {
	      if (a < 0 && b < 0) {
	        return a - b;
	      }
	
	      return b - a;
	    });
	
	    return values;
	  };
	
	  /**
	   * Add start.
	   * @param {number} value - value
	   * @ignore
	   */
	
	
	  SeriesItem.prototype.addStart = function addStart(value) {
	    if (!_tuiCodeSnippet2['default'].isNull(this.start)) {
	      return;
	    }
	
	    this.start = value;
	    this.startLabel = _renderUtil2['default'].formatValue({
	      value: value,
	      formatFunctions: this.formatFunctions,
	      chartType: this.chartType,
	      areaType: 'series',
	      legendName: this.legendName
	    });
	  };
	
	  /**
	   * Update formatted value for range.
	   * @private
	   */
	
	
	  SeriesItem.prototype._updateFormattedValueforRange = function _updateFormattedValueforRange() {
	    this._setLabel(this.startLabel + ' ~ ' + this.endLabel);
	  };
	
	  /**
	   * Add ratio.
	   * @param {number} divNumber - number for division
	   * @param {?number} subNumber - number for subtraction
	   * @param {?number} baseRatio - base ratio
	   */
	
	
	  SeriesItem.prototype.addRatio = function addRatio() {
	    var divNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	    var subNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var baseRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	
	    this.ratio = this.endRatio = _calculator2['default'].calculateRatio(this.value, divNumber, subNumber, baseRatio);
	
	    if (_tuiCodeSnippet2['default'].isExisty(this.start)) {
	      this.startRatio = _calculator2['default'].calculateRatio(this.start, divNumber, subNumber, baseRatio);
	      this.ratioDistance = Math.abs(this.endRatio - this.startRatio);
	    }
	  };
	
	  /**
	   * Get formatted value for tooltip.
	   * @param {string} valueType - value type
	   * @returns {string}
	   * @private
	   */
	
	
	  SeriesItem.prototype._getFormattedValueForTooltip = function _getFormattedValueForTooltip(valueType) {
	    return _renderUtil2['default'].formatValue({
	      value: this[valueType],
	      formatFunctions: this.formatFunctions,
	      chartType: this.chartType,
	      areaType: 'tooltip',
	      valueType: valueType,
	      legendName: this.legendName
	    });
	  };
	
	  /**
	   * Pick value map for tooltip.
	   * @returns {{value: number, start: ?number, end: ?number}}
	   */
	
	
	  SeriesItem.prototype.pickValueMapForTooltip = function pickValueMapForTooltip() {
	    var valueMap = {
	      value: this._getFormattedValueForTooltip('value'),
	      ratio: this.ratio
	    };
	
	    if (_tuiCodeSnippet2['default'].isExisty(this.start)) {
	      valueMap.start = this._getFormattedValueForTooltip('start');
	      valueMap.end = this._getFormattedValueForTooltip('end');
	      valueMap.startRatio = this.startRatio;
	      valueMap.endRatio = this.endRatio;
	    }
	
	    return valueMap;
	  };
	
	  return SeriesItem;
	}();
	
	exports['default'] = SeriesItem;

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview SeriesItemForCoordinateType is a element of SeriesGroup.items.
	                                                                                                                                                           * SeriesItemForCoordinateType has processed terminal data like x, y, r, xRatio, yRatio, rRatio.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var SeriesItemForCoordinateType = function () {
	    /**
	     * SeriesItemForCoordinateType is a element of SeriesGroup.items.
	     * SeriesItemForCoordinateType has processed terminal data like x, y, r, xRatio, yRatio, rRatio.
	     * @constructs SeriesItemForCoordinateType
	     * @private
	     * @param {object} params - parameters
	     *      @param {Array.<number>|{x: number, y:number, r: ?number, label: ?string}} params.datum - raw series datum
	     *      @param {string} params.chartType - type of chart
	     *      @param {?Array.<function>} params.formatFunctions - format functions
	     *      @param {number} params.index - raw data index
	     */
	    function SeriesItemForCoordinateType(params) {
	        _classCallCheck(this, SeriesItemForCoordinateType);
	
	        /**
	         * type of chart
	         * @type {string}
	         */
	        this.chartType = params.chartType;
	
	        /**
	         * format functions
	         * @type {Array.<function>}
	         */
	        this.formatFunctions = params.formatFunctions;
	
	        /**
	         * x axis type
	         * @type {?string}
	         */
	        this.xAxisType = params.xAxisType;
	
	        /**
	         * date format
	         * @type {?string}
	         */
	        this.dateFormat = params.dateFormat;
	
	        /**
	         * ratio map
	         * @type {object}
	         */
	        this.ratioMap = {};
	
	        this._initData(params.datum, params.index);
	    }
	
	    /**
	     * Initialize data of item.
	     @param {Array.<number>|{x: number, y:number, r: ?number, label: ?string}} rawSeriesDatum - raw series datum
	     * @param {number} index - raw data index
	     * @private
	     */
	
	
	    SeriesItemForCoordinateType.prototype._initData = function _initData(rawSeriesDatum, index) {
	        var date = void 0;
	
	        if (_tuiCodeSnippet2['default'].isArray(rawSeriesDatum)) {
	            this.x = rawSeriesDatum[0] || 0;
	            this.y = rawSeriesDatum[1] || 0;
	            if (_predicate2['default'].isBubbleChart(this.chartType)) {
	                var _rawSeriesDatum = _slicedToArray(rawSeriesDatum, 4);
	
	                this.r = _rawSeriesDatum[2];
	                var _rawSeriesDatum$ = _rawSeriesDatum[3];
	                this.label = _rawSeriesDatum$ === undefined ? '' : _rawSeriesDatum$;
	            } else {
	                var _rawSeriesDatum2 = _slicedToArray(rawSeriesDatum, 3);
	
	                var _rawSeriesDatum2$ = _rawSeriesDatum2[2];
	                this.label = _rawSeriesDatum2$ === undefined ? '' : _rawSeriesDatum2$;
	            }
	        } else {
	            this.x = rawSeriesDatum.x;
	            this.y = rawSeriesDatum.y;
	            this.r = rawSeriesDatum.r;
	            this.label = rawSeriesDatum.label || '';
	        }
	
	        if (_predicate2['default'].isDatetimeType(this.xAxisType)) {
	            date = _tuiCodeSnippet2['default'].isDate(this.x) ? this.x : new Date(this.x);
	            this.x = date.getTime() || 0;
	        }
	
	        this.index = index;
	
	        if (!this.label) {
	            if (_predicate2['default'].isLineTypeChart(this.chartType) && _predicate2['default'].isDatetimeType(this.xAxisType)) {
	                this.label = _renderUtil2['default'].formatDate(this.x, this.dateFormat);
	            } else {
	                this.label = _renderUtil2['default'].formatValue({
	                    value: this.x,
	                    formatFunctions: this.formatFunctions,
	                    chartType: this.chartType,
	                    areaType: 'series'
	                });
	            }
	
	            var labelItem = _renderUtil2['default'].formatValue({
	                value: this.y,
	                formatFunctions: this.formatFunctions,
	                chartType: this.chartType,
	                areaType: 'series'
	            });
	
	            this.label += ',&nbsp;' + labelItem;
	        }
	    };
	
	    /**
	     * Add start.
	     * @param {number} value - value
	     * @private
	     */
	
	
	    SeriesItemForCoordinateType.prototype.addStart = function addStart(value) {
	        this.start = value;
	    };
	
	    /**
	     * Add ratio.
	     * @param {string} valueType - type of value like x, y, r
	     * @param {?number} divNumber - number for division
	     * @param {?number} subNumber - number for subtraction
	     */
	
	
	    SeriesItemForCoordinateType.prototype.addRatio = function addRatio(valueType, divNumber, subNumber) {
	        if (!_tuiCodeSnippet2['default'].isExisty(this.ratioMap[valueType]) && divNumber) {
	            this.ratioMap[valueType] = (this[valueType] - subNumber) / divNumber;
	        }
	    };
	
	    /**
	     * Get formatted value for tooltip.
	     * @param {string} valueType - value type
	     * @returns {string}
	     * @private
	     */
	
	
	    SeriesItemForCoordinateType.prototype._getFormattedValueForTooltip = function _getFormattedValueForTooltip(valueType) {
	        var ratio = this.ratioMap[valueType];
	        var value = this[valueType];
	        var formattedValue = _renderUtil2['default'].formatValue({
	            value: value,
	            formatFunctions: this.formatFunctions,
	            chartType: this.chartType,
	            areaType: 'tooltip',
	            valueType: valueType
	        });
	
	        return _tuiCodeSnippet2['default'].isNumber(ratio) ? formattedValue : value;
	    };
	
	    /**
	     * Pick value map for tooltip.
	     * @returns {{x: (number | null), y: (number | null), r: (number | null)}}
	     */
	
	
	    SeriesItemForCoordinateType.prototype.pickValueMapForTooltip = function pickValueMapForTooltip() {
	        var valueMap = {
	            x: this._getFormattedValueForTooltip('x'),
	            y: this._getFormattedValueForTooltip('y'),
	            xRatio: this.ratioMap.x,
	            yRatio: this.ratioMap.y
	        };
	
	        if (_tuiCodeSnippet2['default'].isExisty(this.r)) {
	            valueMap.r = this._getFormattedValueForTooltip('r');
	            valueMap.rRatio = this.ratioMap.r;
	        }
	
	        return valueMap;
	    };
	
	    return SeriesItemForCoordinateType;
	}();
	
	exports['default'] = SeriesItemForCoordinateType;

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _seriesItemForBoxplot = __webpack_require__(435);
	
	var _seriesItemForBoxplot2 = _interopRequireDefault(_seriesItemForBoxplot);
	
	var _seriesDataModel = __webpack_require__(430);
	
	var _seriesDataModel2 = _interopRequireDefault(_seriesDataModel);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview SeriesDataModelForBoxplot is boxplot series model for drawing graph of chart series area,
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *                  and create from rawSeriesData by user,
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SeriesDataModel.groups has SeriesGroups.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/*
	 * Raw series datum.
	 * @typedef {{name: ?string, data: Array.<number>, stack: ?string}} rawSeriesDatum
	 */
	
	/*
	 * Raw series data.
	 * @typedef {Array.<rawSeriesDatum>} rawSeriesData
	 */
	
	/*
	 * Groups.
	 * @typedef {Array.<SeriesGroup>} groups
	 */
	
	/*
	 * SeriesGroup is a element of SeriesDataModel.groups.
	 * SeriesGroup.items has SeriesItem.
	 */
	
	/*
	 * SeriesItem is a element of SeriesGroup.items.
	 * SeriesItem has processed terminal data like value, ratio, etc.
	 */
	
	var concat = Array.prototype.concat;
	
	var SeriesDataModelForBoxplot = function (_SeriesDataModel) {
	  _inherits(SeriesDataModelForBoxplot, _SeriesDataModel);
	
	  /**
	   * SeriesDataModelForBoxplot is series model for boxplot chart
	   * SeriesDataModel.groups has SeriesGroups.
	   * @constructs SeriesDataModel
	   * @param {rawSeriesData} rawSeriesData - raw series data
	   * @param {string} chartType - chart type
	   * @param {object} options - options
	   * @param {Array.<function>} formatFunctions - format functions
	   * @private
	   */
	  function SeriesDataModelForBoxplot(rawSeriesData, chartType, options, formatFunctions) {
	    _classCallCheck(this, SeriesDataModelForBoxplot);
	
	    /**
	     * chart type
	     * @type {string}
	     */
	    var _this = _possibleConstructorReturn(this, _SeriesDataModel.call(this));
	
	    _this.chartType = chartType;
	
	    /**
	     * chart options
	     * @type {Object}
	     */
	    _this.options = options || {};
	
	    /**
	     * functions for formatting
	     * @type {Array.<function>}
	     */
	    _this.formatFunctions = formatFunctions;
	
	    /**
	     * rawData.series
	     * @type {rawSeriesData}
	     */
	    _this.rawSeriesData = rawSeriesData || [];
	
	    /**
	     * baseGroups is base data for making SeriesGroups.
	     * SeriesGroups is made by pivoted baseGroups, lf line type chart.
	     * @type {Array.Array<SeriesItem>}
	     */
	    _this.baseGroups = null;
	
	    /**
	     * groups has SeriesGroups.
	     * @type {Array.<SeriesGroup>}
	     */
	    _this.groups = null;
	
	    _this.options.series = _this.options.series || {};
	
	    /**
	     * map of values by value type like value, x, y, r.
	     * @type {object.<string, Array.<number>>}
	     */
	    _this.valuesMap = {};
	    return _this;
	  }
	
	  /**
	   * Create base groups.
	   * Base groups is two-dimensional array by seriesItems.
	   * @returns {Array.<Array.<(SeriesItem | SeriesItemForCoordinateType)>>}
	   * @private
	   * @override
	   */
	
	
	  SeriesDataModelForBoxplot.prototype._createBaseGroups = function _createBaseGroups() {
	    var chartType = this.chartType,
	        formatFunctions = this.formatFunctions;
	
	
	    return this.rawSeriesData.map(function (rawDatum) {
	      var data = _tuiCodeSnippet2['default'].isArray(rawDatum) ? rawDatum : [].concat(rawDatum.data);
	      var items = data.map(function (datum, index) {
	        return new _seriesItemForBoxplot2['default']({
	          datum: datum,
	          chartType: chartType,
	          formatFunctions: formatFunctions,
	          index: index,
	          legendName: rawDatum.name
	        });
	      });
	
	      return items;
	    });
	  };
	
	  /**
	   * Create values that picked value from SeriesItems of SeriesGroups.
	   * @returns {Array.<number>}
	   * @private
	   * * @override
	   */
	
	
	  SeriesDataModelForBoxplot.prototype._createValues = function _createValues() {
	    var values = [];
	    this.map(function (seriesGroup) {
	      return seriesGroup.items.forEach(function (group) {
	        values.push(group.min);
	        values.push(group.max);
	        values.push(group.uq);
	        values.push(group.lq);
	        values.push(group.median);
	      });
	    });
	
	    values = concat.apply([], values);
	
	    return values.filter(function (value) {
	      return !isNaN(value);
	    });
	  };
	
	  return SeriesDataModelForBoxplot;
	}(_seriesDataModel2['default']);
	
	exports['default'] = SeriesDataModelForBoxplot;

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview SeriesItem is a element of SeriesGroup.items.
	                                                                                                                                                           * SeriesItem has processed terminal data like value, ratio, etc.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var SeriesItem = function () {
	  /**
	   * SeriesItem is a element of SeriesGroup.items.
	   * SeriesItem has processed terminal data like value, ratio, etc.
	   * @constructs SeriesItem
	   * @private
	   * @param {object} params - parameters
	   *      @param {number} params.datum - value
	   *      @param {string} params.chartType - type of chart
	   *      @param {?Array.<function>} params.formatFunctions - format functions
	   *      @param {number} params.index - raw data index
	   *      @param {?string} params.stack - stack
	   */
	  function SeriesItem(params) {
	    _classCallCheck(this, SeriesItem);
	
	    /**
	     * type of chart
	     * @type {string}
	     */
	    this.chartType = params.chartType;
	
	    /**
	     * format functions
	     * @type {Array.<function>}
	     */
	    this.formatFunctions = params.formatFunctions;
	
	    /**
	     * value of item
	     * @type {number}
	     */
	    this.value = null;
	
	    /**
	     * label
	     * @type {string}
	     */
	    this.label = null;
	
	    /**
	     * ratio of value about distance of limit
	     * @type {number}
	     */
	    this.ratio = null;
	
	    /**
	     * min value of item.
	     * @type {number}
	     */
	    this.min = null;
	
	    /**
	     * min label
	     * @type {number}
	     */
	    this.minLabel = null;
	
	    /**
	     * ratio of end value
	     * @type {number}
	     */
	    this.minRatio = null;
	
	    /**
	     * max value of item.
	     * @type {number}
	     */
	    this.max = null;
	
	    /**
	     * max label
	     * @type {number}
	     */
	    this.maxLabel = null;
	
	    /**
	     * ratio of max value
	     * @type {number}
	     */
	    this.maxRatio = null;
	
	    /**
	     * median value of item.
	     * @type {number}
	     */
	    this.median = null;
	
	    /**
	     * median label
	     * @type {number}
	     */
	    this.medianLabel = null;
	
	    /**
	     * ratio of median value
	     * @type {number}
	     */
	    this.medianRatio = null;
	
	    /**
	     * lq value of item.
	     * @type {number}
	     */
	    this.lq = null;
	
	    /**
	     * lq label
	     * @type {number}
	     */
	    this.lqLabel = null;
	
	    /**
	     * ratio of lq value
	     * @type {number}
	     */
	    this.lqRatio = null;
	
	    /**
	     * uq value of item.
	     * @type {number}
	     */
	    this.uq = null;
	
	    /**
	     * uq label
	     * @type {number}
	     */
	    this.uqLabel = null;
	
	    /**
	     * ratio of uq value
	     * @type {number}
	     */
	    this.uqRatio = null;
	
	    /**
	     * distance of start ratio and end ratio
	     * @type {null}
	     */
	    this.ratioDistance = null;
	
	    /**
	     * series legend name
	     * @type {string}
	     */
	    this.legendName = params.legendName;
	
	    this._initValues(params.datum, params.index);
	  }
	
	  /**
	   * Initialize values of item.
	   * @param {number|Array.<number>} rawValue - raw value
	   * @param {number} index - raw data index
	   * @private
	   */
	
	
	  SeriesItem.prototype._initValues = function _initValues(rawValue, index) {
	    var _this = this;
	
	    var values = this._createValues(rawValue);
	
	    var _values = _slicedToArray(values, 5),
	        min = _values[0],
	        lq = _values[1],
	        median = _values[2],
	        uq = _values[3],
	        max = _values[4];
	
	    var hasOutlier = values.length > 5;
	    var outliers = void 0;
	    var formatValue = function formatValue(value) {
	      return _renderUtil2['default'].formatValue({
	        value: value,
	        formatFunctions: _this.formatFunctions,
	        chartType: _this.chartType,
	        areaType: 'makingSeriesLabel',
	        legendName: _this.legendName
	      });
	    };
	
	    this.value = this.max = max;
	    this.uq = uq;
	    this.median = median;
	    this.lq = lq;
	    this.min = min;
	    this.index = index;
	
	    if (hasOutlier) {
	      this.outliers = [];
	
	      outliers = this.outliers;
	
	
	      values.slice(5).forEach(function (outlier) {
	        outliers.push({
	          value: outlier,
	          label: formatValue(outlier)
	        });
	      });
	    }
	
	    this.label = formatValue(max);
	    this.uqLabel = formatValue(uq);
	    this.medianLabel = formatValue(median);
	    this.lqLabel = formatValue(lq);
	    this.minLabel = formatValue(min);
	
	    this.maxLabel = this.label;
	  };
	
	  /**
	   * Crete sorted values.
	   * @param {Array.<number>|number} value value
	   * @returns {Array.<number>}
	   * @private
	   */
	
	
	  SeriesItem.prototype._createValues = function _createValues(value) {
	    return [].concat(value).map(function (newValue) {
	      return _tuiCodeSnippet2['default'].isNull(newValue) ? null : parseFloat(newValue);
	    });
	  };
	
	  /**
	   * Add min.
	   * @param {number} value - value
	   * @private
	   */
	
	
	  SeriesItem.prototype.addStart = function addStart(value) {
	    if (!_tuiCodeSnippet2['default'].isNull(this.min)) {
	      return;
	    }
	
	    this.min = value;
	    this.minLabel = _renderUtil2['default'].formatValue({
	      value: value,
	      formatFunctions: this.formatFunctions,
	      chartType: this.chartType,
	      areaType: 'series',
	      legendName: this.legendName
	    });
	  };
	
	  /**
	   * Update formatted value for range.
	   * @private
	   */
	
	
	  SeriesItem.prototype._updateFormattedValueforRange = function _updateFormattedValueforRange() {
	    this.label = this.minLabel + '~' + this.maxLabel;
	  };
	
	  /**
	   * Add ratio.
	   * @param {number} divNumber - number for division
	   * @param {?number} subNumber - number for subtraction
	   * @param {?number} baseRatio - base ratio
	   */
	
	
	  SeriesItem.prototype.addRatio = function addRatio() {
	    var divNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	    var subNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var baseRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	    var calculateRatio = _calculator2['default'].calculateRatio;
	
	
	    this.ratio = this.maxRatio = calculateRatio(this.max, divNumber, subNumber, baseRatio);
	    this.uqRatio = calculateRatio(this.uq, divNumber, subNumber, baseRatio);
	    this.medianRatio = calculateRatio(this.median, divNumber, subNumber, baseRatio);
	    this.lqRatio = calculateRatio(this.lq, divNumber, subNumber, baseRatio);
	    this.minRatio = calculateRatio(this.min, divNumber, subNumber, baseRatio);
	
	    (this.outliers || []).forEach(function (outlier) {
	      outlier.ratio = calculateRatio(outlier.value, divNumber, subNumber, baseRatio);
	    });
	
	    this.ratioDistance = Math.abs(this.uqRatio - this.lqRatio);
	  };
	
	  /**
	   * Get formatted value for tooltip.
	   * @param {string} valueType - value type
	   * @returns {string}
	   * @private
	   */
	
	
	  SeriesItem.prototype._getFormattedValueForTooltip = function _getFormattedValueForTooltip(valueType) {
	    return _renderUtil2['default'].formatValue({
	      value: this[valueType],
	      formatFunctions: this.formatFunctions,
	      chartType: this.chartType,
	      areaType: 'tooltip',
	      valueType: valueType,
	      legendName: this.legendName
	    });
	  };
	
	  /**
	   * Pick value map for tooltip.
	   * @returns {{value: number, min: ?number, max: ?number}}
	   */
	
	
	  SeriesItem.prototype.pickValueMapForTooltip = function pickValueMapForTooltip() {
	    var valueMap = {
	      value: this._getFormattedValueForTooltip('value'),
	      ratio: this.ratio
	    };
	
	    if (_tuiCodeSnippet2['default'].isExisty(this.min)) {
	      valueMap.min = this._getFormattedValueForTooltip('min');
	      valueMap.max = this._getFormattedValueForTooltip('max');
	      valueMap.minRatio = this.minRatio;
	      valueMap.maxRatio = this.maxRatio;
	      valueMap.maxLabel = this.maxLabel;
	      valueMap.minLabel = this.minLabel;
	      valueMap.uqLabel = this.uqLabel;
	      valueMap.lqLabel = this.lqLabel;
	      valueMap.medianLabel = this.medianLabel;
	      valueMap.outliers = this.outliers;
	    }
	
	    return valueMap;
	  };
	
	  return SeriesItem;
	}();
	
	exports['default'] = SeriesItem;

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _seriesItem = __webpack_require__(432);
	
	var _seriesItem2 = _interopRequireDefault(_seriesItem);
	
	var _seriesDataModel = __webpack_require__(430);
	
	var _seriesDataModel2 = _interopRequireDefault(_seriesDataModel);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview SeriesDataModel for Bullet Chart
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	var SeriesDataModelForBullet = function (_SeriesDataModel) {
	    _inherits(SeriesDataModelForBullet, _SeriesDataModel);
	
	    function SeriesDataModelForBullet() {
	        _classCallCheck(this, SeriesDataModelForBullet);
	
	        return _possibleConstructorReturn(this, _SeriesDataModel.apply(this, arguments));
	    }
	
	    /**
	     * SeriesDataModelForBullet is series model for boxplot chart
	     * SeriesDataModel.groups has SeriesGroups.
	     * @constructs SeriesDataModel
	     * @param {rawSeriesData} rawSeriesData - raw series data
	     * @param {string} chartType - chart type
	     * @param {object} options - options
	     * @param {Array.<function>} formatFunctions - format functions
	     */
	
	    /**
	     * Create base groups.
	     * Base groups is two-dimensional array by seriesItems.
	     * @returns {Array.<Array.<(SeriesItem | SeriesItemForCoordinateType)>>}
	     * @private
	     * @override
	     */
	    SeriesDataModelForBullet.prototype._createBaseGroups = function _createBaseGroups() {
	        var chartType = this.chartType,
	            formatFunctions = this.formatFunctions;
	
	        var maxRangeCount = 0;
	        var maxMarkerCount = 0;
	        var baseGroups = this.rawSeriesData.map(function (rawDatum) {
	            var items = [];
	            var data = rawDatum.data,
	                markers = rawDatum.markers,
	                ranges = rawDatum.ranges;
	
	            var markerCount = markers.length;
	            var rangeCount = ranges.length;
	
	            if (ranges && rangeCount) {
	                ranges.forEach(function (range) {
	                    items.push(new _seriesItem2['default']({
	                        datum: range,
	                        chartType: chartType,
	                        formatFunctions: formatFunctions,
	                        type: _const2['default'].BULLET_TYPE_RANGE
	                    }));
	                });
	                maxRangeCount = Math.max(maxRangeCount, rangeCount);
	            }
	
	            if (data) {
	                items.push(new _seriesItem2['default']({
	                    datum: data,
	                    chartType: chartType,
	                    formatFunctions: formatFunctions,
	                    type: _const2['default'].BULLET_TYPE_ACTUAL
	                }));
	            }
	
	            if (markers && markerCount) {
	                markers.forEach(function (marker) {
	                    items.push(new _seriesItem2['default']({
	                        datum: marker,
	                        chartType: chartType,
	                        formabutFunctions: formatFunctions,
	                        type: _const2['default'].BULLET_TYPE_MARKER
	                    }));
	                });
	                maxMarkerCount = Math.max(maxMarkerCount, markerCount);
	            }
	
	            return items;
	        });
	
	        this.maxMarkerCount = maxMarkerCount;
	        this.maxRangeCount = maxRangeCount;
	
	        return baseGroups;
	    };
	
	    /**
	     * Create SeriesGroups from rawData.series.
	     * @returns {Array.<SeriesGroup>}
	     * @private
	     */
	
	
	    SeriesDataModelForBullet.prototype._createSeriesGroupsFromRawData = function _createSeriesGroupsFromRawData() {
	        return _seriesDataModel2['default'].prototype._createSeriesGroupsFromRawData.call(this);
	    };
	
	    return SeriesDataModelForBullet;
	}(_seriesDataModel2['default']);
	
	exports['default'] = SeriesDataModelForBullet;

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _seriesDataModel = __webpack_require__(430);
	
	var _seriesDataModel2 = _interopRequireDefault(_seriesDataModel);
	
	var _seriesItemForTreemap = __webpack_require__(438);
	
	var _seriesItemForTreemap2 = _interopRequireDefault(_seriesItemForTreemap);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview SeriesDataModelForTreemap is base model for drawing graph of treemap chart series area.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * SeriesDataModel.groups has SeriesGroups.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	var SeriesDataModelForTreeMap = function (_SeriesDataModel) {
	    _inherits(SeriesDataModelForTreeMap, _SeriesDataModel);
	
	    /**
	     * SeriesDataModelForTreemap is base model for drawing graph of treemap chart series area.
	     * @constructs SeriesDataModelForTreemap
	     * @private
	     */
	    function SeriesDataModelForTreeMap() {
	        _classCallCheck(this, SeriesDataModelForTreeMap);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        /**
	         * cached found seriesItems map
	         * @type {object.<string, Array.<SeriesItem>>}
	         */
	        var _this = _possibleConstructorReturn(this, _SeriesDataModel.call.apply(_SeriesDataModel, [this].concat(args)));
	
	        _this.foundSeriesItemsMap = {};
	
	        /**
	         * cached seriesItem map
	         * @type {object<string, SeriesItem>}
	         */
	        _this.seriesItemMap = {};
	        return _this;
	    }
	
	    /**
	     * Flatten hierarchical data.
	     * @param {Array.<object>} rawSeriesData - raw series data
	     * @param {string | number} parent - parent id
	     * @param {?Array.<number>} ancestorIndexes - ancestor indexes
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    SeriesDataModelForTreeMap.prototype._flattenHierarchicalData = function _flattenHierarchicalData(rawSeriesData, parent, ancestorIndexes) {
	        var _this2 = this;
	
	        var flatData = [];
	        var idPrefix = void 0;
	
	        if (parent) {
	            idPrefix = parent + '_';
	        } else {
	            idPrefix = _const2['default'].TREEMAP_ID_PREFIX;
	            parent = _const2['default'].TREEMAP_ROOT_ID;
	        }
	
	        ancestorIndexes = ancestorIndexes || [];
	
	        rawSeriesData.forEach(function (datum, index) {
	            var id = idPrefix + index;
	            var children = datum.children;
	
	            var indexes = ancestorIndexes.concat(index);
	
	            datum.indexes = indexes;
	
	            if (!_tuiCodeSnippet2['default'].isNull(datum.value)) {
	                flatData.push(datum);
	            }
	
	            if (!datum.id) {
	                datum.id = id;
	            }
	
	            if (!datum.parent) {
	                datum.parent = parent;
	            }
	
	            if (children) {
	                flatData = flatData.concat(_this2._flattenHierarchicalData(children, id, indexes));
	                delete datum.children;
	            }
	        });
	
	        return flatData;
	    };
	
	    /**
	     * Partition raw series data by parent id
	     * @param {Array.<object>} rawSeriesData - raw series data
	     * @param {string | number} parent - parent id
	     * @returns {Array.<Array>}
	     * @private
	     */
	
	
	    SeriesDataModelForTreeMap.prototype._partitionRawSeriesDataByParent = function _partitionRawSeriesDataByParent(rawSeriesData, parent) {
	        var filtered = [];
	        var rejected = [];
	
	        rawSeriesData.forEach(function (datum) {
	            if (datum.parent === parent) {
	                filtered.push(datum);
	            } else {
	                rejected.push(datum);
	            }
	        });
	
	        return [filtered, rejected];
	    };
	
	    /**
	     * Set tree properties like depth, group in raw series data.
	     * @param {Array.<object>} flatSeriesData - flat series data
	     * @param {number} depth - tree depth
	     * @param {number} parent - parent id
	     * @param {number} group - tree group
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    SeriesDataModelForTreeMap.prototype._setTreeProperties = function _setTreeProperties(flatSeriesData, depth, parent, group) {
	        var _this3 = this;
	
	        var parted = this._partitionRawSeriesDataByParent(flatSeriesData, parent);
	
	        var _parted = _slicedToArray(parted, 1),
	            filtered = _parted[0];
	
	        var _parted2 = _slicedToArray(parted, 2),
	            rejected = _parted2[1];
	
	        var childDepth = depth + 1;
	
	        filtered.forEach(function (datum, index) {
	            datum.depth = depth;
	            datum.group = _tuiCodeSnippet2['default'].isUndefined(group) ? index : group;
	
	            var descendants = _this3._setTreeProperties(rejected, childDepth, datum.id, datum.group, datum.fillOpacity);
	            var children = descendants.filter(function (descendant) {
	                return descendant.depth === childDepth;
	            });
	
	            if (children.length) {
	                datum.value = _calculator2['default'].sum(_tuiCodeSnippet2['default'].pluck(children, 'value'));
	                datum.hasChild = true;
	            } else {
	                datum.hasChild = false;
	            }
	
	            if (descendants.length) {
	                descendants.sort(function (a, b) {
	                    return b.value - a.value;
	                });
	            }
	
	            filtered = filtered.concat(descendants);
	        });
	
	        return filtered;
	    };
	
	    /**
	     * Set ratio.
	     * @param {Array.<object>} flatSeriesData - raw series data
	     * @param {string} parent - parent id
	     * @private
	     */
	
	
	    SeriesDataModelForTreeMap.prototype._setRatio = function _setRatio(flatSeriesData, parent) {
	        var _this4 = this;
	
	        var parted = this._partitionRawSeriesDataByParent(flatSeriesData, parent);
	
	        var _parted3 = _slicedToArray(parted, 2),
	            filtered = _parted3[0],
	            rejected = _parted3[1];
	
	        var total = _calculator2['default'].sum(_tuiCodeSnippet2['default'].pluck(filtered, 'value'));
	
	        filtered.forEach(function (datum) {
	            var value = _tuiCodeSnippet2['default'].isNull(datum.value) ? 0 : datum.value;
	
	            datum.ratio = value / total;
	
	            if (datum.hasChild) {
	                _this4._setRatio(rejected, datum.id);
	            }
	        });
	    };
	
	    /**
	     * Create base groups.
	     * @returns {Array.<Array.<SeriesItem>>}
	     * @private
	     * @override
	     */
	
	
	    SeriesDataModelForTreeMap.prototype._createBaseGroups = function _createBaseGroups() {
	        var chartType = this.chartType,
	            seriesItemMap = this.seriesItemMap,
	            formatFunctions = this.formatFunctions;
	
	        var flatSeriesData = this._flattenHierarchicalData(this.rawSeriesData);
	
	        flatSeriesData = this._setTreeProperties(flatSeriesData, 1, _const2['default'].TREEMAP_ROOT_ID);
	        this._setRatio(flatSeriesData, _const2['default'].TREEMAP_ROOT_ID);
	
	        return [flatSeriesData.map(function (rawDatum) {
	            var seriesItem = new _seriesItemForTreemap2['default'](rawDatum, formatFunctions, chartType);
	
	            seriesItemMap[seriesItem.id] = seriesItem;
	
	            return seriesItem;
	        })];
	    };
	
	    /**
	     * Find SeriesItems.
	     * @param {string} key - key
	     * @param {function} condition - condition function
	     * @returns {Array.<SeriesItem>}
	     * @private
	     */
	
	
	    SeriesDataModelForTreeMap.prototype._findSeriesItems = function _findSeriesItems(key, condition) {
	        if (!this.foundSeriesItemsMap[key]) {
	            this.foundSeriesItemsMap[key] = this.getFirstSeriesGroup(true).filter(condition);
	        }
	
	        return this.foundSeriesItemsMap[key];
	    };
	
	    /**
	     * Make cache key for caching found SeriesItems.
	     * @param {string} prefix - prefix
	     * @returns {string}
	     * @private
	     */
	
	
	    SeriesDataModelForTreeMap.prototype._makeCacheKey = function _makeCacheKey() {
	        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            args[_key2] = arguments[_key2];
	        }
	
	        var key = args[0];
	
	
	        if (args.length > 1) {
	            key += args.slice(1).join('_');
	        }
	
	        return key;
	    };
	
	    /**
	     * Whether valid group or not.
	     * If comparingGroup is undefined or group and comparingGroup are equal, this group is valid.
	     * @param {number} group - group
	     * @param {number} [comparingGroup] - comparing group
	     * @returns {boolean}
	     * @private
	     */
	
	
	    SeriesDataModelForTreeMap.prototype._isValidGroup = function _isValidGroup(group, comparingGroup) {
	        return !_tuiCodeSnippet2['default'].isExisty(comparingGroup) || group === comparingGroup;
	    };
	
	    /**
	     * Find SeriesItems by depth.
	     * @param {number} depth - tree depth
	     * @param {number} [group] - tree group
	     * @returns {Array.<SeriesItem>}
	     */
	
	
	    SeriesDataModelForTreeMap.prototype.findSeriesItemsByDepth = function findSeriesItemsByDepth(depth, group) {
	        var _this5 = this;
	
	        var key = this._makeCacheKey(_const2['default'].TREEMAP_DEPTH_KEY_PREFIX, depth, group);
	
	        return this._findSeriesItems(key, function (seriesItem) {
	            return seriesItem.depth === depth && _this5._isValidGroup(seriesItem.group, group);
	        });
	    };
	
	    /**
	     * Find SeriesItems by parent id.
	     * @param {string | number} parent - parent id
	     * @returns {Array.<SeriesItem>}
	     */
	
	
	    SeriesDataModelForTreeMap.prototype.findSeriesItemsByParent = function findSeriesItemsByParent(parent) {
	        var key = this._makeCacheKey(_const2['default'].TREEMAP_PARENT_KEY_PREFIX, parent);
	
	        return this._findSeriesItems(key, function (seriesItem) {
	            return seriesItem.parent === parent;
	        });
	    };
	
	    /**
	     * Find leaf SeriesItems.
	     * @param {number} [group] - tree group
	     * @returns {Array.<SeriesItem>}
	     */
	
	
	    SeriesDataModelForTreeMap.prototype.findLeafSeriesItems = function findLeafSeriesItems(group) {
	        var _this6 = this;
	
	        var key = this._makeCacheKey(_const2['default'].TREEMAP_LEAF_KEY_PREFIX, group);
	
	        return this._findSeriesItems(key, function (seriesItem) {
	            return !seriesItem.hasChild && _this6._isValidGroup(seriesItem.group, group);
	        });
	    };
	
	    /**
	     * Find parent by depth.
	     * @param {string} id - id
	     * @param {number} depth - depth
	     * @returns {SeriesItem|null}
	     */
	
	
	    SeriesDataModelForTreeMap.prototype.findParentByDepth = function findParentByDepth(id, depth) {
	        var seriesItem = this.seriesItemMap[id] || null;
	
	        if (seriesItem && seriesItem.depth !== depth) {
	            seriesItem = this.findParentByDepth(seriesItem.parent, depth);
	        }
	
	        return seriesItem;
	    };
	
	    /**
	     * Initialize foundSeriesItemsMap.
	     */
	
	
	    SeriesDataModelForTreeMap.prototype.initSeriesItemsMap = function initSeriesItemsMap() {
	        this.foundSeriesItemsMap = null;
	    };
	
	    return SeriesDataModelForTreeMap;
	}(_seriesDataModel2['default']);
	
	exports['default'] = SeriesDataModelForTreeMap;

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview SeriesItem for treemap.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var SeriesItemForTreemap = function () {
	    /**
	     * SeriesItem for treemap.
	     * @constructs SeriesItemForTreemap
	     * @private
	     * @param {object} rawSeriesDatum - value
	     * @param {?Array.<function>} formatFunctions - format functions
	     * @param {string} chartType - type of chart
	     */
	    function SeriesItemForTreemap(rawSeriesDatum, formatFunctions, chartType) {
	        _classCallCheck(this, SeriesItemForTreemap);
	
	        /**
	         * type of chart
	         * @type {string}
	         */
	        this.chartType = chartType;
	
	        /**
	         * format functions
	         * @type {Array.<function>}
	         */
	        this.formatFunctions = formatFunctions;
	        this.id = rawSeriesDatum.id;
	        this.parent = rawSeriesDatum.parent;
	        this.value = rawSeriesDatum.value;
	        this.ratio = rawSeriesDatum.ratio;
	        this.colorValue = rawSeriesDatum.colorValue;
	        this.depth = rawSeriesDatum.depth;
	        this.label = rawSeriesDatum.label || '';
	        this.group = rawSeriesDatum.group;
	        this.hasChild = !!rawSeriesDatum.hasChild;
	        this.indexes = rawSeriesDatum.indexes;
	        this.fillOpacity = rawSeriesDatum.fillOpacity;
	    }
	
	    /**
	     * Add ratio.
	     * @param {number} divNumber - number for division
	     * @param {?number} subNumber - number for subtraction
	     */
	
	
	    SeriesItemForTreemap.prototype.addRatio = function addRatio() {
	        var divNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	        var subNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	        this.colorRatio = _calculator2['default'].calculateRatio(this.colorValue, divNumber, subNumber, 1) || -1;
	    };
	
	    /**
	     * Pick value map for tooltip.
	     * @returns {{value: number, label: string}}
	     */
	
	
	    SeriesItemForTreemap.prototype.pickValueMapForTooltip = function pickValueMapForTooltip() {
	        var formatFunctions = this.formatFunctions,
	            chartType = this.chartType,
	            colorValue = this.colorValue;
	
	        var formattedValue = _renderUtil2['default'].formatValue({
	            value: this.value,
	            formatFunctions: formatFunctions,
	            chartType: chartType,
	            areaType: 'tooltipValue'
	        });
	        var label = formattedValue;
	        var valueMap = {
	            legend: this.label || '',
	            value: formattedValue,
	            label: label,
	            ratio: this.ratio,
	            tooltipColorIndex: this.indexes[0]
	        };
	
	        if (_tuiCodeSnippet2['default'].isExisty(colorValue)) {
	            valueMap.colorValue = _renderUtil2['default'].formatValue({
	                value: colorValue,
	                formatFunctions: formatFunctions,
	                chartType: chartType,
	                areaType: 'tooltipColorValue'
	            });
	            valueMap.colorRatio = this.colorRatio;
	        }
	
	        return valueMap;
	    };
	
	    /**
	     * Pick data for label template.
	     * @param {number} total - value total
	     * @returns {{value: number, ratio: number, label: string, colorValue: ?number, colorValueRatio: ?number}}
	     */
	
	
	    SeriesItemForTreemap.prototype.pickLabelTemplateData = function pickLabelTemplateData() {
	        var templateData = {
	            value: this.value,
	            ratio: this.ratio,
	            label: this.label
	        };
	
	        if (_tuiCodeSnippet2['default'].isExisty(this.colorValue)) {
	            templateData.colorValue = this.colorValue;
	            templateData.colorValueRatio = this.ratio;
	        }
	
	        return templateData;
	    };
	
	    return SeriesItemForTreemap;
	}();
	
	exports['default'] = SeriesItemForTreemap;

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _boundsModel = __webpack_require__(440);
	
	var _boundsModel2 = _interopRequireDefault(_boundsModel);
	
	var _scaleDataModel = __webpack_require__(446);
	
	var _scaleDataModel2 = _interopRequireDefault(_scaleDataModel);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Bounds and scale data builder.
	 * @module boundsAndScaleBuilder
	 * @private
	 */
	/**
	 * @fileoverview Bounds and scale data builder.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	exports['default'] = {
	    /**
	     * Create BoundsModel.
	     * @param {DataProcessor} dataProcessor - DataProcessor instance
	     * @param {object} params - parameters
	     * @returns {BoundsModel}
	     * @private
	     */
	    _createBoundsModel: function _createBoundsModel(dataProcessor, params) {
	        return new _boundsModel2['default']({
	            chartType: params.chartType,
	            seriesTypes: params.seriesTypes,
	            options: params.options,
	            theme: params.theme,
	            dataProcessor: dataProcessor,
	            hasAxes: params.hasAxes,
	            isVertical: params.isVertical
	        });
	    },
	
	
	    /**
	     * Create ScaleDataModel.
	     * @param {DataProcessor} dataProcessor - DataProcessor instance
	     * @param {BoundsModel} boundsModel - BoundsModel instance
	     * @param {object} params - parameters
	     * @returns {ScaleDataModel}
	     * @private
	     */
	    _createScaleDataModel: function _createScaleDataModel(dataProcessor, boundsModel, params) {
	        return new _scaleDataModel2['default']({
	            chartType: params.chartType,
	            seriesTypes: params.seriesTypes,
	            options: params.options,
	            theme: params.theme,
	            dataProcessor: dataProcessor,
	            boundsModel: boundsModel,
	            hasRightYAxis: params.hasRightYAxis,
	            addedDataCount: params.addedDataCount
	        });
	    },
	
	
	    /**
	     * Add y axis scale.
	     * @param {ScaleDataModel} scaleDataModel - ScaleDataModel instance
	     * @param {string} name - component name
	     * @param {object} scaleOption - option for add scale
	     * @param {object} yAxisOptions - option for yAxis
	     */
	    addYAxisScale: function addYAxisScale(scaleDataModel, name, scaleOption, yAxisOptions) {
	        scaleDataModel.addScale(name, scaleOption && scaleOption.options || yAxisOptions || {}, {
	            valueType: scaleOption.valueType || 'value',
	            areaType: scaleOption.areaType,
	            chartType: scaleOption.chartType
	        }, scaleOption.additionalOptions);
	    },
	
	
	    /**
	     * Register dimension for y axis.
	     * @param {ComponentManager} componentManager - ComponentManager instance
	     * @param {BoundsModel} boundsModel - BoundsModel instance
	     * @param {object.<string, object>} scaleDataMap - scale data map
	     * @param {string} axisName - axis name like yAxis and rightYAxis
	     * @param {boolean} isVertical - whether vertical or not
	     * @private
	     */
	    _registerYAxisDimension: function _registerYAxisDimension(componentManager, boundsModel, scaleDataMap, axisName, isVertical) {
	        var yAxis = componentManager.get(axisName);
	        var limit = null;
	        var yAxisLabels = [];
	
	        if (!yAxis) {
	            return;
	        }
	        var scaleData = scaleDataMap[axisName];
	
	        if (scaleData) {
	            limit = scaleData.limit;
	            yAxisLabels = scaleData.labels;
	        }
	        boundsModel.registerYAxisDimension({
	            limit: limit,
	            axisName: axisName,
	            options: yAxis.options,
	            theme: yAxis.theme,
	            yAxisLabels: yAxisLabels,
	            isVertical: isVertical
	        });
	    },
	
	
	    /**
	     * Set layout bounds and scale.
	     * @param {DataProcessor} dataProcessor - DataProcessor instance
	     * @param {ComponentManager} componentManager - ComponentManager instance
	     * @param {BoundsModel} boundsModel - BoundsModel instance
	     * @param {ScaleDataModel} scaleDataModel - ScaleDataModel instance
	     * @param {object} params - parameter for setting layout bounds and scale data.
	     * @private
	     */
	    _setLayoutBoundsAndScale: function _setLayoutBoundsAndScale(dataProcessor, componentManager, boundsModel, scaleDataModel, params) {
	        var options = params.options,
	            _params$scaleOption = params.scaleOption,
	            scaleOption = _params$scaleOption === undefined ? {} : _params$scaleOption,
	            addingDataMode = params.addingDataMode,
	            isVertical = params.isVertical;
	
	        // 01. register base dimension
	
	        if (componentManager.has('xAxis')) {
	            boundsModel.registerXAxisHeight();
	        }
	
	        if (componentManager.has('legend')) {
	            if (componentManager.get('legend').colorSpectrum) {
	                boundsModel.registerSpectrumLegendDimension();
	            } else {
	                boundsModel.registerLegendDimension();
	            }
	        }
	
	        // 02. add scale of y axis and legend
	        if (scaleOption.yAxis) {
	            this.addYAxisScale(scaleDataModel, 'yAxis', scaleOption.yAxis, params.options.yAxis);
	        }
	
	        if (scaleOption.rightYAxis) {
	            this.addYAxisScale(scaleDataModel, 'rightYAxis', scaleOption.rightYAxis);
	        }
	
	        if (scaleOption.legend) {
	            scaleDataModel.addScale('legend', {}, {
	                chartType: params.chartType
	            }, {
	                tickCounts: [_const2['default'].SPECTRUM_LEGEND_TICK_COUNT]
	            });
	        }
	
	        var scaleDataMap = scaleDataModel.scaleDataMap;
	
	
	        if (scaleDataMap.legend && componentManager.get('legend') && componentManager.get('legend').colorSpectrum) {
	            boundsModel.registerSpectrumLegendDimension(scaleDataMap.legend.limit);
	        }
	
	        // 03. register y axis dimension
	        this._registerYAxisDimension(componentManager, boundsModel, scaleDataMap, 'yAxis', isVertical);
	        this._registerYAxisDimension(componentManager, boundsModel, scaleDataMap, 'rightYAxis', isVertical);
	
	        // 04. add x axis scale
	        if (scaleOption.xAxis) {
	            scaleDataModel.addScale('xAxis', options.xAxis, {
	                valueType: scaleOption.xAxis.valueType || 'value'
	            }, scaleOption.xAxis.additionalOptions);
	        }
	
	        // 05. create and configure axis data map
	        if (params.hasAxes) {
	            scaleDataModel.setAxisDataMap();
	        }
	
	        // 06. register series dimension
	        boundsModel.registerSeriesDimension();
	
	        // 07. register circle legend dimension, if there is a circle legend
	        if (componentManager.has('circleLegend') && options.circleLegend.visible) {
	            boundsModel.registerCircleLegendDimension(scaleDataModel.axisDataMap);
	        }
	
	        if (componentManager.has('xAxis')) {
	            // 08. update axisData, when autoTickInterval option exist
	            if (_predicate2['default'].isAutoTickInterval(options.xAxis.tickInterval)) {
	                scaleDataModel.updateXAxisDataForAutoTickInterval(params.prevXAxisData, addingDataMode);
	            }
	
	            // 09. update axisData related to the rotation of label on x axis
	            scaleDataModel.updateXAxisDataForLabel(addingDataMode);
	        }
	
	        // 10. regiser dimension of rest components
	        //     register positon of all components
	        boundsModel.registerBoundsData(scaleDataModel.axisDataMap.xAxis);
	    },
	
	
	    /**
	     * Build layout bounds and scale data.
	     * @param {DataProcessor} dataProcessor - DataProcessor instance
	     * @param {ComponentManager} componentManager - ComponentManager instance
	     * @param {object} params - parameter for building layout bounds and scale data.
	     * @returns {{
	     *      dimensionMap: object,
	     *      positionMap: object,
	     *      limitMap: {
	     *          xAxis: ?{min: number, max: number},
	     *          yAxis: ?{min: number, max: number},
	     *          rightYAxis: ?{min: number, max: number},
	     *          legend: ?{min: number, max: number}
	     *      },
	     *      axisDataMap: ?object,
	     *      maxRadius: ?number,
	     *      legendScaleData: ?object
	     * }}
	     */
	    build: function build(dataProcessor, componentManager, params) {
	        var boundsModel = this._createBoundsModel(dataProcessor, params);
	        var scaleDataModel = this._createScaleDataModel(dataProcessor, boundsModel, params);
	
	        this._setLayoutBoundsAndScale(dataProcessor, componentManager, boundsModel, scaleDataModel, params);
	
	        var boundsAndScale = {
	            dimensionMap: boundsModel.dimensionMap,
	            positionMap: boundsModel.positionMap,
	            limitMap: scaleDataModel.makeLimitMap(params.seriesTypes || [params.chartType], params.isVertical)
	        };
	
	        if (scaleDataModel.axisDataMap) {
	            boundsAndScale.axisDataMap = scaleDataModel.axisDataMap;
	        }
	
	        if (_predicate2['default'].isBubbleChart(params.chartType)) {
	            boundsAndScale.maxRadius = boundsModel.calculateMaxRadius(scaleDataModel.axisDataMap);
	        }
	
	        if (scaleDataModel.scaleDataMap.legend) {
	            boundsAndScale.legendScaleData = scaleDataModel.scaleDataMap.legend;
	        }
	
	        return boundsAndScale;
	    }
	};

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _raphaelRenderUtil = __webpack_require__(332);
	
	var _raphaelRenderUtil2 = _interopRequireDefault(_raphaelRenderUtil);
	
	var _circleLegendCalculator = __webpack_require__(441);
	
	var _circleLegendCalculator2 = _interopRequireDefault(_circleLegendCalculator);
	
	var _axisCalculator = __webpack_require__(442);
	
	var _axisCalculator2 = _interopRequireDefault(_axisCalculator);
	
	var _legendCalculator = __webpack_require__(443);
	
	var _legendCalculator2 = _interopRequireDefault(_legendCalculator);
	
	var _seriesCalculator = __webpack_require__(444);
	
	var _seriesCalculator2 = _interopRequireDefault(_seriesCalculator);
	
	var _spectrumLegendCalculator = __webpack_require__(445);
	
	var _spectrumLegendCalculator2 = _interopRequireDefault(_spectrumLegendCalculator);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview Bounds model.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var browser = _tuiCodeSnippet2['default'].browser;
	var LEGEND_AREA_H_PADDING = _const2['default'].LEGEND_AREA_H_PADDING;
	
	var IS_LTE_IE8 = browser.msie && browser.version <= 8;
	
	/**
	 * Dimension.
	 * @typedef {{width: number, height:number}} dimension
	 * @private
	 */
	
	/**
	 * Position.
	 * @typedef {{left: number, top:number}} position
	 * @private
	 */
	
	/**
	 * Bound.
	 * @typedef {{dimension: dimension, position:position}} bound
	 * @private
	 */
	
	var BoundsModel = function () {
	    /**
	     * Bounds maker.
	     * @constructs BoundsModel
	     * @private
	     * @param {object} params parameters
	     */
	    function BoundsModel(params) {
	        _classCallCheck(this, BoundsModel);
	
	        /**
	         * options
	         * @type {object}
	         */
	        this.options = params.options || {};
	        this.options.legend = this.options.legend || {};
	        this.options.yAxis = this.options.yAxis || {};
	
	        /**
	         * theme
	         * @type {object}
	         */
	        this.theme = params.theme || {};
	
	        /**
	         * whether chart has axes or not
	         * @type {boolean}
	         */
	        this.hasAxes = params.hasAxes;
	
	        /**
	         * chart type
	         * @type {string}
	         */
	        this.chartType = params.chartType;
	
	        /**
	         * series types
	         */
	        this.seriesTypes = params.seriesTypes || [];
	
	        /**
	         * data processor
	         * @type {DataProcessor}
	         */
	        this.dataProcessor = params.dataProcessor;
	
	        this.initBoundsData();
	    }
	
	    /**
	     * Initialize bounds data.
	     */
	
	
	    BoundsModel.prototype.initBoundsData = function initBoundsData() {
	        this.dimensionMap = {
	            legend: {
	                width: 0
	            },
	            yAxis: {
	                width: 0
	            },
	            rightYAxis: {
	                width: 0
	            },
	            xAxis: {
	                height: 0
	            },
	            circleLegend: {
	                width: 0
	            },
	            chartExportMenu: {
	                width: 0
	            }
	        };
	
	        this.positionMap = {};
	
	        /**
	         * chart left padding
	         * @type {number}
	         */
	        this.chartLeftPadding = _const2['default'].CHART_PADDING;
	
	        this.maxRadiusForBubbleChart = null;
	
	        this._registerChartDimension();
	        this._registerTitleDimension();
	        this._registerChartExportMenuDimension();
	    };
	
	    /**
	     * Register dimension.
	     * @param {string} name component name
	     * @param {dimension} dimension component dimension
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerDimension = function _registerDimension(name, dimension) {
	        this.dimensionMap[name] = _tuiCodeSnippet2['default'].extend(this.dimensionMap[name] || {}, dimension);
	    };
	
	    /**
	     * Get bound.
	     * @param {string} name component name
	     * @returns {bound} component bound
	     */
	
	
	    BoundsModel.prototype.getBound = function getBound(name) {
	        return {
	            dimension: this.dimensionMap[name] || {},
	            position: this.positionMap[name] || {}
	        };
	    };
	
	    /**
	     * Set bound.
	     * @param {string} name component name
	     * @param {bound} bound component bound
	     * @private
	     */
	
	
	    BoundsModel.prototype._setBound = function _setBound(name, bound) {
	        this.dimensionMap[name] = bound.dimension;
	        this.positionMap[name] = bound.position;
	    };
	
	    /**
	     * Get dimension.
	     * @param {string} name component name
	     * @returns {dimension} component dimension
	     */
	
	
	    BoundsModel.prototype.getDimension = function getDimension(name) {
	        return this.dimensionMap[name];
	    };
	
	    /**
	     * Get dimension map.
	     * @param {string} types - dimension type names
	     * @returns {object}
	     */
	
	
	    BoundsModel.prototype.getDimensionMap = function getDimensionMap(types) {
	        var _this = this;
	
	        var dimensionMap = {};
	
	        if (types && types.length) {
	            types.forEach(function (type) {
	                dimensionMap[type] = _this.dimensionMap[type];
	            });
	        } else {
	            dimensionMap = this.dimensionMap;
	        }
	
	        return JSON.parse(JSON.stringify(dimensionMap));
	    };
	
	    /**
	     * Get position.
	     * @param {string} name component name
	     * @returns {position} component position
	     */
	
	
	    BoundsModel.prototype.getPosition = function getPosition(name) {
	        return this.positionMap[name];
	    };
	
	    /**
	     * Register chart dimension
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerChartDimension = function _registerChartDimension() {
	        var chartOptions = this.options.chart || {};
	        var dimension = {
	            width: chartOptions.width || _const2['default'].CHART_DEFAULT_WIDTH,
	            height: chartOptions.height || _const2['default'].CHART_DEFAULT_HEIGHT
	        };
	
	        this._registerDimension('chart', dimension);
	    };
	
	    /**
	     * Register title dimension
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerTitleDimension = function _registerTitleDimension() {
	        var chartOptions = this.options.chart || {};
	        var hasTitleOption = _tuiCodeSnippet2['default'].isExisty(chartOptions.title);
	        var titleTheme = this.theme.title;
	        var titleHeight = hasTitleOption ? _raphaelRenderUtil2['default'].getRenderedTextSize(chartOptions.title.text, titleTheme.fontSize, titleTheme.fontFamily).height : 0;
	        var height = titleHeight || 0;
	
	        if (height) {
	            height += _const2['default'].TITLE_PADDING;
	        }
	
	        this._registerDimension('title', { height: height });
	    };
	
	    /**
	     * Register chartExportMenu dimension
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerChartExportMenuDimension = function _registerChartExportMenuDimension() {
	        var dimension = void 0;
	
	        if (this.options.chartExportMenu.visible === false) {
	            dimension = {
	                width: 0,
	                height: 0
	            };
	        } else {
	            dimension = {
	                height: _const2['default'].CHART_EXPORT_MENU_SIZE + _const2['default'].SERIES_AREA_V_PADDING,
	                width: _const2['default'].CHART_EXPORT_MENU_SIZE
	            };
	        }
	        this._registerDimension('chartExportMenu', dimension);
	    };
	
	    /**
	     * Register height for x axis component.
	     */
	
	
	    BoundsModel.prototype.registerXAxisHeight = function registerXAxisHeight() {
	        this._registerDimension('xAxis', {
	            height: _axisCalculator2['default'].calculateXAxisHeight(this.options.xAxis, this.theme.xAxis)
	        });
	    };
	
	    /**
	     * Register dimension for legend component.
	     */
	
	
	    BoundsModel.prototype.registerLegendDimension = function registerLegendDimension() {
	        var legendLabels = _tuiCodeSnippet2['default'].pluck(this.dataProcessor.getOriginalLegendData(), 'label');
	        var legendOptions = this.options.legend;
	        var labelTheme = this.theme.legend.label;
	        var chartWidth = this.getDimension('chart').width;
	        var legendDimension = _legendCalculator2['default'].calculate(legendOptions, labelTheme, legendLabels, chartWidth);
	
	        this._registerDimension('legend', legendDimension);
	    };
	
	    /**
	     * Register dimension for spectrum legend component.
	     * @param {object} limit - min and maximum value
	     */
	
	
	    BoundsModel.prototype.registerSpectrumLegendDimension = function registerSpectrumLegendDimension(limit) {
	        var maxValue = limit ? limit.max : this.dataProcessor.getFormattedMaxValue(this.chartType, 'legend');
	        var minValue = limit ? limit.min : '';
	        var labelTheme = this.theme.label;
	        var align = this.options.legend.align;
	
	        var dimension = void 0;
	
	        if (_predicate2['default'].isHorizontalLegend(align)) {
	            var isBoxType = _predicate2['default'].isBoxTypeChart(this.chartType);
	            var isTopLegend = _predicate2['default'].isLegendAlignTop(align);
	            dimension = _spectrumLegendCalculator2['default']._makeHorizontalDimension(maxValue, labelTheme, isBoxType, isTopLegend);
	        } else {
	            dimension = _spectrumLegendCalculator2['default']._makeVerticalDimension(maxValue, minValue, labelTheme);
	        }
	
	        this._registerDimension('legend', dimension);
	        this.useSpectrumLegend = true;
	    };
	
	    /**
	     * Register dimension for y axis.
	     * @param {object} dimensionInfos - options for calculate dimension
	     *     @param {{min: number, max: number}} dimensionInfos.limit - min, max
	     *     @param {string} dimensionInfos.componentName - component name like yAxis, rightYAxis
	     *     @param {object} dimensionInfos.options - options for y axis
	     *     @param {{title: object, label: object}} dimensionInfos.theme - them for y axis
	     *     @param {Array} dimensionInfos.yAxisLabels - them for y axis
	     *     @param {boolean} dimensionInfos.isVertical - whether vertical or not
	     */
	
	
	    BoundsModel.prototype.registerYAxisDimension = function registerYAxisDimension(dimensionInfos) {
	        var limit = dimensionInfos.limit,
	            options = dimensionInfos.options,
	            theme = dimensionInfos.theme,
	            yAxisLabels = dimensionInfos.yAxisLabels,
	            isVertical = dimensionInfos.isVertical,
	            componentName = dimensionInfos.axisName;
	
	        var isDiverging = this.options.series && this.options.series.diverging;
	        var categories = void 0,
	            yAxisOptions = void 0;
	
	        if (limit) {
	            categories = [limit.min, limit.max];
	        } else if (_predicate2['default'].isHeatmapChart(this.chartType) || !isVertical) {
	            categories = this.dataProcessor.getCategories(true);
	        } else {
	            return;
	        }
	
	        if (_tuiCodeSnippet2['default'].isArray(options)) {
	            yAxisOptions = componentName === 'yAxis' ? options[0] : options[1];
	        } else {
	            yAxisOptions = options;
	        }
	
	        this._registerDimension(componentName, {
	            width: _axisCalculator2['default'].calculateYAxisWidth(categories, yAxisOptions, theme, yAxisLabels, isDiverging)
	        });
	    };
	
	    /**
	     * Create series width.
	     * @returns {number} series width
	     */
	
	
	    BoundsModel.prototype.calculateSeriesWidth = function calculateSeriesWidth() {
	        var maxLabel = this.dataProcessor.getFormattedMaxValue(this.chartType, 'series', 'value');
	        var dimensionMap = this.getDimensionMap(['chart', 'yAxis', 'legend', 'rightYAxis']);
	        var maxLabelWidth = 0;
	        if (!_predicate2['default'].isColumnTypeChart(this.chartType)) {
	            maxLabelWidth = _renderUtil2['default'].getRenderedLabelHeight(maxLabel, this.theme.title);
	        }
	        var seriesWidth = _seriesCalculator2['default'].calculateWidth(dimensionMap, this.options.legend, maxLabelWidth);
	
	        if (_predicate2['default'].isMapChart(this.chartType) && !IS_LTE_IE8) {
	            seriesWidth -= _const2['default'].MAP_CHART_ZOOM_AREA_WIDTH + LEGEND_AREA_H_PADDING;
	        }
	
	        return seriesWidth;
	    };
	
	    /**
	     * Create series height
	     * @returns {number} series height
	     */
	
	
	    BoundsModel.prototype.calculateSeriesHeight = function calculateSeriesHeight() {
	        var dimensionMap = this.getDimensionMap(['chart', 'title', 'legend', 'xAxis', 'chartExportMenu']);
	        var yAxisTitleAreaHeight = 0;
	
	        if (this.options.yAxis && this.options.yAxis.title) {
	            yAxisTitleAreaHeight = _renderUtil2['default'].getRenderedLabelHeight(this.options.yAxis.title, this.theme.title);
	        }
	
	        return _seriesCalculator2['default'].calculateHeight(dimensionMap, this.options.legend, yAxisTitleAreaHeight);
	    };
	
	    BoundsModel.prototype.getBaseSizeForLimit = function getBaseSizeForLimit(isVertical) {
	        var baseSize = void 0;
	
	        if (isVertical) {
	            baseSize = this.calculateSeriesHeight();
	        } else {
	            baseSize = this.calculateSeriesWidth();
	        }
	
	        return baseSize;
	    };
	
	    /**
	     * Make series dimension.
	     * @returns {{width: number, height: number}} series dimension
	     * @private
	     */
	
	
	    BoundsModel.prototype._makeSeriesDimension = function _makeSeriesDimension() {
	        return {
	            width: this.calculateSeriesWidth(),
	            height: this.calculateSeriesHeight()
	        };
	    };
	
	    /**
	     * Register series dimension.
	     */
	
	
	    BoundsModel.prototype.registerSeriesDimension = function registerSeriesDimension() {
	        var seriesDimension = this._makeSeriesDimension();
	
	        this._registerDimension('series', seriesDimension);
	    };
	
	    /**
	     * Update width of legend and series of BoundsModel.
	     * @param {number} circleLegendWidth - width for circle legend
	     * @param {number} diffWidth - difference width
	     * @private
	     */
	
	
	    BoundsModel.prototype._updateLegendAndSeriesWidth = function _updateLegendAndSeriesWidth(circleLegendWidth, diffWidth) {
	        var legendOptions = this.options.legend;
	
	        if (_predicate2['default'].isVerticalLegend(legendOptions.align) && legendOptions.visible) {
	            this._registerDimension('legend', {
	                width: circleLegendWidth
	            });
	        }
	
	        this._registerDimension('series', {
	            width: this.getDimension('series').width - diffWidth
	        });
	    };
	
	    /**
	     * Register dimension of circle legend.
	     * @param {object} axisDataMap - axisData map
	     */
	
	
	    BoundsModel.prototype.registerCircleLegendDimension = function registerCircleLegendDimension(axisDataMap) {
	        var seriesDimension = this.getDimension('series');
	        var legendOptions = this.options.legend;
	
	        var maxLabel = this.dataProcessor.getFormattedMaxValue(this.chartType, 'circleLegend', 'r');
	        var fontFamily = this.theme.chart.fontFamily;
	
	        var circleLegendWidth = _circleLegendCalculator2['default'].calculateCircleLegendWidth(seriesDimension, axisDataMap, maxLabel, fontFamily);
	        var legendWidth = void 0;
	
	        if (_predicate2['default'].isVerticalLegend(legendOptions.align) && legendOptions.visible) {
	            legendWidth = this.getDimension('legend').width;
	        } else {
	            legendWidth = 0;
	        }
	        circleLegendWidth = Math.min(circleLegendWidth, Math.max(legendWidth, _const2['default'].MIN_LEGEND_WIDTH));
	
	        var diffWidth = circleLegendWidth - legendWidth;
	
	        this._registerDimension('circleLegend', {
	            width: circleLegendWidth,
	            height: circleLegendWidth
	        });
	
	        /**
	         * the reason why check diffWidth is positive:
	         * if circle legend area is narrower than text legend area, patial text legend area is not showing.
	         * because legend area width is set to circle legend area
	         */
	        if (diffWidth > 0) {
	            /**
	             * If circle legend area is wider than text legend area,
	             * recalculate legend and series width, base on circle legend width
	             */
	            this._updateLegendAndSeriesWidth(circleLegendWidth, diffWidth);
	        }
	    };
	
	    /**
	     * Make plot dimention
	     * @returns {{width: number, height: number}} plot dimension
	     * @private
	     */
	
	
	    BoundsModel.prototype._makePlotDimension = function _makePlotDimension() {
	        var seriesDimension = this.getDimension('series');
	
	        return {
	            width: seriesDimension.width,
	            height: seriesDimension.height + _const2['default'].OVERLAPPING_WIDTH
	        };
	    };
	
	    /**
	     * Register center components dimension.
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerCenterComponentsDimension = function _registerCenterComponentsDimension() {
	        var seriesDimension = this.getDimension('series');
	
	        this._registerDimension('tooltip', seriesDimension);
	        this._registerDimension('mouseEventDetector', seriesDimension);
	    };
	
	    /**
	     * Register axis components dimension.
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerAxisComponentsDimension = function _registerAxisComponentsDimension() {
	        var plotDimension = this._makePlotDimension();
	
	        this._registerDimension('plot', plotDimension);
	
	        this._registerDimension('xAxis', {
	            width: plotDimension.width
	        });
	
	        this._registerDimension('yAxis', {
	            height: plotDimension.height
	        });
	
	        this._registerDimension('rightYAxis', {
	            height: plotDimension.height
	        });
	    };
	
	    /**
	     * Update width of dimensions.
	     * @param {object} overflowInfo overflowLeft, overflowRight
	     * @private
	     */
	
	
	    BoundsModel.prototype._updateDimensionsWidth = function _updateDimensionsWidth(overflowInfo) {
	        var overflowLeft = Math.max(overflowInfo.overflowLeft, 0);
	        var overflowRight = overflowInfo.overflowRight ? Math.max(overflowInfo.overflowRight, 0) : 0;
	        var margin = overflowLeft + overflowRight;
	
	        this.chartLeftPadding += overflowLeft;
	        this.dimensionMap.plot.width -= margin;
	        this.dimensionMap.series.width -= margin;
	        this.dimensionMap.mouseEventDetector.width -= margin;
	        this.dimensionMap.xAxis.width -= margin;
	    };
	
	    /**
	     * Update height of dimensions.
	     * @param {number} diffHeight diff height
	     * @private
	     */
	
	
	    BoundsModel.prototype._updateDimensionsHeight = function _updateDimensionsHeight(diffHeight) {
	        this.dimensionMap.plot.height -= diffHeight;
	        this.dimensionMap.series.height -= diffHeight;
	        this.dimensionMap.mouseEventDetector.height -= diffHeight;
	        this.dimensionMap.tooltip.height -= diffHeight;
	        this.dimensionMap.yAxis.height -= diffHeight;
	        this.dimensionMap.rightYAxis.height -= diffHeight;
	        this.dimensionMap.xAxis.height += diffHeight;
	    };
	
	    /**
	     * Update dimensions for label of x axis.
	     * @param {?object} xAxisData - axis data for x axis.
	     * @private
	     */
	
	
	    BoundsModel.prototype._updateDimensionsForXAxisLabel = function _updateDimensionsForXAxisLabel(xAxisData) {
	        if (xAxisData.overflowRight > 0 || xAxisData.overflowLeft > 0) {
	            this._updateDimensionsWidth(xAxisData);
	        }
	
	        if (xAxisData.overflowHeight) {
	            this._updateDimensionsHeight(xAxisData.overflowHeight);
	        }
	    };
	
	    /**
	     * Register axes type component positions.
	     * @param {number} leftLegendWidth legend width
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerAxisComponentsPosition = function _registerAxisComponentsPosition(leftLegendWidth) {
	        var seriesPosition = this.getPosition('series');
	        var seriesDimension = this.getDimension('series');
	        var yAxisWidth = this.getDimension('yAxis').width;
	        var leftAreaWidth = leftLegendWidth + yAxisWidth + seriesDimension.width;
	
	        this.positionMap.plot = {
	            top: seriesPosition.top,
	            left: seriesPosition.left
	        };
	
	        this.positionMap.yAxis = {
	            top: seriesPosition.top,
	            left: this.chartLeftPadding + leftLegendWidth
	        };
	
	        this.positionMap.xAxis = {
	            top: seriesPosition.top + seriesDimension.height,
	            left: seriesPosition.left
	        };
	
	        this.positionMap.rightYAxis = {
	            top: seriesPosition.top,
	            left: this.chartLeftPadding + leftAreaWidth - _const2['default'].OVERLAPPING_WIDTH
	        };
	    };
	
	    /**
	     * Make legend position.
	     * @returns {{top: number, left: number}} legend bound
	     * @private
	     */
	
	
	    BoundsModel.prototype._makeLegendPosition = function _makeLegendPosition() {
	        var dimensionMap = this.dimensionMap;
	
	        var seriesDimension = dimensionMap.series;
	        var seriesPositionTop = this.getPosition('series').top;
	        var legendOption = this.options.legend;
	        var top = 0;
	        var yAxisAreaWidth = void 0,
	            left = void 0;
	
	        if (_predicate2['default'].isHorizontalLegend(legendOption.align)) {
	            left = (this.getDimension('chart').width - this.getDimension('legend').width) / 2;
	            if (_predicate2['default'].isLegendAlignBottom(legendOption.align)) {
	                top = seriesPositionTop + seriesDimension.height + this.getDimension('xAxis').height + _const2['default'].SERIES_AREA_V_PADDING;
	            } else {
	                top = seriesPositionTop - dimensionMap.legend.height + _const2['default'].LEGEND_AREA_V_PADDING;
	            }
	        } else {
	            if (_predicate2['default'].isLegendAlignLeft(legendOption.align)) {
	                left = this.chartLeftPadding;
	            } else {
	                yAxisAreaWidth = this.getDimension('yAxis').width + this.getDimension('rightYAxis').width;
	                left = this.chartLeftPadding + yAxisAreaWidth + seriesDimension.width;
	            }
	            top = seriesPositionTop + _const2['default'].SERIES_AREA_V_PADDING;
	        }
	
	        return {
	            top: top,
	            left: left
	        };
	    };
	
	    /**
	     * make spectrum legend position
	     * @returns {{top: number, left: number}} legend bound
	     * @private
	     */
	
	
	    BoundsModel.prototype._makeSpectrumLegendPosition = function _makeSpectrumLegendPosition() {
	        var legendOption = this.options.legend;
	        var align = this.options.legend.align;
	
	        var seriesPosition = this.getPosition('series');
	        var seriesDimension = this.getDimension('series');
	        var legendDimension = this.getDimension('legend');
	        var top = void 0,
	            left = void 0,
	            right = void 0;
	
	        if (_predicate2['default'].isHorizontalLegend(align)) {
	            left = (this.getDimension('chart').width - legendDimension.width) / 2;
	
	            if (_predicate2['default'].isLegendAlignTop(align)) {
	                top = seriesPosition.top - legendDimension.height;
	            } else {
	                top = seriesPosition.top + seriesDimension.height + this.getDimension('xAxis').height;
	            }
	        } else {
	            if (_predicate2['default'].isLegendAlignLeft(legendOption.align)) {
	                left = this.chartLeftPadding;
	            } else {
	                right = this.getDimension('chart').width - this.chartLeftPadding;
	                left = right - this.getDimension('legend').width;
	            }
	
	            if (_predicate2['default'].isBoxTypeChart(this.chartType)) {
	                top = seriesPosition.top;
	            } else {
	                top = seriesPosition.top + _const2['default'].MAP_CHART_ZOOM_AREA_HEIGHT * 0.75;
	            }
	        }
	
	        var position = {
	            top: top,
	            left: left
	        };
	
	        if (right) {
	            position.right = right;
	        }
	
	        return position;
	    };
	
	    /**
	     * Make chartExportMenu position.
	     * @returns {{top: number, left: number}}
	     * @private
	     */
	
	
	    BoundsModel.prototype._makeChartExportMenuPosition = function _makeChartExportMenuPosition() {
	        var top = this.getPosition('series').top - _const2['default'].SERIES_AREA_V_PADDING - _const2['default'].CHART_EXPORT_MENU_SIZE;
	
	        return {
	            top: top,
	            right: _const2['default'].CHART_PADDING
	        };
	    };
	
	    /**
	     * Make CircleLegend position.
	     * @returns {{top: number, left: number}}
	     * @private
	     */
	
	
	    BoundsModel.prototype._makeCircleLegendPosition = function _makeCircleLegendPosition() {
	        var seriesPosition = this.getPosition('series');
	        var seriesDimension = this.getDimension('series');
	        var circleDimension = this.getDimension('circleLegend');
	        var legendOptions = this.options.legend;
	        var left = void 0,
	            legendWidth = void 0;
	
	        if (_predicate2['default'].isLegendAlignLeft(legendOptions.align)) {
	            left = 0;
	        } else {
	            left = seriesPosition.left + seriesDimension.width;
	        }
	
	        if (_predicate2['default'].isVerticalLegend(legendOptions.align) && legendOptions.visible) {
	            legendWidth = this.getDimension('legend').width + _const2['default'].CHART_PADDING;
	            left += (legendWidth - circleDimension.width) / 2;
	        }
	
	        return {
	            top: seriesPosition.top + seriesDimension.height - circleDimension.height,
	            left: left
	        };
	    };
	
	    /**
	     * Whether need expansion series or not.
	     * @returns {boolean}
	     * @private
	     */
	
	
	    BoundsModel.prototype._isNeedExpansionSeries = function _isNeedExpansionSeries() {
	        var chartType = this.chartType;
	
	
	        return !(_predicate2['default'].isPieChart(chartType) || _predicate2['default'].isMapChart(chartType)) && !_predicate2['default'].isTreemapChart(chartType) && !_predicate2['default'].isRadialChart(chartType) && !_predicate2['default'].isPieDonutComboChart(chartType, this.seriesTypes);
	    };
	
	    /**
	     * Register essential components positions.
	     * Essential components is all components except components for axis.
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerEssentialComponentsPositions = function _registerEssentialComponentsPositions() {
	        var seriesPosition = this.getPosition('series');
	        var tooltipPosition = void 0;
	
	        this.positionMap.mouseEventDetector = Object.assign({}, seriesPosition);
	        this.positionMap.legend = this.useSpectrumLegend ? this._makeSpectrumLegendPosition() : this._makeLegendPosition();
	        this.positionMap.chartExportMenu = this._makeChartExportMenuPosition();
	
	        if (this.getDimension('circleLegend').width) {
	            this.positionMap.circleLegend = this._makeCircleLegendPosition();
	        }
	
	        if (this._isNeedExpansionSeries()) {
	            tooltipPosition = {
	                top: seriesPosition.top - _const2['default'].SERIES_EXPAND_SIZE,
	                left: seriesPosition.left - _const2['default'].SERIES_EXPAND_SIZE
	            };
	        } else {
	            tooltipPosition = seriesPosition;
	        }
	
	        this.positionMap.tooltip = tooltipPosition;
	    };
	
	    /**
	     * Register positions.
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerPositions = function _registerPositions() {
	        var _this2 = this;
	
	        var alignOption = this.options.legend.align;
	        var isVisibleLegend = this.options.legend.visible;
	        var legendDimension = this.getDimension('legend');
	        var isLegendAlignTop = _predicate2['default'].isLegendAlignTop(alignOption) && isVisibleLegend;
	        var isLegendAlignLeft = _predicate2['default'].isLegendAlignLeft(alignOption) && isVisibleLegend;
	        var topLegendHeight = isLegendAlignTop ? legendDimension.height : 0;
	        var leftLegendWidth = isLegendAlignLeft ? legendDimension.width : 0;
	        var titleOrExportMenuHeight = Math.max(this.getDimension('title').height, this.getDimension('chartExportMenu').height);
	        var yAxisTitlePadding = function () {
	            if (_this2.options.yAxis.title && !_this2.useSpectrumLegend) {
	                var titlePadding = _renderUtil2['default'].getRenderedLabelHeight(_this2.options.yAxis.title, _this2.theme.yAxis.title);
	
	                return titlePadding + _const2['default'].Y_AXIS_TITLE_PADDING;
	            }
	
	            return 0;
	        }();
	
	        var seriesPadding = Math.max(0, Math.max(topLegendHeight, yAxisTitlePadding) - _const2['default'].TITLE_PADDING);
	        var seriesTop = titleOrExportMenuHeight + seriesPadding;
	
	        if (!titleOrExportMenuHeight) {
	            seriesTop = Math.max(topLegendHeight, yAxisTitlePadding);
	        }
	
	        var seriesPosition = {
	            top: seriesTop + _const2['default'].CHART_PADDING,
	            left: this.chartLeftPadding + leftLegendWidth + this.getDimension('yAxis').width
	        };
	
	        this.positionMap.series = seriesPosition;
	
	        if (this.hasAxes) {
	            this._registerAxisComponentsPosition(leftLegendWidth);
	        }
	
	        this._registerEssentialComponentsPositions();
	    };
	
	    /**
	     * Register bound of extended series for rendering.
	     * @private
	     */
	
	
	    BoundsModel.prototype._registerExtendedSeriesBound = function _registerExtendedSeriesBound() {
	        var seriesBound = this.getBound('series');
	        if (this._isNeedExpansionSeries()) {
	            seriesBound = _renderUtil2['default'].expandBound(seriesBound);
	        }
	
	        this._setBound('extendedSeries', seriesBound);
	    };
	
	    /**
	     * Update bounds(positions, dimensions) of components for center option of yAxis.
	     * @private
	     */
	
	
	    BoundsModel.prototype._updateBoundsForYAxisCenterOption = function _updateBoundsForYAxisCenterOption() {
	        var yAxisWidth = this.getDimension('yAxis').width;
	        var yAxisExtensibleLeft = Math.floor(this.getDimension('series').width / 2) + _const2['default'].OVERLAPPING_WIDTH;
	        var xAxisDecreasingLeft = yAxisWidth - _const2['default'].OVERLAPPING_WIDTH;
	        var additionalLeft = _renderUtil2['default'].isOldBrowser() ? 1 : 0;
	
	        this.dimensionMap.extendedSeries.width += yAxisWidth;
	        this.dimensionMap.xAxis.width += _const2['default'].OVERLAPPING_WIDTH;
	        this.dimensionMap.plot.width += yAxisWidth + _const2['default'].OVERLAPPING_WIDTH;
	        this.dimensionMap.mouseEventDetector.width += yAxisWidth;
	        this.dimensionMap.tooltip.width += yAxisWidth;
	
	        this.positionMap.series.left -= yAxisWidth - additionalLeft;
	        this.positionMap.extendedSeries.left -= xAxisDecreasingLeft - additionalLeft;
	        this.positionMap.plot.left -= xAxisDecreasingLeft;
	        this.positionMap.yAxis.left += yAxisExtensibleLeft;
	        this.positionMap.xAxis.left -= xAxisDecreasingLeft;
	        this.positionMap.mouseEventDetector.left -= xAxisDecreasingLeft;
	        this.positionMap.tooltip.left -= xAxisDecreasingLeft;
	    };
	
	    /**
	     * Register bounds data.
	     * @param {?object} xAxisData - axis data for x axis.
	     */
	
	
	    BoundsModel.prototype.registerBoundsData = function registerBoundsData(xAxisData) {
	        this._registerCenterComponentsDimension();
	
	        if (this.useSpectrumLegend) {
	            this._updateDimensionsForSpectrumLegend();
	        }
	
	        if (this.hasAxes) {
	            this._registerAxisComponentsDimension();
	            this._updateDimensionsForXAxisLabel(xAxisData);
	        }
	
	        this._registerPositions();
	        this._registerExtendedSeriesBound();
	
	        if (this.options.yAxis.isCenter) {
	            this._updateBoundsForYAxisCenterOption();
	        }
	    };
	
	    /**
	     * Update spectrum legend dimension, to prevent overflow
	     * @private
	     */
	
	
	    BoundsModel.prototype._updateDimensionsForSpectrumLegend = function _updateDimensionsForSpectrumLegend() {
	        var legendAlignOption = this.options.legend.align;
	        var legendDimension = this.getDimension('legend');
	        var seriesDimension = this.getDimension('series');
	
	        if (_predicate2['default'].isHorizontalLegend(legendAlignOption) && legendDimension.width > seriesDimension.width) {
	            legendDimension.width = seriesDimension.width;
	        } else if (_predicate2['default'].isVerticalLegend(legendAlignOption)) {
	            if (_predicate2['default'].isBoxTypeChart(this.chartType)) {
	                legendDimension.height = seriesDimension.height;
	            } else if (legendDimension.height > seriesDimension.height - _const2['default'].MAP_CHART_ZOOM_AREA_HEIGHT) {
	                legendDimension.height = seriesDimension.height - _const2['default'].MAP_CHART_ZOOM_AREA_HEIGHT;
	            }
	        }
	    };
	
	    /**
	     * Calculate max radius.
	     * @param {object} axisDataMap - axisData map
	     * @returns {number}
	     */
	
	
	    BoundsModel.prototype.calculateMaxRadius = function calculateMaxRadius(axisDataMap) {
	        var dimensionMap = this.getDimensionMap(['series', 'circleLegend']);
	        var circleLegendVisible = this.options.circleLegend ? this.options.circleLegend.visible : false;
	
	        return _circleLegendCalculator2['default'].calculateMaxRadius(dimensionMap, axisDataMap, circleLegendVisible);
	    };
	
	    return BoundsModel;
	}();
	
	exports['default'] = BoundsModel;

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Calculator for circle legend.
	 * @module circleLegendCalculator
	 * @private
	 */
	/**
	 * @fileoverview Calculator for circle legend.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	exports['default'] = {
	    /**
	     * Calculate step of pixel unit.
	     * @param {{tickCount: number, isLabelAxis: boolean}} axisData - data for rendering axis
	     * @param {number} size - width or height of series area
	     * @returns {number}
	     * @private
	     */
	    _calculatePixelStep: function _calculatePixelStep(axisData, size) {
	        var tickCount = axisData.tickCount;
	
	        var pixelStep = void 0;
	
	        if (axisData.isLabelAxis) {
	            pixelStep = size / tickCount / 2;
	        } else {
	            pixelStep = size / (tickCount - 1);
	        }
	
	        return parseInt(pixelStep, 10);
	    },
	
	
	    /**
	     * Calculate radius by axis data.
	     * @param {{width: number, height: number}} seriesDimension - dimension for series
	     * @param {{xAxis: object, yAxis: object}} axisDataMap - axis data map
	     * @returns {number}
	     * @private
	     */
	    _calculateRadiusByAxisData: function _calculateRadiusByAxisData(seriesDimension, axisDataMap) {
	        var yPixelStep = this._calculatePixelStep(axisDataMap.yAxis, seriesDimension.height);
	        var xPixelStep = this._calculatePixelStep(axisDataMap.xAxis, seriesDimension.width);
	
	        return Math.min(yPixelStep, xPixelStep);
	    },
	
	
	    /**
	     * Get max width of label for CircleLegend.
	     * @param {string} maxLabel - maximum label
	     * @param {string} fontFamily - fontFamily for legend
	     * @returns {number}
	     * @private
	     */
	    _getCircleLegendLabelMaxWidth: function _getCircleLegendLabelMaxWidth(maxLabel, fontFamily) {
	        return _renderUtil2['default'].getRenderedLabelWidth(maxLabel, {
	            fontSize: _const2['default'].CIRCLE_LEGEND_LABEL_FONT_SIZE,
	            fontFamily: fontFamily
	        });
	    },
	
	
	    /**
	     * Calculate width for circle legend.
	     * @param {{width: number, height: number}} seriesDimension - dimension for series
	     * @param {{xAxis: object, yAxis: object}} axisDataMap - axis data map
	     * @param {string} maxLabel - maximum label
	     * @param {string} fontFamily - fontFamily for legend
	     * @returns {number}
	     */
	    calculateCircleLegendWidth: function calculateCircleLegendWidth(seriesDimension, axisDataMap, maxLabel, fontFamily) {
	        var maxRadius = this._calculateRadiusByAxisData(seriesDimension, axisDataMap);
	        var maxLabelWidth = this._getCircleLegendLabelMaxWidth(maxLabel, fontFamily);
	
	        return Math.max(maxRadius * 2, maxLabelWidth) + _const2['default'].CIRCLE_LEGEND_PADDING;
	    },
	
	
	    /**
	     * Calculate max radius.
	     * @param {{series: {width: number, height: number}, circleLegend: {width: number}}} dimensionMap - dimension map
	     * @param {{xAxis: object, yAxis: object}} axisDataMap - axis data map
	     * @param {boolean} [circleLegendVisible] - circleLegend visible option
	     * @returns {number}
	     */
	    calculateMaxRadius: function calculateMaxRadius(dimensionMap, axisDataMap, circleLegendVisible) {
	        var maxRadius = this._calculateRadiusByAxisData(dimensionMap.series, axisDataMap);
	        var circleLegendWidth = dimensionMap.circleLegend.width;
	
	        if (!circleLegendVisible) {
	            return maxRadius;
	        }
	
	        return Math.min((circleLegendWidth - _const2['default'].CIRCLE_LEGEND_PADDING) / 2, maxRadius);
	    }
	};

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Calculator for dimension of axis.
	 * @module axisCalculator
	 * @private */
	exports['default'] = {
	    /**
	     * Calculate height for x axis.
	     * @param {{title: string, labelMargin: number}} options - title and label margin option for x axis
	     * @param {{title: object, label: object}} theme - theme for x axis
	     * @returns {*}
	     */
	    calculateXAxisHeight: function calculateXAxisHeight(options, theme) {
	        var title = options.title;
	
	        var titleHeight = title ? _renderUtil2['default'].getRenderedLabelHeight(title.text, theme.title) : 0;
	        var titleAreaHeight = titleHeight ? titleHeight + _const2['default'].X_AXIS_TITLE_PADDING : 0;
	        var labelMargin = options.labelMargin || 0;
	        var labelHeight = _renderUtil2['default'].getRenderedLabelHeight(_const2['default'].MAX_HEIGHT_WORD, theme.label);
	        var height = titleAreaHeight + _const2['default'].X_AXIS_LABEL_PADDING;
	
	        if (labelMargin > 0) {
	            height += labelMargin;
	        }
	
	        if (options.showLabel !== false) {
	            height += labelHeight;
	        }
	
	        return height;
	    },
	
	
	    /**
	     * Calculate width for y axis.
	     * @param {Array.<string | number>} labels labels
	     * @param {{title: ?string, isCenter: ?boolean}} options - options
	     * @param {{title: object, label: object}} theme - theme for y axis calculate
	     * @param {Array} yAxisLabels - yAxis labels for y axis calculate
	     * @param {boolean} isDiverging - whether is diverging chart or not
	     * @returns {number}
	     */
	    calculateYAxisWidth: function calculateYAxisWidth(labels, options, theme, yAxisLabels, isDiverging) {
	        var labelMargin = options.labelMargin,
	            prefix = options.prefix,
	            suffix = options.suffix,
	            isCenter = options.isCenter,
	            type = options.type,
	            dateFormat = options.dateFormat,
	            showLabel = options.showLabel,
	            title = options.title;
	
	        var titleWidth = 0;
	        var maxLabelWidth = 0;
	        var width = 0;
	
	        labels = options.categories || labels;
	        labels = _renderUtil2['default'].addPrefixSuffix(labels, prefix, suffix);
	        yAxisLabels = _renderUtil2['default'].addPrefixSuffix(yAxisLabels, prefix, suffix);
	
	        if (isCenter) {
	            width += _const2['default'].Y_AXIS_LABEL_PADDING;
	        }
	
	        if (_predicate2['default'].isDatetimeType(type)) {
	            labels = _renderUtil2['default'].formatDates(labels, dateFormat);
	            yAxisLabels = _renderUtil2['default'].formatDates(yAxisLabels, dateFormat);
	        }
	        if (labelMargin && labelMargin > 0) {
	            width += labelMargin;
	        }
	        labels = yAxisLabels.length ? yAxisLabels : labels;
	        if (showLabel !== false) {
	            maxLabelWidth = _renderUtil2['default'].getRenderedLabelsMaxWidth(labels, theme.label);
	        }
	        if (title) {
	            titleWidth = _renderUtil2['default'].getRenderedLabelWidth(title.text, theme.title);
	        }
	
	        width += (isDiverging ? Math.max(maxLabelWidth, titleWidth) : maxLabelWidth) + _const2['default'].Y_AXIS_LABEL_PADDING;
	
	        return width;
	    }
	}; /**
	    * @fileoverview Calculator for dimension of axis.
	    * @author NHN.
	    *         FE Development Lab <dl_javascript@nhn.com>
	    */

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var LEGEND_CHECKBOX_SIZE = _const2['default'].LEGEND_CHECKBOX_SIZE,
	    LEGEND_ICON_WIDTH = _const2['default'].LEGEND_ICON_WIDTH,
	    LEGEND_LABEL_LEFT_PADDING = _const2['default'].LEGEND_LABEL_LEFT_PADDING,
	    LEGEND_V_LABEL_RIGHT_PADDING = _const2['default'].LEGEND_V_LABEL_RIGHT_PADDING,
	    LEGEND_H_LABEL_RIGHT_PADDING = _const2['default'].LEGEND_H_LABEL_RIGHT_PADDING,
	    LEGEND_AREA_H_PADDING = _const2['default'].LEGEND_AREA_H_PADDING;
	
	/**
	 * Calculator for dimension of legend.
	 * @module legendCalculator
	 * @private */
	/**
	 * @fileoverview Calculator for dimension of legend.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	exports['default'] = {
	    /**
	     * Calculate sum of legends width.
	     * @param {Array.<string>} labels - legend labels
	     * @param {{fontSize: number, fontFamily: number}} labelTheme - legend label theme
	     * @param {number} checkboxWidth - width for checkbox
	     * @param {?number} [maxWidth] - user option legend maxWidth
	     * @returns {number}
	     * @private
	     */
	    _calculateLegendsWidth: function _calculateLegendsWidth(labels, labelTheme, checkboxWidth, maxWidth) {
	        var restWidth = _calculator2['default'].sum([LEGEND_AREA_H_PADDING, checkboxWidth, LEGEND_ICON_WIDTH, LEGEND_LABEL_LEFT_PADDING]);
	
	        return labels.map(function (label) {
	            var labelWidth = _renderUtil2['default'].getRenderedLabelWidth(label, labelTheme);
	
	            if (maxWidth && labelWidth > maxWidth) {
	                labelWidth = maxWidth;
	            }
	            labelWidth += restWidth;
	
	            return labelWidth + LEGEND_H_LABEL_RIGHT_PADDING;
	        });
	    },
	
	
	    /**
	     * Divide legend labels.
	     * @param {Array.<string>} labels legend labels
	     * @param {number} maxRowCount division limit count
	     * @returns {Array.<Array.<string>>}
	     * @private
	     */
	    _divideLegendLabels: function _divideLegendLabels(labels, maxRowCount) {
	        var results = [];
	        var temp = [];
	
	        labels.forEach(function (label) {
	            if (temp.length < maxRowCount) {
	                temp.push(label);
	            } else {
	                results.push(temp);
	                temp = [label];
	            }
	        });
	
	        if (temp.length) {
	            results.push(temp);
	        }
	
	        return results;
	    },
	
	
	    /**
	     * Get max line width.
	     * @param {Array.<string>} dividedLabels - divided labels
	     * @param {{fontFamily: ?string, fontSize: ?string}} labelTheme - label theme
	     * @param {number} checkboxWidth - width for checkbox
	     * @param {?number} [maxWidth] - user option legend maxWidth
	     * @returns {number}
	     * @private
	     */
	    _getLegendWidthInfo: function _getLegendWidthInfo(dividedLabels, labelTheme, checkboxWidth, maxWidth) {
	        var _this = this;
	
	        var labelWidthArr = [];
	        var legendWidths = dividedLabels.map(function (labels) {
	            var legendLabelWidthArr = _this._calculateLegendsWidth(labels, labelTheme, checkboxWidth, maxWidth);
	            var legendWidth = _calculator2['default'].sum(legendLabelWidthArr);
	
	            labelWidthArr = labelWidthArr.concat(legendLabelWidthArr);
	            legendWidth = legendWidth - LEGEND_H_LABEL_RIGHT_PADDING + LEGEND_AREA_H_PADDING;
	
	            return legendWidth;
	        });
	
	        return {
	            labelWidthArr: labelWidthArr,
	            legendWidths: legendWidths
	        };
	    },
	
	
	    /**
	     * Make divided labels and max line width.
	     * @param {Array.<string>} labels legend labels
	     * @param {number} chartWidth chart width
	     * @param {{fontSize: number, fontFamily: number}} labelTheme legend label theme
	     * @param {number} checkboxWidth - width for checkbox
	     * @param {?number} [maxWidth] - user option legend maxWidth
	     * @returns {{dividedLabels: Array.<Array.<string>>, maxLineWidth: number}}
	     * @private
	     */
	    _makeDividedLabelsAndMaxLineWidth: function _makeDividedLabelsAndMaxLineWidth(labels, chartWidth, labelTheme, checkboxWidth, maxWidth) {
	        var maxRowCount = Number.MAX_VALUE;
	        var divideCount = 1;
	        var maxLineWidth = 0;
	        var dividedLabels = void 0,
	            lineWidths = void 0,
	            labelWidths = void 0;
	        do {
	            maxRowCount = Math.round(labels.length / divideCount);
	            dividedLabels = this._divideLegendLabels(labels, maxRowCount);
	            var legendWidthInfo = this._getLegendWidthInfo(dividedLabels, labelTheme, checkboxWidth, maxWidth);
	
	            lineWidths = legendWidthInfo.legendWidths;
	            labelWidths = legendWidthInfo.labelWidthArr;
	
	
	            maxLineWidth = _arrayUtil2['default'].max(lineWidths);
	
	            if (maxRowCount === 1) {
	                break;
	            }
	
	            divideCount += 1;
	        } while (maxLineWidth >= chartWidth);
	
	        maxLineWidth = Math.min(maxLineWidth, chartWidth);
	
	        return {
	            labels: this._optimizedHorizontalLegendLabels(labels, labelWidths, maxLineWidth),
	            maxLineWidth: maxLineWidth
	        };
	    },
	
	
	    /**
	     * Make space optimized legend labels
	     * @param {Array.<string>} labels - labels string
	     * @param {Array.<number>} labelWidths - labels width
	     * @param {number} maxLineWidth - max line width
	     * @returns {Array.<Array.<string>>}
	     * @private
	     */
	    _optimizedHorizontalLegendLabels: function _optimizedHorizontalLegendLabels(labels, labelWidths, maxLineWidth) {
	        var optimizedDvidedLabels = [];
	        var labelsLastIdx = labels.length - 1;
	        var sum = 0;
	        var temp = [];
	
	        labels.forEach(function (label, labelIdx) {
	            var labelWidth = labelWidths[labelIdx];
	            var paddingWidth = LEGEND_AREA_H_PADDING - LEGEND_H_LABEL_RIGHT_PADDING;
	            var predictedLineWidth = sum + labelWidth + paddingWidth;
	
	            if (predictedLineWidth <= maxLineWidth) {
	                temp.push(label);
	            } else {
	                optimizedDvidedLabels.push(temp);
	                temp = [label];
	                sum = 0;
	            }
	
	            sum += labelWidth;
	
	            if (labelsLastIdx === labelIdx) {
	                optimizedDvidedLabels.push(temp);
	            }
	        });
	
	        return optimizedDvidedLabels;
	    },
	
	
	    /**
	     * Calculate height of horizontal legend.
	     * @param {Array.<Array.<string>>} dividedLabels - divided labels
	     * @param {{fontSize: number, fontFamily: number}} labelTheme - label theme for legend
	     * @returns {number}
	     * @private
	     */
	    _calculateHorizontalLegendHeight: function _calculateHorizontalLegendHeight(dividedLabels, labelTheme) {
	        var heightByLabel = Math.max.apply(null, dividedLabels.map(function (labels) {
	            return _renderUtil2['default'].getRenderedLabelsMaxHeight(labels, labelTheme);
	        }));
	        var labelItemHeightWithPaddingTop = _calculator2['default'].sum([Math.max(_const2['default'].LEGEND_CHECKBOX_SIZE, heightByLabel), _const2['default'].LINE_MARGIN_TOP]);
	
	        var legendHeight = labelItemHeightWithPaddingTop * dividedLabels.length - _const2['default'].LINE_MARGIN_TOP + _const2['default'].SERIES_AREA_V_PADDING;
	
	        return legendHeight;
	    },
	
	
	    /**
	     * Make dimension of horizontal legend.
	     * @param {{fontSize: number, fontFamily: number}} labelTheme - label theme for legend
	     * @param {Array.<string>} legendLabels - labels for legend
	     * @param {number} chartWidth - chart width
	     * @param {number} checkboxWidth - width for checkbox
	     * @param {?number} [maxWidth] - user option legend maxWidth
	     * @returns {{width: number, height: (number)}}
	     * @private
	     */
	    _makeHorizontalDimension: function _makeHorizontalDimension(labelTheme, legendLabels, chartWidth, checkboxWidth, maxWidth) {
	        var dividedInfo = this._makeDividedLabelsAndMaxLineWidth(legendLabels, chartWidth, labelTheme, checkboxWidth, maxWidth);
	        var horizontalLegendHeight = this._calculateHorizontalLegendHeight(dividedInfo.labels, labelTheme);
	        var legendHeight = horizontalLegendHeight + _const2['default'].SERIES_AREA_V_PADDING;
	
	        return {
	            width: Math.max(dividedInfo.maxLineWidth, _const2['default'].MIN_LEGEND_WIDTH),
	            height: legendHeight
	        };
	    },
	
	
	    /**
	     * Make dimension of vertical legend.
	     * @param {{fontSize: number, fontFamily: number}} labelTheme - label theme for legend
	     * @param {Array.<string>} legendLabels - labels for legend
	     * @param {number} checkboxWidth - width for checkbox
	     * @param {?number} [maxWidth] - user option legend maxWidth
	     * @returns {{width: (number)}}
	     * @private
	     */
	    _makeVerticalDimension: function _makeVerticalDimension(labelTheme, legendLabels, checkboxWidth, maxWidth) {
	        var labelWidth = _renderUtil2['default'].getRenderedLabelsMaxWidth(legendLabels, labelTheme);
	        var legendWidth = 0;
	
	        if (maxWidth && labelWidth > maxWidth) {
	            labelWidth = maxWidth;
	        }
	
	        legendWidth = _calculator2['default'].sum([LEGEND_AREA_H_PADDING * 2, checkboxWidth, LEGEND_ICON_WIDTH, LEGEND_LABEL_LEFT_PADDING, labelWidth, LEGEND_V_LABEL_RIGHT_PADDING]);
	
	        return {
	            width: legendWidth,
	            height: 0
	        };
	    },
	
	
	    /**
	     * Calculate legend dimension.
	     * @param {{showCheckbox: boolean, visible: boolean, align: string}} options - options for legend
	     * @param {{fontSize: number, fontFamily: number}} labelTheme - label theme for legend
	     * @param {Array.<string>} legendLabels - labels for legend
	     * @param {number} chartWidth chart width
	     * @returns {{width: number, height: number}}
	     */
	    calculate: function calculate(options, labelTheme, legendLabels, chartWidth) {
	        var checkboxWidth = options.showCheckbox === false ? 0 : LEGEND_CHECKBOX_SIZE + LEGEND_LABEL_LEFT_PADDING;
	        var maxWidth = options.maxWidth;
	
	        var dimension = {};
	
	        if (!options.visible) {
	            dimension.width = 0;
	        } else if (_predicate2['default'].isHorizontalLegend(options.align)) {
	            dimension = this._makeHorizontalDimension(labelTheme, legendLabels, chartWidth, checkboxWidth, maxWidth);
	        } else {
	            dimension = this._makeVerticalDimension(labelTheme, legendLabels, checkboxWidth, maxWidth);
	        }
	
	        return dimension;
	    }
	};

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Calculator for series.
	 * @module seriesCalculator
	 * @private */
	/**
	 * @fileoverview Calculator for series.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	exports['default'] = {
	    /**
	     * Calculate width.
	     * @param {{
	     *      chart: {width: number},
	     *      yAxis: {width: number},
	     *      legend: {width: number},
	     *      rightYAxis: ?{width: number}
	     * }} dimensionMap - dimension map
	     * @param {{align: ?string, visible: boolean}} legendOptions - legend options
	     * @param {number} maxLabelWidth - max label width
	     * @returns {number} series width
	     */
	    calculateWidth: function calculateWidth(dimensionMap, legendOptions, maxLabelWidth) {
	        var chartWidth = dimensionMap.chart.width,
	            yAxis = dimensionMap.yAxis,
	            rightYAxis = dimensionMap.rightYAxis,
	            legend = dimensionMap.legend;
	
	        var yAxisAreaWidth = yAxis.width + rightYAxis.width;
	        var legendDimension = legend;
	        var legendWidth = 0;
	        var xAxisLabelPadding = 0;
	
	        if (_predicate2['default'].isVerticalLegend(legendOptions.align) && legendOptions.visible) {
	            legendWidth = legendDimension ? legendDimension.width : 0;
	        }
	
	        if (!legendWidth && !rightYAxis.width && maxLabelWidth) {
	            xAxisLabelPadding = maxLabelWidth / 2;
	        }
	
	        return chartWidth - _const2['default'].CHART_PADDING * 2 - yAxisAreaWidth - legendWidth - xAxisLabelPadding;
	    },
	
	
	    /**
	     * Calculate height.
	     * @param {{
	     *      chart: {height: number},
	     *      title: {height: number},
	     *      legend: {height: number},
	     *      xAxis: {height: number}
	     * }} dimensionMap - dimension map
	     * @param {{align: ?string, visible: boolean}} legendOptions - legend options
	     * @param {number} yAxisTitleAreaHeight - yAxis title area height
	     * @returns {number} series height
	     */
	    calculateHeight: function calculateHeight(dimensionMap, legendOptions, yAxisTitleAreaHeight) {
	        var chartHeight = dimensionMap.chart.height;
	        var titleHeight = Math.max(dimensionMap.title.height, dimensionMap.chartExportMenu.height);
	        var legendHeight = legendOptions.visible ? dimensionMap.legend.height : 0;
	        var topLegendHeight = _predicate2['default'].isLegendAlignTop(legendOptions.align) ? legendHeight : 0;
	        var topAreaPadding = Math.max(0, Math.max(yAxisTitleAreaHeight, topLegendHeight) - _const2['default'].TITLE_PADDING);
	        var topAreaHeight = titleHeight + topAreaPadding;
	        var bottomLegendHeight = _predicate2['default'].isLegendAlignBottom(legendOptions.align) ? legendHeight : 0;
	        var bottomAreaHeight = dimensionMap.xAxis.height + bottomLegendHeight;
	
	        return chartHeight - _const2['default'].CHART_PADDING * 2 - topAreaHeight - bottomAreaHeight;
	    }
	};

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING = _const2['default'].MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING,
	    MAP_LEGEND_WEDGE_SIZE = _const2['default'].MAP_LEGEND_WEDGE_SIZE,
	    MAP_LEGEND_AREA_PADDING_WIDE = _const2['default'].MAP_LEGEND_AREA_PADDING_WIDE,
	    MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE = _const2['default'].MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE,
	    MAP_LEGEND_GRAPH_SIZE = _const2['default'].MAP_LEGEND_GRAPH_SIZE,
	    MAP_LEGEND_LABEL_PADDING = _const2['default'].MAP_LEGEND_LABEL_PADDING,
	    VERTICAL_MAP_LEGEND_HEIGHT = _const2['default'].VERTICAL_MAP_LEGEND_HEIGHT,
	    MAP_LEGEND_TOOLTIP_VERTICAL_PADDING = _const2['default'].MAP_LEGEND_TOOLTIP_VERTICAL_PADDING,
	    MAP_LEGEND_AREA_PADDING_NARROW = _const2['default'].MAP_LEGEND_AREA_PADDING_NARROW,
	    HORIZONTAL_MAP_LEGEND_WIDTH = _const2['default'].HORIZONTAL_MAP_LEGEND_WIDTH;
	
	/**
	 * Calculator for spectrum legend.
	 * @module spectrumLegendCalculator
	 * @private
	 */
	/**
	 * @fileoverview Calculator for spectrum legend.
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	exports['default'] = {
	    /**
	     * Make vertical dimension.
	     * @param {string} maxValue - formatted max value
	     * @param {string} minValue - formatted min value
	     * @param {object} labelTheme - theme for label
	     * @returns {{width: number, height: number}}
	     * @private
	     */
	    _makeVerticalDimension: function _makeVerticalDimension(maxValue, minValue, labelTheme) {
	        var maxValueLabelWidth = _renderUtil2['default'].getRenderedLabelWidth(maxValue, labelTheme);
	        var minValueLabelWidth = _renderUtil2['default'].getRenderedLabelWidth(minValue, labelTheme);
	        var labelWidth = _renderUtil2['default'].getRenderedLabelWidth(maxValue, labelTheme);
	        var tooltipWidth = _calculator2['default'].sum([MAP_LEGEND_TOOLTIP_HORIZONTAL_PADDING * 2, labelWidth, MAP_LEGEND_WEDGE_SIZE]);
	
	        return {
	            width: _calculator2['default'].sum([MAP_LEGEND_AREA_PADDING_WIDE, tooltipWidth, MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE, MAP_LEGEND_GRAPH_SIZE, MAP_LEGEND_LABEL_PADDING, Math.max(maxValueLabelWidth, minValueLabelWidth)]),
	            height: VERTICAL_MAP_LEGEND_HEIGHT
	        };
	    },
	
	
	    /**
	     * Make horizontal dimension.
	     * @param {string} maxValue - formatted max value
	     * @param {object} labelTheme - theme for label
	     * @param {boolean} isBoxType - whether use narrow padding or not
	     * @param {boolean} isTopLegend - whether use top legend or not
	     * @returns {{width: number, height: number}}
	     * @private
	     */
	    _makeHorizontalDimension: function _makeHorizontalDimension(maxValue, labelTheme, isBoxType, isTopLegend) {
	        var labelHeight = _renderUtil2['default'].getRenderedLabelHeight(maxValue, labelTheme);
	        var tooltipHeight = _calculator2['default'].sum([MAP_LEGEND_TOOLTIP_VERTICAL_PADDING * 2, labelHeight, MAP_LEGEND_WEDGE_SIZE]);
	        var padding = isBoxType ? MAP_LEGEND_AREA_PADDING_NARROW : MAP_LEGEND_AREA_PADDING_WIDE;
	        var additionalTopPadding = isTopLegend ? MAP_LEGEND_AREA_PADDING_WIDE : 0;
	
	        return {
	            width: HORIZONTAL_MAP_LEGEND_WIDTH,
	            height: _calculator2['default'].sum([padding, tooltipHeight, MAP_LEGEND_PADDING_BTW_GRAPH_AND_WEDGE, MAP_LEGEND_GRAPH_SIZE, MAP_LEGEND_LABEL_PADDING, labelHeight, MAP_LEGEND_LABEL_PADDING, additionalTopPadding])
	        };
	    }
	};

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _scaleDataMaker = __webpack_require__(447);
	
	var _scaleDataMaker2 = _interopRequireDefault(_scaleDataMaker);
	
	var _scaleLabelFormatter = __webpack_require__(449);
	
	var _scaleLabelFormatter2 = _interopRequireDefault(_scaleLabelFormatter);
	
	var _axisDataMaker = __webpack_require__(450);
	
	var _axisDataMaker2 = _interopRequireDefault(_axisDataMaker);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ScaleDataModel = function () {
	    /**
	     * ScaleDataModel is scale model for scale data and axis data.
	     * @param {object} params - parameters
	     * @constructs ScaleDataModel
	     * @private
	     */
	    function ScaleDataModel(params) {
	        _classCallCheck(this, ScaleDataModel);
	
	        this.chartType = params.chartType;
	        this.seriesTypes = params.seriesTypes;
	        this.dataProcessor = params.dataProcessor;
	        this.boundsModel = params.boundsModel;
	        this.options = params.options;
	        this.theme = params.theme;
	        this.hasRightYAxis = !!params.hasRightYAxis;
	        this.prevValidLabelCount = null;
	
	        this.initScaleData(params.addedDataCount);
	        this.initForAutoTickInterval();
	    }
	
	    /**
	     * Initialize scale data.
	     * @param {?number} addedDataCount - increased added count by dynamic adding data
	     */
	
	
	    ScaleDataModel.prototype.initScaleData = function initScaleData(addedDataCount) {
	        this.scaleDataMap = {};
	        this.axisDataMap = {};
	        this.addedDataCount = addedDataCount;
	    };
	
	    /**
	     * Initialize for auto tick interval.
	     */
	
	
	    ScaleDataModel.prototype.initForAutoTickInterval = function initForAutoTickInterval() {
	        this.firstTickCount = null;
	    };
	
	    /**
	     * Pick limit option.
	     * @param {{min: ?number, max: ?number}} axisOptions - axis options
	     * @returns {{min: ?number, max: ?number}}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype._pickLimitOption = function _pickLimitOption(axisOptions) {
	        axisOptions = axisOptions || {};
	
	        return {
	            min: axisOptions.min,
	            max: axisOptions.max
	        };
	    };
	
	    /**
	     * Create base scale data.
	     * @param {{
	     *      chartType: string,
	     *      areaType: string,
	     *      valueType: string
	     * }} typeMap - type map
	     * @param {{
	     *      type: string,
	     *      stackType: string,
	     *      diverging: boolean
	     * }} baseOptions - base options
	     * @param {object} axisOptions - axis options
	     * @param {object} additionalOptions - additional options
	     * @returns {{limit: {min: number, max: number}, step: number}}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype._createBaseScaleData = function _createBaseScaleData(typeMap, baseOptions, axisOptions, additionalOptions) {
	        var chartType = typeMap.chartType;
	
	        var isVertical = typeMap.areaType !== 'xAxis';
	        var baseValues = this.dataProcessor.createBaseValuesForLimit(chartType, additionalOptions.isSingleYAxis, baseOptions.stackType, typeMap.valueType, typeMap.areaType);
	
	        var baseSize = this.boundsModel.getBaseSizeForLimit(isVertical);
	        var options = Object.assign(baseOptions, {
	            isVertical: isVertical,
	            limitOption: this._pickLimitOption(axisOptions),
	            tickCounts: additionalOptions.tickCounts,
	            showLabel: this.options.series.showLabel
	        });
	
	        if (_predicate2['default'].isBubbleChart(chartType)) {
	            options.overflowItem = this.dataProcessor.findOverflowItem(chartType, typeMap.valueType);
	        }
	
	        if (_predicate2['default'].isMapChart(chartType) || _predicate2['default'].isHeatmapChart(chartType) || _predicate2['default'].isTreemapChart(chartType)) {
	            options.useSpectrumLegend = true;
	        }
	
	        return _scaleDataMaker2['default'].makeScaleData(baseValues, baseSize, chartType, options);
	    };
	
	    /**
	     * Create scale labels.
	     * @param {{limit: {min: number, max: number}, step: number}} baseScaleData - base scale data
	     * @param {{
	     *      chartType: string,
	     *      areaType: string,
	     *      valueType: string
	     * }} typeMap - type map
	     * @param {{
	     *      type: string,
	     *      stackType: string,
	     *      diverging: boolean
	     * }} baseOptions - base options
	     * @param {string} dateFormat - date format
	     * @returns {Array.<string>}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype._createScaleLabels = function _createScaleLabels(baseScaleData, typeMap, baseOptions, dateFormat) {
	        var formatFunctions = this.dataProcessor.getFormatFunctions();
	        var options = Object.assign(baseOptions, {
	            dateFormat: dateFormat
	        });
	
	        return _scaleLabelFormatter2['default'].createFormattedLabels(baseScaleData, typeMap, options, formatFunctions);
	    };
	
	    /**
	     * Create scale.
	     * @param {object} axisOptions - axis options
	     * @param {{chartType: string, areaType: string, valueType: string}} typeMap - type map
	     * @param {?object} additionalOptions - additional options
	     * @returns {object}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype._createScaleData = function _createScaleData(axisOptions, typeMap, additionalOptions) {
	        var seriesOptions = this.options.series;
	        var chartType = typeMap.chartType || this.chartType;
	
	        typeMap.chartType = chartType;
	        seriesOptions = seriesOptions[chartType] || seriesOptions;
	
	        var baseOptions = {
	            stackType: additionalOptions.stackType || seriesOptions.stackType,
	            diverging: seriesOptions.diverging,
	            type: axisOptions.type
	        };
	        var baseScaleData = this._createBaseScaleData(typeMap, baseOptions, axisOptions, additionalOptions);
	
	        return _tuiCodeSnippet2['default'].extend(baseScaleData, {
	            labels: this._createScaleLabels(baseScaleData, typeMap, baseOptions, axisOptions.dateFormat),
	            axisOptions: axisOptions
	        });
	    };
	
	    /**
	     * Create value type axis data.
	     * @param {{labels: Array.<string>, limit: {min: number, max: number}, step: number}} scaleData - scale data
	     * @param {object} labelTheme - label theme
	     * @param {boolean} aligned - aligned tick and label
	     * @param {boolean} isVertical - whether vertical or not
	     * @param {boolean} isPositionRight - whether right position or not
	     * @returns {{
	     *      labels: Array.<string>,
	     *      tickCount: number,
	     *      validTickCount: number,
	     *      isLabelAxis: boolean,
	     *      limit: {min: number, max: number},
	     *      isVertical: boolean
	     * }}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype._createValueAxisData = function _createValueAxisData(scaleData, labelTheme, aligned, isVertical, isPositionRight) {
	        var hasCategories = this.dataProcessor.hasCategories();
	        var isCoordinateLineType = !isVertical && !hasCategories && aligned;
	        var labels = scaleData.labels,
	            limit = scaleData.limit,
	            step = scaleData.step;
	
	        var tickCount = labels.length;
	
	        var axisData = _axisDataMaker2['default'].makeValueAxisData({
	            labels: labels,
	            tickCount: labels.length,
	            limit: limit,
	            step: step,
	            labelTheme: labelTheme,
	            aligned: aligned,
	            options: scaleData.axisOptions,
	            isVertical: !!isVertical,
	            isPositionRight: !!isPositionRight
	        });
	
	        if (isCoordinateLineType) {
	            var values = this.dataProcessor.getValues(this.chartType, 'x');
	            var additional = _axisDataMaker2['default'].makeAdditionalDataForCoordinateLineType(labels, values, limit, step, tickCount);
	            _tuiCodeSnippet2['default'].extend(axisData, additional);
	        }
	
	        return axisData;
	    };
	
	    /**
	     * Create label type axis data.
	     * @param {object} axisOptions - options for axis
	     * @param {object} labelTheme - label theme
	     * @param {boolean} aligned - aligned tick and label
	     * @param {boolean} isVertical - whether vertical or not
	     * @param {boolean} isPositionRight - whether right position or not
	     * @returns {{
	     *      labels: Array.<string>,
	     *      tickCount: number,
	     *      validTickCount: number,
	     *      isLabelAxis: boolean,
	     *      options: object,
	     *      isVertical: boolean,
	     *      isPositionRight: boolean,
	     *      aligned: boolean
	     * }}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype._createLabelAxisData = function _createLabelAxisData(axisOptions, labelTheme, aligned, isVertical, isPositionRight) {
	        var labels = axisOptions.categories || this.dataProcessor.getCategories(isVertical);
	
	        return _axisDataMaker2['default'].makeLabelAxisData({
	            labels: labels,
	            options: axisOptions,
	            labelTheme: labelTheme,
	            aligned: aligned,
	            isVertical: !!isVertical,
	            isPositionRight: !!isPositionRight,
	            addedDataCount: this.options.series.shifting ? this.addedDataCount : 0
	        });
	    };
	
	    /**
	     * Create axis data.
	     * @param {object} scaleData - scale data
	     * @param {object} axisOptions - axis options
	     * @param {object} labelTheme - them for label
	     * @param {boolean} isVertical - whether vertical or not
	     * @param {boolean} isPositionRight - whether right position or not
	     * @returns {object}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype._createAxisData = function _createAxisData(scaleData, axisOptions, labelTheme, isVertical, isPositionRight) {
	        var aligned = _predicate2['default'].isLineTypeChart(this.chartType, this.seriesTypes) && !axisOptions.pointOnColumn;
	        var axisData = void 0;
	
	        if (scaleData) {
	            axisData = this._createValueAxisData(scaleData, labelTheme, aligned, isVertical, isPositionRight);
	        } else {
	            axisData = this._createLabelAxisData(axisOptions, labelTheme, aligned, isVertical, isPositionRight);
	        }
	
	        return axisData;
	    };
	
	    /**
	     * Create axes data.
	     * @returns {object.<string, object>}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype._createAxesData = function _createAxesData() {
	        var scaleDataMap = this.scaleDataMap,
	            options = this.options,
	            theme = this.theme;
	
	        var yAxisOptions = _tuiCodeSnippet2['default'].isArray(options.yAxis) ? options.yAxis : [options.yAxis];
	        var dataMap = {};
	
	        dataMap.xAxis = this._createAxisData(scaleDataMap.xAxis, options.xAxis, theme.xAxis.label);
	        dataMap.yAxis = this._createAxisData(scaleDataMap.yAxis, yAxisOptions[0], theme.yAxis.label, true);
	
	        if (this.hasRightYAxis) {
	            dataMap.rightYAxis = this._createAxisData(scaleDataMap.rightYAxis, yAxisOptions[1], theme.yAxis.label, true, true);
	            if (!dataMap.rightYAxis.aligned) {
	                dataMap.rightYAxis.aligned = dataMap.yAxis.aligned;
	            }
	        }
	
	        return dataMap;
	    };
	
	    /**
	     * Add scale.
	     * @param {string} axisName - axis name
	     * @param {options} axisOptions - axis options
	     * @param {{chartType: string, areaType: string}} typeMap - type map
	     * @param {object} additionalOptions - additional parameters
	     */
	
	
	    ScaleDataModel.prototype.addScale = function addScale(axisName, axisOptions) {
	        var typeMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	        var additionalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	
	        typeMap.areaType = typeMap.areaType || axisName;
	        typeMap.chartType = additionalOptions.chartType || typeMap.chartType;
	
	        this.scaleDataMap[axisName] = this._createScaleData(axisOptions, typeMap, additionalOptions);
	    };
	
	    /**
	     * Set axis data map.
	     */
	
	
	    ScaleDataModel.prototype.setAxisDataMap = function setAxisDataMap() {
	        this.axisDataMap = this._createAxesData();
	    };
	
	    /**
	     * Update x axis data for auto tick interval.
	     * @param {object} prevXAxisData - previous xAxis data
	     * @param {?boolean} addingDataMode - whether adding data mode or not
	     */
	
	
	    ScaleDataModel.prototype.updateXAxisDataForAutoTickInterval = function updateXAxisDataForAutoTickInterval(prevXAxisData, addingDataMode) {
	        var shiftingOption = this.options.series.shifting;
	        var zoomableOption = this.options.series.zoomable;
	        var xAxisData = this.axisDataMap.xAxis;
	        var seriesWidth = this.boundsModel.getDimension('series').width;
	        var addedCount = this.addedDataCount;
	
	        if (shiftingOption || !prevXAxisData || zoomableOption) {
	            _axisDataMaker2['default'].updateLabelAxisDataForAutoTickInterval(xAxisData, seriesWidth, addedCount, addingDataMode);
	        } else {
	            _axisDataMaker2['default'].updateLabelAxisDataForStackingDynamicData(xAxisData, prevXAxisData, this.firstTickCount);
	        }
	
	        if (!this.firstTickCount) {
	            this.firstTickCount = xAxisData.tickCount;
	        }
	    };
	
	    /**
	     * Update x axis data for label.
	     * @param {?boolean} addingDataMode - whether adding data mode or not
	     */
	
	
	    ScaleDataModel.prototype.updateXAxisDataForLabel = function updateXAxisDataForLabel(addingDataMode) {
	        var axisData = this.axisDataMap.xAxis;
	        var dimensionMap = this.boundsModel.getDimensionMap(['series', 'yAxis', 'chart']);
	        var isLabelAxis = axisData.isLabelAxis;
	
	        var theme = this.theme.xAxis.label;
	        var validLabelCount = void 0,
	            additionalData = void 0;
	        var labels = axisData.labels;
	
	
	        if (addingDataMode) {
	            labels = labels.slice(0, labels.length - 1);
	        }
	
	        labels = _renderUtil2['default'].addPrefixSuffix(labels, this.options.xAxis.prefix, this.options.xAxis.suffix);
	
	        var validLabels = _tuiCodeSnippet2['default'].filter(labels, function (label) {
	            return !!label;
	        });
	
	        if (!_tuiCodeSnippet2['default'].isNull(this.prevValidLabelCount)) {
	            validLabelCount = this.prevValidLabelCount;
	        } else {
	            validLabelCount = validLabels.length;
	        }
	
	        if (this.options.yAxis.isCenter) {
	            validLabelCount += 1;
	            dimensionMap.yAxis.width = 0;
	        }
	
	        if (axisData.options.rotateLabel === false) {
	            additionalData = _axisDataMaker2['default'].makeAdditionalDataForMultilineLabels(labels, validLabelCount, theme, isLabelAxis, dimensionMap);
	        } else {
	            additionalData = _axisDataMaker2['default'].makeAdditionalDataForRotatedLabels(validLabels, validLabelCount, theme, isLabelAxis, dimensionMap);
	        }
	
	        this.prevValidLabelCount = validLabelCount;
	
	        _tuiCodeSnippet2['default'].extend(axisData, additionalData);
	    };
	
	    /**
	     * Find limit from limitMap by seriesIndex
	     * @param {object} limitMap - limit map
	     * @param {number} seriesIndex - series index
	     * @param {boolean} isVertical - whether vertical or not
	     * @returns {boolean}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype._findLimit = function _findLimit(limitMap, seriesIndex, isVertical) {
	        var limit = void 0;
	
	        if (seriesIndex === 0) {
	            limit = isVertical ? limitMap.yAxis : limitMap.xAxis;
	        } else {
	            limit = limitMap.rightYAxis ? limitMap.rightYAxis : limitMap.yAxis;
	        }
	
	        return limit;
	    };
	
	    /**
	     * Make limit map.
	     * @param {Array.<string>} seriesTypes - series types like bar, column, line, area
	     * @param {boolean} isVertical - whether vertical or not
	     * @returns {{
	     *      xAxis: ?{min: number, max: number},
	     *      yAxis: ?{min: number, max: number},
	     *      rightYAxis: ?{min: number, max: number},
	     *      legend: ?{min: number, max: number},
	     *      bar: ?{min: number, max: number}
	     * }}
	     * @private
	     */
	
	
	    ScaleDataModel.prototype.makeLimitMap = function makeLimitMap(seriesTypes, isVertical) {
	        var _this = this;
	
	        var scaleDataMap = this.scaleDataMap;
	
	        var limitMap = {};
	
	        if (scaleDataMap.xAxis) {
	            limitMap.xAxis = scaleDataMap.xAxis.limit;
	        }
	
	        if (scaleDataMap.yAxis) {
	            limitMap.yAxis = scaleDataMap.yAxis.limit;
	        }
	
	        if (scaleDataMap.rightYAxis) {
	            limitMap.rightYAxis = scaleDataMap.rightYAxis.limit;
	        }
	
	        if (scaleDataMap.legend) {
	            limitMap.legend = scaleDataMap.legend.limit;
	        }
	
	        seriesTypes.forEach(function (seriesType, index) {
	            limitMap[seriesType] = _this._findLimit(limitMap, index, isVertical);
	        });
	
	        return limitMap;
	    };
	
	    return ScaleDataModel;
	}();
	
	exports['default'] = ScaleDataModel;

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @fileoverview scaleMaker calculates the limit and step into values of processed data and returns it.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @auth NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *       FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _coordinateScaleCalculator = __webpack_require__(448);
	
	var _coordinateScaleCalculator2 = _interopRequireDefault(_coordinateScaleCalculator);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * scaleMaker calculates limit and step into values of processed data and returns it.
	 * @module scaleDataMaker
	 * @private */
	var scaleDataMaker = {
	    /**
	     * Make limit for diverging option.
	     * To balance diverging chart
	     * compare absolute value of min, max. and find larger one
	     * set min by making the value negative
	     * @param {{min: number, max: number}} limit limit
	     * @returns {{min: number, max: number}} changed limit
	     * @private
	     */
	    _makeLimitForDivergingOption: function _makeLimitForDivergingOption(limit) {
	        var newMax = Math.max(Math.abs(limit.min), Math.abs(limit.max));
	
	        return {
	            min: -newMax,
	            max: newMax
	        };
	    },
	
	    /**
	     * Adjust limit for bubble chart.
	     * @param {{min: number, max: number}} limit - limit
	     * @param {number} step - step;
	     * @param {{min: boolean, max: boolean}} isOverflowed - overflow Item map
	     * @returns {object} limit
	     * @private
	     */
	    _adjustLimitForOverflow: function _adjustLimitForOverflow(limit, step, isOverflowed) {
	        var min = limit.min,
	            max = limit.max;
	
	
	        if (isOverflowed.min) {
	            min = _calculator2['default'].subtract(min, step);
	        }
	
	        if (isOverflowed.max) {
	            max = _calculator2['default'].add(max, step);
	        }
	
	        return {
	            min: min,
	            max: max
	        };
	    },
	
	
	    /**
	     * millisecond map
	     */
	    millisecondMap: {
	        year: 31536000000,
	        month: 2678400000,
	        week: 604800000,
	        date: 86400000,
	        hour: 3600000,
	        minute: 60000,
	        second: 1000
	    },
	
	    /**
	     * millisecond types
	     */
	    millisecondTypes: ['year', 'month', 'week', 'date', 'hour', 'minute', 'second'],
	
	    /**
	     * Find date type.
	     * @param {{min: number, max: number}} dataLimit - data limit
	     * @param {number} count - data count
	     * @returns {string}
	     * @private
	     */
	    _findDateType: function _findDateType(dataLimit, count) {
	        var diff = dataLimit.max - dataLimit.min;
	        var millisecondTypes = this.millisecondTypes,
	            millisecondMap = this.millisecondMap;
	
	        var lastTypeIndex = millisecondTypes.length - 1;
	        var foundType = void 0;
	
	        if (diff) {
	            millisecondTypes.every(function (type, index) {
	                var millisecond = millisecondMap[type];
	                var dividedCount = Math.floor(diff / millisecond);
	                var foundIndex = void 0;
	
	                if (dividedCount) {
	                    foundIndex = index < lastTypeIndex && dividedCount < 2 && dividedCount < count ? index + 1 : index;
	                    foundType = millisecondTypes[foundIndex];
	                }
	
	                return !_tuiCodeSnippet2['default'].isExisty(foundIndex);
	            });
	        } else {
	            foundType = _const2['default'].DATE_TYPE_SECOND;
	        }
	
	        return foundType;
	    },
	
	
	    /**
	     * Make datetime information
	     * @param {{min: number, max: number}} dataLimit - data limit
	     * @param {number} count - data count
	     * @returns {{divisionNumber: number, minDate: number, dataLimit: {min: number, max: number}}}
	     * @private
	     */
	    _makeDatetimeInfo: function _makeDatetimeInfo(dataLimit, count) {
	        var dateType = this._findDateType(dataLimit, count);
	        var divisionNumber = this.millisecondMap[dateType];
	        var minDate = _calculator2['default'].divide(dataLimit.min, divisionNumber);
	        var maxDate = _calculator2['default'].divide(dataLimit.max, divisionNumber);
	        var max = maxDate - minDate;
	
	        return {
	            divisionNumber: divisionNumber,
	            minDate: minDate,
	            dataLimit: {
	                min: 0,
	                max: max
	            }
	        };
	    },
	
	
	    /**
	     * Restore scale to datetime type.
	     * @param {{scale: number, limit:{min: number, max: number}}} scale - scale
	     * @param {number} minDate - minimum date
	     * @param {number} divisionNumber - division number
	     * @returns {{step: number, limit: {min: number, max: number}}}
	     * @private
	     */
	    _restoreScaleToDatetimeType: function _restoreScaleToDatetimeType(scale, minDate, divisionNumber) {
	        var limit = scale.limit;
	
	
	        scale.step = _calculator2['default'].multiply(scale.step, divisionNumber);
	        limit.min = _calculator2['default'].multiply(_calculator2['default'].add(limit.min, minDate), divisionNumber);
	        limit.max = _calculator2['default'].multiply(_calculator2['default'].add(limit.max, minDate), divisionNumber);
	
	        return scale;
	    },
	
	
	    /**
	     * Get limit values safely by limit values are both Zero then set max value to 10 temporary.
	     * @param {Array} baseValues base values
	     * @returns {{min: number, max: number}}
	     */
	    _getLimitSafely: function _getLimitSafely(baseValues) {
	        var limit = {
	            min: _arrayUtil2['default'].min(baseValues),
	            max: _arrayUtil2['default'].max(baseValues)
	        };
	
	        if (baseValues.length === 1) {
	            var _baseValues = _slicedToArray(baseValues, 1),
	                firstValue = _baseValues[0];
	
	            if (firstValue > 0) {
	                limit.min = 0;
	            } else if (firstValue === 0) {
	                limit.max = 10;
	            } else {
	                limit.max = 0;
	            }
	        } else if (limit.min === 0 && limit.max === 0) {
	            limit.max = 10;
	        } else if (limit.min === limit.max) {
	            limit.min -= limit.min / 10;
	            limit.max += limit.max / 10;
	        }
	
	        return limit;
	    },
	
	
	    /**
	     * Calculate date time scale.
	     * @param {Array.<number>} baseValues - base values for calculating scale data
	     * @param {number} baseSize - base size(width or height) for calculating scale data
	     * @param {boolean} isDiverging - is diverging or not
	     * @returns {{limit: {min: number, max: number}, step: number}}
	     * @private
	     */
	    _calculateDatetimeScale: function _calculateDatetimeScale(baseValues, baseSize, isDiverging) {
	        var datetimeInfo = this._makeDatetimeInfo(this._getLimitSafely(baseValues), baseValues.length);
	        var limit = datetimeInfo.dataLimit;
	
	        if (isDiverging) {
	            limit = this._makeLimitForDivergingOption(limit);
	        }
	
	        var scale = (0, _coordinateScaleCalculator2['default'])({
	            min: limit.min,
	            max: limit.max,
	            offsetSize: baseSize,
	            minimumStepSize: 1
	        });
	
	        scale = this._restoreScaleToDatetimeType(scale, datetimeInfo.minDate, datetimeInfo.divisionNumber);
	
	        return scale;
	    },
	
	
	    /**
	     * Calculate percent stackType scale.
	     * @param {Array.<number>} baseValues - base values
	     * @param {boolean} isDiverging - is diverging or not
	     * @returns {{limit: {min:number, max:number}, step: number}}
	     * @private
	     */
	    _calculatePercentStackedScale: function _calculatePercentStackedScale(baseValues, isDiverging) {
	        var scale = void 0;
	
	        if (_calculator2['default'].sumMinusValues(baseValues) === 0) {
	            scale = _const2['default'].PERCENT_STACKED_AXIS_SCALE;
	        } else if (_calculator2['default'].sumPlusValues(baseValues) === 0) {
	            scale = _const2['default'].MINUS_PERCENT_STACKED_AXIS_SCALE;
	        } else if (isDiverging) {
	            scale = _const2['default'].DIVERGING_PERCENT_STACKED_AXIS_SCALE;
	        } else {
	            scale = _const2['default'].DUAL_PERCENT_STACKED_AXIS_SCALE;
	        }
	
	        return scale;
	    },
	
	
	    /**
	     * Calculate coordinate scale.
	     * @param {object} makeScaleInfos - calculate scale infos
	     *     @param {Array.<number>} makeScaleInfos.baseValues - base values
	     *     @param {number} makeScaleInfos.baseSize - base size(width or height) for calculating scale data
	     *     @param {object} makeScaleInfos.overflowItem - overflow item
	     *     @param {boolean} makeScaleInfos.isDiverging - is diverging or not
	     *     @param {strint} makeScaleInfos.chartType - chartType
	     *     @param {object} makeScaleInfos.options - scale options
	     *         @param {{min: ?number, max: ?number}} makeScaleInfos.options.limit - limit options
	     * @returns {{limit: {min:number, max:number}, step: number}}
	     * @private
	     */
	    _calculateCoordinateScale: function _calculateCoordinateScale(makeScaleInfos) {
	        var _makeScaleInfos$optio = makeScaleInfos.options,
	            _makeScaleInfos$optio2 = _makeScaleInfos$optio.limitOption,
	            limitOption = _makeScaleInfos$optio2 === undefined ? {} : _makeScaleInfos$optio2,
	            useSpectrumLegend = _makeScaleInfos$optio.useSpectrumLegend,
	            baseSize = makeScaleInfos.baseSize,
	            overflowItem = makeScaleInfos.overflowItem,
	            chartType = makeScaleInfos.chartType;
	
	        var limit = this._getLimitSafely(makeScaleInfos.baseValues);
	        var hasMinOption = _tuiCodeSnippet2['default'].isExisty(limitOption.min);
	        var hasMaxOption = _tuiCodeSnippet2['default'].isExisty(limitOption.max);
	        var min = limit.min,
	            max = limit.max;
	
	        var isOverflowed = void 0;
	        var stepCount = makeScaleInfos.options.stepCount;
	
	
	        if (hasMinOption) {
	            min = limitOption.min;
	
	            stepCount = null;
	        }
	
	        if (hasMaxOption) {
	            max = limitOption.max;
	
	            stepCount = null;
	        }
	
	        var scaleData = (0, _coordinateScaleCalculator2['default'])({
	            min: min,
	            max: max,
	            stepCount: stepCount,
	            offsetSize: baseSize
	        });
	
	        if (!useSpectrumLegend) {
	            isOverflowed = this._isOverflowed(overflowItem, scaleData, limit, hasMinOption, hasMaxOption);
	        }
	
	        if (isOverflowed && !_predicate2['default'].isMapTypeChart(chartType)) {
	            scaleData.limit = this._adjustLimitForOverflow(scaleData.limit, scaleData.step, isOverflowed);
	        }
	
	        if (makeScaleInfos.isDiverging) {
	            scaleData.limit = this._makeLimitForDivergingOption(scaleData.limit);
	        }
	
	        return scaleData;
	    },
	    _isOverflowed: function _isOverflowed(overflowItem, scaleData, limit, hasMinOption, hasMaxOption) {
	        var isBubbleMinOverflowed = !!(overflowItem && overflowItem.minItem);
	        var isBubbleMaxOverflowed = !!(overflowItem && overflowItem.maxItem);
	        var scaleDataLimit = scaleData.limit;
	        var isOverflowedMin = isBubbleMinOverflowed || !hasMinOption && scaleDataLimit.min === limit.min && scaleDataLimit.min !== 0;
	        var isOverflowedMax = isBubbleMaxOverflowed || !hasMaxOption && scaleDataLimit.max === limit.max && scaleDataLimit.max !== 0;
	
	        if (!isOverflowedMin && !isOverflowedMax) {
	            return null;
	        }
	
	        return {
	            min: isOverflowedMin,
	            max: isOverflowedMax
	        };
	    },
	
	
	    /**
	     * Make scale data.
	     * @param {Array.<number>} baseValues - base values for calculating scale data
	     * @param {number} baseSize - base size(width or height) for calculating scale data
	     * @param {string} chartType - chart type
	     * @param {{
	     *      type: string,
	     *      stackType: string,
	     *      diverging: boolean,
	     *      isVertical: boolean,
	     *      limitOption: ?{min: ?number, max: ?number},
	     *      tickCounts: ?Array.<number>
	     * }} options - options
	     * @returns {{limit: {min:number, max:number}, step: number, stepCount: number}}
	     */
	    makeScaleData: function makeScaleData(baseValues, baseSize, chartType, options) {
	        var scaleData = void 0;
	        var isDiverging = _predicate2['default'].isDivergingChart(chartType, options.diverging);
	        var overflowItem = options.overflowItem;
	
	
	        if (_predicate2['default'].isPercentStackChart(chartType, options.stackType)) {
	            scaleData = this._calculatePercentStackedScale(baseValues, isDiverging);
	        } else if (_predicate2['default'].isDatetimeType(options.type)) {
	            scaleData = this._calculateDatetimeScale(baseValues, baseSize, isDiverging);
	        } else {
	            if (_predicate2['default'].isRadialChart(chartType)) {
	                options.stepCount = Math.floor(baseSize / 100);
	            }
	
	            scaleData = this._calculateCoordinateScale({
	                baseValues: baseValues,
	                baseSize: baseSize,
	                overflowItem: overflowItem,
	                isDiverging: isDiverging,
	                chartType: chartType,
	                options: options
	            });
	        }
	
	        return scaleData;
	    }
	};
	
	exports['default'] = scaleDataMaker;

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * The reference values to normailze value
	 * @private
	 * @type {Array.<number>}
	 */
	var SNAP_VALUES = [1, 2, 5, 10];
	
	/**
	 * Default step pixel size
	 * @private
	 * @type {number}
	 */
	/**
	 * @fileoverview Implement function that calculate coordinate scale data
	 * @author Sungho Kim
	 */
	
	var DEFAULT_PIXELS_PER_STEP = 88;
	
	/**
	 * Get digits of number
	 * @param {number} number number
	 * @returns {number}
	 * @private
	 * @example
	 * this.getDigits(2145) == 1000
	 */
	function getDigits(number) {
	    var logNumberDividedLN10 = number === 0 ? 1 : Math.log(Math.abs(number)) / Math.LN10;
	
	    return Math.pow(10, Math.floor(logNumberDividedLN10));
	}
	
	/**
	 * Select value within SNAP_VALUES that most close with given value
	 * @param {number} number number
	 * @private
	 * @returns {number}
	 */
	function getSnappedNumber(number) {
	    var snapNumber = void 0;
	
	    for (var i = 0, t = SNAP_VALUES.length; i < t; i += 1) {
	        snapNumber = SNAP_VALUES[i];
	        var guideValue = (snapNumber + (SNAP_VALUES[i + 1] || snapNumber)) / 2;
	
	        if (number <= guideValue) {
	            break;
	        }
	    }
	
	    return snapNumber;
	}
	
	/**
	 * Get normalized step value
	 * @param {number} step step
	 * @private
	 * @returns {number}
	 */
	function getNormalizedStep(step) {
	    var placeNumber = getDigits(step);
	    var simplifiedStepValue = step / placeNumber;
	
	    return getSnappedNumber(simplifiedStepValue) * placeNumber;
	}
	
	/**
	 * Get normailzed limit values
	 * @param {number} min min
	 * @param {number} max max
	 * @param {number} step step
	 * @param {number} [showLabel] showLabel option
	 * @private
	 * @returns {{
	 *     min: number,
	 *     max: number
	 * }}
	 * max = 155 and step = 10 ---> max = 160
	 */
	function getNormalizedLimit(min, max, step, showLabel) {
	    var minNumber = Math.min(getDigits(max), getDigits(step));
	    var placeNumber = minNumber > 1 ? 1 : 1 / minNumber;
	    var fixedStep = step * placeNumber;
	    var noExtraMax = max;
	    var isNotEnoughSize = false;
	
	    // ceil max value step digits
	    max = Math.ceil(max * placeNumber / fixedStep) * fixedStep / placeNumber;
	    isNotEnoughSize = fixedStep / 2 > max - noExtraMax;
	
	    if (showLabel && isNotEnoughSize) {
	        max += fixedStep;
	    }
	
	    if (min > step) {
	        // floor min value to multiples of step
	        min = Math.floor(min * placeNumber / fixedStep) * fixedStep / placeNumber;
	    } else if (min < 0) {
	        min = -(Math.ceil(Math.abs(min) * placeNumber / fixedStep) * fixedStep) / placeNumber;
	    } else {
	        // 0 when min value is positive and smaller than step
	        min = 0;
	    }
	
	    return {
	        min: min,
	        max: max
	    };
	}
	
	/**
	 * Get normalized step count for floating point calculate error
	 * @param {number} limitSize limit size of chart min max distance
	 * @param {number} step step distance
	 * @returns {number}
	 * @ignore
	 */
	function getNormalizedStepCount(limitSize, step) {
	    var multiplier = 1 / Math.min(getDigits(limitSize), getDigits(step));
	
	    return Math.ceil(limitSize * multiplier / (step * multiplier));
	}
	
	/**
	 * Get normalized scale data
	 * @param {object} scale scale
	 * @param {number} [showLabel] showLabel option
	 * @private
	 * @returns {object}
	 * @ignore
	 */
	function getNormalizedScale(scale, showLabel) {
	    var step = getNormalizedStep(scale.step);
	    var edge = getNormalizedLimit(scale.limit.min, scale.limit.max, step, showLabel);
	    var limitSize = Math.abs(edge.max - edge.min);
	    var stepCount = getNormalizedStepCount(limitSize, step);
	
	    return {
	        limit: {
	            min: edge.min,
	            max: edge.max
	        },
	        step: step,
	        stepCount: stepCount
	    };
	}
	
	/**
	 * Get rough(not normalized) scale data
	 * @param {number} min min
	 * @param {number} max max
	 * @param {number} offsetSize offset size
	 * @param {number} stepCount step count
	 * @param {object} [minimumStepSize] for ensure minimum step size
	 * @private
	 * @returns {object} scale data
	 */
	function getRoughScale(min, max, offsetSize, stepCount, minimumStepSize) {
	    var limitSize = Math.abs(max - min);
	    var valuePerPixel = limitSize / offsetSize;
	
	    if (!stepCount) {
	        stepCount = Math.ceil(offsetSize / DEFAULT_PIXELS_PER_STEP);
	    }
	
	    var pixelsPerStep = offsetSize / stepCount;
	    var step = valuePerPixel * pixelsPerStep;
	
	    if (_tuiCodeSnippet2['default'].isNumber(minimumStepSize) && step < minimumStepSize) {
	        step = minimumStepSize;
	        stepCount = limitSize / step;
	    }
	
	    return {
	        limit: {
	            min: min,
	            max: max
	        },
	        step: step,
	        stepCount: stepCount
	    };
	}
	
	/**
	 * Calculate coordinate scale
	 * @param {object} options optionsPP
	 * @param {object} options.min min value
	 * @param {object} options.max max value
	 * @param {object} options.offsetSize offset pixel size of screen that needs scale
	 * @param {object} [options.stepCount] if need fixed step count
	 * @param {object} [options.minimumStepSize] for ensure minimum step size
	 * @returns {object}
	 * @ignore
	 */
	function coordinateScaleCalculator(options) {
	    var min = options.min,
	        max = options.max,
	        offsetSize = options.offsetSize,
	        stepCount = options.stepCount,
	        minimumStepSize = options.minimumStepSize,
	        showLabel = options.showLabel;
	
	    var scale = getRoughScale(min, max, offsetSize, stepCount, minimumStepSize);
	
	    scale = getNormalizedScale(scale, showLabel);
	
	    return scale;
	}
	
	exports['default'] = coordinateScaleCalculator;

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Format scale data labels
	 * @module scaleLabelFormatter
	 * @private
	 */
	/**
	 * @fileoverview scaleMaker calculates the limit and step into values of processed data and returns it.
	 * @author NHN.
	 *       FE Development Lab <dl_javascript@nhn.com>
	 */
	
	var scaleLabelFormatter = {
	    /**
	     * Get functions for formatting value.
	     * @param {string} chartType - chart type
	     * @param {string} stackType - stack type
	     * @param {?Array.<function>} formatFunctions - format functions
	     * @returns {Array.<function>}
	     * @private
	     */
	    _getFormatFunctions: function _getFormatFunctions(chartType, stackType, formatFunctions) {
	        if (_predicate2['default'].isPercentStackChart(chartType, stackType)) {
	            formatFunctions = [function (value) {
	                return value + '%';
	            }];
	        }
	
	        return formatFunctions;
	    },
	
	
	    /**
	     * Create scale values.
	     * @param {{limit: {min: number, max: number}, step: number}} scale - scale data
	     * @param {string} chartType - chart type
	     * @param {boolean} diverging - diverging option
	     * @returns {Array.<number>}
	     * @private
	     */
	    _createScaleValues: function _createScaleValues(scale, chartType, diverging) {
	        var values = _calculator2['default'].makeLabelsFromLimit(scale.limit, scale.step);
	
	        return _predicate2['default'].isDivergingChart(chartType, diverging) ? _tuiCodeSnippet2['default'].map(values, Math.abs) : values;
	    },
	
	
	    /**
	     * Create formatted scale values.
	     * @param {{limit: {min: number, max: number}, step: number}} scale - scale data
	     * @param {{
	     *      chartType: string,
	     *      areaType: string,
	     *      valueType: string
	     * }} typeMap - type map
	     * @param {{
	     *      type: string,
	     *      stackType: string,
	     *      diverging: boolean,
	     *      dateFormat: ?string
	     * }} options - options
	     * @param {?Array.<function>} formatFunctions - format functions
	     * @returns {Array.<string|number>|*}
	     */
	    createFormattedLabels: function createFormattedLabels(scale, typeMap, options, formatFunctions) {
	        var chartType = typeMap.chartType,
	            areaType = typeMap.areaType,
	            valueType = typeMap.valueType;
	        var diverging = options.diverging,
	            type = options.type,
	            dateFormat = options.dateFormat,
	            stackType = options.stackType;
	
	        var values = this._createScaleValues(scale, chartType, diverging);
	        var formattedValues = void 0;
	
	        if (_predicate2['default'].isDatetimeType(type)) {
	            formattedValues = _renderUtil2['default'].formatDates(values, dateFormat);
	        } else {
	            formatFunctions = this._getFormatFunctions(chartType, stackType, formatFunctions);
	            formattedValues = _renderUtil2['default'].formatValues(values, formatFunctions, {
	                chartType: chartType,
	                areaType: areaType,
	                valueType: valueType
	            });
	        }
	
	        return formattedValues;
	    }
	};
	
	exports['default'] = scaleLabelFormatter;

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @fileoverview Axis Data Maker
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _geometric = __webpack_require__(376);
	
	var _geometric2 = _interopRequireDefault(_geometric);
	
	var _calculator = __webpack_require__(351);
	
	var _calculator2 = _interopRequireDefault(_calculator);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var AUTO_INTERVAL_MIN_WIDTH = 90;
	var AUTO_INTERVAL_MAX_WIDTH = 121;
	var AUTO_INTERVAL_RANGE_STEP = 5;
	
	/**
	 * Axis data maker.
	 * @module axisDataMaker
	 * @private */
	var axisDataMaker = {
	    /**
	     * Makes labels by labelInterval option.
	     * @param {Array.<string>} labels - labels
	     * @param {number} labelInterval - label interval option
	     * @param {number} [addedDataCount] - added data count
	     * @returns {Array.<string>} labels
	     * @private
	     */
	    _makeLabelsByIntervalOption: function _makeLabelsByIntervalOption(labels, labelInterval, addedDataCount) {
	        addedDataCount = addedDataCount || 0;
	        labels = labels.map(function (label, index) {
	            if ((index + addedDataCount) % labelInterval !== 0) {
	                label = _const2['default'].EMPTY_AXIS_LABEL;
	            }
	
	            return label;
	        });
	
	        return labels;
	    },
	
	
	    /**
	     * Make axis data for label type.
	     * @memberOf module:axisDataMaker
	     * @param {object} params - parameters
	     *      @param {Array.<string>} params.labels - chart labels
	     *      @param {boolean} params.isVertical - whether vertical or not
	     *      @param {boolean} params.aligned - whether align or not
	     *      @param {?boolean} params.addedDataCount - added data count
	     * @returns {{
	     *      labels: Array.<string>,
	     *      tickCount: number,
	     *      validTickCount: number,
	     *      isLabelAxis: boolean,
	     *      options: object,
	     *      isVertical: boolean,
	     *      isPositionRight: boolean,
	     *      aligned: boolean
	     * }}
	     */
	    makeLabelAxisData: function makeLabelAxisData(params) {
	        var _params$options = params.options,
	            options = _params$options === undefined ? {} : _params$options;
	
	        var tickCount = params.labels.length;
	        var labels = params.labels;
	
	
	        if (_predicate2['default'].isValidLabelInterval(options.labelInterval, options.tickInterval) && params.labels.length > options.labelInterval) {
	            labels = this._makeLabelsByIntervalOption(params.labels, options.labelInterval, params.addedDataCount);
	        }
	
	        if (_predicate2['default'].isDatetimeType(options.type)) {
	            labels = _renderUtil2['default'].formatDates(labels, options.dateFormat);
	        }
	
	        if (!params.aligned) {
	            tickCount += 1;
	        }
	
	        return {
	            labels: labels,
	            tickCount: tickCount,
	            validTickCount: tickCount,
	            isLabelAxis: true,
	            options: options,
	            isVertical: !!params.isVertical,
	            isPositionRight: !!params.isPositionRight,
	            aligned: !!params.aligned
	        };
	    },
	
	
	    /**
	     * Make data for value type axis.
	     * @memberOf module:axisDataMaker
	     * @param {object} params parameters
	     *      @param {AxisScaleMaker} params.axisScaleMaker chart values
	     *      @param {boolean} params.isVertical whether vertical or not
	     * @returns {{
	     *      labels: Array.<string>,
	     *      tickCount: number,
	     *      validTickCount: number,
	     *      isLabelAxis: boolean,
	     *      limit: {min: number, max: number},
	     *      isVertical: boolean
	     * }} axis data
	     */
	    makeValueAxisData: function makeValueAxisData(params) {
	        var labels = params.labels,
	            tickCount = params.tickCount,
	            limit = params.limit;
	        var step = params.step,
	            options = params.options,
	            isVertical = params.isVertical,
	            isPositionRight = params.isPositionRight,
	            aligned = params.aligned;
	
	
	        var axisData = {
	            labels: labels,
	            tickCount: tickCount,
	            limit: limit,
	            step: step,
	            options: options,
	            validTickCount: tickCount,
	            dataMin: limit.min,
	            distance: limit.max - limit.min,
	            isVertical: !!isVertical,
	            isPositionRight: !!isPositionRight,
	            aligned: !!aligned
	        };
	
	        return axisData;
	    },
	
	
	    /**
	     * Make additional data for coordinate line type chart.
	     * @param {Array.<string>} labels - labels
	     * @param {Array.<number>} values - values
	     * @param {{min: number, max: number}} limit - limit
	     * @param {number} step - step
	     * @param {number} tickCount = tickCount
	     * @returns {{
	     *      labels: Array.<string>,
	     *      tickCount: number,
	     *      validTickCount: number,
	     *      limit: {min: number, max: number},
	     *      positionRatio: number,
	     *      sizeRatio: number
	     * }}
	     */
	    makeAdditionalDataForCoordinateLineType: function makeAdditionalDataForCoordinateLineType(labels, values, limit, step, tickCount) {
	        var min = _arrayUtil2['default'].min(values);
	        var max = _arrayUtil2['default'].max(values);
	        var distance = max - min;
	        var positionRatio = 0;
	        var sizeRatio = 1;
	
	        if (distance) {
	            if (limit.min < min) {
	                limit.min += step;
	                positionRatio = (limit.min - min) / distance;
	                sizeRatio -= positionRatio;
	                tickCount -= 1;
	                labels.shift();
	            }
	
	            if (limit.max > max) {
	                limit.max -= step;
	                sizeRatio -= (max - limit.max) / distance;
	                tickCount -= 1;
	                labels.pop();
	            }
	        }
	
	        return {
	            labels: labels,
	            tickCount: tickCount,
	            limit: limit,
	            distance: distance,
	            positionRatio: positionRatio,
	            sizeRatio: sizeRatio,
	            validTickCount: tickCount,
	            dataMin: min
	        };
	    },
	
	
	    /**
	     * Make adjusting tick interval information.
	     * @param {number} beforeBlockCount - before block count
	     * @param {number} seriesWidth - width of series area
	     * @param {number} blockSize - block size
	     * @returns {null | {blockCount: number, beforeRemainBlockCount: number, interval: number}}
	     * @private
	     */
	    _makeAdjustingIntervalInfo: function _makeAdjustingIntervalInfo(beforeBlockCount, seriesWidth, blockSize) {
	        var remainCount = void 0;
	        var newBlockCount = parseInt(seriesWidth / blockSize, 10);
	        var intervalInfo = null;
	        // interval : number of previous blocks in a new block(spaces between tick and tick)
	        var interval = parseInt(beforeBlockCount / newBlockCount, 10);
	
	        if (interval > 1) {
	            // remainCount : remaining block count after filling new blocks
	            // | | | | | | | | | | | |  - previous block interval
	            // |     |     |     |      - new block interval
	            //                   |*|*|  - remaining block
	            remainCount = beforeBlockCount - interval * newBlockCount;
	
	            if (remainCount >= interval) {
	                newBlockCount += parseInt(remainCount / interval, 0);
	                remainCount = remainCount % interval;
	            }
	
	            intervalInfo = {
	                blockCount: newBlockCount,
	                beforeRemainBlockCount: remainCount,
	                interval: interval
	            };
	        }
	
	        return intervalInfo;
	    },
	
	
	    /**
	     * Make candidate for adjusting tick interval.
	     * @param {number} beforeBlockCount - before block count
	     * @param {number} seriesWidth - width of series area
	     * @returns {Array.<{newBlockCount: number, remainBlockCount: number, interval: number}>}
	     * @private
	     */
	    _makeCandidatesForAdjustingInterval: function _makeCandidatesForAdjustingInterval(beforeBlockCount, seriesWidth) {
	        var _this = this;
	
	        var candidates = [];
	        var candidateInterval = _calculator2['default'].divisors(beforeBlockCount);
	        candidateInterval.forEach(function (interval) {
	            var intervalWidth = interval / beforeBlockCount * seriesWidth;
	            if (intervalWidth >= AUTO_INTERVAL_MIN_WIDTH && intervalWidth <= AUTO_INTERVAL_MAX_WIDTH) {
	                candidates.push({
	                    interval: interval,
	                    blockCount: beforeBlockCount / interval,
	                    beforeRemainBlockCount: 0
	                });
	            }
	        });
	
	        if (candidates.length === 0) {
	            var blockSizeRange = _tuiCodeSnippet2['default'].range(AUTO_INTERVAL_MIN_WIDTH, AUTO_INTERVAL_MAX_WIDTH, AUTO_INTERVAL_RANGE_STEP);
	            candidates = blockSizeRange.map(function (blockSize) {
	                return _this._makeAdjustingIntervalInfo(beforeBlockCount, seriesWidth, blockSize);
	            });
	        }
	
	        return candidates.filter(function (info) {
	            return !!info;
	        });
	    },
	
	
	    /**
	     * Calculate adjusting interval information for auto tick interval option.
	     * @param {number} curBlockCount - current block count
	     * @param {number} seriesWidth - series width
	     * @returns {{newBlockCount: number, remainBlockCount: number, interval: number}}
	     * @private
	     */
	    _calculateAdjustingIntervalInfo: function _calculateAdjustingIntervalInfo(curBlockCount, seriesWidth) {
	        var candidates = this._makeCandidatesForAdjustingInterval(curBlockCount, seriesWidth);
	        var intervalInfo = null;
	
	        if (candidates.length) {
	            intervalInfo = _arrayUtil2['default'].max(candidates, function (candidate) {
	                return candidate.blockCount;
	            });
	        }
	
	        return intervalInfo;
	    },
	
	
	    /**
	     * Make filtered labels by interval.
	     * @param {Array.<string>} labels - labels
	     * @param {number} startIndex - start index
	     * @param {number} interval - interval
	     * @returns {Array.<string>}
	     * @private
	     */
	    _makeFilteredLabelsByInterval: function _makeFilteredLabelsByInterval(labels, startIndex, interval) {
	        return labels.slice(startIndex).filter(function (label, index) {
	            return index % interval === 0;
	        });
	    },
	
	
	    /**
	     * Update label type axisData for auto tick interval option.
	     * @param {object} axisData - axisData
	     * @param {number} seriesWidth - series width
	     * @param {?number} addedDataCount - added data count
	     * @param {?boolean} addingDataMode - whether adding data mode or not
	     */
	    updateLabelAxisDataForAutoTickInterval: function updateLabelAxisDataForAutoTickInterval(axisData, seriesWidth, addedDataCount, addingDataMode) {
	        if (addingDataMode) {
	            axisData.tickCount -= 1;
	            axisData.labels.pop();
	        }
	
	        var beforeBlockCount = axisData.tickCount - 1;
	        var intervalInfo = this._calculateAdjustingIntervalInfo(beforeBlockCount, seriesWidth);
	
	        if (!intervalInfo) {
	            return;
	        }
	
	        // startIndex: (remaing block count / 2) - current moved tick index
	        // |     |     |     |*|*|*|    - * remaing block
	        // |*|*|O    |     |     |*|    - tick is not moved (O startIndex = 2)
	        // |*|O    |     |     |*|*|    - tick moved 1 (O startIndex = 1)
	        // startIndex = Math.round(beforeRemainBlockCount / 2) - (addedDataCount % interval);
	        // if (startIndex < 0) {
	        //     startIndex += interval;
	        // }
	        // Fixed to 0 due to issues. (https://github.com/nhn/tui.chart/issues/56)
	
	        axisData.eventTickCount = axisData.tickCount;
	
	        var adjustingBlockCount = intervalInfo.blockCount;
	        var beforeRemainBlockCount = intervalInfo.beforeRemainBlockCount,
	            interval = intervalInfo.interval;
	
	        var tickCount = adjustingBlockCount + 1;
	        var startIndex = 0;
	        var lastLabelValue = axisData.labels[axisData.labels.length - 1];
	        axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);
	
	        if (beforeRemainBlockCount > 0) {
	            axisData.labels.push(lastLabelValue);
	        }
	
	        _tuiCodeSnippet2['default'].extend(axisData, {
	            startIndex: startIndex,
	            tickCount: tickCount,
	            interval: interval,
	            positionRatio: startIndex / beforeBlockCount,
	            sizeRatio: 1 - beforeRemainBlockCount / beforeBlockCount,
	            remainLastBlockInterval: beforeRemainBlockCount
	        });
	    },
	
	
	    /**
	     * Update label type axisData for stacking dynamic data.
	     * @param {object} axisData - axis data
	     * @param {object} prevUpdatedData - previous updated axisData
	     * @param {number} firstTickCount - calculated first tick count
	     */
	    updateLabelAxisDataForStackingDynamicData: function updateLabelAxisDataForStackingDynamicData(axisData, prevUpdatedData, firstTickCount) {
	        var interval = prevUpdatedData.interval;
	        var startIndex = prevUpdatedData.startIndex;
	
	        var beforeBlockCount = axisData.tickCount - 1;
	        var firstBlockCount = firstTickCount ? firstTickCount - 1 : 0;
	        var newBlockCount = beforeBlockCount / interval;
	
	        // twice interval, if new block count is greater than twice of new block count
	        if (firstBlockCount && firstBlockCount * 2 <= newBlockCount) {
	            interval *= 2;
	        }
	
	        axisData.labels = this._makeFilteredLabelsByInterval(axisData.labels, startIndex, interval);
	        newBlockCount = axisData.labels.length - 1;
	        var beforeRemainBlockCount = beforeBlockCount - interval * newBlockCount;
	
	        _tuiCodeSnippet2['default'].extend(axisData, {
	            startIndex: startIndex,
	            interval: interval,
	            eventTickCount: axisData.tickCount,
	            tickCount: axisData.labels.length,
	            positionRatio: startIndex / beforeBlockCount,
	            sizeRatio: 1 - beforeRemainBlockCount / beforeBlockCount
	        });
	    },
	
	
	    /**
	     * Calculate width for label area for x axis.
	     * @param {boolean} isLabelAxis - whether label type axis or not
	     * @param {number} seriesWidth - series width
	     * @param {number} labelCount - label count
	     * @returns {number} limit width
	     * @private
	     */
	    _calculateXAxisLabelAreaWidth: function _calculateXAxisLabelAreaWidth(isLabelAxis, seriesWidth, labelCount) {
	        if (!isLabelAxis) {
	            labelCount -= 1;
	        }
	
	        return seriesWidth / labelCount;
	    },
	
	
	    /**
	     * Create multiline label.
	     * @param {string} label - label
	     * @param {number} limitWidth - limit width
	     * @param {object} theme - label theme
	     * @returns {string}
	     * @private
	     */
	    _createMultilineLabel: function _createMultilineLabel(label, limitWidth, theme) {
	        var words = String(label).split(/\s+/);
	        var lines = [];
	
	        var _words = _slicedToArray(words, 1),
	            lineWords = _words[0];
	
	        words.slice(1).forEach(function (word) {
	            var width = _renderUtil2['default'].getRenderedLabelWidth(lineWords + ' ' + word, theme);
	
	            if (width > limitWidth) {
	                lines.push(lineWords);
	                lineWords = word;
	            } else {
	                lineWords += ' ' + word;
	            }
	        });
	
	        if (lineWords) {
	            lines.push(lineWords);
	        }
	
	        return lines.join('<br>');
	    },
	
	
	    /**
	     * Create multiline labels.
	     * @param {Array.<string>} labels - labels
	     * @param {object} labelTheme - theme for label
	     * @param {number} labelAreaWidth - label area width
	     * @returns {Array}
	     * @private
	     */
	    _createMultilineLabels: function _createMultilineLabels(labels, labelTheme, labelAreaWidth) {
	        var _createMultilineLabel = this._createMultilineLabel;
	
	
	        return labels.map(function (label) {
	            return _createMultilineLabel(label, labelAreaWidth, labelTheme);
	        });
	    },
	
	
	    /**
	     * Calculate multiline height.
	     * @param {Array.string} multilineLabels - multiline labels
	     * @param {object} labelTheme - theme for label
	     * @param {number} labelAreaWidth - width for label area
	     * @returns {number}
	     * @private
	     */
	    _calculateMultilineHeight: function _calculateMultilineHeight(multilineLabels, labelTheme, labelAreaWidth) {
	        return _renderUtil2['default'].getRenderedLabelsMaxHeight(multilineLabels, Object.assign({
	            cssText: 'line-height:1.2;width:' + labelAreaWidth + 'px'
	        }, labelTheme));
	    },
	
	
	    /**
	     * Calculate height difference between origin category and multiline category.
	     * @param {Array.<string>} labels - labels
	     * @param {Array.<string>} validLabelCount - valid label count
	     * @param {object} labelTheme - theme for label
	     * @param {boolean} isLabelAxis - whether label type axis or not
	     * @param {{series: {width: number}, yAxis: {width: number}}} dimensionMap - dimension map
	     * @returns {number}
	     */
	    makeAdditionalDataForMultilineLabels: function makeAdditionalDataForMultilineLabels(labels, validLabelCount, labelTheme, isLabelAxis, dimensionMap) {
	        var seriesWidth = dimensionMap.series.width;
	        var labelAreaWidth = this._calculateXAxisLabelAreaWidth(isLabelAxis, seriesWidth, validLabelCount);
	        var multilineLabels = this._createMultilineLabels(labels, labelTheme, seriesWidth);
	        var multilineHeight = this._calculateMultilineHeight(multilineLabels, labelTheme, labelAreaWidth);
	        var labelHeight = _renderUtil2['default'].getRenderedLabelsMaxHeight(labels, labelTheme);
	
	        return {
	            multilineLabels: multilineLabels,
	            overflowHeight: multilineHeight - labelHeight,
	            overflowLeft: labelAreaWidth / 2 - dimensionMap.yAxis.width
	        };
	    },
	
	
	    /**
	     * Find rotation degree.
	     * @param {number} labelAreaWidth - limit width
	     * @param {number} labelWidth - label width
	     * @param {number} labelHeight - label height
	     * @returns {number}
	     * @private
	     */
	    _findRotationDegree: function _findRotationDegree(labelAreaWidth, labelWidth, labelHeight) {
	        var foundDegree = null;
	
	        _const2['default'].DEGREE_CANDIDATES.every(function (degree) {
	            var compareWidth = _geometric2['default'].calculateRotatedWidth(degree, labelWidth, labelHeight);
	            foundDegree = degree;
	
	            if (compareWidth <= labelAreaWidth) {
	                return false;
	            }
	
	            return true;
	        });
	
	        return foundDegree;
	    },
	
	
	    /**
	     * Calculate rotated width.
	     * @param {number} degree - degree for label of x axis
	     * @param {string} firstLabel - first label
	     * @param {number} labelHeight - labelHeight
	     * @param {object} labelTheme - theme for label
	     * @returns {number}
	     * @private
	     */
	    _calculateRotatedWidth: function _calculateRotatedWidth(degree, firstLabel, labelHeight, labelTheme) {
	        var firstLabelWidth = _renderUtil2['default'].getRenderedLabelWidth(firstLabel, labelTheme);
	        var newLabelWidth = _geometric2['default'].calculateRotatedWidth(degree, firstLabelWidth, labelHeight);
	
	        // when checking overflow, calculation should be based on right top angle
	        newLabelWidth -= _geometric2['default'].calculateAdjacent(_const2['default'].ANGLE_90 - degree, labelHeight / 2);
	
	        return newLabelWidth;
	    },
	
	
	    /**
	     * Calculate limit width for label
	     * @param {number} yAxisWidth - y axis width
	     * @param {boolean} isLabelAxis - aligned tick and label
	     * @param {number} labelAreaWidth - width for label area
	     * @returns {number}
	     * @private
	     */
	    _calculateLimitWidth: function _calculateLimitWidth(yAxisWidth, isLabelAxis, labelAreaWidth) {
	        var limitWidth = yAxisWidth;
	
	        if (isLabelAxis) {
	            limitWidth += labelAreaWidth / 2;
	        }
	
	        return limitWidth;
	    },
	
	
	    /**
	     * Make additional data for rotated labels.
	     * The label size is larger than the specified area, creating data to handle the area beyond the border.
	     * @param {Array.<string>} validLabels - valid labels
	     * @param {Array.<string>} validLabelCount - valid label count
	     * @param {object} labelTheme - theme for label
	     * @param {boolean} isLabelAxis - whether label type axis or not
	     * @param {{series: {width: number}, yAxis: {width: number}}} dimensionMap - dimension map
	     * @returns {{degree: number, overflowHeight: number, overflowLeft: number}}
	     */
	    makeAdditionalDataForRotatedLabels: function makeAdditionalDataForRotatedLabels(validLabels, validLabelCount, labelTheme, isLabelAxis, dimensionMap) {
	        var maxLabelWidth = _renderUtil2['default'].getRenderedLabelsMaxWidth(validLabels, labelTheme);
	        var seriesWidth = dimensionMap.series.width;
	        var yAxisAreaWidth = dimensionMap.yAxis.width + (dimensionMap.rightYAxis ? dimensionMap.rightYAxis.width : 0);
	
	        var labelAreaWidth = this._calculateXAxisLabelAreaWidth(isLabelAxis, seriesWidth, validLabelCount);
	        var additionalData = null;
	        var contentWidth = _const2['default'].CHART_PADDING * 2 + yAxisAreaWidth + seriesWidth;
	
	        if (labelAreaWidth < maxLabelWidth) {
	            var labelHeight = _renderUtil2['default'].getRenderedLabelsMaxHeight(validLabels, labelTheme);
	            var degree = this._findRotationDegree(labelAreaWidth, maxLabelWidth, labelHeight);
	            var rotatedHeight = _geometric2['default'].calculateRotatedHeight(degree, maxLabelWidth, labelHeight);
	            var rotatedWidth = this._calculateRotatedWidth(degree, validLabels[0], labelHeight, labelTheme);
	            var limitWidth = this._calculateLimitWidth(dimensionMap.yAxis.width, isLabelAxis, labelAreaWidth);
	            contentWidth += rotatedWidth; // add spaces to render maybe one label
	
	            additionalData = {
	                degree: degree,
	                overflowHeight: rotatedHeight - labelHeight,
	                overflowLeft: rotatedWidth - limitWidth,
	                overflowRight: contentWidth - dimensionMap.chart.width
	            };
	        } else {
	            contentWidth += maxLabelWidth;
	
	            labelAreaWidth = _renderUtil2['default'].getRenderedLabelWidth(validLabels[0], labelTheme) / 2;
	            additionalData = {
	                overflowLeft: labelAreaWidth - dimensionMap.yAxis.width,
	                overflowRight: contentWidth - dimensionMap.chart.width
	            };
	        }
	
	        return additionalData;
	    }
	};
	
	exports['default'] = axisDataMaker;

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Column chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var ColumnChart = function (_ChartBase) {
	    _inherits(ColumnChart, _ChartBase);
	
	    /**
	     * Column chart.
	     * @constructs ColumnChart
	     * @extends ChartBase
	     * @mixes axisTypeMixer
	     * @mixes verticalTypeMixer
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function ColumnChart(rawData, theme, options) {
	        _classCallCheck(this, ColumnChart);
	
	        _rawDataHandler2['default'].updateRawSeriesDataByOptions(rawData, options.series);
	
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true,
	            isVertical: true
	        }));
	
	        _this._updateOptionsRelatedDiverging(options);
	
	        /**
	         * className
	         * @type {string}
	         */
	        _this.className = 'tui-column-chart';
	        return _this;
	    }
	
	    /**
	     * Update options related diverging option.
	     * @param {object} options - options
	     * @private
	     */
	
	
	    ColumnChart.prototype._updateOptionsRelatedDiverging = function _updateOptionsRelatedDiverging(options) {
	        options.series = options.series || {};
	
	        if (options.series.diverging) {
	            options.series.stackType = options.series.stackType || _const2['default'].NORMAL_STACK_TYPE;
	        }
	    };
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    ColumnChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('columnSeries', 'columnSeries');
	
	        this.componentManager.register('yAxis', 'axis');
	        this.componentManager.register('xAxis', 'axis');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{yAxis: boolean}}
	     * @override
	     */
	
	
	    ColumnChart.prototype.getScaleOption = function getScaleOption() {
	        return {
	            yAxis: true
	        };
	    };
	
	    /**
	     * Add data ratios.
	     * modified from axisTypeMixer
	     * @override
	     */
	
	
	    ColumnChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        var _options$series = this.options.series,
	            seriesOption = _options$series === undefined ? {} : _options$series;
	        var chartType = this.chartType;
	
	        var _ref = seriesOption[chartType] || seriesOption,
	            stackType = _ref.stackType;
	
	        this.dataProcessor.addDataRatios(limitMap[chartType], stackType, chartType);
	    };
	
	    return ColumnChart;
	}(_chartBase2['default']);
	
	exports['default'] = ColumnChart;

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _dynamicDataHelper = __webpack_require__(453);
	
	var _dynamicDataHelper2 = _interopRequireDefault(_dynamicDataHelper);
	
	var _lineChartSeries = __webpack_require__(412);
	
	var _lineChartSeries2 = _interopRequireDefault(_lineChartSeries);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Line chart
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var LineChart = function (_ChartBase) {
	    _inherits(LineChart, _ChartBase);
	
	    /**
	     * Line chart.
	     * @param {Array.<Array>} rawData - raw data
	     * @param {object} theme - chart theme
	     * @param {object} options - chart options
	     * @constructs LineChart
	     * @extends ChartBase
	     * @mixes axisTypeMixer
	     * @mixes lineTypeMixer
	     */
	    function LineChart(rawData, theme, options) {
	        _classCallCheck(this, LineChart);
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true,
	            isVertical: true
	        }));
	
	        _this.className = 'tui-line-chart';
	
	        /**
	         * Series class
	         * @type {function}
	         */
	        _this.Series = _lineChartSeries2['default'];
	
	        if (_this.dataProcessor.isCoordinateType()) {
	            delete _this.options.xAxis.tickInterval;
	            _this.options.tooltip.grouped = false;
	            _this.options.series.shifting = false;
	        }
	
	        _this._dynamicDataHelper = new _dynamicDataHelper2['default'](_this);
	        return _this;
	    }
	
	    /**
	     * Add data.
	     * @param {string} category - category
	     * @param {Array} values - values
	     * @api
	     */
	
	
	    LineChart.prototype.addData = function addData(category, values) {
	        this._dynamicDataHelper.addData(category, values);
	    };
	
	    /**
	     * On change checked legend.
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @param {?object} rawData rawData
	     * @param {?object} boundsParams addition params for calculating bounds
	     * @override
	     */
	
	
	    LineChart.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends, rawData, boundsParams) {
	        this._dynamicDataHelper.reset();
	        this._dynamicDataHelper.changeCheckedLegends(checkedLegends, rawData, boundsParams);
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     * from axisTypeMixer
	     */
	
	
	    LineChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        var _this2 = this;
	
	        var chartTypes = this.chartTypes || [this.chartType];
	        var seriesOption = this.options.series || {};
	        var addDataRatio = void 0;
	
	        if (this.dataProcessor.isCoordinateType()) {
	            addDataRatio = function addDataRatio(chartType) {
	                var hasRadius = _predicate2['default'].isBubbleChart(chartType);
	                _this2.dataProcessor.addDataRatiosForCoordinateType(chartType, limitMap, hasRadius);
	            };
	        } else {
	            addDataRatio = function addDataRatio(chartType) {
	                var _ref = seriesOption[chartType] || seriesOption,
	                    stackType = _ref.stackType;
	
	                _this2.dataProcessor.addDataRatios(limitMap[chartType], stackType, chartType);
	            };
	        }
	
	        _tuiCodeSnippet2['default'].forEachArray(chartTypes, addDataRatio);
	    };
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    LineChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	
	        this.componentManager.register('lineSeries', 'lineSeries');
	
	        this.componentManager.register('xAxis', 'axis');
	
	        if (this.hasRightYAxis) {
	            this.componentManager.register('rightYAxis', 'axis');
	        }
	
	        this.componentManager.register('yAxis', 'axis');
	
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Get scale option.
	     * from lineTypeMixer
	     * @returns {{xAxis: ?{valueType:string}, yAxis: ?(boolean|{valueType:string})}}
	     * @override
	     */
	
	
	    LineChart.prototype.getScaleOption = function getScaleOption() {
	        var scaleOption = {};
	        var xAxisOption = this.options.xAxis;
	        var yAxisOption = this.options.yAxis;
	        var hasDateFormat = void 0,
	            isDateTimeTypeXAxis = void 0;
	
	        if (this.dataProcessor.isCoordinateType()) {
	            isDateTimeTypeXAxis = xAxisOption && xAxisOption.type === 'datetime';
	            hasDateFormat = isDateTimeTypeXAxis && _tuiCodeSnippet2['default'].isExisty(xAxisOption.dateFormat);
	
	            scaleOption.xAxis = {
	                valueType: 'x'
	            };
	
	            if (isDateTimeTypeXAxis) {
	                scaleOption.xAxis.type = (xAxisOption || {}).dateTime;
	            }
	
	            if (hasDateFormat) {
	                scaleOption.xAxis.format = (xAxisOption || {}).dateFormat;
	            }
	
	            scaleOption.yAxis = {
	                valueType: 'y'
	            };
	        } else if (this.hasRightYAxis) {
	            scaleOption.yAxis = this._makeYAxisScaleOption('yAxis', yAxisOption[0]);
	            scaleOption.rightYAxis = this._makeYAxisScaleOption('yAxis', yAxisOption[1]);
	        } else {
	            scaleOption.yAxis = true;
	        }
	
	        return scaleOption;
	    };
	
	    LineChart.prototype._makeYAxisScaleOption = function _makeYAxisScaleOption(name, yAxisOption) {
	        return {
	            options: yAxisOption,
	            areaType: 'yAxis'
	        };
	    };
	
	    /**
	     * Add plot line.
	     * @param {{index: number, color: string, id: string}} data - data
	     * @override
	     * @api
	     */
	
	
	    LineChart.prototype.addPlotLine = function addPlotLine(data) {
	        this.componentManager.get('plot').addPlotLine(data);
	    };
	
	    /**
	     * Add plot band.
	     * @param {{range: Array.<number>, color: string, id: string}} data - data
	     * @override
	     * @api
	     */
	
	
	    LineChart.prototype.addPlotBand = function addPlotBand(data) {
	        this.componentManager.get('plot').addPlotBand(data);
	    };
	
	    /**
	     * Remove plot line.
	     * @param {string} id - line id
	     * @override
	     * @api
	     */
	
	
	    LineChart.prototype.removePlotLine = function removePlotLine(id) {
	        this.componentManager.get('plot').removePlotLine(id);
	    };
	
	    /**
	     * Remove plot band.
	     * @param {string} id - band id
	     * @override
	     * @api
	     */
	
	
	    LineChart.prototype.removePlotBand = function removePlotBand(id) {
	        this.componentManager.get('plot').removePlotBand(id);
	    };
	
	    /**
	     * Render for zoom.
	     * from chart/zoomMixer
	     * @param {boolean} isResetZoom - whether reset zoom or not
	     * @private
	     */
	
	
	    LineChart.prototype._renderForZoom = function _renderForZoom(isResetZoom) {
	        var boundsAndScale = this.readyForRender();
	
	        this.componentManager.render('zoom', boundsAndScale, { isResetZoom: isResetZoom });
	    };
	
	    /**
	     * On zoom.
	     * nnfrom chart/zoomMixer
	     * @param {Array.<number>} indexRange - index range for zoom
	     * @override
	     */
	
	
	    LineChart.prototype.onZoom = function onZoom(indexRange) {
	        this._dynamicDataHelper.pauseAnimation();
	        this.dataProcessor.updateRawDataForZoom(indexRange);
	        this._renderForZoom(false);
	    };
	
	    /**
	     * On reset zoom.
	     * from chart/zoomMixer
	     * @override
	     */
	
	
	    LineChart.prototype.onResetZoom = function onResetZoom() {
	        var rawData = this.dataProcessor.getOriginalRawData();
	
	        if (this._dynamicDataHelper.checkedLegends) {
	            rawData = _rawDataHandler2['default'].filterCheckedRawData(rawData, this._dynamicDataHelper.checkedLegends);
	        }
	
	        this.dataProcessor.initData(rawData);
	        this.dataProcessor.initZoomedRawData();
	        this.dataProcessor.addDataFromRemainDynamicData(_tuiCodeSnippet2['default'].pick(this.options.series, 'shifting'));
	        this._renderForZoom(true);
	        this._dynamicDataHelper.restartAnimation();
	    };
	
	    return LineChart;
	}(_chartBase2['default']);
	
	exports['default'] = LineChart;

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var DynamicDataHelper = function () {
	    function DynamicDataHelper(chart) {
	        var _this = this;
	
	        _classCallCheck(this, DynamicDataHelper);
	
	        var firstRenderCheck = function firstRenderCheck() {
	            _this.isInitRenderCompleted = true;
	            _this.chart.off(firstRenderCheck);
	        };
	
	        /**
	         * chart instance
	         * @type {ChartBase}
	         */
	        this.chart = chart;
	
	        this.isInitRenderCompleted = false;
	
	        this.chart.on('load', firstRenderCheck);
	
	        this.reset();
	    }
	
	    DynamicDataHelper.prototype.reset = function reset() {
	        /**
	         * whether lookupping or not
	         * @type {boolean}
	         */
	        this.lookupping = false;
	
	        /**
	         * whether paused or not
	         * @type {boolean}
	         */
	        this.paused = false;
	
	        /**
	         * rendering delay timer id
	         * @type {null}
	         */
	        this.rerenderingDelayTimerId = null;
	
	        /**
	         * added data count
	         * @type {number}
	         */
	        this.addedDataCount = 0;
	
	        /**
	         * checked legends.
	         * @type {null | Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}}
	         */
	        this.checkedLegends = null;
	
	        /**
	         * previous xAxis data
	         * @type {null|object}
	         */
	        this.prevXAxisData = null;
	    };
	
	    /**
	     * Calculate animate tick size.
	     * @param {number} xAxisWidth - x axis width
	     * @returns {number}
	     * @private
	     */
	
	
	    DynamicDataHelper.prototype._calculateAnimateTickSize = function _calculateAnimateTickSize(xAxisWidth) {
	        var dataProcessor = this.chart.dataProcessor;
	        var tickInterval = this.chart.options.xAxis.tickInterval;
	
	        var shiftingOption = !!this.chart.options.series.shifting;
	        var tickCount = void 0;
	
	        if (dataProcessor.isCoordinateType()) {
	            tickCount = dataProcessor.getValues(this.chart.chartType, 'x').length - 1;
	        } else {
	            tickCount = dataProcessor.getCategoryCount(false) - 1;
	        }
	
	        if (shiftingOption && !_predicate2['default'].isAutoTickInterval(tickInterval)) {
	            tickCount -= 1;
	        }
	
	        return xAxisWidth / tickCount;
	    };
	
	    /**
	     * Animate for adding data.
	     * @private
	     */
	
	
	    DynamicDataHelper.prototype._animateForAddingData = function _animateForAddingData() {
	        var chart = this.chart;
	
	        var boundsAndScale = chart.readyForRender(true);
	        var shiftingOption = !!this.chart.options.series.shifting;
	
	        this.addedDataCount += 1;
	
	        var tickSize = this._calculateAnimateTickSize(boundsAndScale.dimensionMap.xAxis.width);
	
	        chart.componentManager.render('animateForAddingData', boundsAndScale, {
	            tickSize: tickSize,
	            shifting: shiftingOption
	        });
	
	        if (shiftingOption) {
	            chart.dataProcessor.shiftData();
	        }
	    };
	
	    /**
	     * Rerender for adding data.
	     * @private
	     */
	
	
	    DynamicDataHelper.prototype._rerenderForAddingData = function _rerenderForAddingData() {
	        var chart = this.chart;
	
	        var boundsAndScale = chart.readyForRender();
	        chart.componentManager.render('rerender', boundsAndScale);
	    };
	
	    /**
	     * Check for added data.
	     * @private
	     */
	
	
	    DynamicDataHelper.prototype._checkForAddedData = function _checkForAddedData() {
	        var _this2 = this;
	
	        var chart = this.chart;
	
	        var added = chart.dataProcessor.addDataFromDynamicData();
	
	        if (!added) {
	            this.lookupping = false;
	
	            return;
	        }
	
	        if (this.paused) {
	            if (chart.options.series.shifting) {
	                chart.dataProcessor.shiftData();
	            }
	
	            return;
	        }
	
	        this._animateForAddingData();
	
	        this.rerenderingDelayTimerId = setTimeout(function () {
	            _this2.rerenderingDelayTimerId = null;
	            _this2._rerenderForAddingData();
	            _this2._checkForAddedData();
	        }, 400);
	    };
	
	    /**
	     * Change checked legend.
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @param {?object} rawData rawData
	     * @param {?object} boundsParams addition params for calculating bounds
	     */
	
	
	    DynamicDataHelper.prototype.changeCheckedLegends = function changeCheckedLegends(checkedLegends, rawData, boundsParams) {
	        var _this3 = this;
	
	        var chart = this.chart;
	
	        var shiftingOption = !!chart.options.series.shifting;
	        var pastPaused = this.paused;
	
	        if (!pastPaused) {
	            this.pauseAnimation();
	        }
	
	        this.checkedLegends = checkedLegends;
	        chart.protectedRerender(checkedLegends, rawData, boundsParams);
	
	        if (!pastPaused) {
	            setTimeout(function () {
	                chart.dataProcessor.addDataFromRemainDynamicData(shiftingOption);
	                _this3.restartAnimation();
	            }, _const2['default'].RERENDER_TIME);
	        }
	    };
	
	    /**
	     * Pause animation for adding data.
	     */
	
	
	    DynamicDataHelper.prototype.pauseAnimation = function pauseAnimation() {
	        this.paused = true;
	
	        if (this.rerenderingDelayTimerId) {
	            clearTimeout(this.rerenderingDelayTimerId);
	            this.rerenderingDelayTimerId = null;
	
	            if (this.chart.options.series.shifting) {
	                this.chart.dataProcessor.shiftData();
	            }
	        }
	    };
	
	    /**
	     * Restart animation for adding data.
	     */
	
	
	    DynamicDataHelper.prototype.restartAnimation = function restartAnimation() {
	        this.paused = false;
	        this.lookupping = false;
	        this._startLookup();
	    };
	
	    /**
	     * Start lookup for checking added data.
	     * @private
	     */
	
	
	    DynamicDataHelper.prototype._startLookup = function _startLookup() {
	        if (this.lookupping) {
	            return;
	        }
	
	        this.lookupping = true;
	
	        this._checkForAddedData();
	    };
	
	    /**
	     * Add data.
	     * @param {string} category - category
	     * @param {Array} values - values
	     */
	
	
	    DynamicDataHelper.prototype.addData = function addData(category, values) {
	        if (!values) {
	            values = category;
	            category = null;
	        }
	
	        this.chart.dataProcessor.addDynamicData(category, values);
	
	        // we should not animate for added data if initial render have not completed
	        if (this.isInitRenderCompleted) {
	            this._startLookup();
	        } else if (values) {
	            this.addedDataCount += 1;
	        }
	    };
	
	    return DynamicDataHelper;
	}();
	
	exports['default'] = DynamicDataHelper;

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _dynamicDataHelper = __webpack_require__(453);
	
	var _dynamicDataHelper2 = _interopRequireDefault(_dynamicDataHelper);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	var _areaChartSeries = __webpack_require__(415);
	
	var _areaChartSeries2 = _interopRequireDefault(_areaChartSeries);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Area chart
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	/** Class representing a point. */
	var AreaChart = function (_ChartBase) {
	    _inherits(AreaChart, _ChartBase);
	
	    /**
	     * Area chart.
	     * @constructs AreaChart
	     * @extends ChartBase
	     * @param {Array.<Array>} rawData - raw data
	     * @param {object} theme - chart theme
	     * @param {object} options - chart options
	     * @mixes axisTypeMixer
	     * @mixes lineTypeMixer
	     */
	    function AreaChart(rawData, theme, options) {
	        _classCallCheck(this, AreaChart);
	
	        _rawDataHandler2['default'].removeSeriesStack(rawData.series);
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true,
	            isVertical: true
	        }));
	
	        _this.className = 'tui-area-chart';
	
	        /**
	         * Series class
	         * @type {function}
	         * @ignore
	         */
	        _this.Series = _areaChartSeries2['default'];
	
	        _this._dynamicDataHelper = new _dynamicDataHelper2['default'](_this);
	        return _this;
	    }
	
	    /**
	     * Add data.
	     * @param {string} category - category
	     * @param {Array} values - values
	     * @api
	     */
	
	
	    AreaChart.prototype.addData = function addData(category, values) {
	        this._dynamicDataHelper.addData(category, values);
	    };
	
	    /**
	     * On change checked legend.
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @param {?object} rawData rawData
	     * @param {?object} boundsParams addition params for calculating bounds
	     * @override
	     * @ignore
	     */
	
	
	    AreaChart.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends, rawData, boundsParams) {
	        this._dynamicDataHelper.reset();
	        this._dynamicDataHelper.changeCheckedLegends(checkedLegends, rawData, boundsParams);
	    };
	
	    /**
	     * Add data ratios.
	     * from axisTypeMixer
	     * @override
	     * @ignore
	     */
	
	
	    AreaChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        var _this2 = this;
	
	        var chartTypes = this.chartTypes || [this.chartType];
	        var seriesOption = this.options.series || {};
	        var addDataRatio = void 0;
	
	        if (this.dataProcessor.isCoordinateType()) {
	            addDataRatio = function addDataRatio(chartType) {
	                _this2.dataProcessor.addDataRatiosForCoordinateType(chartType, limitMap, false);
	            };
	        } else {
	            addDataRatio = function addDataRatio(chartType) {
	                var _ref = seriesOption[chartType] || seriesOption,
	                    stackType = _ref.stackType;
	
	                _this2.dataProcessor.addDataRatios(limitMap[chartType], stackType, chartType);
	            };
	        }
	
	        chartTypes.forEach(addDataRatio);
	    };
	
	    /**
	     * Add components
	     * @override
	     * @ignore
	     */
	
	
	    AreaChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('areaSeries', 'areaSeries');
	
	        this.componentManager.register('xAxis', 'axis');
	        this.componentManager.register('yAxis', 'axis');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Get scale option.
	     * from lineTypeMixer
	     * @returns {{xAxis: ?{valueType:string}, yAxis: ?(boolean|{valueType:string})}}
	     * @override
	     * @ignore
	     */
	
	
	    AreaChart.prototype.getScaleOption = function getScaleOption() {
	        var scaleOption = {};
	
	        if (this.dataProcessor.isCoordinateType()) {
	            scaleOption.xAxis = {
	                valueType: 'x'
	            };
	            scaleOption.yAxis = {
	                valueType: 'y'
	            };
	        } else {
	            scaleOption.yAxis = true;
	        }
	
	        return scaleOption;
	    };
	
	    /**
	     * Add plot line.
	     * @param {{index: number, color: string, id: string}} data - data
	     * @override
	     * @api
	     */
	
	
	    AreaChart.prototype.addPlotLine = function addPlotLine(data) {
	        this.componentManager.get('plot').addPlotLine(data);
	    };
	
	    /**
	     * Add plot band.
	     * @param {{range: Array.<number>, color: string, id: string}} data - data
	     * @override
	     * @api
	     */
	
	
	    AreaChart.prototype.addPlotBand = function addPlotBand(data) {
	        this.componentManager.get('plot').addPlotBand(data);
	    };
	
	    /**
	     * Remove plot line.
	     * @param {string} id - line id
	     * @override
	     * @api
	     */
	
	
	    AreaChart.prototype.removePlotLine = function removePlotLine(id) {
	        this.componentManager.get('plot').removePlotLine(id);
	    };
	
	    /**
	     * Remove plot band.
	     * @param {string} id - band id
	     * @override
	     * @api
	     */
	
	
	    AreaChart.prototype.removePlotBand = function removePlotBand(id) {
	        this.componentManager.get('plot').removePlotBand(id);
	    };
	
	    /**
	     * Render for zoom.
	     * from chart/zoomMixer
	     * @param {boolean} isResetZoom - whether reset zoom or not
	     * @private
	     */
	
	
	    AreaChart.prototype._renderForZoom = function _renderForZoom(isResetZoom) {
	        var boundsAndScale = this.readyForRender();
	
	        this.componentManager.render('zoom', boundsAndScale, { isResetZoom: isResetZoom });
	    };
	
	    /**
	     * On zoom.
	     * nnfrom chart/zoomMixer
	     * @param {Array.<number>} indexRange - index range for zoom
	     * @override
	     * @ignore
	     */
	
	
	    AreaChart.prototype.onZoom = function onZoom(indexRange) {
	        this._dynamicDataHelper.pauseAnimation();
	        this.dataProcessor.updateRawDataForZoom(indexRange);
	        this._renderForZoom(false);
	    };
	
	    /**
	     * On reset zoom.
	     * from chart/zoomMixer
	     * @override
	     * @ignore
	     */
	
	
	    AreaChart.prototype.onResetZoom = function onResetZoom() {
	        var rawData = this.dataProcessor.getOriginalRawData();
	
	        if (this._dynamicDataHelper.checkedLegends) {
	            rawData = _rawDataHandler2['default'].filterCheckedRawData(rawData, this._dynamicDataHelper.checkedLegends);
	        }
	
	        this.dataProcessor.initData(rawData);
	        this.dataProcessor.initZoomedRawData();
	        this.dataProcessor.addDataFromRemainDynamicData(_tuiCodeSnippet2['default'].pick(this.options.series, 'shifting'));
	        this._renderForZoom(true);
	        this._dynamicDataHelper.restartAnimation();
	    };
	
	    return AreaChart;
	}(_chartBase2['default']);
	
	exports['default'] = AreaChart;

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _validTypeMakerForYAxisOptions = __webpack_require__(456);
	
	var _validTypeMakerForYAxisOptions2 = _interopRequireDefault(_validTypeMakerForYAxisOptions);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Column and Line Combo chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var ColumnLineComboChart = function (_ChartBase) {
	    _inherits(ColumnLineComboChart, _ChartBase);
	
	    /**
	     * Column and Line Combo chart.
	     * @constructs ColumnLineComboChart
	     * @extends ChartBase
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function ColumnLineComboChart(rawData, theme, options) {
	        _classCallCheck(this, ColumnLineComboChart);
	
	        options.tooltip = options.tooltip || {};
	        options.tooltip.grouped = true;
	
	        var typeData = (0, _validTypeMakerForYAxisOptions2['default'])({
	            rawSeriesData: rawData.series,
	            yAxisOptions: options.yAxis
	        });
	
	        /**
	         * yAxis options
	         * @type {object}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            chartTypes: typeData.chartTypes,
	            seriesTypes: typeData.seriesTypes,
	            hasAxes: true,
	            isVertical: true
	        }));
	
	        _this.yAxisOptions = _this._makeYAxisOptions(_this.chartTypes, options.yAxis);
	        return _this;
	    }
	
	    /**
	     * Make yAxis options.
	     * from verticalTypeComboMixer
	     * @param {Array.<string>} chartTypes chart types
	     * @param {?object} yAxisOptions yAxis options
	     * @returns {{column: ?object, line: ?object}} options map
	     * @private
	     */
	
	
	    ColumnLineComboChart.prototype._makeYAxisOptions = function _makeYAxisOptions(chartTypes, yAxisOptions) {
	        var options = {};
	        yAxisOptions = yAxisOptions || {};
	        chartTypes.forEach(function (chartType, index) {
	            options[chartType] = yAxisOptions[index] || yAxisOptions;
	        });
	
	        return options;
	    };
	
	    /**
	     * On change selected legend.
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @ignore
	     */
	
	
	    ColumnLineComboChart.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
	        var originalRawData = this.dataProcessor.getOriginalRawData();
	        var rawData = _rawDataHandler2['default'].filterCheckedRawData(originalRawData, checkedLegends);
	        var typeData = (0, _validTypeMakerForYAxisOptions2['default'])({
	            rawSeriesData: rawData.series,
	            yAxisOptions: this.options.yAxis
	        });
	
	        this.chartTypes = typeData.chartTypes;
	        this.seriesTypes = typeData.seriesTypes;
	
	        this.protectedRerender(checkedLegends, rawData, typeData);
	    };
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    ColumnLineComboChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('columnSeries', 'columnSeries');
	        this.componentManager.register('lineSeries', 'lineSeries');
	
	        this.componentManager.register('yAxis', 'axis');
	
	        if (this.hasRightYAxis) {
	            this.componentManager.register('rightYAxis', 'axis');
	        }
	
	        this.componentManager.register('xAxis', 'axis');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{
	     *      yAxis: {options: object, areaType: string, chartType: string, additionalParams: object},
	     *      rightYAxis: {options: object, areaType: string, chartType: string, additionalParams: object}
	     * }}
	     * @override
	     */
	
	
	    ColumnLineComboChart.prototype.getScaleOption = function getScaleOption() {
	        var scaleOption = {
	            yAxis: this._makeYAxisScaleOption('yAxis', this.chartTypes[0], !this.hasRightYAxis)
	        };
	
	        if (this.hasRightYAxis) {
	            scaleOption.rightYAxis = this._makeYAxisScaleOption('rightYAxis', this.chartTypes[1]);
	        }
	
	        return scaleOption;
	    };
	
	    /**
	     * Make y axis scale option.
	     * @param {string} name - component name
	     * @param {string} chartType - chart type
	     * @param {boolean} isSingleYAxis - whether single y axis or not
	     * @returns {{options: object, areaType: string, chartType: string, additionalParams: object}}
	     * @private
	     */
	
	
	    ColumnLineComboChart.prototype._makeYAxisScaleOption = function _makeYAxisScaleOption(name, chartType, isSingleYAxis) {
	        var yAxisOption = this.yAxisOptions[chartType];
	        var additionalOptions = {
	            isSingleYAxis: !!isSingleYAxis
	        };
	
	        if (isSingleYAxis && this.options.series) {
	            this._setAdditionalOptions(additionalOptions);
	        }
	
	        return {
	            options: yAxisOption,
	            areaType: 'yAxis',
	            chartType: chartType,
	            additionalOptions: additionalOptions
	        };
	    };
	
	    /**
	     * Set additional parameter for making y axis scale option.
	     * @param {{isSingleYAxis: boolean}} additionalOptions - additional options
	     * @private
	     */
	
	
	    ColumnLineComboChart.prototype._setAdditionalOptions = function _setAdditionalOptions(additionalOptions) {
	        var dataProcessor = this.dataProcessor;
	
	
	        Object.entries(this.options.series).forEach(function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2),
	                seriesType = _ref2[0],
	                seriesOption = _ref2[1];
	
	            if (!seriesOption.stackType) {
	                return;
	            }
	
	            var chartType = dataProcessor.findChartType(seriesType);
	
	            if (!_predicate2['default'].isAllowedStackOption(chartType)) {
	                return;
	            }
	
	            additionalOptions.chartType = chartType;
	            additionalOptions.stackType = seriesOption.stackType;
	        });
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     */
	
	
	    ColumnLineComboChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        var _this2 = this;
	
	        var chartTypes = this.chartTypes || [this.chartType];
	        var seriesOption = this.options.series || {};
	        var addDataRatio = function addDataRatio(chartType) {
	            var _ref3 = seriesOption[chartType] || seriesOption,
	                stackType = _ref3.stackType;
	
	            _this2.dataProcessor.addDataRatios(limitMap[chartType], stackType, chartType);
	        };
	
	        chartTypes.forEach(addDataRatio);
	    };
	
	    return ColumnLineComboChart;
	}(_chartBase2['default']);
	
	exports['default'] = ColumnLineComboChart;

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports['default'] = validTypeMakerForYAxisOptions;
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	/**
	 * Make valid types on yAxisOptions
	 * @param {object} params parameters
	 * @param {Array.<Array>} params.rawSeriesData raw series data
	 * @param {object} params.yAxisOptions chart yAxis options
	 * @param {string} params.chartType chart type
	 * @returns {object} {
	 *     chartTypes: Array.<string>,
	 *     seriesTypes: Array.<string>,
	 *     hasRightYAxis: boolean,
	 *     yAxisOptionsMap: object
	 * }
	 * @ignore
	 */
	function validTypeMakerForYAxisOptions(params) {
	    var rawSeriesData = params.rawSeriesData,
	        yAxisOptions = params.yAxisOptions;
	
	    var chartTypesMap = makeChartTypesMap(rawSeriesData, yAxisOptions);
	
	    return {
	        chartTypes: chartTypesMap.chartTypes,
	        seriesTypes: chartTypesMap.seriesTypes
	    };
	}
	
	/**
	 * Make chart types map.
	 * @param {object} rawSeriesData raw series data
	 * @param {object} yAxisOption option for y axis
	 * @returns {object} chart types map
	 * @private
	 */
	/**
	 * @fileoverview Implements valid type maker on yAxisOptions
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	function makeChartTypesMap(rawSeriesData, yAxisOption) {
	    var seriesTypes = _tuiCodeSnippet2['default'].keys(rawSeriesData).sort();
	    var optionChartTypes = getYAxisOptionChartTypes(seriesTypes, yAxisOption);
	    var chartTypes = optionChartTypes.length ? optionChartTypes : seriesTypes;
	    var validChartTypes = optionChartTypes.filter(function (_chartType) {
	        return rawSeriesData[_chartType].length;
	    });
	    var chartTypesMap = void 0;
	
	    if (validChartTypes.length === 1) {
	        chartTypesMap = {
	            chartTypes: validChartTypes,
	            seriesTypes: validChartTypes
	        };
	    } else {
	        chartTypesMap = {
	            chartTypes: chartTypes,
	            seriesTypes: seriesTypes
	        };
	    }
	
	    return chartTypesMap;
	}
	
	/**
	 * Get y axis option chart types.
	 * @param {Array.<string>} chartTypes chart types
	 * @param {object} yAxisOption - options for y axis
	 * @returns {Array.<string>}
	 * @private
	 */
	function getYAxisOptionChartTypes(chartTypes, yAxisOption) {
	    var resultChartTypes = chartTypes.slice();
	    var yAxisOptions = [].concat(yAxisOption || []);
	    var isReverse = false;
	    var optionChartTypes = void 0;
	
	    if (!yAxisOptions.length || yAxisOptions.length === 1 && !yAxisOptions[0].chartType) {
	        resultChartTypes = [];
	    } else if (yAxisOptions.length) {
	        optionChartTypes = yAxisOptions.map(function (option) {
	            return option.chartType;
	        });
	
	        optionChartTypes.forEach(function (chartType, index) {
	            isReverse = isReverse || chartType && resultChartTypes[index] !== chartType || false;
	        });
	
	        if (isReverse) {
	            resultChartTypes.reverse();
	        }
	    }
	
	    return resultChartTypes;
	}

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Line and Scatter Combo chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var LineScatterComboChart = function (_ChartBase) {
	    _inherits(LineScatterComboChart, _ChartBase);
	
	    /**
	     * Line and Scatter Combo chart.
	     * @constructs LineScatterComboChart
	     * @extends ChartBase
	     * @param {Array.<Array>} rawData - raw data
	     * @param {object} theme - chart theme
	     * @param {object} options - chart options
	     */
	    function LineScatterComboChart(rawData, theme, options) {
	        _classCallCheck(this, LineScatterComboChart);
	
	        return _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            chartTypes: ['line', 'scatter'],
	            seriesTypes: ['line', 'scatter'],
	            hasAxes: true,
	            isVertical: true
	        }));
	    }
	
	    /**
	     * Get scale option.
	     * @returns {{
	     *      yAxis: {valueType: string, additionalOptions: {isSingleYAxis: boolean}},
	     *      xAxis: {valueType: string}
	     * }}
	     * @override
	     */
	
	
	    LineScatterComboChart.prototype.getScaleOption = function getScaleOption() {
	        return {
	            yAxis: {
	                valueType: 'y'
	            },
	            xAxis: {
	                valueType: 'x'
	            }
	        };
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     * from axisTypeMixer
	     */
	
	
	    LineScatterComboChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        var _this2 = this;
	
	        var chartTypes = this.chartTypes || [this.chartType];
	
	        var addDataRatio = function addDataRatio(chartType) {
	            _this2.dataProcessor.addDataRatiosForCoordinateType(chartType, limitMap, false);
	        };
	
	        _tuiCodeSnippet2['default'].forEachArray(chartTypes, addDataRatio);
	    };
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    LineScatterComboChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('lineSeries', 'lineSeries');
	        this.componentManager.register('scatterSeries', 'scatterSeries');
	
	        this.componentManager.register('yAxis', 'axis');
	        this.componentManager.register('xAxis', 'axis');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    return LineScatterComboChart;
	}(_chartBase2['default']);
	
	exports['default'] = LineScatterComboChart;

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	var _predicate = __webpack_require__(342);
	
	var _predicate2 = _interopRequireDefault(_predicate);
	
	var _validTypeMakerForYAxisOptions = __webpack_require__(456);
	
	var _validTypeMakerForYAxisOptions2 = _interopRequireDefault(_validTypeMakerForYAxisOptions);
	
	var _dynamicDataHelper = __webpack_require__(453);
	
	var _dynamicDataHelper2 = _interopRequireDefault(_dynamicDataHelper);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Line and Area Combo chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var LineAreaComboChart = function (_ChartBase) {
	    _inherits(LineAreaComboChart, _ChartBase);
	
	    /**
	     * Line and Area Combo chart.
	     * @constructs LineAreaComboChart
	     * @extends ChartBase
	     * @param {Array.<Array>} rawData - raw data
	     * @param {object} theme - chart theme
	     * @param {object} options - chart options
	     */
	    function LineAreaComboChart(rawData, theme, options) {
	        _classCallCheck(this, LineAreaComboChart);
	
	        var typeData = (0, _validTypeMakerForYAxisOptions2['default'])({
	            rawSeriesData: rawData.series,
	            yAxisOptions: options.yAxis
	        });
	
	        options.tooltip = options.tooltip || {};
	        options.tooltip.grouped = true;
	
	        /**
	         * yAxis options
	         * @type {object}
	         * @ignore
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            seriesTypes: typeData.seriesTypes,
	            chartTypes: typeData.chartTypes,
	            hasAxes: true,
	            isVertical: true
	        }));
	
	        _this.yAxisOptions = _this._makeYAxisOptions(_this.chartTypes, options.yAxis);
	
	        _this._dynamicDataHelper = new _dynamicDataHelper2['default'](_this);
	
	        /**
	         * className
	         * @type {string}
	         */
	        _this.className = 'tui-combo-chart';
	        return _this;
	    }
	
	    /**
	     * On change selected legend.
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @ignore
	     */
	
	
	    LineAreaComboChart.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
	        var currentData = this.dataProcessor.getCurrentData();
	        var rawData = _rawDataHandler2['default'].filterCheckedRawData(currentData, checkedLegends);
	        var typeData = (0, _validTypeMakerForYAxisOptions2['default'])({
	            rawSeriesData: rawData.series,
	            yAxisOptions: this.options.yAxis
	        });
	
	        this._dynamicDataHelper.reset();
	        this._dynamicDataHelper.changeCheckedLegends(checkedLegends, rawData, typeData);
	    };
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    LineAreaComboChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('areaSeries', 'areaSeries');
	        this.componentManager.register('lineSeries', 'lineSeries');
	
	        this.componentManager.register('xAxis', 'axis');
	        this.componentManager.register('yAxis', 'axis');
	
	        if (this.hasRightYAxis) {
	            this.componentManager.register('rightYAxis', 'axis');
	        }
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{
	     *      yAxis: {options: object, areaType: string, chartType: string, additionalParams: object},
	     *      rightYAxis: {options: object, areaType: string, chartType: string, additionalParams: object}
	     * }}
	     * @override
	     */
	
	
	    LineAreaComboChart.prototype.getScaleOption = function getScaleOption() {
	        var scaleOption = {
	            yAxis: this._makeYAxisScaleOption('yAxis', this.chartTypes[0], !this.hasRightYAxis)
	        };
	
	        if (this.hasRightYAxis) {
	            scaleOption.rightYAxis = this._makeYAxisScaleOption('rightYAxis', this.chartTypes[1]);
	        }
	
	        return scaleOption;
	    };
	
	    /**
	     * Make y axis scale option.
	     * @param {string} name - component name
	     * @param {string} chartType - chart type
	     * @param {boolean} isSingleYAxis - whether single y axis or not
	     * @returns {{options: object, areaType: string, chartType: string, additionalParams: object}}
	     * @private
	     * from verticalTypeComboMixer
	     */
	
	
	    LineAreaComboChart.prototype._makeYAxisScaleOption = function _makeYAxisScaleOption(name, chartType, isSingleYAxis) {
	        var yAxisOption = this.yAxisOptions[chartType];
	        var additionalOptions = {
	            isSingleYAxis: !!isSingleYAxis
	        };
	
	        if (isSingleYAxis && this.options.series) {
	            this._setAdditionalOptions(additionalOptions);
	        }
	
	        return {
	            options: yAxisOption,
	            areaType: 'yAxis',
	            chartType: chartType,
	            additionalOptions: additionalOptions
	        };
	    };
	
	    /**
	     * Make yAxis options.
	     * @param {Array.<string>} chartTypes chart types
	     * @param {?object} yAxisOptions yAxis options
	     * @returns {{column: ?object, line: ?object}} options map
	     * @private
	     * from verticalTypeComboMixer
	     */
	
	
	    LineAreaComboChart.prototype._makeYAxisOptions = function _makeYAxisOptions(chartTypes) {
	        var yAxisOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	        var options = {};
	        chartTypes.forEach(function (chartType, index) {
	            options[chartType] = yAxisOptions[index] || yAxisOptions;
	        });
	
	        return options;
	    };
	
	    /**
	     * Add data.
	     * @param {string} category - category
	     * @param {Array} values - values
	     * @api
	     */
	
	
	    LineAreaComboChart.prototype.addData = function addData(category, values) {
	        this._dynamicDataHelper.addData(category, values);
	    };
	
	    /**
	     * Set additional parameter for making y axis scale option.
	     * @param {{isSingleYAxis: boolean}} additionalOptions - additional options
	     * @private
	     * from verticalTypeComboMixer
	     */
	
	
	    LineAreaComboChart.prototype._setAdditionalOptions = function _setAdditionalOptions(additionalOptions) {
	        var dataProcessor = this.dataProcessor;
	
	
	        Object.entries(this.options.series).forEach(function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2),
	                seriesType = _ref2[0],
	                seriesOption = _ref2[1];
	
	            if (!seriesOption.stackType) {
	                return;
	            }
	
	            var chartType = dataProcessor.findChartType(seriesType);
	
	            if (!_predicate2['default'].isAllowedStackOption(chartType)) {
	                return;
	            }
	
	            additionalOptions.chartType = chartType;
	            additionalOptions.stackType = seriesOption.stackType;
	        });
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     */
	
	
	    LineAreaComboChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        var _this2 = this;
	
	        var chartTypes = this.chartTypes || [this.chartType];
	        var seriesOption = this.options.series || {};
	        var addDataRatio = void 0;
	
	        if (this.dataProcessor.isCoordinateType()) {
	            addDataRatio = function addDataRatio(chartType) {
	                _this2.dataProcessor.addDataRatiosForCoordinateType(chartType, limitMap, false);
	            };
	        } else {
	            addDataRatio = function addDataRatio(chartType) {
	                var _ref3 = seriesOption[chartType] || seriesOption,
	                    stackType = _ref3.stackType;
	
	                _this2.dataProcessor.addDataRatios(limitMap[chartType], stackType, chartType);
	            };
	        }
	
	        _tuiCodeSnippet2['default'].forEachArray(chartTypes, addDataRatio);
	    };
	
	    /**
	     * Add plot line.
	     * @param {{index: number, color: string, id: string}} data - data
	     * @override
	     * @api
	     */
	
	
	    LineAreaComboChart.prototype.addPlotLine = function addPlotLine(data) {
	        this.componentManager.get('plot').addPlotLine(data);
	    };
	
	    /**
	     * Add plot band.
	     * @param {{range: Array.<number>, color: string, id: string}} data - data
	     * @override
	     * @api
	     */
	
	
	    LineAreaComboChart.prototype.addPlotBand = function addPlotBand(data) {
	        this.componentManager.get('plot').addPlotBand(data);
	    };
	
	    /**
	     * Remove plot line.
	     * @param {string} id - line id
	     * @override
	     * @api
	     */
	
	
	    LineAreaComboChart.prototype.removePlotLine = function removePlotLine(id) {
	        this.componentManager.get('plot').removePlotLine(id);
	    };
	
	    /**
	     * Remove plot band.
	     * @param {string} id - band id
	     * @override
	     * @api
	     */
	
	
	    LineAreaComboChart.prototype.removePlotBand = function removePlotBand(id) {
	        this.componentManager.get('plot').removePlotBand(id);
	    };
	
	    /**
	     * Render for zoom.
	     * from chart/zoomMixer
	     * @param {boolean} isResetZoom - whether reset zoom or not
	     * @private
	     */
	
	
	    LineAreaComboChart.prototype._renderForZoom = function _renderForZoom(isResetZoom) {
	        var boundsAndScale = this.readyForRender();
	
	        this.componentManager.render('zoom', boundsAndScale, { isResetZoom: isResetZoom });
	    };
	
	    /**
	     * On zoom.
	     * nnfrom chart/zoomMixer
	     * @param {Array.<number>} indexRange - index range for zoom
	     * @override
	     */
	
	
	    LineAreaComboChart.prototype.onZoom = function onZoom(indexRange) {
	        this._dynamicDataHelper.pauseAnimation();
	        this.dataProcessor.updateRawDataForZoom(indexRange);
	        this._renderForZoom(false);
	    };
	
	    /**
	     * On reset zoom.
	     * from chart/zoomMixer
	     * @override
	     */
	
	
	    LineAreaComboChart.prototype.onResetZoom = function onResetZoom() {
	        var rawData = this.dataProcessor.getOriginalRawData();
	
	        if (this._dynamicDataHelper.checkedLegends) {
	            rawData = _rawDataHandler2['default'].filterCheckedRawData(rawData, this._dynamicDataHelper.checkedLegends);
	        }
	
	        this.dataProcessor.initData(rawData);
	        this.dataProcessor.initZoomedRawData();
	        this.dataProcessor.addDataFromRemainDynamicData(_tuiCodeSnippet2['default'].pick(this.options.series, 'shifting'));
	        this._renderForZoom(true);
	        this._dynamicDataHelper.restartAnimation();
	    };
	
	    return LineAreaComboChart;
	}(_chartBase2['default']);
	
	exports['default'] = LineAreaComboChart;

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Pie and Donut Combo chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var PieDonutComboChart = function (_ChartBase) {
	    _inherits(PieDonutComboChart, _ChartBase);
	
	    /**
	     * Pie and Donut Combo chart.
	     * @constructs PieDonutComboChart
	     * @extends ChartBase
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function PieDonutComboChart(rawData, theme, options) {
	        _classCallCheck(this, PieDonutComboChart);
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            seriesTypes: _tuiCodeSnippet2['default'].keys(rawData.series).sort(),
	            chartTypes: ['pie', 'pie'],
	            isVertical: true
	        }));
	
	        _this.className = 'tui-combo-chart';
	        return _this;
	    }
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    PieDonutComboChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('pie1Series', 'pieSeries');
	        this.componentManager.register('pie2Series', 'pieSeries');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     */
	
	
	    PieDonutComboChart.prototype.addDataRatios = function addDataRatios() {
	        var _this2 = this;
	
	        var seriesTypes = this.seriesTypes || [this.chartType];
	
	        seriesTypes.forEach(function (chartType) {
	            _this2.dataProcessor.addDataRatiosOfPieChart(chartType);
	        });
	    };
	
	    /**
	     * On change selected legend.
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @override
	     */
	
	
	    PieDonutComboChart.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
	        var originalRawData = this.dataProcessor.getOriginalRawData();
	        var rawData = _rawDataHandler2['default'].filterCheckedRawData(originalRawData, checkedLegends);
	
	        _chartBase2['default'].prototype.onChangeCheckedLegends.call(this, checkedLegends, rawData, {
	            seriesTypes: this.seriesTypes
	        });
	    };
	
	    return PieDonutComboChart;
	}(_chartBase2['default']);
	
	exports['default'] = PieDonutComboChart;

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Pie chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	/** Class representing a point. */
	var PieChart = function (_ChartBase) {
	    _inherits(PieChart, _ChartBase);
	
	    /**
	     * Pie chart.
	     * @constructs PieChart
	     * @extends ChartBase
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function PieChart(rawData, theme, options) {
	        _classCallCheck(this, PieChart);
	
	        options.tooltip = options.tooltip || {};
	
	        if (!options.tooltip.align) {
	            options.tooltip.align = _const2['default'].TOOLTIP_DEFAULT_ALIGN_OPTION;
	        }
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options
	        }));
	
	        _this.className = 'tui-pie-chart';
	        return _this;
	    }
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    PieChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('pieSeries', 'pieSeries');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     */
	
	
	    PieChart.prototype.addDataRatios = function addDataRatios() {
	        this.dataProcessor.addDataRatiosOfPieChart(this.chartType);
	    };
	
	    return PieChart;
	}(_chartBase2['default']);
	
	exports['default'] = PieChart;

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Bubble chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	/** Class representing a point. */
	var BubbleChart = function (_ChartBase) {
	    _inherits(BubbleChart, _ChartBase);
	
	    /**
	     * Bubble chart.
	     * @constructs BubbleChart
	     * @extends ChartBase
	     * @mixes axisTypeMixer
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function BubbleChart(rawData, theme, options) {
	        _classCallCheck(this, BubbleChart);
	
	        options = Object.assign({
	            tooltip: {},
	            circleLegend: {}
	        }, options);
	
	        options.circleLegend = Object.assign({
	            visible: true
	        }, options.circleLegend);
	
	        options.tooltip = Object.assign({
	            align: _const2['default'].TOOLTIP_DEFAULT_ALIGN_OPTION,
	            grouped: false
	        }, options.tooltip);
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true
	        }));
	
	        _this.className = 'tui-bubble-chart';
	        return _this;
	    }
	
	    /**
	     * Get scale option.
	     * @returns {{xAxis: ?{valueType:string}, yAxis: ?{valueType:string}}}
	     * @override
	     */
	
	
	    BubbleChart.prototype.getScaleOption = function getScaleOption() {
	        var scaleOption = {};
	
	        if (this.dataProcessor.hasXValue(this.chartType)) {
	            scaleOption.xAxis = {
	                valueType: 'x'
	            };
	        }
	        if (this.dataProcessor.hasYValue(this.chartType)) {
	            scaleOption.yAxis = {
	                valueType: 'y'
	            };
	        }
	
	        return scaleOption;
	    };
	
	    /**
	     * Set default options.
	     * @param {object} options - options for bubble chart
	     * @private
	     * @override
	     */
	
	
	    BubbleChart.prototype._setDefaultOptions = function _setDefaultOptions(options) {
	        _chartBase2['default'].prototype._setDefaultOptions.call(this, options);
	        this.options.circleLegend = this.options.circleLegend || {};
	
	        if (_tuiCodeSnippet2['default'].isUndefined(this.options.circleLegend.visible)) {
	            this.options.circleLegend.visible = true;
	        }
	    };
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    BubbleChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	        this.componentManager.register('circleLegend', 'circleLegend');
	
	        this.componentManager.register('bubbleSeries', 'bubbleSeries');
	
	        this.componentManager.register('yAxis', 'axis');
	        this.componentManager.register('xAxis', 'axis');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     */
	
	
	    BubbleChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        this.dataProcessor.addDataRatiosForCoordinateType(this.chartType, limitMap, true);
	    };
	
	    return BubbleChart;
	}(_chartBase2['default']);
	
	exports['default'] = BubbleChart;

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Scatter chart is a type of plot or mathematical diagram using Cartesian coordinates
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *                  to display values for typically two variables for a set of data.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	
	/** Class representing a point. */
	var ScatterChart = function (_ChartBase) {
	    _inherits(ScatterChart, _ChartBase);
	
	    /**
	     * Scatter chart is a type of plot or mathematical diagram using Cartesian coordinates
	     *  to display values for typically two variables for a set of data.
	     * @constructs ScatterChart
	     * @extends ChartBase
	     * @mixes axisTypeMixer
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function ScatterChart(rawData, theme, options) {
	        _classCallCheck(this, ScatterChart);
	
	        options.tooltip = options.tooltip || {};
	
	        if (!options.tooltip.align) {
	            options.tooltip.align = _const2['default'].TOOLTIP_DEFAULT_ALIGN_OPTION;
	        }
	
	        options.tooltip.grouped = false;
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true
	        }));
	
	        _this.className = 'tui-scatter-chart';
	        return _this;
	    }
	
	    /**
	     * Get scale option.
	     * @returns {{xAxis: {valueType: string}, yAxis: {valueType: string}}}
	     * @override
	     */
	
	
	    ScatterChart.prototype.getScaleOption = function getScaleOption() {
	        return {
	            xAxis: {
	                valueType: 'x'
	            },
	            yAxis: {
	                valueType: 'y'
	            }
	        };
	    };
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    ScatterChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('scatterSeries', 'scatterSeries');
	
	        this.componentManager.register('yAxis', 'axis');
	        this.componentManager.register('xAxis', 'axis');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     */
	
	
	    ScatterChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        this.dataProcessor.addDataRatiosForCoordinateType(this.chartType, limitMap, false);
	    };
	
	    return ScatterChart;
	}(_chartBase2['default']);
	
	exports['default'] = ScatterChart;

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _colorSpectrum = __webpack_require__(464);
	
	var _colorSpectrum2 = _interopRequireDefault(_colorSpectrum);
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Heatmap chart is a graphical representation of data where the individual values contained
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *                      in a matrix are represented as colors.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var HeatmapChart = function (_ChartBase) {
	    _inherits(HeatmapChart, _ChartBase);
	
	    /**
	     * Heatmap chart is a graphical representation of data where the individual values contained
	     *      in a matrix are represented as colors.
	     * @constructs HeatmapChart
	     * @extends ChartBase
	     * @mixes axisTypeMixer
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function HeatmapChart(rawData, theme, options) {
	        _classCallCheck(this, HeatmapChart);
	
	        options.tooltip = options.tooltip || {};
	
	        if (!options.tooltip.align) {
	            options.tooltip.align = _const2['default'].TOOLTIP_DEFAULT_ALIGN_OPTION;
	        }
	
	        options.tooltip.grouped = false;
	
	        /**
	         *
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true,
	            isVertical: true
	        }));
	
	        _this.className = 'tui-heatmap-chart';
	        return _this;
	    }
	
	    /**
	     * Add components.
	     * @private
	     */
	
	
	    HeatmapChart.prototype._addComponents = function _addComponents() {
	        var seriesTheme = this.theme.series[this.chartType];
	        var colorSpectrum = new _colorSpectrum2['default'](seriesTheme.startColor, seriesTheme.endColor);
	
	        this._addComponentsForAxisType({
	            axis: [{
	                name: 'yAxis',
	                isVertical: true
	            }, {
	                name: 'xAxis'
	            }],
	            legend: {
	                classType: 'spectrumLegend',
	                additionalParams: {
	                    colorSpectrum: colorSpectrum
	                }
	            },
	            series: [{
	                name: 'heatmapSeries',
	                data: {
	                    colorSpectrum: colorSpectrum
	                }
	            }],
	            tooltip: true,
	            mouseEventDetector: true
	        });
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{legend: boolean}}
	     * @override
	     */
	
	
	    HeatmapChart.prototype.getScaleOption = function getScaleOption() {
	        return {
	            legend: true
	        };
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     */
	
	
	    HeatmapChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        this.dataProcessor.addDataRatios(limitMap.legend, null, this.chartType);
	    };
	
	    /**
	     * Add components.
	     * @override
	     * @private
	     */
	
	
	    HeatmapChart.prototype.addComponents = function addComponents() {
	        var seriesTheme = this.theme.series[this.chartType];
	        var colorSpectrum = new _colorSpectrum2['default'](seriesTheme.startColor, seriesTheme.endColor);
	
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('legend', 'spectrumLegend', { colorSpectrum: colorSpectrum });
	
	        this.componentManager.register('heatmapSeries', 'heatmapSeries', { colorSpectrum: colorSpectrum });
	
	        this.componentManager.register('xAxis', 'axis');
	        this.componentManager.register('yAxis', 'axis');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip', { colorSpectrum: colorSpectrum });
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    return HeatmapChart;
	}(_chartBase2['default']);
	
	exports['default'] = HeatmapChart;

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _colorutil = __webpack_require__(465);
	
	var _colorutil2 = _interopRequireDefault(_colorutil);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview ColorSpectrum create a color spectrum and provide color value.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	
	var ColorSpectrum = function () {
	    /**
	     * ColorSpectrum create a color spectrum and provide color value.
	     * @constructs ColorSpectrum
	     * @param {string} startColor hex color
	     * @param {string} endColor hex color
	     * @private
	     */
	    function ColorSpectrum(startColor, endColor) {
	        _classCallCheck(this, ColorSpectrum);
	
	        this.start = _colorutil2['default'].colorNameToHex(startColor);
	        this.startRGB = _colorutil2['default'].hexToRGB(this.start);
	        this.end = _colorutil2['default'].colorNameToHex(endColor);
	
	        var endRGB = _colorutil2['default'].hexToRGB(this.end);
	        this.distances = this._makeDistances(this.startRGB, endRGB);
	        this.colorMap = {};
	    }
	
	    /**
	     * Make distances start RGB to end RGB.
	     * @param {Array.<number>} startRGB start RGB
	     * @param {Array.<number>} endRGB end RGB
	     * @returns {Array.<number>} distances
	     * @private
	     */
	
	
	    ColorSpectrum.prototype._makeDistances = function _makeDistances(startRGB, endRGB) {
	        return startRGB.map(function (value, index) {
	            return endRGB[index] - value;
	        });
	    };
	
	    /**
	     * Get hex color.
	     * @param {number} ratio ratio
	     * @returns {string} hexcolor
	     */
	
	
	    ColorSpectrum.prototype.getColor = function getColor(ratio) {
	        var hexColor = this.colorMap[ratio];
	
	        if (!hexColor) {
	            var distances = this.distances,
	                startRGB = this.startRGB;
	
	            var rgbColor = startRGB.map(function (start, index) {
	                return start + parseInt(distances[index] * ratio, 10);
	            });
	            hexColor = _colorutil2['default'].rgbToHEX.apply(_colorutil2['default'], _toConsumableArray(rgbColor));
	        }
	
	        return hexColor || null;
	    };
	
	    return ColorSpectrum;
	}();
	
	exports['default'] = ColorSpectrum;

/***/ }),
/* 465 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	/**
	 * @fileoverview Utility methods to manipulate colors
	 * @author NHN.
	 *         FE Development Lab <dl_javascript@nhn.com>
	 */
	
	var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
	
	/**
	 * Color map.
	 * http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes
	 * http://www.w3schools.com/HTML/html_colornames.asp
	 * @type {object}
	 * @ignore
	 */
	var colorMap = {
	    'aliceblue': '#f0f8ff',
	    'antiquewhite': '#faebd7',
	    'aqua': '#00ffff',
	    'aquamarine': '#7fffd4',
	    'azure': '#f0ffff',
	    'beige': '#f5f5dc',
	    'bisque': '#ffe4c4',
	    'black': '#000000',
	    'blanchedalmond': '#ffebcd',
	    'blue': '#0000ff',
	    'blueviolet': '#8a2be2',
	    'brown': '#a52a2a',
	    'burlywood': '#deb887',
	    'cadetblue': '#5f9ea0',
	    'chartreuse': '#7fff00',
	    'chocolate': '#d2691e',
	    'coral': '#ff7f50',
	    'cornflowerblue': '#6495ed',
	    'cornsilk': '#fff8dc',
	    'crimson': '#dc143c',
	    'cyan': '#00ffff',
	    'darkblue': '#00008b',
	    'darkcyan': '#008b8b',
	    'darkgoldenrod': '#b8860b',
	    'darkgray': '#a9a9a9',
	    'darkgreen': '#006400',
	    'darkkhaki': '#bdb76b',
	    'darkmagenta': '#8b008b',
	    'darkolivegreen': '#556b2f',
	    'darkorange': '#ff8c00',
	    'darkorchid': '#9932cc',
	    'darkred': '#8b0000',
	    'darksalmon': '#e9967a',
	    'darkseagreen': '#8fbc8f',
	    'darkslateblue': '#483d8b',
	    'darkslategray': '#2f4f4f',
	    'darkturquoise': '#00ced1',
	    'darkviolet': '#9400d3',
	    'deeppink': '#ff1493',
	    'deepskyblue': '#00bfff',
	    'dimgray': '#696969',
	    'dodgerblue': '#1e90ff',
	    'firebrick': '#b22222',
	    'floralwhite': '#fffaf0',
	    'forestgreen': '#228b22',
	    'fuchsia': '#ff00ff',
	    'gainsboro': '#dcdcdc',
	    'ghostwhite': '#f8f8ff',
	    'gold': '#ffd700',
	    'goldenrod': '#daa520',
	    'gray': '#808080',
	    'green': '#008000',
	    'greenyellow': '#adff2f',
	    'honeydew': '#f0fff0',
	    'hotpink': '#ff69b4',
	    'indianred ': '#cd5c5c',
	    'indigo': '#4b0082',
	    'ivory': '#fffff0',
	    'khaki': '#f0e68c',
	    'lavender': '#e6e6fa',
	    'lavenderblush': '#fff0f5',
	    'lawngreen': '#7cfc00',
	    'lemonchiffon': '#fffacd',
	    'lightblue': '#add8e6',
	    'lightcoral': '#f08080',
	    'lightcyan': '#e0ffff',
	    'lightgoldenrodyellow': '#fafad2',
	    'lightgrey': '#d3d3d3',
	    'lightgreen': '#90ee90',
	    'lightpink': '#ffb6c1',
	    'lightsalmon': '#ffa07a',
	    'lightseagreen': '#20b2aa',
	    'lightskyblue': '#87cefa',
	    'lightslategray': '#778899',
	    'lightsteelblue': '#b0c4de',
	    'lightyellow': '#ffffe0',
	    'lime': '#00ff00',
	    'limegreen': '#32cd32',
	    'linen': '#faf0e6',
	    'magenta': '#ff00ff',
	    'maroon': '#800000',
	    'mediumaquamarine': '#66cdaa',
	    'mediumblue': '#0000cd',
	    'mediumorchid': '#ba55d3',
	    'mediumpurple': '#9370d8',
	    'mediumseagreen': '#3cb371',
	    'mediumslateblue': '#7b68ee',
	    'mediumspringgreen': '#00fa9a',
	    'mediumturquoise': '#48d1cc',
	    'mediumvioletred': '#c71585',
	    'midnightblue': '#191970',
	    'mintcream': '#f5fffa',
	    'mistyrose': '#ffe4e1',
	    'moccasin': '#ffe4b5',
	    'navajowhite': '#ffdead',
	    'navy': '#000080',
	    'oldlace': '#fdf5e6',
	    'olive': '#808000',
	    'olivedrab': '#6b8e23',
	    'orange': '#ffa500',
	    'orangered': '#ff4500',
	    'orchid': '#da70d6',
	    'palegoldenrod': '#eee8aa',
	    'palegreen': '#98fb98',
	    'paleturquoise': '#afeeee',
	    'palevioletred': '#d87093',
	    'papayawhip': '#ffefd5',
	    'peachpuff': '#ffdab9',
	    'peru': '#cd853f',
	    'pink': '#ffc0cb',
	    'plum': '#dda0dd',
	    'powderblue': '#b0e0e6',
	    'purple': '#800080',
	    'red': '#ff0000',
	    'rosybrown': '#bc8f8f',
	    'royalblue': '#4169e1',
	    'saddlebrown': '#8b4513',
	    'salmon': '#fa8072',
	    'sandybrown': '#f4a460',
	    'seagreen': '#2e8b57',
	    'seashell': '#fff5ee',
	    'sienna': '#a0522d',
	    'silver': '#c0c0c0',
	    'skyblue': '#87ceeb',
	    'slateblue': '#6a5acd',
	    'slategray': '#708090',
	    'snow': '#fffafa',
	    'springgreen': '#00ff7f',
	    'steelblue': '#4682b4',
	    'tan': '#d2b48c',
	    'teal': '#008080',
	    'thistle': '#d8bfd8',
	    'tomato': '#ff6347',
	    'turquoise': '#40e0d0',
	    'violet': '#ee82ee',
	    'wheat': '#f5deb3',
	    'white': '#ffffff',
	    'whitesmoke': '#f5f5f5',
	    'yellow': '#ffff00',
	    'yellowgreen': '#9acd32'
	};
	
	exports['default'] = {
	    /**
	     * pad left zero characters.
	     * @param {number} number number value to pad zero.
	     * @param {number} length pad length to want.
	     * @returns {string} padded string.
	     */
	    leadingZero: function leadingZero(number, length) {
	        var zero = '';
	
	        if (String(number).length > length) {
	            return String(number);
	        }
	
	        for (var i = 0; i < length - 1; i += 1) {
	            zero += '0';
	        }
	
	        return (zero + number).slice(length * -1);
	    },
	
	
	    /**
	     * Check validate of hex string value is RGB
	     * @param {string} str - rgb hex string
	     * @returns {boolean} return true when supplied str is valid RGB hex string
	     */
	    isValidRGB: function isValidRGB(str) {
	        return hexRX.test(str);
	    },
	
	
	    // @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html
	
	    /**
	     * Convert color hex string to rgb number array
	     * @param {string} hexStr - hex string
	     * @returns {number[]} rgb numbers
	     */
	    hexToRGB: function hexToRGB(hexStr) {
	        if (!this.isValidRGB(hexStr)) {
	            return false;
	        }
	
	        hexStr = hexStr.substring(1);
	
	        var r = parseInt(hexStr.substr(0, 2), 16);
	        var g = parseInt(hexStr.substr(2, 2), 16);
	        var b = parseInt(hexStr.substr(4, 2), 16);
	
	        return [r, g, b];
	    },
	
	
	    /**
	     * Convert rgb number to hex string
	     * @param {number} r - red
	     * @param {number} g - green
	     * @param {number} b - blue
	     * @returns {string|boolean} return false when supplied rgb number is not valid. otherwise, converted hex string
	     */
	    rgbToHEX: function rgbToHEX(r, g, b) {
	        var hexPreFix = '#';
	        var hexStr = hexPreFix + this.leadingZero(r.toString(16), 2) + this.leadingZero(g.toString(16), 2) + this.leadingZero(b.toString(16), 2);
	
	        if (this.isValidRGB(hexStr)) {
	            return hexStr;
	        }
	
	        return false;
	    },
	
	
	    /**
	     * Color name to hex.
	     * @param {string} colorName color name
	     * @returns {string} hex
	     */
	    colorNameToHex: function colorNameToHex(colorName) {
	        return colorMap[colorName.toLowerCase()] || colorName;
	    }
	};

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _colorSpectrum = __webpack_require__(464);
	
	var _colorSpectrum2 = _interopRequireDefault(_colorSpectrum);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Treemap chart is graphical representation of hierarchical data by using rectangles.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var TreemapChart = function (_ChartBase) {
	    _inherits(TreemapChart, _ChartBase);
	
	    /**
	     * Treemap chart is graphical representation of hierarchical data by using rectangles.
	     * @constructs TreemapChart
	     * @extends ChartBase
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function TreemapChart(rawData, theme, options) {
	        _classCallCheck(this, TreemapChart);
	
	        // options.series = options.series || {};
	        options.tooltip = options.tooltip || {};
	        options.tooltip.grouped = false;
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: false,
	            isVertical: true
	        }));
	
	        _this.className = 'tui-treemap-chart';
	        return _this;
	    }
	
	    /**
	     * Add components.
	     * @override
	     */
	
	
	    TreemapChart.prototype.addComponents = function addComponents() {
	        var seriesTheme = this.theme.series[this.chartType];
	        var useColorValue = this.options.series.useColorValue;
	
	        var colorSpectrum = useColorValue ? new _colorSpectrum2['default'](seriesTheme.startColor, seriesTheme.endColor) : null;
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('treemapSeries', 'treemapSeries', { colorSpectrum: colorSpectrum });
	
	        if (useColorValue && this.options.legend.visible) {
	            this.componentManager.register('legend', 'spectrumLegend', { colorSpectrum: colorSpectrum });
	        }
	
	        this.componentManager.register('tooltip', 'tooltip', Object.assign({
	            labelTheme: _tuiCodeSnippet2['default'].pick(this.theme, 'series', 'label'),
	            colorSpectrum: colorSpectrum
	        }));
	
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{legend: boolean}}
	     * @override
	     */
	
	
	    TreemapChart.prototype.getScaleOption = function getScaleOption() {
	        return {
	            legend: true
	        };
	    };
	
	    /**
	     * Add data ratios to dataProcessor for rendering graph.
	     * @override
	     */
	
	
	    TreemapChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        this.dataProcessor.addDataRatiosForTreemapChart(limitMap.legend, this.chartType);
	    };
	
	    /**
	     * On zoom.
	     * @param {number} index - index of target seriesItem
	     */
	
	
	    TreemapChart.prototype.onZoom = function onZoom(index) {
	        this.componentManager.render('zoom', null, { index: index });
	    };
	
	    return TreemapChart;
	}(_chartBase2['default']);
	
	exports['default'] = TreemapChart;

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _mapManager = __webpack_require__(363);
	
	var _mapManager2 = _interopRequireDefault(_mapManager);
	
	var _mapChartMapModel = __webpack_require__(468);
	
	var _mapChartMapModel2 = _interopRequireDefault(_mapChartMapModel);
	
	var _mapChartDataProcessor = __webpack_require__(469);
	
	var _mapChartDataProcessor2 = _interopRequireDefault(_mapChartDataProcessor);
	
	var _colorSpectrum = __webpack_require__(464);
	
	var _colorSpectrum2 = _interopRequireDefault(_colorSpectrum);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Map chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var MapChart = function (_ChartBase) {
	    _inherits(MapChart, _ChartBase);
	
	    /**
	     * Map chart.
	     * @constructs MapChart
	     * @extends ChartBase
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function MapChart(rawData, theme, options) {
	        _classCallCheck(this, MapChart);
	
	        options.map = _mapManager2['default'].get(options.map);
	        options.tooltip = options.tooltip || {};
	        options.legend = options.legend || {};
	
	        /**
	         * class name
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            DataProcessor: _mapChartDataProcessor2['default']
	        }));
	
	        _this.className = 'tui-map-chart';
	        return _this;
	    }
	
	    /**
	     * Add components.
	     * @override
	     * @private
	     */
	
	
	    MapChart.prototype.addComponents = function addComponents() {
	        var seriesTheme = this.theme.series[this.chartType];
	        var colorSpectrum = new _colorSpectrum2['default'](seriesTheme.startColor, seriesTheme.endColor);
	        this.mapModel = new _mapChartMapModel2['default'](this.dataProcessor, this.options.map);
	
	        this.componentManager.register('mapSeries', 'mapSeries', {
	            mapModel: this.mapModel,
	            colorSpectrum: colorSpectrum
	        });
	
	        this.componentManager.register('title', 'title');
	
	        this.componentManager.register('legend', 'spectrumLegend', {
	            colorSpectrum: colorSpectrum
	        });
	
	        this.componentManager.register('tooltip', 'tooltip', {
	            mapModel: this.mapModel,
	            colorSpectrum: colorSpectrum
	        });
	
	        this.componentManager.register('zoom', 'zoom');
	        this.componentManager.register('mouseEventDetector', 'mapChartEventDetector');
	    };
	
	    /**
	     * setData
	     * need to clearMapData before setData. To re-generate map data.
	     * @param {object} rawData rawData
	     * @api
	     * @override
	     */
	
	
	    MapChart.prototype.setData = function setData() {
	        var rawData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	        this.mapModel.clearMapData();
	        _ChartBase.prototype.setData.call(this, rawData);
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{legend: boolean}}
	     * @override
	     */
	
	
	    MapChart.prototype.getScaleOption = function getScaleOption() {
	        return {
	            legend: true
	        };
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     */
	
	
	    MapChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        this.dataProcessor.addDataRatios(limitMap.legend);
	    };
	
	    return MapChart;
	}(_chartBase2['default']);
	
	exports['default'] = MapChart;

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _arrayUtil = __webpack_require__(337);
	
	var _arrayUtil2 = _interopRequireDefault(_arrayUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
	                                                                                                                                                           * @fileoverview MapChartMapModel is map model of map chart.
	                                                                                                                                                           * @author NHN.
	                                                                                                                                                           *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                           */
	
	var MapChartMapModel = function () {
	    /**
	     * MapChartMapModel is map model of map chart.
	     * @constructs MapChartMapModel
	     * @param {MapChartDataProcessor} dataProcessor Map chart data processor
	     * @param {Array.<{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data
	     * @ignore
	     */
	    function MapChartMapModel(dataProcessor, rawMapData) {
	        _classCallCheck(this, MapChartMapModel);
	
	        /**
	         * Command function map.
	         * @type {{
	         *      M: MapChartMapModel._makeCoordinate, m: MapChartMapModel._makeCoordinateFromRelativeCoordinate,
	         *      L: MapChartMapModel._makeCoordinate, l: MapChartMapModel._makeCoordinateFromRelativeCoordinate,
	         *      H: MapChartMapModel._makeXCoordinate, h: MapChartMapModel._makeXCoordinateFroRelativeCoordinate,
	         *      V: MapChartMapModel._makeYCoordinate, v: MapChartMapModel._makeYCoordinateFromRelativeCoordinate
	         * }}
	         */
	        this.commandFuncMap = {
	            M: _tuiCodeSnippet2['default'].bind(this._makeCoordinate, this),
	            m: _tuiCodeSnippet2['default'].bind(this._makeCoordinateFromRelativeCoordinate, this),
	            L: _tuiCodeSnippet2['default'].bind(this._makeCoordinate, this),
	            l: _tuiCodeSnippet2['default'].bind(this._makeCoordinateFromRelativeCoordinate, this),
	            H: _tuiCodeSnippet2['default'].bind(this._makeXCoordinate, this),
	            h: _tuiCodeSnippet2['default'].bind(this._makeXCoordinateFroRelativeCoordinate, this),
	            V: _tuiCodeSnippet2['default'].bind(this._makeYCoordinate, this),
	            v: _tuiCodeSnippet2['default'].bind(this._makeYCoordinateFromRelativeCoordinate, this)
	        };
	
	        /**
	         * Ignore command map.
	         * @type {{Z: boolean, z: boolean}}
	         */
	        this.ignoreCommandMap = {
	            Z: true,
	            z: true
	        };
	
	        /**
	         * Map dimension
	         * @type {{width: number, height: number}}
	         */
	        this.mapDimension = null;
	
	        /**
	         * Map chart data processor.
	         * @type {MapChartDataProcessor}
	         */
	        this.dataProcessor = dataProcessor;
	
	        /**
	         * Raw map data.
	         * @type {Array.<{name: string, path: string, labelCoordinate: ?{x: number, y: number}}>}
	         */
	        this.rawMapData = rawMapData;
	
	        /**
	         * Map data.
	         * @type {null|Array.<object>}
	         */
	        this.mapData = null;
	    }
	
	    /**
	     * Split coordinate string.
	     * @param {string} coordinateStr coordinate string
	     * @returns {{x: number, y: number}} coordinate map
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._splitCoordinate = function _splitCoordinate(coordinateStr) {
	        var coordinates = coordinateStr.split(',');
	        var result = {
	            x: parseFloat(coordinates[0])
	        };
	
	        if (coordinates[1]) {
	            result.y = parseFloat(coordinates[1]);
	        }
	
	        return result;
	    };
	
	    /**
	     * Make coordinate
	     * @param {string} coordinateStr coordinate
	     * @returns {{x: number, y: number}} coordinate
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._makeCoordinate = function _makeCoordinate(coordinateStr) {
	        return this._splitCoordinate(coordinateStr);
	    };
	
	    /**
	     * Make coordinate from relative coordinate.
	     * @param {string} coordinateStr coordinate
	     * @param {{x: number, y: number}} prevCoordinate previous coordinate
	     * @returns {{x: number, y: number}} coordinate
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._makeCoordinateFromRelativeCoordinate = function _makeCoordinateFromRelativeCoordinate(coordinateStr, prevCoordinate) {
	        var coordinate = this._splitCoordinate(coordinateStr);
	
	        return {
	            x: coordinate.x + prevCoordinate.x,
	            y: coordinate.y + prevCoordinate.y
	        };
	    };
	
	    /**
	     * Make x coordinate.
	     * @param {string} coordinateStr coordinate
	     * @returns {{x: number}} x coordinate
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._makeXCoordinate = function _makeXCoordinate(coordinateStr) {
	        var coordinate = this._splitCoordinate(coordinateStr);
	
	        return {
	            x: coordinate.x
	        };
	    };
	
	    /**
	     * Make x coordinate from relative coordinate.
	     * @param {string} coordinateStr coordinate
	     * @param {{x: number, y: number}} prevCoordinate previous coordinate
	     * @returns {{x: number}} x coordinate
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._makeXCoordinateFroRelativeCoordinate = function _makeXCoordinateFroRelativeCoordinate(coordinateStr, prevCoordinate) {
	        var coordinate = this._splitCoordinate(coordinateStr);
	
	        return {
	            x: coordinate.x + prevCoordinate.x
	        };
	    };
	
	    /**
	     * Make y coordinate.
	     * @param {string} coordinateStr coordinate
	     * @returns {{y: number}} y coordinate
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._makeYCoordinate = function _makeYCoordinate(coordinateStr) {
	        var coordinate = this._splitCoordinate(coordinateStr);
	
	        return {
	            y: coordinate.x
	        };
	    };
	
	    /**
	     * Make y coordinate from relative coordinate.
	     * @param {string} coordinateStr coordinate
	     * @param {{x: number, y: number}} prevCoordinate previous coordinate
	     * @returns {{y: number}} y coordinate
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._makeYCoordinateFromRelativeCoordinate = function _makeYCoordinateFromRelativeCoordinate(coordinateStr, prevCoordinate) {
	        var coordinate = this._splitCoordinate(coordinateStr);
	
	        return {
	            y: coordinate.x + prevCoordinate.y
	        };
	    };
	
	    /**
	     * Split path.
	     * @param {string} path path
	     * @returns {Array.<{type: string, coordinate: string}>} splitted path data
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._splitPath = function _splitPath(path) {
	        var len = path.length;
	        var pathData = [];
	        var coordinate = '';
	        var commandType = void 0;
	
	        for (var i = 0; i < len; i += 1) {
	            var chr = path.charAt(i);
	            if (this.commandFuncMap[chr]) {
	                if (commandType && coordinate) {
	                    pathData.push({
	                        type: commandType,
	                        coordinate: coordinate
	                    });
	                }
	                commandType = chr;
	                coordinate = '';
	            } else if (!this.ignoreCommandMap[chr]) {
	                coordinate += chr;
	            }
	        }
	
	        this._addCommandPath(pathData, {
	            commandType: commandType,
	            coordinate: coordinate
	        });
	
	        return pathData;
	    };
	
	    /**
	     * Add command path for Split path.
	     * @param {Array} pathData svg path array
	     * @param {Object} pathInfos svg path infos
	     *   @param {string} commandType svg command type
	     *   @param {string} coordinate path string
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._addCommandPath = function _addCommandPath(pathData) {
	        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	            commandType = _ref.commandType,
	            coordinate = _ref.coordinate;
	
	        if (commandType && coordinate) {
	            pathData.push({
	                type: commandType,
	                coordinate: coordinate
	            });
	        }
	    };
	
	    /**
	     * Make coordinates from path.
	     * @param {string} path path
	     * @returns {Array.<{x: number, y: number}>} coordinates
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._makeCoordinatesFromPath = function _makeCoordinatesFromPath(path) {
	        var _this = this;
	
	        var pathData = this._splitPath(path);
	        var prevCoordinate = {
	            x: 0,
	            y: 0
	        };
	
	        return pathData.map(function (datum) {
	            var commandFunc = _this.commandFuncMap[datum.type];
	            var coordinate = commandFunc(datum.coordinate, prevCoordinate);
	
	            _tuiCodeSnippet2['default'].extend(prevCoordinate, coordinate);
	
	            return coordinate;
	        });
	    };
	
	    /**
	     * Find bound from coordinates.
	     * @param {Array.<{left: number, top: number}>} coordinates coordinates
	     * @returns {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._findBoundFromCoordinates = function _findBoundFromCoordinates(coordinates) {
	        var xs = _tuiCodeSnippet2['default'].pluck(coordinates, 'x').filter(function (x) {
	            return !_tuiCodeSnippet2['default'].isUndefined(x);
	        });
	        var ys = _tuiCodeSnippet2['default'].pluck(coordinates, 'y').filter(function (y) {
	            return !_tuiCodeSnippet2['default'].isUndefined(y);
	        });
	        var maxLeft = _arrayUtil2['default'].max(xs);
	        var minLeft = _arrayUtil2['default'].min(xs);
	        var maxTop = _arrayUtil2['default'].max(ys);
	        var minTop = _arrayUtil2['default'].min(ys);
	
	        return {
	            dimension: {
	                width: maxLeft - minLeft,
	                height: maxTop - minTop
	            },
	            position: {
	                left: minLeft,
	                top: minTop
	            }
	        };
	    };
	
	    /**
	     * Make label position.
	     * @param {{dimension: {width: number, height: number}, position: {top: number, left: number}}} bound bound
	     * @param {?{left: number, top: number}} positionRatio position ratio
	     * @returns {{left: number, top: number}} label position
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._makeLabelPosition = function _makeLabelPosition(bound, positionRatio) {
	        positionRatio = positionRatio || _const2['default'].MAP_CHART_LABEL_DEFAULT_POSITION_RATIO;
	
	        return {
	            left: bound.position.left + bound.dimension.width * positionRatio.x,
	            top: bound.position.top + bound.dimension.height * positionRatio.y
	        };
	    };
	
	    /**
	     * Create map data.
	     * @param {Array.<{name: string, path: string, labelCoordinate: ?{x: number, y:number}}>} rawMapData raw map data
	     * @returns {Array.<object>}
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._createMapData = function _createMapData(rawMapData) {
	        var _this2 = this;
	
	        return rawMapData.map(function (datum) {
	            var coordinate = _this2._makeCoordinatesFromPath(datum.path);
	            var bound = _this2._findBoundFromCoordinates(coordinate);
	            var userData = _this2.dataProcessor.getValueMapDatum(datum.code);
	            var name = void 0,
	                labelCoordinate = void 0,
	                label = void 0,
	                ratio = void 0;
	
	            if (userData) {
	                label = userData.label;
	                ratio = userData.ratio;
	                name = userData.name || datum.name;
	                labelCoordinate = userData.labelCoordinate || datum.labelCoordinate;
	            }
	
	            var resultData = {
	                code: datum.code,
	                name: name,
	                path: datum.path,
	                bound: bound,
	                labelPosition: _this2._makeLabelPosition(bound, labelCoordinate)
	            };
	
	            if (label) {
	                resultData.label = label;
	            }
	
	            if (ratio >= 0) {
	                resultData.ratio = ratio;
	            }
	
	            return resultData;
	        });
	    };
	
	    /**
	     * clear map data.
	     */
	
	
	    MapChartMapModel.prototype.clearMapData = function clearMapData() {
	        this.mapData = null;
	    };
	
	    /**
	     * Get map data.
	     * @returns {Array.<object>}
	     */
	
	
	    MapChartMapModel.prototype.getMapData = function getMapData() {
	        if (!this.mapData) {
	            this.mapData = this._createMapData(this.rawMapData);
	        }
	
	        return this.mapData;
	    };
	
	    /**
	     * Get map datum.
	     * @param {number} index - index
	     * @returns {object}
	     */
	
	
	    MapChartMapModel.prototype.getDatum = function getDatum(index) {
	        return this.getMapData()[index];
	    };
	
	    /**
	     * Get label data.
	     * @param {number} ratio ratio
	     * @returns {Array.<{name: string, bound: {dimension: {width: number, height: number},
	     *          position: {top: number, left: number}}, labelPosition: {width: number, height: number}}>} map data
	     */
	
	
	    MapChartMapModel.prototype.getLabelData = function getLabelData(ratio) {
	        var _this3 = this;
	
	        var mapData = this.getMapData();
	        var labelData = mapData.filter(function (datum) {
	            return _this3.dataProcessor.getValueMapDatum(datum.code);
	        });
	
	        return labelData.map(function (datum) {
	            return {
	                name: datum.name,
	                labelPosition: {
	                    left: datum.labelPosition.left * ratio,
	                    top: datum.labelPosition.top * ratio
	                }
	            };
	        });
	    };
	
	    /**
	     * Make map dimension
	     * @returns {{width: number, height: number}} map dimension
	     * @private
	     */
	
	
	    MapChartMapModel.prototype._makeMapDimension = function _makeMapDimension() {
	        var mapData = this.getMapData();
	        var lefts = mapData.map(function (datum) {
	            return datum.bound.position.left;
	        });
	        var rights = mapData.map(function (datum) {
	            return datum.bound.position.left + datum.bound.dimension.width;
	        });
	        var tops = mapData.map(function (datum) {
	            return datum.bound.position.top;
	        });
	        var bottoms = mapData.map(function (datum) {
	            return datum.bound.position.top + datum.bound.dimension.height;
	        });
	
	        return {
	            width: _arrayUtil2['default'].max(rights) - _arrayUtil2['default'].min(lefts),
	            height: _arrayUtil2['default'].max(bottoms) - _arrayUtil2['default'].min(tops)
	        };
	    };
	
	    /**
	     * Get map dimension.
	     * @returns {{width: number, height: number}} map dimension
	     */
	
	
	    MapChartMapModel.prototype.getMapDimension = function getMapDimension() {
	        if (!this.mapDimension) {
	            this.mapDimension = this._makeMapDimension();
	        }
	
	        return this.mapDimension;
	    };
	
	    return MapChartMapModel;
	}();
	
	exports['default'] = MapChartMapModel;

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _dataProcessorBase = __webpack_require__(429);
	
	var _dataProcessorBase2 = _interopRequireDefault(_dataProcessorBase);
	
	var _renderUtil = __webpack_require__(334);
	
	var _renderUtil2 = _interopRequireDefault(_renderUtil);
	
	var _tuiCodeSnippet = __webpack_require__(333);
	
	var _tuiCodeSnippet2 = _interopRequireDefault(_tuiCodeSnippet);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Data processor for map chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/**
	 * Raw series data.
	 * @typedef {Array.<{code: string, name: ?string, data: number}>} rawSeriesData
	 * @private
	 */
	
	/**
	 * Value map.
	 * @typedef {{value: number, label: string, name: ?string}} valueMap
	 * @private
	 */
	
	var MapChartDataProcessor = function (_DataProcessorBase) {
	    _inherits(MapChartDataProcessor, _DataProcessorBase);
	
	    /**
	     * Data processor for map chart.
	     * @param {rawData} rawData raw data
	     * @param {string} chartType chart type
	     * @param {object} options options
	     * @constructs MapChartDataProcessor
	     * @private
	     * @extends DataProcessor
	     */
	    function MapChartDataProcessor(rawData, chartType, options) {
	        _classCallCheck(this, MapChartDataProcessor);
	
	        /**
	         * raw data
	         * @type {rawData}
	         */
	        var _this = _possibleConstructorReturn(this, _DataProcessorBase.call(this));
	
	        _this.rawData = rawData;
	
	        /**
	         * chart options
	         * @type {Object}
	         */
	        _this.options = options;
	        return _this;
	    }
	
	    /**
	     * Update raw data.
	     * @param {{series: rawSeriesData}} rawData raw data
	     */
	
	
	    MapChartDataProcessor.prototype.initData = function initData(rawData) {
	        this.rawData = rawData;
	        /**
	         * value map
	         * @type {valueMap}
	         */
	        this.valueMap = null;
	    };
	
	    /**
	     * Make value map.
	     * @returns {valueMap} value map
	     * @private
	     */
	
	
	    MapChartDataProcessor.prototype._makeValueMap = function _makeValueMap() {
	        var rawSeriesData = this.rawData.series.map;
	        var valueMap = {};
	        var formatFunctions = this._findFormatFunctions();
	
	        rawSeriesData.forEach(function (datum) {
	            var result = {
	                value: datum.data,
	                label: _renderUtil2['default'].formatValue({
	                    value: datum.data,
	                    formatFunctions: formatFunctions,
	                    chartType: 'map',
	                    areaType: 'series'
	                })
	            };
	
	            if (datum.name) {
	                result.name = datum.name;
	            }
	
	            if (datum.labelCoordinate) {
	                result.labelCoordinate = datum.labelCoordinate;
	            }
	
	            valueMap[datum.code] = result;
	        });
	
	        return valueMap;
	    };
	
	    /**
	     * Get value map.
	     * @returns {number} value
	     */
	
	
	    MapChartDataProcessor.prototype.getValueMap = function getValueMap() {
	        if (!this.valueMap) {
	            this.valueMap = this._makeValueMap();
	        }
	
	        return this.valueMap;
	    };
	
	    /**
	     * Get values.
	     * @returns {Array.<number>} picked values.
	     */
	
	
	    MapChartDataProcessor.prototype.getValues = function getValues() {
	        return _tuiCodeSnippet2['default'].pluck(this.getValueMap(), 'value');
	    };
	
	    /**
	     * Get current data.
	     * Map chart does not have zoomed data. So, returns rawData.
	     * @returns {*|null}
	     */
	
	
	    MapChartDataProcessor.prototype.getCurrentData = function getCurrentData() {
	        return this.rawData;
	    };
	
	    /**
	     * Get valueMap datum.
	     * @param {string} code map code
	     * @returns {{code: string, name: string, label: number,
	     *              labelCoordinate: {x: number, y: number}}} valueMap datum
	     */
	
	
	    MapChartDataProcessor.prototype.getValueMapDatum = function getValueMapDatum(code) {
	        return this.getValueMap()[code];
	    };
	
	    /**
	     * Add data ratios of map chart.
	     * @param {{min: number, max: number}} limit axis limit
	     */
	
	
	    MapChartDataProcessor.prototype.addDataRatios = function addDataRatios(limit) {
	        var min = limit.min;
	
	        var max = limit.max - min;
	        var maps = Object.values(this.getValueMap());
	
	        maps.forEach(function (map) {
	            map.ratio = (map.value - min) / max;
	        });
	    };
	
	    MapChartDataProcessor.prototype.createBaseValuesForLimit = function createBaseValuesForLimit() {
	        return this.getValues();
	    };
	
	    MapChartDataProcessor.prototype.getLegendVisibility = function getLegendVisibility() {
	        return null;
	    };
	
	    return MapChartDataProcessor;
	}(_dataProcessorBase2['default']);
	
	exports['default'] = MapChartDataProcessor;

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _lineChartSeries = __webpack_require__(412);
	
	var _lineChartSeries2 = _interopRequireDefault(_lineChartSeries);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Radial chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var RadialChart = function (_ChartBase) {
	    _inherits(RadialChart, _ChartBase);
	
	    /**
	     * Radial chart.
	     * @constructs RadialChart
	     * @extends ChartBase
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function RadialChart(rawData, theme, options) {
	        _classCallCheck(this, RadialChart);
	
	        // radial chart doesn't supprot group tooltip
	        // should delete this code, when it supports group tooltip
	        if (options.tooltip) {
	            options.tooltip.grouped = false;
	        }
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, { rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true,
	            isVertical: true
	        }));
	
	        _this.className = 'tui-radial-chart';
	
	        /**
	         * Series class
	         * @type {function}
	         * @ignore
	         */
	        _this.Series = _lineChartSeries2['default'];
	        return _this;
	    }
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    RadialChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('legend', 'legend');
	        this.componentManager.register('plot', 'radialPlot');
	
	        this.componentManager.register('radialSeries', 'radialSeries');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Add data ratios.
	     * @override
	     */
	
	
	    RadialChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        this.dataProcessor.addDataRatios(limitMap[this.chartType], null, this.chartType);
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{xAxis: ?{valueType:string}, yAxis: ?(boolean|{valueType:string})}}
	     * @override
	     */
	
	
	    RadialChart.prototype.getScaleOption = function getScaleOption() {
	        return {
	            yAxis: {}
	        };
	    };
	
	    return RadialChart;
	}(_chartBase2['default']);
	
	exports['default'] = RadialChart;

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Boxplot chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var BoxplotChart = function (_ChartBase) {
	    _inherits(BoxplotChart, _ChartBase);
	
	    /**
	     * Boxplot chart.
	     * @constructs BoxplotChart
	     * @extends ChartBase
	     * @mixes axisTypeMixer
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function BoxplotChart(rawData, theme, options) {
	        _classCallCheck(this, BoxplotChart);
	
	        _rawDataHandler2['default'].appendOutliersToSeriesData(rawData);
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true,
	            isVertical: true
	        }));
	
	        _this.className = 'tui-boxplot-chart';
	        return _this;
	    }
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    BoxplotChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('boxplotSeries', 'boxplotSeries');
	
	        this.componentManager.register('yAxis', 'axis');
	        this.componentManager.register('xAxis', 'axis');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu');
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{xAxis: boolean}}
	     * @override
	     */
	
	
	    BoxplotChart.prototype.getScaleOption = function getScaleOption() {
	        return {
	            yAxis: true
	        };
	    };
	
	    /**
	     * On change selected legend.
	     * @param {Array.<?boolean> | {line: ?Array.<boolean>, column: ?Array.<boolean>}} checkedLegends checked legends
	     * @ignore
	     */
	
	
	    BoxplotChart.prototype.onChangeCheckedLegends = function onChangeCheckedLegends(checkedLegends) {
	        var boundParams = void 0;
	
	        if (this.hasRightYAxis) {
	            boundParams = {
	                optionChartTypes: ['boxplot', 'boxplot']
	            };
	        }
	        _chartBase2['default'].prototype.onChangeCheckedLegends.call(this, checkedLegends, null, boundParams);
	    };
	
	    /**
	     * Add data ratios.
	     * modified from axisTypeMixer
	     * @override
	     */
	
	
	    BoxplotChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        var _options$series = this.options.series,
	            seriesOption = _options$series === undefined ? {} : _options$series,
	            chartType = this.chartType;
	
	        var _ref = seriesOption[chartType] || seriesOption,
	            stackType = _ref.stackType;
	
	        this.dataProcessor.addDataRatios(limitMap[chartType], stackType, chartType);
	    };
	
	    return BoxplotChart;
	}(_chartBase2['default']);
	
	exports['default'] = BoxplotChart;

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _chartBase = __webpack_require__(370);
	
	var _chartBase2 = _interopRequireDefault(_chartBase);
	
	var _rawDataHandler = __webpack_require__(359);
	
	var _rawDataHandler2 = _interopRequireDefault(_rawDataHandler);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @fileoverview Bullet chart.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author NHN.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *         FE Development Lab <dl_javascript@nhn.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */
	
	/** Class representing a point. */
	var BulletChart = function (_ChartBase) {
	    _inherits(BulletChart, _ChartBase);
	
	    /**
	     * Bullet chart.
	     * @constructs BulletChart
	     * @extends ChartBase
	     * @mixes axisTypeMixer
	     * @param {Array.<Array>} rawData raw data
	     * @param {object} theme chart theme
	     * @param {object} options chart options
	     */
	    function BulletChart(rawData, theme, options) {
	        _classCallCheck(this, BulletChart);
	
	        _rawDataHandler2['default']._makeRawSeriesDataForBulletChart(rawData);
	
	        /**
	         * className
	         * @type {string}
	         */
	        var _this = _possibleConstructorReturn(this, _ChartBase.call(this, {
	            rawData: rawData,
	            theme: theme,
	            options: options,
	            hasAxes: true,
	            isVertical: !!options.series.vertical
	        }));
	
	        _this.className = 'tui-bullet-chart';
	        return _this;
	    }
	
	    /**
	     * Add components
	     * @override
	     */
	
	
	    BulletChart.prototype.addComponents = function addComponents() {
	        this.componentManager.register('title', 'title');
	        this.componentManager.register('plot', 'plot');
	        this.componentManager.register('legend', 'legend');
	
	        this.componentManager.register('bulletSeries', 'bulletSeries');
	
	        this.componentManager.register('yAxis', 'axis');
	        this.componentManager.register('xAxis', 'axis');
	
	        this.componentManager.register('chartExportMenu', 'chartExportMenu', { chartType: 'bullet' });
	        this.componentManager.register('tooltip', 'tooltip');
	        this.componentManager.register('mouseEventDetector', 'mouseEventDetector');
	    };
	
	    /**
	     * Get scale option.
	     * @returns {{xAxis: boolean}}
	     * @override
	     */
	
	
	    BulletChart.prototype.getScaleOption = function getScaleOption() {
	        if (this.isVertical) {
	            return {
	                yAxis: true
	            };
	        }
	
	        return {
	            xAxis: true
	        };
	    };
	
	    /**
	     * Add data ratios.
	     * modified from axisTypeMixer
	     * @override
	     */
	
	
	    BulletChart.prototype.addDataRatios = function addDataRatios(limitMap) {
	        this.dataProcessor.addDataRatios(limitMap[this.chartType], null, this.chartType);
	    };
	
	    return BulletChart;
	}(_chartBase2['default']);
	
	exports['default'] = BulletChart;

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _const = __webpack_require__(335);
	
	var _const2 = _interopRequireDefault(_const);
	
	var _themeManager = __webpack_require__(361);
	
	var _themeManager2 = _interopRequireDefault(_themeManager);
	
	var _defaultTheme = __webpack_require__(362);
	
	var _defaultTheme2 = _interopRequireDefault(_defaultTheme);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	_themeManager2['default'].register(_const2['default'].DEFAULT_THEME_NAME, _defaultTheme2['default']);

/***/ }),
/* 474 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ })
/******/ ])
});
;